{
  "comments": [
    {
      "key": {
        "uuid": "422ac74f_b77fc70c",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 59,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "Might as well just declare it as an int, then? And in any case, this still allows for seemingly-silly values like 2**31. (Is the value further sanity-checked inside `DecodeCBOR`?)",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c94f6e59_c47b14e9",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 59,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "Changed param type to int and added additional check for case when user passes in value higher than |kCBORMaxDepth|. Thus, decoder will now only accept value smaller than |kCBORMaxDepth| to  |max_nesting_level|.",
      "parentUuid": "422ac74f_b77fc70c",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "54aadb4f_df3530bb",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 72,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "I think the checked_cast will prevent this from ever happening. A size_t value that is too large to fit in a positive int will CHECK before we get to this point.\n\nAnd we\u0027re still allowing 2**31 and other huge values. I think it\u0027s better to set a tighter limit here, if you can.",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7dd2dc1_54e21650",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 72,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "The reasoning for checking negative |max_nesting_level| is due to implementation detail. For all nested CBORvalues, we call CBORReader::DecodeCBOR() recursively. At every recursive call, we decrease |max_nesting_level| by 1. Thus, whenever |max_nesting_level| reaches -1, we know that the decoding CBORvalue has too much nesting layers.\n\nPlease let me know if you have any other suggestions! :) \n\np.s. Sanity check for values such as 2^^31 was added as well.",
      "parentUuid": "54aadb4f_df3530bb",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4d2a986_1ac7f3d8",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 99,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "The code might be more resilient against future maintenance mistakes if you change this to:\n\n  case CBORValue::Type::NONE:\n    break;\n  default:\n    NOTREACHED();\n    break;\n\nIt has the same effect in production, but it more clearly expresses the intent. Arguably. This is just a nit, feel free to ignore.",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bce5f39e_aaf21b7f",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 99,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b4d2a986_1ac7f3d8",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "11ac2356_89e689d1",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 99,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-12-01T04:27:30Z",
      "side": 1,
      "message": "We got rid of the default: so the compiler will check that all values of CBORValue::Type are covered. I agree that adding a NOTREACHED() after the switch makes sense. However, that does mean that Jun should add the major types 1, 6, and 7 to the enum, and explicitly map them to UNSUPPORTED_MAJOR_TYPE_ERROR. I *think* it\u0027s a bug for Type::NONE to ever be found here, so the break; there that leads to NOTREACHED() is still correct.",
      "parentUuid": "bce5f39e_aaf21b7f",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4856b662_eb58ac36",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 141,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "|num_bytes| appears to be the result stored in the out-param of `ReadUnsignedInt`, which is attacker-controlled. So lines 140 (directly) and 141 (indirectly, later) could result in out-of-bounds reads. I think. Right?\n\nI\u0027m not sure, but I *think* a call to `CanConsume(num_bytes)` would avoid this vulnerability. Depending on how `CanConsume` is implemented, which I\u0027ll get to in a moment.",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "812afd12_414831a1",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 141,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4856b662_eb58ac36",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "61f1c0f9_84154887",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 192,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "http://en.cppreference.com/w/cpp/iterator/distance says that the complexity of std::distance is... linear, unless our iterators meet the requirements of RandomAccessIterator. Do they? If it really is O(N), we should do something else.\n\nAlso, apparently the return value can be negative, so checked_cast is warranted. I was going to say \"use checked_cast for the sake of form, and it\u0027ll be compiled away\", but apparently it could actually be necessary as well as good form.",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b42bd076_c6c380c3",
        "filename": "content/browser/webauth/cbor/cbor_reader.cc",
        "patchSetId": 22
      },
      "lineNbr": 192,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "I believe so. http://www.cplusplus.com/reference/vector/vector/ says that iterator member of std::vectors are random access iterators. Please let me know if I\u0027m missing anything!\n\nChanged static_cast to checked_cast.",
      "parentUuid": "61f1c0f9_84154887",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e56c2b68_51187aa3",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 64,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "API design thought (feel free to ignore): You could just expose simply:\n\n  static const char* const GetErrorMessage(CBORDecoderError e);",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa90b088_292700f2",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 64,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "Changed existing API return value to const char*",
      "parentUuid": "e56c2b68_51187aa3",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9fa16ce6_399748d9",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 83,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "API design thought (feel free to ignore): You could expose:\n\n  using Decoded \u003d std::pair\u003cCBORDecodingError, CBORValue\u003e;\n  static Decoded Read(const std::vector\u003cuint8_t\u003e\u0026 input_data, size_t max_nesting_level \u003d kCBORMaxDepth);",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e319785b_69815be8",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 83,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "9fa16ce6_399748d9",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "06325201_0a32d5a8",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 89,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "Ahh, I see, you are doing what I suggested above. To me, this means you don\u0027t need to expose the various `static const char kFoo...[];`s in this .h; they can be implementation details in the .cc.\n\nAlso, you\u0027re incurring a std::string construction even if the caller doesn\u0027t need one. It\u0027s a micro-optimization, but returning `const char* const` enables the caller to choose whether they need a copy or are just going to immediately print it or whatever.\n\nAgain, these are all nits, and not important to security, so feel free to ignore on these things. :)",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5735c681_4113f375",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 89,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "06325201_0a32d5a8",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a355157_dd71856f",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 94,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "Note: In `Read`, |max_nesting_level| is specified as a size_t. You should consistently choose 1 type.",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97fd1c35_f9fdac5d",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 94,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "The reasoning behind choosing size_t for exposed static CBORReader::Read() function and int for private CBORReader::Decode() was to prevent callers from the API from passing in any negative values. \n\nHowever, I believe if the caller does pass in negative value as |max_nesting_level| current implementation will always return TOO_MUCH_NESTING_ERROR, which is also correct.\n\nChanged type of |max_nesting_level| to int.",
      "parentUuid": "9a355157_dd71856f",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8912136_2875e1bc",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 94,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-12-01T04:27:30Z",
      "side": 1,
      "message": "https://google.github.io/styleguide/cppguide.html#Integer_Types says \"In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this.\"\n\nMy thought when I didn\u0027t complain about the mix of types, was that a size_t parameter doesn\u0027t cause any implicit conversions in the call, no matter what the argument type is. (I guess I\u0027m assuming we have 64-bit builds everywhere...) Then the checked_cast\u003cint\u003e catches if the argument is something like 2^32+5.\n\nIt doesn\u0027t matter much, since this particular argument is likely to be constant everywhere. And I don\u0027t think there\u0027s any way to ensure implicit casts are avoided everywhere.",
      "parentUuid": "97fd1c35_f9fdac5d",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35960629_d5e96449",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 109,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-12-01T01:32:23Z",
      "side": 1,
      "message": "How is this different from `ErrorCodeToString`, above?",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "00b3db00_771d7261",
        "filename": "content/browser/webauth/cbor/cbor_reader.h",
        "patchSetId": 22
      },
      "lineNbr": 109,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2017-12-01T04:07:42Z",
      "side": 1,
      "message": "Thanks for the catch! :-)",
      "parentUuid": "35960629_d5e96449",
      "revId": "3f85e3ad5bcdc257bfbfb4dc09e7063135d3c291",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}