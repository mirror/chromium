{
  "comments": [
    {
      "key": {
        "uuid": "a1fdb80c_eadaee8d",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T19:56:56Z",
      "side": 1,
      "message": "I\u0027d slightly prefer that we be able to use DOM-style events rather than extension API events for manager in order to avoid adding additional dependencies on the API and also to be able to leverage regular web testing tools.  How would you feel about having service fire these events when it received them, and then adding listeners for \u0027profile-state-changed\u0027 and such here?",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "54ae299f_5fa6448a",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T20:20:54Z",
      "side": 1,
      "message": "Service is not an HTMLElement, so in order to fire its own events it would have to either\n\n1) inherit from cr.ui.EventTarget, see [1] or,\n2) contain a service.eventTarget member variable\n\nI was trying to avoid that, since it just seems it is adding an additional level of indirection (C++ event fired -\u003e Service handles C++ event -\u003e Service re-fires DOM event -\u003e Manager handles DOM event) and additional JS code to be executed.\n\nAlso DOM events seem more heavy-weight than necessary for Service-\u003eManager communication. DOM events have bubbling/capturing/preventDefault/stopPropagation mechanisms which only make sense when propagating events within a DOM tree.\n\n\u003e in order to avoid adding additional dependencies on the API\n\nDo you mean avoid additional methods on the API like getXXXTarget()? Personally I don\u0027t mind the extra method, especially since a FakeChromeEvent implementation already exists (see [2]) and I am already leveraging this during tests.\n\n[1] https://cs.chromium.org/chromium/src/ui/webui/resources/js/cr/event_target.js\n[2] https://cs.chromium.org/chromium/src/chrome/test/data/webui/fake_chrome_event.js",
      "parentUuid": "a1fdb80c_eadaee8d",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30d1cf85_e7bc0a11",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T20:29:11Z",
      "side": 1,
      "message": "Fair points, and I don\u0027t feel strongly, so if this is your preference, I\u0027m fine with it. :)",
      "parentUuid": "54ae299f_5fa6448a",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70ffd4c4_d29ff8c6",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T23:30:45Z",
      "side": 1,
      "message": "Thanks!",
      "parentUuid": "30d1cf85_e7bc0a11",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "489a3746_8ee0075d",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T19:56:56Z",
      "side": 1,
      "message": "Is this worth testing?  It seems like this is more just change-detection rather than behavior validation.  Should we either remove it, or instead test that the results are correct in the manager?",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48df86ac_6fcb293b",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T23:30:45Z",
      "side": 1,
      "message": "Yes. This is not intended to be change detection. It ensures that the assertions within all the test() methods are happening after certain calls to developerPrivate API has happened, and therefore after the DOM has had a chance to be updated.",
      "parentUuid": "489a3746_8ee0075d",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6a727ea_acfe6e51",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-08T19:59:25Z",
      "side": 1,
      "message": "Hmm... this seems like something where we\u0027d be better off exposing an onReady-type promise from manager, which it has control over.  This strikes me as brittle, since it will break if we change which of these need to be called, or require more to be called in the future (and might break flakily in the second case).",
      "parentUuid": "48df86ac_6fcb293b",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "595962f0_1a79d94f",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-08T20:59:43Z",
      "side": 1,
      "message": "This test follows the pattern used in Settings and AFAIK it is not considered a brittle pattern. Explaining a bit more the rationale below:\n\nWhen unit testing a UI component, the C++ side of things is considered an external dependency and should not be tested along with the unit test. But, the calls that are made between this unit and the external world are part of the \"contract\" between these two systems, and therefore this test verifies that this unit adheres to the \"contract\". We don\u0027t expose an onReady-type Promise, because we are interested on explicitly validating that these calls to the \"external\" world happen and more specifically we can verify that they happen when expected (for example on startup, or when user clicks a button etc).\n\nIt\u0027s the responsibility of a different unit test (a C++ one) to verify that when those calls are made, the correct responses are sent back to JS, therefore in the JS unit test, we provide dummy responses, as necessary to trigger all the interesting codepaths.\n\nAlso worth noting that splitting the responsibilities of JS and C++ unit tests (and testing the communication layer from both sides separately) has been done with the motivation of reducing flakiness, not increasing it. I am interested to hear your thoughts (not necessarily in this context) if you think otherwise.",
      "parentUuid": "b6a727ea_acfe6e51",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f81afc73_5505b978",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T19:56:56Z",
      "side": 1,
      "message": "These are all copy-paste, right?",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33634d9f_fc9eb9c2",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T23:30:45Z",
      "side": 1,
      "message": "This is mostly copy-paste. I changed the way installed extensions are simulated, using simulateExtensionInstall(). Before, when these tests resided within Service, the test fixture was a subclass of CrExtensionsBrowserTestWithInstalledExtension and was relying on actual calls to chrome.developerPrivate to provide test data. The current test does  not talk to chrome.developerPrivate, instead it talks to TestService defined near the top of this file.",
      "parentUuid": "f81afc73_5505b978",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1cc174d4_f94ae0b6",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-08T19:59:25Z",
      "side": 1,
      "message": "I\u0027m a bit nervous that we appear to have fully migrated off any dependencies on developerPrivate.  This is good for manger tests, but it seems like now we have no end-to-end tests with real installed extensions that we try to manipulate.  I\u0027d feel more comfortable having one or two integration tests somewhere (not in this unit test file).\n\nI\u0027d be fine saving that for another CL, but I think it is reasonably important.",
      "parentUuid": "33634d9f_fc9eb9c2",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1020bec1_c9b48216",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-08T20:59:43Z",
      "side": 1,
      "message": "\u003e we have no end-to-end tests with real installed extensions that we try to manipulate.\n\nextensions_manager_tests.js still contains tests that contact chrome.developerPrivate. Same holds for other tests that extend CrExtensionsManagerTestWithMultipleExtensionTypesInstalled and CrExtensionsBrowserTestWithInstalledExtension, so we still have some end-to-end tests.\n\nHaving said that (also see my other comment about C++/JS testing separation), I\u0027d prefer having C++ unit tests like https://cs.chromium.org/search/?q\u003d_unittest.cc+file:%5Esrc/chrome/browser/ui/webui/settings/+package:%5Echromium$\u0026type\u003dcs, to test the C++ side of things, instead of relying on chrome/test/data/webui/* tests to do that.\n\nIn my ideal world there are:\n1) JS unit tests (do not talk to C++ at all)\n2) C++ unit tests (do not talk to JS at all)\n3) end-to-end tests (both sides talk to each other).\n\nEven though end-to-end tests can catch a certain class of errors not caught by the other two, they are harder to author and maintain. Examples scenarios that come to mind from Settings that are fairly hard to simulate in an end-to-end test: logged-in, multiple profiles, guest mode, detected corrupt profile, detected malware etc. Those are much easier to simulate in unit tests.\n\nIn my past experience with WebUI, developers are more likely to write unit tests than end-to-end tests, especially when writing unit tests is made fairly easy (like providing canonical ways of mocking, e.g TestBrowserProxy).",
      "parentUuid": "1cc174d4_f94ae0b6",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}