{
  "comments": [
    {
      "key": {
        "uuid": "a1fdb80c_eadaee8d",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T19:56:56Z",
      "side": 1,
      "message": "I\u0027d slightly prefer that we be able to use DOM-style events rather than extension API events for manager in order to avoid adding additional dependencies on the API and also to be able to leverage regular web testing tools.  How would you feel about having service fire these events when it received them, and then adding listeners for \u0027profile-state-changed\u0027 and such here?",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "54ae299f_5fa6448a",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T20:20:54Z",
      "side": 1,
      "message": "Service is not an HTMLElement, so in order to fire its own events it would have to either\n\n1) inherit from cr.ui.EventTarget, see [1] or,\n2) contain a service.eventTarget member variable\n\nI was trying to avoid that, since it just seems it is adding an additional level of indirection (C++ event fired -\u003e Service handles C++ event -\u003e Service re-fires DOM event -\u003e Manager handles DOM event) and additional JS code to be executed.\n\nAlso DOM events seem more heavy-weight than necessary for Service-\u003eManager communication. DOM events have bubbling/capturing/preventDefault/stopPropagation mechanisms which only make sense when propagating events within a DOM tree.\n\n\u003e in order to avoid adding additional dependencies on the API\n\nDo you mean avoid additional methods on the API like getXXXTarget()? Personally I don\u0027t mind the extra method, especially since a FakeChromeEvent implementation already exists (see [2]) and I am already leveraging this during tests.\n\n[1] https://cs.chromium.org/chromium/src/ui/webui/resources/js/cr/event_target.js\n[2] https://cs.chromium.org/chromium/src/chrome/test/data/webui/fake_chrome_event.js",
      "parentUuid": "a1fdb80c_eadaee8d",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30d1cf85_e7bc0a11",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T20:29:11Z",
      "side": 1,
      "message": "Fair points, and I don\u0027t feel strongly, so if this is your preference, I\u0027m fine with it. :)",
      "parentUuid": "54ae299f_5fa6448a",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70ffd4c4_d29ff8c6",
        "filename": "chrome/browser/resources/md_extensions/manager.js",
        "patchSetId": 18
      },
      "lineNbr": 147,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T23:30:45Z",
      "side": 1,
      "message": "Thanks!",
      "parentUuid": "30d1cf85_e7bc0a11",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "489a3746_8ee0075d",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T19:56:56Z",
      "side": 1,
      "message": "Is this worth testing?  It seems like this is more just change-detection rather than behavior validation.  Should we either remove it, or instead test that the results are correct in the manager?",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48df86ac_6fcb293b",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T23:30:45Z",
      "side": 1,
      "message": "Yes. This is not intended to be change detection. It ensures that the assertions within all the test() methods are happening after certain calls to developerPrivate API has happened, and therefore after the DOM has had a chance to be updated.",
      "parentUuid": "489a3746_8ee0075d",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6a727ea_acfe6e51",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-08T19:59:25Z",
      "side": 1,
      "message": "Hmm... this seems like something where we\u0027d be better off exposing an onReady-type promise from manager, which it has control over.  This strikes me as brittle, since it will break if we change which of these need to be called, or require more to be called in the future (and might break flakily in the second case).",
      "parentUuid": "48df86ac_6fcb293b",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "595962f0_1a79d94f",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-08T20:59:43Z",
      "side": 1,
      "message": "This test follows the pattern used in Settings and AFAIK it is not considered a brittle pattern. Explaining a bit more the rationale below:\n\nWhen unit testing a UI component, the C++ side of things is considered an external dependency and should not be tested along with the unit test. But, the calls that are made between this unit and the external world are part of the \"contract\" between these two systems, and therefore this test verifies that this unit adheres to the \"contract\". We don\u0027t expose an onReady-type Promise, because we are interested on explicitly validating that these calls to the \"external\" world happen and more specifically we can verify that they happen when expected (for example on startup, or when user clicks a button etc).\n\nIt\u0027s the responsibility of a different unit test (a C++ one) to verify that when those calls are made, the correct responses are sent back to JS, therefore in the JS unit test, we provide dummy responses, as necessary to trigger all the interesting codepaths.\n\nAlso worth noting that splitting the responsibilities of JS and C++ unit tests (and testing the communication layer from both sides separately) has been done with the motivation of reducing flakiness, not increasing it. I am interested to hear your thoughts (not necessarily in this context) if you think otherwise.",
      "parentUuid": "b6a727ea_acfe6e51",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e77b7734_c711a5fd",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 69,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-08T21:29:19Z",
      "side": 1,
      "message": "But the contract that we validate shouldn\u0027t, IMO, include \"The JS should call these methods exactly at init\".  Rather, it should validate \"the JS should respond to these signals in these ways\".\n\nLet\u0027s take a more concrete example: here, we validate that the manager calls getItemStateChangedTarget() on init.  If the manager doesn\u0027t call it for any reason, then this test fails (times out).  If we move item state observation to a new class (say, an ExtensionItemList that maintains itself and simply provides an opaque list to the manager), then this fails, even though the change is legitimate.  Additionally, if we add some other init step to the manager (let\u0027s say getFooConfiguration()), this test would *not* fail immediately, because these four methods would be called, but the expectations in the test would potentially be invalid and the test could flake.\n\nMy suggested solution to those would be to\na) have a test that checks that mutating item state results in the UI being updated.  With this, we don\u0027t need to validate that manager calls getItemStateChangedTarget(), because we don\u0027t actually care - what we care about is that the UI is updated when the backend is updated.  The fact that currently this happens through the item state changed event is an implementation detail that we shouldn\u0027t need to test or preserve, whereas the UI updating to reflect that change is a functional piece of the application that we *do* need to test and preserve.\nb) have an onReady() type promise exposed on the manager which is resolved when it has done its initialization.  I think it\u0027s far more likely that people will know to update when the onReady promise is resolved (since it\u0027s presumably right next to all the other initialization code) rather than updating a unittest\u0027s set up method - especially if that test doesn\u0027t fail (as might be the case).  This way, we make the \"wait for initialization\" step more resilient by both avoiding breaking changes when some implementation detail changes and also accounting for changes that might have otherwise slipped through.",
      "parentUuid": "595962f0_1a79d94f",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f81afc73_5505b978",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-07T19:56:56Z",
      "side": 1,
      "message": "These are all copy-paste, right?",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33634d9f_fc9eb9c2",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-07T23:30:45Z",
      "side": 1,
      "message": "This is mostly copy-paste. I changed the way installed extensions are simulated, using simulateExtensionInstall(). Before, when these tests resided within Service, the test fixture was a subclass of CrExtensionsBrowserTestWithInstalledExtension and was relying on actual calls to chrome.developerPrivate to provide test data. The current test does  not talk to chrome.developerPrivate, instead it talks to TestService defined near the top of this file.",
      "parentUuid": "f81afc73_5505b978",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1cc174d4_f94ae0b6",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-08T19:59:25Z",
      "side": 1,
      "message": "I\u0027m a bit nervous that we appear to have fully migrated off any dependencies on developerPrivate.  This is good for manger tests, but it seems like now we have no end-to-end tests with real installed extensions that we try to manipulate.  I\u0027d feel more comfortable having one or two integration tests somewhere (not in this unit test file).\n\nI\u0027d be fine saving that for another CL, but I think it is reasonably important.",
      "parentUuid": "33634d9f_fc9eb9c2",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1020bec1_c9b48216",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-11-08T20:59:43Z",
      "side": 1,
      "message": "\u003e we have no end-to-end tests with real installed extensions that we try to manipulate.\n\nextensions_manager_tests.js still contains tests that contact chrome.developerPrivate. Same holds for other tests that extend CrExtensionsManagerTestWithMultipleExtensionTypesInstalled and CrExtensionsBrowserTestWithInstalledExtension, so we still have some end-to-end tests.\n\nHaving said that (also see my other comment about C++/JS testing separation), I\u0027d prefer having C++ unit tests like https://cs.chromium.org/search/?q\u003d_unittest.cc+file:%5Esrc/chrome/browser/ui/webui/settings/+package:%5Echromium$\u0026type\u003dcs, to test the C++ side of things, instead of relying on chrome/test/data/webui/* tests to do that.\n\nIn my ideal world there are:\n1) JS unit tests (do not talk to C++ at all)\n2) C++ unit tests (do not talk to JS at all)\n3) end-to-end tests (both sides talk to each other).\n\nEven though end-to-end tests can catch a certain class of errors not caught by the other two, they are harder to author and maintain. Examples scenarios that come to mind from Settings that are fairly hard to simulate in an end-to-end test: logged-in, multiple profiles, guest mode, detected corrupt profile, detected malware etc. Those are much easier to simulate in unit tests.\n\nIn my past experience with WebUI, developers are more likely to write unit tests than end-to-end tests, especially when writing unit tests is made fairly easy (like providing canonical ways of mocking, e.g TestBrowserProxy).",
      "parentUuid": "1cc174d4_f94ae0b6",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "24efcfee_7498035c",
        "filename": "chrome/test/data/webui/extensions/extension_manager_unit_test.js",
        "patchSetId": 18
      },
      "lineNbr": 91,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-08T21:29:19Z",
      "side": 1,
      "message": "Agreed on all points! :)\n\nI was just worried that we were moving away from the ideal world in which we have both unit and end-to-end tests.  I think both are important (though I wholeheartedly agree that unit tests should be the default).",
      "parentUuid": "1020bec1_c9b48216",
      "revId": "f171d53f41f7eb1e509d6471d7e189b424999664",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}