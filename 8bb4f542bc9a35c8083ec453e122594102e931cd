{
  "comments": [
    {
      "key": {
        "uuid": "4f47967e_b1ce1c88",
        "filename": "content/common/leveldb_wrapper.mojom",
        "patchSetId": 13
      },
      "lineNbr": 61,
      "author": {
        "id": 1137859
      },
      "writtenOn": "2017-10-12T18:18:54Z",
      "side": 1,
      "message": "I\u0027m not familiar with leveldb, but why would the client know the old value? Isn\u0027t that in the actual database the client is working on?",
      "revId": "8bb4f542bc9a35c8083ec453e122594102e931cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "279d6acc_a49358ac",
        "filename": "content/common/leveldb_wrapper.mojom",
        "patchSetId": 13
      },
      "lineNbr": 61,
      "author": {
        "id": 1110029
      },
      "writtenOn": "2017-10-12T18:31:37Z",
      "side": 1,
      "message": "For what it\u0027s worth, LevelDBWrapper is really badly named (I think cmumford@ had some plans to rename it, but not very high priority). That it is (indirectly) backed by leveldb is completely irrelevant. It really should be called KeyValueStore or something like that.\n\nBut yeah, it is a bit unfortunate that this makes a mostly generic key value store interface slightly less generic (since as you point out not every use case for a key value store might want to keep around a copy of all the data), but I think that\u0027s fine in this case anyway. If you squint it would still be possible to use the same interface for other purposes; whatever API a client would use to get a LevelDBWrapper could always document that its LevelDBWrappers will never need client_old_value for example...",
      "parentUuid": "4f47967e_b1ce1c88",
      "revId": "8bb4f542bc9a35c8083ec453e122594102e931cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72786ee5_4cd05ed3",
        "filename": "content/common/leveldb_wrapper.mojom",
        "patchSetId": 13
      },
      "lineNbr": 61,
      "author": {
        "id": 1137859
      },
      "writtenOn": "2017-10-12T18:33:22Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "279d6acc_a49358ac",
      "revId": "8bb4f542bc9a35c8083ec453e122594102e931cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7b63a0c1_3e30f9ca",
        "filename": "content/common/leveldb_wrapper.mojom",
        "patchSetId": 13
      },
      "lineNbr": 61,
      "author": {
        "id": 1125359
      },
      "writtenOn": "2017-10-12T18:36:05Z",
      "side": 1,
      "message": "The implementation of local storage databases have an in-memory cache on both client side and on the wrapper. The clients keep a copy so that the get calls are synchronous and transactions are faster without IPC.  The wrapper needs to send notifications to all observers about each change with the old value. For this reason we currently cache values in the wrapper also instead of accessing the leveldb database (disk) at each transaction.\nIf the old values are sent from the clients then the wrapper does not need to store the values in cache, which saves memory.\n\nThis old_value param is needed for the case of local storage. If we have other use cases for leveldb wrapper then we can just notify sending old values is not required.",
      "parentUuid": "4f47967e_b1ce1c88",
      "revId": "8bb4f542bc9a35c8083ec453e122594102e931cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}