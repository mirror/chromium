{
  "comments": [
    {
      "key": {
        "uuid": "1f5d7850_d10337f8",
        "filename": "content/browser/histogram_controller.cc",
        "patchSetId": 19
      },
      "lineNbr": 103,
      "author": {
        "id": 1117419
      },
      "writtenOn": "2017-10-05T13:13:33Z",
      "side": 1,
      "message": "What does \"MakeRequest\" have to do with \"SetHistogramMemory\"?  What happens if this method is never called?  It\u0027s optional, and not even enabled 100% on all builds.",
      "range": {
        "startLine": 103,
        "startChar": 38,
        "endLine": 103,
        "endChar": 49
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc816648_1698490b",
        "filename": "content/browser/histogram_controller.cc",
        "patchSetId": 19
      },
      "lineNbr": 103,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-05T21:03:33Z",
      "side": 1,
      "message": "MakeRequest is mojo boilerplate for setting up a message pipe, in preparation for talking to a remote interface: internally it makes a message pipe. It passes one end to the out param (which is an interface pointer: this is how you talk to the remote end of the interface), and it returns a request (which is passed to the actual implementation of the object, which uses something like mojo::Binding to \u0027accept\u0027 the connection request).\n\nAs for what happens if it\u0027s not called... I\u0027m really not sure how the child process histogramming works today. Hence my earlier request for maybe linking to some design docs in the mojom that would help make the cross-process dance of setting these up (or not setting them up, if not enabled) clearer.",
      "parentUuid": "1f5d7850_d10337f8",
      "range": {
        "startLine": 103,
        "startChar": 38,
        "endLine": 103,
        "endChar": 49
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f52270ce_fc6a4888",
        "filename": "content/browser/histogram_controller.cc",
        "patchSetId": 19
      },
      "lineNbr": 103,
      "author": {
        "id": 1117419
      },
      "writtenOn": "2017-10-10T13:55:14Z",
      "side": 1,
      "message": "Histograms are created all the time and in many places within the code.  If a shared memory segment has been specified (SetHistogramMemory), then newly created histograms are allocated from that.  If not, they\u0027re allocated from the heap.\n\nShared (aka \"persistent\") histograms are directly accessible from the parent process (that sent the SetHistogramMemory message).  Others need to be fetched via RPC.\n\nBecause the SetHistogramMemory message occurs after startup and thus reside on the heap, there\u0027s always a couple histograms created before it.  Or, if persistence is disabled globally, all of them reside on the heap.\n\nIf you\u0027re trying to send heap histograms via RPC, there is no shared memory to worry about because that\u0027s done elsewhere.  If you\u0027re trying to handle the message that initializes the shared memory, there are no histograms involved.\n\nSomething named \"ChildHistogramFactoryPtr\" sounds like an object for creating child histograms but all histograms are created through FactoryGet methods (usually via macros) and managed by the StatisticsRecorder.",
      "parentUuid": "fc816648_1698490b",
      "range": {
        "startLine": 103,
        "startChar": 38,
        "endLine": 103,
        "endChar": 49
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8dc6d7e_7804931f",
        "filename": "content/browser/histogram_controller.cc",
        "patchSetId": 19
      },
      "lineNbr": 103,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-10T22:51:40Z",
      "side": 1,
      "message": "So, IIRC, if SetHistogramMemory has been called for a process, we should never be calling GetChildNonPersistentHistogramData for that process? So if there exists an entry in the ChildHistogramMap, we should elide the call to GetChildNonPersistentHistogramData. If that\u0027s right, then the logic in this file needs another rewrite.  \n\nBut I\u0027m not convinced that this matches the old behavior. The old code always iterates through all processes sending GetChildNonPersistentHistogramData, and ChildHistgramMessageFilter can always send those histograms not in shared memory.",
      "parentUuid": "f52270ce_fc6a4888",
      "range": {
        "startLine": 103,
        "startChar": 38,
        "endLine": 103,
        "endChar": 49
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2187010_bb0779ad",
        "filename": "content/browser/histogram_controller.cc",
        "patchSetId": 19
      },
      "lineNbr": 103,
      "author": {
        "id": 1117419
      },
      "writtenOn": "2017-10-11T15:27:47Z",
      "side": 1,
      "message": "It\u0027s still always called because (a) there may be some histograms that aren\u0027t in shared memory and (b) it\u0027s better to be safe than sorry.  Also, if shared memory gets full, then the system will fall back to heap allocation since the shared memory segment cannot be expanded.\n\nHowever, there will be little or no data returned when persistence is enabled.",
      "parentUuid": "e8dc6d7e_7804931f",
      "range": {
        "startLine": 103,
        "startChar": 38,
        "endLine": 103,
        "endChar": 49
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0ff8597_8dc52ad1",
        "filename": "content/browser/histogram_controller.cc",
        "patchSetId": 19
      },
      "lineNbr": 131,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T08:10:46Z",
      "side": 1,
      "message": "1) What child processes won\u0027t end up initialized via the current paths in the child process host / render process host?\n2) If we\u0027re not going to pass a shm handle at all, why not just return nullptr and skip initializing it at all?",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c5ad158_bb60a877",
        "filename": "content/browser/histogram_controller.cc",
        "patchSetId": 19
      },
      "lineNbr": 131,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-04T10:32:01Z",
      "side": 1,
      "message": "1) unit test child processes\n2) using non-shared memory for histograms is still legit",
      "parentUuid": "d0ff8597_8dc52ad1",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49a3726b_30283a5f",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 33,
      "author": {
        "id": 1117419
      },
      "writtenOn": "2017-10-04T21:06:16Z",
      "side": 1,
      "message": "I\u0027m confused by this.  The name says it creates a child histogram yet it can be called only once.",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 30
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9eeea3ef_a0e93a88",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 33,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-04T22:48:36Z",
      "side": 1,
      "message": "It can be used once per child process. It binds a ChildHistogram interface that requires no further initialization. Barring introducing constructor arguments to mojo, this is simplest way to get creation-as-initialization. Daniel\u0027s upstream comments said that from a security perspective, this is the endorsed way.",
      "parentUuid": "49a3726b_30283a5f",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 30
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "959f54cb_c9257ec7",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 33,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T23:32:57Z",
      "side": 1,
      "message": "You could call it something else I guess... ChildHistogramInitializer? I don\u0027t care too strongly either way.",
      "parentUuid": "9eeea3ef_a0e93a88",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 30
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8184522_85828fc2",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 33,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-05T01:33:59Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "959f54cb_c9257ec7",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 30
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2393aacc_d3c9b496",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 33,
      "author": {
        "id": 1117419
      },
      "writtenOn": "2017-10-05T13:13:33Z",
      "side": 1,
      "message": "I think what\u0027s confusing is that these aren\u0027t child histograms but child histogram *messages*.  Perhaps the style for Mojo things is to not mention this explicitly -- I don\u0027t know -- but if not, could you make it more clear?\n\nBut yes, please change the name.  I suggest:  SetChildHistogramSharedMemory()",
      "parentUuid": "b8184522_85828fc2",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 30
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "914a670f_8438da40",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 33,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-05T21:03:33Z",
      "side": 1,
      "message": "As far as I can tell, nverne is using this to bootstrap child histogram set up in child processes (whether or not they\u0027re using persistent histograms). I was the one who suggested a factory pattern originally (perhaps incorrectly). To avoid further confusion, I think it would be helpful to have some more background on how this is expected to work for:\n- processes where child histograms use persistent memory. Presumably we expect the shmem allocator to be set up ASAP\n- processes where child histograms which don\u0027t use persistent memory. It looks like they just report histogram diffs, but it\u0027s not clear if any initialization is required.\n- other cases?",
      "parentUuid": "2393aacc_d3c9b496",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 30
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c7094441_76b3951f",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 39,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T08:10:46Z",
      "side": 1,
      "message": "Do we expect this to fail in practice?",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e282f3f9_494dcd6d",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 39,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-04T10:32:01Z",
      "side": 1,
      "message": "When the handle is uninitialized, and this can happen when it\u0027s optional.",
      "parentUuid": "c7094441_76b3951f",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fd3595eb_4c0191c4",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 39,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-05T01:33:59Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "e282f3f9_494dcd6d",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f517c42a_502aa4f1",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 50,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T08:10:46Z",
      "side": 1,
      "message": "Out of curiosity, what would cause this to be null?",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e95f8d48_c33135fe",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 50,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-04T10:32:01Z",
      "side": 1,
      "message": "Don\u0027t know. I ported the code from the old file.",
      "parentUuid": "f517c42a_502aa4f1",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e44990c5_0eb57aef",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 50,
      "author": {
        "id": 1117419
      },
      "writtenOn": "2017-10-04T21:06:16Z",
      "side": 1,
      "message": "It would be null if the above CreateWith...() was never called.",
      "parentUuid": "e95f8d48_c33135fe",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e1ea462_d1cf2162",
        "filename": "content/child/child_histogram_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 50,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-04T22:48:36Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "e44990c5_0eb57aef",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d7f01a0c_0f9b2e97",
        "filename": "content/child/child_histogram_impl.h",
        "patchSetId": 19
      },
      "lineNbr": 41,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T08:10:46Z",
      "side": 1,
      "message": "Nit: I\u0027m guessing this was moved, but prefer using A \u003d B; over typedef B A;",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90708e8c_9a7de907",
        "filename": "content/child/child_histogram_impl.h",
        "patchSetId": 19
      },
      "lineNbr": 41,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-04T10:32:01Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "d7f01a0c_0f9b2e97",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "30497cd0_23fb9136",
        "filename": "content/child/child_histogram_impl.h",
        "patchSetId": 19
      },
      "lineNbr": 41,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T19:20:23Z",
      "side": 1,
      "message": "Please fix though \u003d)",
      "parentUuid": "90708e8c_9a7de907",
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "702c8eea_ad244096",
        "filename": "content/common/child_histogram.mojom",
        "patchSetId": 19
      },
      "lineNbr": 10,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T08:10:46Z",
      "side": 1,
      "message": "Why optional? Is there a point to calling this if we don\u0027t pass down a shm handle??",
      "range": {
        "startLine": 10,
        "startChar": 23,
        "endLine": 10,
        "endChar": 45
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7b118dc_32965458",
        "filename": "content/common/child_histogram.mojom",
        "patchSetId": 19
      },
      "lineNbr": 10,
      "author": {
        "id": 1210615
      },
      "writtenOn": "2017-10-04T10:32:01Z",
      "side": 1,
      "message": "This enforces that you can\u0027t set the shared memory for histograms after you\u0027ve started using them. I think it\u0027s better this way.",
      "parentUuid": "702c8eea_ad244096",
      "range": {
        "startLine": 10,
        "startChar": 23,
        "endLine": 10,
        "endChar": 45
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea1123af_1645e914",
        "filename": "content/common/child_histogram.mojom",
        "patchSetId": 19
      },
      "lineNbr": 10,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-04T19:20:23Z",
      "side": 1,
      "message": "OK, thanks for helping me understand how this works. Do you mind updating this to mention that |shm_handle| not being set means that we won\u0027t get the persistent UMAs? +bcwhite as well, maybe if there\u0027s overall documentation (that\u0027s not too stale) for the child UMA stuff, it would be useful to link to that here as well.",
      "parentUuid": "e7b118dc_32965458",
      "range": {
        "startLine": 10,
        "startChar": 23,
        "endLine": 10,
        "endChar": 45
      },
      "revId": "4afb99672fa1a87455e21baaaae1efb8d08cc6ef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}