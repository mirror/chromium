{
  "comments": [
    {
      "key": {
        "uuid": "9fba35de_78a9f1ff",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 138,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-08T00:57:00Z",
      "side": 1,
      "message": "This is not what we eventually want, but helpful towards making progress.",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11654857_8fb648e0",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 179,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-08T00:57:00Z",
      "side": 1,
      "message": "I wonder why we want to delete displays the user is when merely switching configurations. It seems mostly like an unintended side-effect of automatic display destruction when removing a display\u0027s root window (which is perhaps useful in other scenarios?). It\u0027s also probably a misdirected communication as ash\u0027s DisplayManager is attempting to notify components sitting above it that a display is going away (ie. there is no unique second display with its own root window now, only an inaccessible mirror), but this same notification propagates to Mus as a \"Hey, this physical display is being removed (eg. disconnected)\"...",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d6522be_121ba83f",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 179,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-08T14:44:05Z",
      "side": 1,
      "message": "Maybe this points to removing a root ServerWindow/AshWindowTreeHost being something separate from destroying a ws::Display?",
      "parentUuid": "11654857_8fb648e0",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf994398_b9bfde0a",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 179,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2017-11-08T18:24:52Z",
      "side": 1,
      "message": "What is the display sequence when a display is setup as a mirror? Do we end up in WindowManagerState::DeleteWindowManagerDisplayRoot() for the display before it is made the mirror?",
      "parentUuid": "0d6522be_121ba83f",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06b8196b_834ba9fb",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 179,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-08T19:03:50Z",
      "side": 1,
      "message": "No, see the comment below. Ash (1) calls SetDisplayConfiguration with the display-\u003emirror change, and then (2) destroys the display as it becomes a mirror. I do think it would be better to avoid destroying displays when we remove/replace root windows.",
      "parentUuid": "bf994398_b9bfde0a",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82815854_2a6d661e",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 261,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-08T00:57:00Z",
      "side": 1,
      "message": "It\u0027s a bit tough to discern the intended workflow between ash and mus when it comes to display configuration, but this occurs when ash (1) calls SetDisplayConfiguration with the display-\u003emirror change, and then (2) destroys the display as it becomes a mirror.\n\nCallstack from (1):\n  base::debug::StackTrace::StackTrace()\n  ash::DisplaySynchronizer::SendDisplayConfigurationToServer()\n  ash::DisplaySynchronizer::OnDidProcessDisplayChanges()\n  display::DisplayManager::BeginEndNotifier::~BeginEndNotifier()\n  display::DisplayManager::UpdateDisplaysWith()\n  display::DisplayManager::OnNativeDisplaysChanged()\n  display::DisplayChangeObserver::OnDisplayModeChanged()\n  display::DisplayConfigurator::NotifyDisplayStateObservers()\n  display::DisplayConfigurator::OnConfigured()\n\nCallstack from (2):\n  ui::ws::DisplayManager::DestroyDisplay()\n  ui::ws::WindowManagerState::DeleteWindowManagerDisplayRoot()\n  ui::ws::WindowTree::RemoveRoot()\n  ui::ws::WindowTree::DeleteWindow\n MOJO...\n  aura::WindowTreeClient::OnWindowMusDestroyed()\n  aura::WindowPortMus::~WindowPortMus()\n ... \n  ash::RootWindowController::Shutdown()\n  ash::WindowTreeHostManager::DeleteHost()\n  ash::WindowTreeHostManager::OnDisplayRemoved()\n  display::DisplayManager::NotifyDisplayRemoved()\n  display::DisplayManager::UpdateDisplaysWith()\n\nIf I don\u0027t remove the display from that list here, we hit a dcheck when it\u0027s re-added on the next SetDisplayConfiguration call... and sadly I need to check that the screen manager exists (it doesn\u0027t as some tests destroy all displays on shut down...)",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "faf3a85a_a16078f7",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 261,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-08T14:44:05Z",
      "side": 1,
      "message": "Is the root of the problem here that the ws::Display is destroyed when WindowTreeClient::OnWindowMusDestroyed() is called for a root window? The information contained in WindowTreeClient::SetDisplayConfiguration() also provides a signal to destroy a ws::Display (or move it to mirroring list) based on the fact that the display is no longer in the list.",
      "parentUuid": "82815854_2a6d661e",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0aeacc73_3eda80cc",
        "filename": "services/ui/ws/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 261,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-08T19:03:50Z",
      "side": 1,
      "message": "Yeah, afiact, SetDisplayConfiguration does the correct thing, then Ash\u0027s NotifyDisplayRemoved correctly destroys the root window, but that also causes unintended destruction of the ws::Display. It seems like DisplayManager should be explicitly manage ws::Displays, and WindowTree root removal should not destroy ws::Displays.",
      "parentUuid": "faf3a85a_a16078f7",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3fa892e6_500ee388",
        "filename": "ui/display/manager/chromeos/display_configurator.cc",
        "patchSetId": 14
      },
      "lineNbr": 290,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-08T14:44:05Z",
      "side": 1,
      "message": "Can you explain this a bit better to me?",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c467997_1f354c40",
        "filename": "ui/display/manager/chromeos/display_configurator.cc",
        "patchSetId": 14
      },
      "lineNbr": 290,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-08T19:03:50Z",
      "side": 1,
      "message": "This is a possible method for detecting that the displays are fake linux-desktop chromeos display windows, and reverting from hardware mirroring to software mirroring when using the display configurator.",
      "parentUuid": "3fa892e6_500ee388",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38e55415_64e406f9",
        "filename": "ui/display/manager/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 1241,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-08T14:44:05Z",
      "side": 1,
      "message": "When running classic ash on Linux desktop do the displays ever get added to the |hardware_mirroring_display_id_list_| or are they only added to the |software_mirroring_display_list_|? It looks like displays are considered for hardware mirroring if they have the same origin here:\n\nhttps://cs.chromium.org/chromium/src/ui/display/manager/display_manager.cc?type\u003dcs\u0026sq\u003dpackage:chromium\u0026l\u003d737\n\nWhen running cash on Linux desktop it doesn\u0027t run ConfigureDisplaysTask which is what updates DisplaySnapshot origin. ConfigureDisplaysTask does run with mus/mash and when building the DisplayConfigureRequest all displays get the origin of (0, 0) here:\n\nhttps://cs.chromium.org/chromium/src/ui/display/manager/chromeos/display_configurator.cc?l\u003d220\n\nIt seems like somewhere (DisplayConfigurator, UpdateDiplayConfigurationTask or ConfiugreDisplaysTask probably) that drops into software mirroring automatically if !chromeos::IsRunningAsSystemCompositor().",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf67bda0_00e7cb3c",
        "filename": "ui/display/manager/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 1241,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-08T19:03:50Z",
      "side": 1,
      "message": "No, afaict, the displays are never added to |hardware_mirroring_display_id_list_| when running classic ash on Linux desktop, and OnNativeDisplaysChanged is never called when switching in or out of mirroring mode on mus... the DisplayConfigurator and mus desktop codepaths are vastly different than the classic ash desktop codepaths, making it tricky for me to establish a solid mental model of how these components should work.\n\nCan you enlighten me about chromeos::IsRunningAsSystemCompositor? Is that essentially a check for cash vs. mus, or is it related to running on device/desktop?",
      "parentUuid": "38e55415_64e406f9",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88d43836_9b2c4e81",
        "filename": "ui/display/manager/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 1241,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-08T19:55:28Z",
      "side": 1,
      "message": "chromeos::IsRunningAsSystemCompositor() is the canonical check for device/desktop, so use that when necessary.\n\nHow does the fallback to software mirroring work on a real device? I\u0027ve never looked into that.",
      "parentUuid": "cf67bda0_00e7cb3c",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39a600f2_52e70d49",
        "filename": "ui/display/manager/display_manager.cc",
        "patchSetId": 14
      },
      "lineNbr": 1241,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-11-09T00:46:50Z",
      "side": 1,
      "message": "Returning false in FindMirrorMode (or bailing from ParseDisplays early) if chromeos::IsRunningAsSystemCompositor() is false does indeed fall back to software mirroring earlier, and never adds the displays to the hardware mirroring list (the origins are different). I made that change, reverted changes here and in GetDisplayLayout. Thanks for the tip!\n\nI\u0027ll have to test the software fallback behavior on a device (presumably you\u0027re asking about cash?) tomorrow, if you\u0027d find that info helpful. What conditions would you like to know about? (I\u0027m guessing my external monitor has a different resolution and that would cause software fallback, probably from DisplayConfigurator::DisplayLayoutManagerImpl::ParseDisplays / FindMirrorMode).",
      "parentUuid": "88d43836_9b2c4e81",
      "revId": "87f0fb87e85e6b6f23f6ff467558bafdb59fe06e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}