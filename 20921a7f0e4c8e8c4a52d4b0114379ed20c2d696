{
  "comments": [
    {
      "key": {
        "uuid": "6f4e9c1e_0467d6f3",
        "filename": "services/video_capture/device_factory_media_to_mojo_adapter.cc",
        "patchSetId": 5
      },
      "lineNbr": 156,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-11-16T14:15:07Z",
      "side": 1,
      "message": "I haven\u0027t followed recent changes in coding guidelines for Chromium. Is the C++14 std::make_unique now officially allowed and recommended to be used instead of base::MakeUnique?",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49590e3b_fc7ee084",
        "filename": "services/video_capture/device_factory_media_to_mojo_adapter.cc",
        "patchSetId": 5
      },
      "lineNbr": 156,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-11-16T17:30:35Z",
      "side": 1,
      "message": "Not sure. Will use base::MakeUnique to make it consistent.",
      "parentUuid": "6f4e9c1e_0467d6f3",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9ae3cc6_8038a3ed",
        "filename": "services/video_capture/device_factory_media_to_mojo_adapter.cc",
        "patchSetId": 5
      },
      "lineNbr": 156,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-11-16T17:40:27Z",
      "side": 1,
      "message": "Hmm, looking at the video capture service code, we been using std::make_unique pretty much everywhere, base::MakeUnique is only used in couple places. And according to https://chromium-cpp.appspot.com/, std::make_unique is currently allowed.\n\nSo it probably make more sense to switch the couple instances of base::MakeUnique to std::make_unique. Will update.",
      "parentUuid": "49590e3b_fc7ee084",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a5e9a50_b486fe42",
        "filename": "services/video_capture/device_factory_media_to_mojo_adapter.cc",
        "patchSetId": 5
      },
      "lineNbr": 156,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-11-16T17:45:15Z",
      "side": 1,
      "message": "It turns out that all base::MakeUnique are changed to std::unique_ptr in this CL: https://chromium-review.googlesource.com/c/chromium/src/+/767370\n\nThe leftover instances mentioned in previous comment are actually new code added by me :)",
      "parentUuid": "c9ae3cc6_8038a3ed",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8242e6d8_3ae3da6d",
        "filename": "services/video_capture/public/interfaces/virtual_device.mojom",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-11-16T14:15:07Z",
      "side": 1,
      "message": "We need to update the description comments to explain how this is supposed to work.\nFirst, we need to describe that the basic idea is that every time the producer wants to push a frame it first calls RequestFrameBuffer, then waits for a response indicating new or reused buffer handle, then calls OnFrameReadyInBuffer. \n\nMy understanding is that this method is to be called by the producer to request a free buffer large enough to hold a frame with the given parameters. The service can react in one of two ways.\n1. It may provide a new buffer. If so, it will invoke Producer::OnNewBufferHandle() and will respond with the corresponding |buffer_id|.\n2. It may choose to reuse an existing buffer. If so it responds with the corresponding |buffer_id| without invoking Producer::OnNewBufferHandle().\n\nI think we could improve the clarity of the API by removing the \u003d\u003e (int32 buffer_id) response here and instead adding a method OnReuseBufferHandle() to the Producer interface. This would change the above to \n1. It may provide a new buffer. If so it will invoke Producer::OnNewBufferHandle().\n2. It may choose to reuse an existing buffer. If so it will invoke Producer::OnReuseBufferHandle().\n\nWe may also consider renaming this method here to \"RequestFrameBuffer\".",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f3be8c5_7e81c737",
        "filename": "services/video_capture/public/interfaces/virtual_device.mojom",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-11-16T17:30:35Z",
      "side": 1,
      "message": "Agreed on updating the comments.\n\nHowever, I think having a response callback \u003d\u003e(int32 buffer_id) make more sense from API point of view. So that the caller can easily associate a returned buffer_id with a request, and having the service providing a response back when there is no buffer available is also important. \n\nThe fact that a returned buffer is a newly created or not is not really important to the caller, and can be handled \"out-of-band\". When a caller request a buffer, a new buffer might be created and old buffer might be retired, they will be handled by the producer (Producer.OnNewBufferHandle and Producer.OnBufferRetired), and update the buffer information accordingly. I think it make sense to keep Producer.OnNewBufferHandle and Producer.OnBufferRetired used for updating buffer information only, not as a direct answer for RequestFrameBuffer.\n\nFor example, if in the future we decided to change the implementation of VirtualDevice to pre-allocate buffers instead of on-demand, then the current API would still work. I don\u0027t think the producer needs to know if the buffers are pre-allocated or on-demand. The suggested API would not, since it assumes the buffers are allocated on-demand.\n\nSimilarly with the real device capture, when a new frame comes in, a new buffer might be created and old buffer might be retired, Receiver.OnNewBufferHandle and Receiver.OnBufferRetired are invoked to handle these events. We always use OnFrameReadyInBuffer to signal that a buffer is ready, we don\u0027t specifically indicate if this is a new or a reused buffer.\n\nI am fine with renaming it to \"RequestFrameBuffer\".\n\nLet me know what you think.",
      "parentUuid": "8242e6d8_3ae3da6d",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "267eaf2a_cad750f0",
        "filename": "services/video_capture/public/interfaces/virtual_device.mojom",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-11-16T22:51:51Z",
      "side": 1,
      "message": "Hmm, what you write makes sense.\nOne remaining concern with this, is that the call (or lack of call) to Producer::OnNewBufferHandle() must be guaranteed to arrive before the response \u003d\u003e (int32 buffer_id), because otherwise the response may point to a buffer_id that is not yet known by the producer.\n\nIn the Mojo world, it is not enough to simply call producer_-\u003eOnNewBufferHandler() before invoking the callback to guarantee they arrive in the same order. \n\nOne possible solution would be to use Mojo \"Associated interfaces\", but I think this is not recommended. Maybe a better solution would be to have OnNewBufferHandle() send an empty response back, basically just indicating that the message was received by the producer. Then the service can wait for that before sending out the response \u003d\u003e (buffer_id).",
      "parentUuid": "9f3be8c5_7e81c737",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "739bc8e8_b60d8ca8",
        "filename": "services/video_capture/public/interfaces/virtual_device.mojom",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-11-16T23:06:18Z",
      "side": 1,
      "message": "I see, so the message order are only guarantee when delivering through the same message pipe, which is why we don\u0027t have this ordering problem with Receiver::OnNewBufferHandle being invoked before Receiver::OnFrameReadyInBuffer in VideoCaptureDeviceClient, right? And here the invocation of Producer::OnNewBufferHandle() and the response callback will be posted on different message pipes.\n\nIn this case, what you suggested should work. Basically, have the service wait for the producer to ack that the newly created buffer is received before sending the response.",
      "parentUuid": "267eaf2a_cad750f0",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "35b26b93_f22f1ec2",
        "filename": "services/video_capture/test/virtual_device_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 143,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-11-16T14:15:07Z",
      "side": 1,
      "message": "It would be nice if we could add a test case that demonstrates how the producer is able to transport a series of frames larger than max_buffer_pool_buffer_count without having to remap any buffer handles.",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f89e740f_63246fc2",
        "filename": "services/video_capture/test/virtual_device_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 143,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-11-16T17:30:35Z",
      "side": 1,
      "message": "Will do.",
      "parentUuid": "35b26b93_f22f1ec2",
      "revId": "20921a7f0e4c8e8c4a52d4b0114379ed20c2d696",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}