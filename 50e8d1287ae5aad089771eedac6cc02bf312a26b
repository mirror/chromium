{
  "comments": [
    {
      "key": {
        "uuid": "93e11a91_8c7be169",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-26T21:45:09Z",
      "side": 1,
      "message": "Are you confident that all viewport script scrolling goes through these two methods\n(window.scrollBy and window.scrollTo)?\n\nI am pretty sure you can scroll window via document.scrollingElement as well.\nFor example document.scrollingElement.scrollY\u003d10; should scroll the window. Here is\nwhat comes to my mind:\n1. document.scrollingElement.scroll{Top,Left}\u003d\n2. document.scrollingElement.scroll{By,To}()\n3. potentially scrollIntoView\n\nI checked (1) and it should go through the LocalDOMWindow methods but (2) goes\nthrough Element::ScrollFrameBy which bypassed LocalDOMWindow. Didn\u0027t check (3).\n\nSo, can you make sure we know all possible routes to scroll window and account\nfor them. Perhaps we don\u0027t care about some of them but at least we should know\nwhat we are ignoring.\n\n\nI was thinking whether we can actually move this recording inside ScrollableArea itself (i.e, viewport-\u003eSetScrollOffset()) and record this flag when kProgrammaticScroll is set but\nunfortunately we are using kProgrammaticScroll for more than just scripted scrolls.",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "738f736f_4932859c",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1197698
      },
      "writtenOn": "2018-01-30T20:02:09Z",
      "side": 1,
      "message": "Added scrollingElement.scroll{Top, Left, By, To, IntoView, IntoViewIfNeed}.",
      "parentUuid": "93e11a91_8c7be169",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "697ce72a_aa0ca5b3",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-31T19:30:57Z",
      "side": 1,
      "message": "That is better.\n\nBut thinking about it some more, I am worried that we are sprinkling setting\nthese flags across all these different entry points for scrolling viewport via javascript. \nThis result in a fairly brittle code.\n\nIMHO, a better approach may be to perhaps split kProgrammaticScroll into two different categories: kPrgrammaticScroll and kScriptScroll and use the latter anytime we have a scroll coming from javascript. This way you can set this flag inside Viewport::SetScrollOffset in one place. Being able to differentiate between programmatic and script scrolling may end\nup useful in other ways too!\n\nI am not an expert here so let\u0027s see if skobes@ has opinion one way or another.",
      "parentUuid": "738f736f_4932859c",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0fd7891e_66b9df9a",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-01-31T19:42:38Z",
      "side": 1,
      "message": "\u003e IMHO, a better approach may be to perhaps split kProgrammaticScroll into two different categories: kPrgrammaticScroll and kScriptScroll and use the latter anytime we have a scroll coming from javascript. This way you can set this flag inside Viewport::SetScrollOffset in one place. Being able to differentiate between programmatic and script scrolling may end\n\u003e up useful in other ways too!\n\u003e \n\u003e I am not an expert here so let\u0027s see if skobes@ has opinion one way or another.\n\nI agree that we should set was_scrolled_by_js from UpdateScrollOffset based on ScrollType.\n\nTo me \"programmatic\" is synonymous with script.  What are we using kProgrammaticScroll for besides script?  We should split out the non-script uses.",
      "parentUuid": "697ce72a_aa0ca5b3",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa442f1b_9f5aa20c",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-31T19:59:40Z",
      "side": 1,
      "message": "In addition to all the script scrolls, there is a whole bunch of cases considered programmatic\nbut are not related to script. For example:\n\n - FrameLoader::RestoreScrollPositionAndViewState\n - Page::DidCommitLoad\n - RotationViewportAnchor::RestoreToAnchor\n - SnapCoordinator::PerformSnapping\n - TextFieldInputType::ForwardEvent\n - ImageDocument::ImageClicked \n\nand etc.\n\nIt appears to me that currently kProgrammaticScroll is treated like a generic category \nthat is used when it is not user scroll and it does not fall into a more specific category (clamping, anchoring, compositor). \n\nI am not sure is there is a better term to refer to all above. But I am fine calling these\nProgrammaticScroll and using ScriptScroll for scrolls coming directly via various scroll\nmethods  from javascript. Better suggestions are welcome.",
      "parentUuid": "0fd7891e_66b9df9a",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8cbcd3e_ab751963",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-01-31T20:08:19Z",
      "side": 1,
      "message": "\u003e In addition to all the script scrolls, there is a whole bunch of cases considered programmatic\n\u003e but are not related to script. For example:\n\u003e \n\u003e  - FrameLoader::RestoreScrollPositionAndViewState\n\u003e  - Page::DidCommitLoad\n\u003e  - RotationViewportAnchor::RestoreToAnchor\n\u003e  - SnapCoordinator::PerformSnapping\n\u003e  - TextFieldInputType::ForwardEvent\n\u003e  - ImageDocument::ImageClicked \n\u003e \n\u003e and etc.\n\u003e \n\u003e It appears to me that currently kProgrammaticScroll is treated like a generic category \n\u003e that is used when it is not user scroll and it does not fall into a more specific category (clamping, anchoring, compositor). \n\u003e \n\u003e I am not sure is there is a better term to refer to all above. But I am fine calling these\n\u003e ProgrammaticScroll and using ScriptScroll for scrolls coming directly via various scroll\n\u003e methods  from javascript. Better suggestions are welcome.\n\nHow about kBrowserScroll for the generic stuff and kPlatformScroll for scrolls from the web platform API\u0027s?",
      "parentUuid": "fa442f1b_9f5aa20c",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80f45cae_dac5f26b",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-01-31T20:57:11Z",
      "side": 1,
      "message": "\u003e How about kBrowserScroll for the generic stuff and kPlatformScroll for scrolls from the web platform API\u0027s?\n\nkBrowserScroll and kScriptScroll is fine too",
      "parentUuid": "d8cbcd3e_ab751963",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "836dfc75_7756741e",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1002681
      },
      "writtenOn": "2018-02-02T02:14:23Z",
      "side": 1,
      "message": "\u003e - FrameLoader::RestoreScrollPositionAndViewState\n\u003e - Page::DidCommitLoad\n\u003e - RotationViewportAnchor::RestoreToAnchor\n\u003e - SnapCoordinator::PerformSnapping\n\u003e - TextFieldInputType::ForwardEvent\n\u003e - ImageDocument::ImageClicked\n\nDoes user scrolling cancel browser restoration? Should it? It does cancel fragment navigation and this feels like a similar use case.\n\nIMHO, These all seem like they\u0027re either at a time when it doesn\u0027t matter for scroll restoration or they\u0027re the result of a user action which we should maybe be taking as a cue not to change the scroll offset.\n\nScrollType was originally meant to handle the fact that we have separate animators for programmatic and user scrolling but has since grown from the original 2 to 6 and there\u0027s already ambiguity between different types so I\u0027m a bit weary of adding yet another.\n\nIf we\u0027re going to make a sweeping change (Chao\u0027s split out patch touches lots of stuff) I think we\u0027d be better served by a bit field. such that kProgrammaticScroll \u003d\u003d kBrowserScroll | kScriptScroll | kSequencedScroll (and maybe Anchoring | Clamping?). Then we could also have compositor scrolls being kCompositorScroll | kUserScroll to differentiate from kCompositorScroll | kClampingScroll which would also be helpful in some situations. That way if we keep adding information to where a scroll came from we don\u0027t have to keep changing every handler to make sure it covers the new case too. WDYT?",
      "parentUuid": "80f45cae_dac5f26b",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bff68e97_87566044",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1197698
      },
      "writtenOn": "2018-02-02T02:26:38Z",
      "side": 1,
      "message": "Does user scrolling cancel browser restoration? Yes.\n\nThe split patch really touches lot of stuff. https://chromium-review.googlesource.com/c/chromium/src/+/897932",
      "parentUuid": "836dfc75_7756741e",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "992ec33e_ffc139bb",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-02-02T19:58:48Z",
      "side": 1,
      "message": "\u003e Does user scrolling cancel browser restoration? Should it? It does cancel fragment navigation and this feels like a similar use case.\n\nUser scrolls have always cancelled history restore, this is what InitialScrollState::was_scrolled_by_user is for.\n\nThe interaction of user scrolls and fragment navigation is more complicated. :)\n\n\u003e ScrollType was originally meant to handle the fact that we have separate animators for programmatic and user scrolling but has since grown from the original 2 to 6 and there\u0027s already ambiguity between different types so I\u0027m a bit weary of adding yet another.\n\nYeah it\u0027s gotten messy.  What do you think of expressing the overlapping categories with IsXxx helpers?  E.g.\n\n  bool IsProgrammaticScrollType(ScrollType type) {\n    return type \u003d\u003d kBrowserScroll || type \u003d\u003d kScriptScroll || ...;\n  }\n\nThis seems simpler to me than a bit field.",
      "parentUuid": "bff68e97_87566044",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc027695_ee63a4f0",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-02-02T20:06:12Z",
      "side": 1,
      "message": "Wait I might have missed your point.  Are you saying we shouldn\u0027t even bother separating kProgrammaticScroll into kBrowserScroll and kScriptScroll, because their behavior should be identical with respect to supressing history restore?\n\nIf so I am totally on board with leaving ScrollType as is. :)",
      "parentUuid": "992ec33e_ffc139bb",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19ff7a62_2a453a5e",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-02-05T15:55:11Z",
      "side": 1,
      "message": "\u003e Are you saying we shouldn\u0027t even bother separating kProgrammaticScroll into kBrowserScroll and kScriptScroll, because their behavior should be identical with respect to supressing history restore?\n\nWell, I think eventually we want to treat them the same for scroll restoration behavior. However, first step we wanted to measure how often we will suppress scroll restoration\nif we change the behavior. Given that it will have a UX impact it is important to know\nthis.\n\n\nI am not sure if we want to treat all of what is currently kProgrammaticScroll \nthe same though in this regard. For example it is odd to have \u0027FrameLoader::RestoreScrollPositionAndViewState\u0027 supress scroll restoration.\n\n\n\u003e Yeah it\u0027s gotten messy.  What do you think of expressing the overlapping categories with IsXxx helpers?  E.g.  bool IsProgrammaticScrollType(ScrollType type) { return type \u003d\u003d kBrowserScroll || type \u003d\u003d kScriptScroll || ...;} This seems simpler to me than a bit field.\n\nI think the main merit of bitfield idea is that we can has a single argument but use it to\nexpress cases where the scroll has multiple dimensions but perhaps we need\nan structs with two simple enums?. I can see two dimensions at least: \n\nStruct type { \n Source: kBrowserScroll || kScriptScroll || kUser || kCompositor\n Kind: Input || Clamping || Anchoring || Snapping || Restoring || Sequenced  \n}\n\nHere are some examples: \nTextFieldInputType::ForwardEvent  \u003d\u003e {kBrowserScroll, Input}\nFrameLoader::RestoreScroll        \u003d\u003e {kBrowserScroll, Restoring}\nPage::DidCommitLoad               \u003d\u003e {kBrowserScroll, ???} // this is the initial scroll\nRotationViewportAnchor::RestoreToAnchor \u003d\u003e {kBrowserScroll, Snapping\nSnapCoordinator::PerformSnapping  \u003d\u003e {[...], Snapping} // source is whatever caused the snap!\nImageDocument::ImageClicked       \u003d\u003e {kBrowserScroll, Input}\njavascript methods                \u003d\u003e {kScriptScroll, Input}\ncompositor                        \u003d\u003e {kCompositor, [...] }\n\n\nIn any case, I can see that this clean up may require more work than expected.\nSo I am fine if Chao want to land this CL in its current form with a TODO\nto do the refactor and clean up in a follow up patch.",
      "parentUuid": "cc027695_ee63a4f0",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c1fe8ac_32dab918",
        "filename": "tools/metrics/histograms/enums.xml",
        "patchSetId": 1
      },
      "lineNbr": 17700,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-26T21:45:09Z",
      "side": 1,
      "message": "This is not really a web feature API. So I don\u0027t think this is the right enum histogram\nto add it. In any case if it was you have to add it to \"web_feature.mojom\".\n\nI think you want to introduce a new enum histogram for this.",
      "range": {
        "startLine": 17700,
        "startChar": 0,
        "endLine": 17700,
        "endChar": 61
      },
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bc55c34_207a0b5c",
        "filename": "tools/metrics/histograms/enums.xml",
        "patchSetId": 1
      },
      "lineNbr": 17700,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-31T19:30:57Z",
      "side": 1,
      "message": "This still seems to be an issue.",
      "parentUuid": "7c1fe8ac_32dab918",
      "range": {
        "startLine": 17700,
        "startChar": 0,
        "endLine": 17700,
        "endChar": 61
      },
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}