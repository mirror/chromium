{
  "comments": [
    {
      "key": {
        "uuid": "93e11a91_8c7be169",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-26T21:45:09Z",
      "side": 1,
      "message": "Are you confident that all viewport script scrolling goes through these two methods\n(window.scrollBy and window.scrollTo)?\n\nI am pretty sure you can scroll window via document.scrollingElement as well.\nFor example document.scrollingElement.scrollY\u003d10; should scroll the window. Here is\nwhat comes to my mind:\n1. document.scrollingElement.scroll{Top,Left}\u003d\n2. document.scrollingElement.scroll{By,To}()\n3. potentially scrollIntoView\n\nI checked (1) and it should go through the LocalDOMWindow methods but (2) goes\nthrough Element::ScrollFrameBy which bypassed LocalDOMWindow. Didn\u0027t check (3).\n\nSo, can you make sure we know all possible routes to scroll window and account\nfor them. Perhaps we don\u0027t care about some of them but at least we should know\nwhat we are ignoring.\n\n\nI was thinking whether we can actually move this recording inside ScrollableArea itself (i.e, viewport-\u003eSetScrollOffset()) and record this flag when kProgrammaticScroll is set but\nunfortunately we are using kProgrammaticScroll for more than just scripted scrolls.",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "738f736f_4932859c",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1197698
      },
      "writtenOn": "2018-01-30T20:02:09Z",
      "side": 1,
      "message": "Added scrollingElement.scroll{Top, Left, By, To, IntoView, IntoViewIfNeed}.",
      "parentUuid": "93e11a91_8c7be169",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "697ce72a_aa0ca5b3",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-31T19:30:57Z",
      "side": 1,
      "message": "That is better.\n\nBut thinking about it some more, I am worried that we are sprinkling setting\nthese flags across all these different entry points for scrolling viewport via javascript. \nThis result in a fairly brittle code.\n\nIMHO, a better approach may be to perhaps split kProgrammaticScroll into two different categories: kPrgrammaticScroll and kScriptScroll and use the latter anytime we have a scroll coming from javascript. This way you can set this flag inside Viewport::SetScrollOffset in one place. Being able to differentiate between programmatic and script scrolling may end\nup useful in other ways too!\n\nI am not an expert here so let\u0027s see if skobes@ has opinion one way or another.",
      "parentUuid": "738f736f_4932859c",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0fd7891e_66b9df9a",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-01-31T19:42:38Z",
      "side": 1,
      "message": "\u003e IMHO, a better approach may be to perhaps split kProgrammaticScroll into two different categories: kPrgrammaticScroll and kScriptScroll and use the latter anytime we have a scroll coming from javascript. This way you can set this flag inside Viewport::SetScrollOffset in one place. Being able to differentiate between programmatic and script scrolling may end\n\u003e up useful in other ways too!\n\u003e \n\u003e I am not an expert here so let\u0027s see if skobes@ has opinion one way or another.\n\nI agree that we should set was_scrolled_by_js from UpdateScrollOffset based on ScrollType.\n\nTo me \"programmatic\" is synonymous with script.  What are we using kProgrammaticScroll for besides script?  We should split out the non-script uses.",
      "parentUuid": "697ce72a_aa0ca5b3",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa442f1b_9f5aa20c",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-31T19:59:40Z",
      "side": 1,
      "message": "In addition to all the script scrolls, there is a whole bunch of cases considered programmatic\nbut are not related to script. For example:\n\n - FrameLoader::RestoreScrollPositionAndViewState\n - Page::DidCommitLoad\n - RotationViewportAnchor::RestoreToAnchor\n - SnapCoordinator::PerformSnapping\n - TextFieldInputType::ForwardEvent\n - ImageDocument::ImageClicked \n\nand etc.\n\nIt appears to me that currently kProgrammaticScroll is treated like a generic category \nthat is used when it is not user scroll and it does not fall into a more specific category (clamping, anchoring, compositor). \n\nI am not sure is there is a better term to refer to all above. But I am fine calling these\nProgrammaticScroll and using ScriptScroll for scrolls coming directly via various scroll\nmethods  from javascript. Better suggestions are welcome.",
      "parentUuid": "0fd7891e_66b9df9a",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8cbcd3e_ab751963",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-01-31T20:08:19Z",
      "side": 1,
      "message": "\u003e In addition to all the script scrolls, there is a whole bunch of cases considered programmatic\n\u003e but are not related to script. For example:\n\u003e \n\u003e  - FrameLoader::RestoreScrollPositionAndViewState\n\u003e  - Page::DidCommitLoad\n\u003e  - RotationViewportAnchor::RestoreToAnchor\n\u003e  - SnapCoordinator::PerformSnapping\n\u003e  - TextFieldInputType::ForwardEvent\n\u003e  - ImageDocument::ImageClicked \n\u003e \n\u003e and etc.\n\u003e \n\u003e It appears to me that currently kProgrammaticScroll is treated like a generic category \n\u003e that is used when it is not user scroll and it does not fall into a more specific category (clamping, anchoring, compositor). \n\u003e \n\u003e I am not sure is there is a better term to refer to all above. But I am fine calling these\n\u003e ProgrammaticScroll and using ScriptScroll for scrolls coming directly via various scroll\n\u003e methods  from javascript. Better suggestions are welcome.\n\nHow about kBrowserScroll for the generic stuff and kPlatformScroll for scrolls from the web platform API\u0027s?",
      "parentUuid": "fa442f1b_9f5aa20c",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80f45cae_dac5f26b",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1116039
      },
      "writtenOn": "2018-01-31T20:57:11Z",
      "side": 1,
      "message": "\u003e How about kBrowserScroll for the generic stuff and kPlatformScroll for scrolls from the web platform API\u0027s?\n\nkBrowserScroll and kScriptScroll is fine too",
      "parentUuid": "d8cbcd3e_ab751963",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "836dfc75_7756741e",
        "filename": "third_party/WebKit/Source/core/frame/LocalDOMWindow.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1215,
      "author": {
        "id": 1002681
      },
      "writtenOn": "2018-02-02T02:14:23Z",
      "side": 1,
      "message": "\u003e - FrameLoader::RestoreScrollPositionAndViewState\n\u003e - Page::DidCommitLoad\n\u003e - RotationViewportAnchor::RestoreToAnchor\n\u003e - SnapCoordinator::PerformSnapping\n\u003e - TextFieldInputType::ForwardEvent\n\u003e - ImageDocument::ImageClicked\n\nDoes user scrolling cancel browser restoration? Should it? It does cancel fragment navigation and this feels like a similar use case.\n\nIMHO, These all seem like they\u0027re either at a time when it doesn\u0027t matter for scroll restoration or they\u0027re the result of a user action which we should maybe be taking as a cue not to change the scroll offset.\n\nScrollType was originally meant to handle the fact that we have separate animators for programmatic and user scrolling but has since grown from the original 2 to 6 and there\u0027s already ambiguity between different types so I\u0027m a bit weary of adding yet another.\n\nIf we\u0027re going to make a sweeping change (Chao\u0027s split out patch touches lots of stuff) I think we\u0027d be better served by a bit field. such that kProgrammaticScroll \u003d\u003d kBrowserScroll | kScriptScroll | kSequencedScroll (and maybe Anchoring | Clamping?). Then we could also have compositor scrolls being kCompositorScroll | kUserScroll to differentiate from kCompositorScroll | kClampingScroll which would also be helpful in some situations. That way if we keep adding information to where a scroll came from we don\u0027t have to keep changing every handler to make sure it covers the new case too. WDYT?",
      "parentUuid": "80f45cae_dac5f26b",
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c1fe8ac_32dab918",
        "filename": "tools/metrics/histograms/enums.xml",
        "patchSetId": 1
      },
      "lineNbr": 17700,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-26T21:45:09Z",
      "side": 1,
      "message": "This is not really a web feature API. So I don\u0027t think this is the right enum histogram\nto add it. In any case if it was you have to add it to \"web_feature.mojom\".\n\nI think you want to introduce a new enum histogram for this.",
      "range": {
        "startLine": 17700,
        "startChar": 0,
        "endLine": 17700,
        "endChar": 61
      },
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bc55c34_207a0b5c",
        "filename": "tools/metrics/histograms/enums.xml",
        "patchSetId": 1
      },
      "lineNbr": 17700,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2018-01-31T19:30:57Z",
      "side": 1,
      "message": "This still seems to be an issue.",
      "parentUuid": "7c1fe8ac_32dab918",
      "range": {
        "startLine": 17700,
        "startChar": 0,
        "endLine": 17700,
        "endChar": 61
      },
      "revId": "50e8d1287ae5aad089771eedac6cc02bf312a26b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}