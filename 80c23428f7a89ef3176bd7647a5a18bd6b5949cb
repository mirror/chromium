{
  "comments": [
    {
      "key": {
        "uuid": "a99bb964_b19da059",
        "filename": "gpu/ipc/service/pass_through_image_transport_surface.cc",
        "patchSetId": 11
      },
      "lineNbr": 41,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-02T18:28:51Z",
      "side": 1,
      "message": "If we\u0027re going to expose LatencyInfo on GLSurface, I would go and refactor this to simplify, to pass the LatencyInfo from the GpuCommandBufferStub/InProcessCommandBuffer via the GLES2Decoder rather than trying to shortcut and pass it to the PassThroughImageTransportSurface via callbacks:\n1- simplifies ImageTransportSurfaceDelegate and implementations (GpuCommandBufferStub/InProcessCommandBuffer), they don\u0027t need to track LatencyInfo and callbacks\n2- removes duplication for a bunch of this logic between PassThroughImageTransportSurface and ImageTransportSurfaceOverlayMac that deals with LatencyInfo. This could just move to GLES2Decoder.\n3- avoids the slight ugliness of passing an empty latency info in the decoder, just to discard it and replace it.\n\nThe idea would be simply to add a AddLatencyInfo to GLES2Decoder, that would track the latency info vector, called directly in GpuCommandBufferStub::OnAsyncFlush and InProcessCommandBuffer::FlushOnGpuThread (instead of calling the callback), and then add a (protected) PrepareTakeLatencyInfo on GLES2Decoder that would take (move and reset) the latency info vector, after adding the INPUT_EVENT_GPU_SWAP_BUFFER_COMPONENT component, that would be called by GLES2DecoderImpl/GLES2DecoderPassthroughImpl implementations before sending to the surface\u0027s SwapBuffer etc.\n\nThe long term goal is that eventually we can reduce PassThroughImageTransportSurface to about nothing at all and actually remove it (along with GLSurfaceAdapter), and leave ImageTransportSurfaceOverlayMac to focus on the specific implementation of the surface, and not the unrelated logic (latency info tracking and related IPCs). But small steps, I think the above would help a lot, and make the code easier to follow.",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "571d9f81_01888ed5",
        "filename": "gpu/ipc/service/pass_through_image_transport_surface.cc",
        "patchSetId": 11
      },
      "lineNbr": 41,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-10-02T22:58:13Z",
      "side": 1,
      "message": "Sounds like a good cleanup.\n\nNow that I understand PassThroughImageTransportSurface better, I think we could also avoid ui/gl\u0027s dependency on ui/latency_info by adding a separate GLLatencyInfo. In addition to better layering, it would:\n1) avoid unnecessary overhead of IPCing a bunch of LatencyInfo to the GPU service only to IPC most of it back unread and untouched.\n2) allow GLLatencyInfo to record each timestamp once per frame rather than once per element of a LatencyInfo vector.\n\nBest of all, we don\u0027t need to pass anything into any flavor of SwapBuffers or IPCs inbound to the GPU Service! The client could just set a surface property indicating they want GLLatencyInfo, then each implementation would create one as needed instead of having to transfer ownership. Then it\u0027s up to the client to merge the GLLatencyInfo with LatencyInfo or whatever else it wants to.",
      "parentUuid": "a99bb964_b19da059",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c4fdd65_a09abaf2",
        "filename": "ui/gl/DEPS",
        "patchSetId": 11
      },
      "lineNbr": 7,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-09-28T21:33:43Z",
      "side": 1,
      "message": "Question: Is adding this dependency okay?",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70e70c81_b1e23643",
        "filename": "ui/gl/DEPS",
        "patchSetId": 11
      },
      "lineNbr": 7,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2017-09-29T02:54:42Z",
      "side": 1,
      "message": "It seems OK. I can\u0027t imagine ui/latency depending on ui/gl.",
      "parentUuid": "7c4fdd65_a09abaf2",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b6171ec_d6431df5",
        "filename": "ui/gl/gl_surface.h",
        "patchSetId": 11
      },
      "lineNbr": 90,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-09-28T21:33:43Z",
      "side": 1,
      "message": "Forcing all SwapBuffers implementations to update LatencyInfo is a bit invasive, but is straightforward and makes it obvious when LatencyInfos are discarded by implementations and when they aren\u0027t available at call sites.\n\nAlternatively, this patch could add a separate method to add LatencyInfo before a swap and a way to get completed LatencyInfo (either through a callback or check), but it becomes less explicit where LatencyInfo is discarded or not available.\n\nA followup patch will add latency_info support to other flavors of swap buffers as needed, including Async, WithBounds, SubBuffer, etc.",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e72d8d69_42941268",
        "filename": "ui/gl/gl_surface.h",
        "patchSetId": 11
      },
      "lineNbr": 90,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2017-09-29T02:54:42Z",
      "side": 1,
      "message": "Agree that this touches a lot of code, and a lot of it seems duplicated and somewhat boilerplate.\n\nI agree that changing SwapBuffers\u0027 signature may be the best way to ensure this information is maintained correctly, but changing all of the GLSurface implementations is also fragile. How will regressions be avoided?\n\nIs it really better to change all of the SwapBuffers implementations than the (apparently relatively few) call sites of SwapBuffers to do a before/after call, and assert somewhere/somehow that these were called? (Same question for the other SwapBuffers variants.) Would this allow the implementation to be mostly shared, at least among the platforms that don\u0027t support the timestamps you have in mind to expose?",
      "parentUuid": "9b6171ec_d6431df5",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0b3c77f_9377e66c",
        "filename": "ui/gl/gl_surface.h",
        "patchSetId": 11
      },
      "lineNbr": 90,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-09-29T22:54:46Z",
      "side": 1,
      "message": "Regarding asserts: That would be good and isn\u0027t something I had considered to ensure correctness.\n\nRegarding implementation sharing: This patch shares code with explicit delegation to LatencyInfo::AddTerminatedFrameSwapComponent. It could be shared with less boilerplate via implementation inheritance.\n\nIf the surface is always given ownership of the LatencyInfo, overriding implementations will inherit useless member variables if the default implementation is added to GLSurface. The useless member variables could be avoided with a separate SwapLatencyInfo abstract class and a SwapLatencyInfoDefault implementation most GLSurfaces could inherit from, but that adds boilerplate of its own. I don\u0027t think it adds diamond inheritance, at least.\n\nAlternatively, if the before/after calls could *optionally* take ownership of the LatencyInfos, the default GLSurface implementation could rely on the caller holding the state during the swap while others could hold the state themselves. That\u0027s a bit awkward, but might be the best option.",
      "parentUuid": "e72d8d69_42941268",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c987012_6e472044",
        "filename": "ui/gl/gl_surface.h",
        "patchSetId": 11
      },
      "lineNbr": 90,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2017-09-30T17:19:36Z",
      "side": 1,
      "message": "I\u0027m no expert this area but having this class optionally take ownership of the LatencyInfos sounds confusing and error-prone, especially since taking ownership of a std::vector leaves the source vector in an \"undefined but consistent state\" -- which you\u0027ve had to account for in one of your patches. It would be problematic if all callers, and subclasses of GLSurface, had to take that into consideration.\n\nAdding member variables to GLSurface sounds like a good idea to me, even if they aren\u0027t touched by most implementations. I don\u0027t understand all of the implications of this patch, but if GLSurface can just have mutable pointers to the LatencyInfo vector, and leave ownership up to the outside world, that might simplify things.",
      "parentUuid": "f0b3c77f_9377e66c",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15770a4e_3940b2f3",
        "filename": "ui/gl/gl_surface.h",
        "patchSetId": 11
      },
      "lineNbr": 90,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-02T18:28:51Z",
      "side": 1,
      "message": "Note, the other versions of SwapBuffers will also need to be changed to be consistent. Namely:\n- SwapBuffersWithBounds, PostSubBuffer and CommitOverlayPlanes\n- the Async version of all 4 of these (or... 3, I don\u0027t think we have an async version of SwapBuffersWithBounds, though it should probably be added).\n\nIn particular, I don\u0027t think the current method fits very well with the Async version. I think SwapBuffersAsync and friends need to take ownership of the vector, and return it with the callback. Keeping in mind that there might be more than 1 SwapBuffers in flight.\nMaybe the way I would approach it is by passing the LatencyInfo by value to SwapBuffersAsync (expecting the caller to explicitly std::move), and pass it back to the callback by value as well (implementation would std::move too). This makes it clear at the callsite about ownership transfers (and moving vectors is very cheap).\n\nIf we go that route, I think I would have SwapBuffers be consistent as well, that is, take the input LatencyInfo by value, and returning the output LatencyInfo by value as well (e.g. introducing a movable SwapBuffersResult value type with the SwapResult and the LatencyInfo - which could also be used by the callback for async versions).",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b715475_f583a32c",
        "filename": "ui/gl/gl_surface.h",
        "patchSetId": 11
      },
      "lineNbr": 90,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-10-02T22:58:13Z",
      "side": 1,
      "message": "CrOS\u0027s async flavors of swap tie gfx::SwapResult to both the SwapAck and LatencyInfo of the frame. However, for Android, we\u0027ll want to keep them separate (or have something that can contain the SwapAck for one frame and the GLLatencyInfo of another) since we\u0027ll want to ack before the \"reads done\" timestamp is known.\n\nI\u0027ll probably just add a GLSurface::SetGLLatencyInfoCallback() and leave it up to the callback provider to decide what to do with the GLLatencyInfo.",
      "parentUuid": "15770a4e_3940b2f3",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "42e8af0c_b452be27",
        "filename": "ui/gl/gl_surface_egl.cc",
        "patchSetId": 11
      },
      "lineNbr": 959,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2017-09-29T02:54:42Z",
      "side": 1,
      "message": "Does calling this helper in these three different places have a materially different effect than calling it once at the beginning of this method?",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d1491fe_aa03b0ef",
        "filename": "ui/gl/gl_surface_egl.cc",
        "patchSetId": 11
      },
      "lineNbr": 959,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-09-29T22:54:46Z",
      "side": 1,
      "message": "This particular component is measured after swap returns (before and after this patch), with the intent that it includes any time that the actual call to eglSwapBuffers blocks. Only calling it at the beginning would cause a discontinuity in some UMA metrics.",
      "parentUuid": "42e8af0c_b452be27",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d1dbe9a_06acc30f",
        "filename": "ui/latency/latency_info.cc",
        "patchSetId": 11
      },
      "lineNbr": 167,
      "author": {
        "id": 1116050
      },
      "writtenOn": "2017-09-29T03:43:04Z",
      "side": 1,
      "message": "I\u0027d prefer we pass the time in here. Otherwise, the contract for calling this method is a bit hairy, and we\u0027d need to call out explicitly the timing requirements for calling it.",
      "range": {
        "startLine": 166,
        "startChar": 42,
        "endLine": 167,
        "endChar": 57
      },
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2cada467_74c7b99a",
        "filename": "ui/latency/latency_info.cc",
        "patchSetId": 11
      },
      "lineNbr": 167,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-09-29T22:54:46Z",
      "side": 1,
      "message": "Ok, I\u0027ll change it to always pass Now().",
      "parentUuid": "8d1dbe9a_06acc30f",
      "range": {
        "startLine": 166,
        "startChar": 42,
        "endLine": 167,
        "endChar": 57
      },
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f427f8c8_49189c18",
        "filename": "ui/latency/latency_info.h",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1002151
      },
      "writtenOn": "2017-09-28T21:33:43Z",
      "side": 1,
      "message": "@tdresser: Is this a good place to add a helper function like this, which is used by many implementations of SwapBuffers?",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ec7ea9d_a5a8b0a2",
        "filename": "ui/latency/latency_info.h",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1116050
      },
      "writtenOn": "2017-09-29T03:43:04Z",
      "side": 1,
      "message": "Yeah, this seems reasonable.",
      "parentUuid": "f427f8c8_49189c18",
      "revId": "80c23428f7a89ef3176bd7647a5a18bd6b5949cb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}