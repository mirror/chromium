{
  "comments": [
    {
      "key": {
        "uuid": "1ce2fcaa_8f640fba",
        "filename": "services/network/network_context.cc",
        "patchSetId": 31
      },
      "lineNbr": 127,
      "author": {
        "id": 1001809
      },
      "writtenOn": "2018-01-31T22:15:33Z",
      "side": 1,
      "message": "If I understand correctly, NetworkContexts will be created whether or not we\u0027re running the network service, but this ResourceScheduler will only be used if the network service is enabled.  If that\u0027s accurate, can we make this allocation dependent on the network service being enabled, so we crash if current or future code uses this ResourceScheduler in a non-network service world?  (I.e. we make sure we track how the network service is being used?)",
      "range": {
        "startLine": 127,
        "startChar": 11,
        "endLine": 127,
        "endChar": 22
      },
      "revId": "69b666f87eb65c74b4fa4c58d9b737449c771b9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbb64c21_fa0c20dd",
        "filename": "services/network/network_context.cc",
        "patchSetId": 31
      },
      "lineNbr": 127,
      "author": {
        "id": 1114080
      },
      "writtenOn": "2018-02-01T09:45:36Z",
      "side": 1,
      "message": "I didn\u0027t know that (except for test cases), thank you. NetworkContext::resource_scheduler_ is accessed whenever NetworkContext::CreateURLLoaderFactory is called; Can it be called with kNetworkService disabled?\n\nWe can create a disabled ResourceScheduler in such cases, by the way.",
      "parentUuid": "1ce2fcaa_8f640fba",
      "range": {
        "startLine": 127,
        "startChar": 11,
        "endLine": 127,
        "endChar": 22
      },
      "revId": "69b666f87eb65c74b4fa4c58d9b737449c771b9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "237b0f45_276999e2",
        "filename": "services/network/network_context.cc",
        "patchSetId": 31
      },
      "lineNbr": 127,
      "author": {
        "id": 1001809
      },
      "writtenOn": "2018-02-02T18:54:08Z",
      "side": 1,
      "message": "So my understanding, which I\u0027m not confident of, is that NetworkContext::CreateURLLoaderFactory is only called if the network service is enabled.  If it\u0027s called when it\u0027s disabled, then we\u0027re using two different resources schedulers (one attached to the URLLoaderFactory, one to the ResourceDispatcherHost) which strikes me as a bad idea and worth avoiding; thus my suggestion about only allocating the resource scheduler here and seeing if there are any crashes.  But one way or another I\u0027d like to make sure that we\u0027re not allocating two different resource schedulers in any configuration before landing this CL; leaving resource_scheduler_ null (with a comment) if we\u0027re not enabling the network service seems like a reasonable way to guarantee that.\n\n+mmenke: Is it true that NetworkContext::CreateURLLoaderFactory is only called if the network service is enabled?",
      "parentUuid": "bbb64c21_fa0c20dd",
      "range": {
        "startLine": 127,
        "startChar": 11,
        "endLine": 127,
        "endChar": 22
      },
      "revId": "69b666f87eb65c74b4fa4c58d9b737449c771b9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6d3ded6_d47cfb0a",
        "filename": "services/network/network_context.cc",
        "patchSetId": 31
      },
      "lineNbr": 127,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2018-02-02T18:58:41Z",
      "side": 1,
      "message": "CreateURLLoaderFactory is used, regardless of whether the network service is enabled.  If you\u0027re using SimpleURLLoaders, that\u0027s how you get the URLLoaderFactory to pass to it.\n\nSee https://cs.chromium.org/chromium/src/content/browser/storage_partition_impl.cc?sq\u003dpackage:chromium\u0026l\u003d656 (Note that there\u0027s no magic depending on whether the network service is enabled or not, unlike in GetNetworkContext)",
      "parentUuid": "237b0f45_276999e2",
      "range": {
        "startLine": 127,
        "startChar": 11,
        "endLine": 127,
        "endChar": 22
      },
      "revId": "69b666f87eb65c74b4fa4c58d9b737449c771b9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6491c514_775d8b45",
        "filename": "services/network/network_context.cc",
        "patchSetId": 31
      },
      "lineNbr": 127,
      "author": {
        "id": 1001809
      },
      "writtenOn": "2018-02-02T19:31:17Z",
      "side": 1,
      "message": "Ah, drat, so we\u0027re gradually shifting over to using the NetworkContext -\u003e URLLoaderFactory -\u003e URLLoader pathway.  Which I should have been able to figure out from first principles; ooops :-}.  Please ignore my request to make this null in the Network service enabled case.\n\nSo this means we\u0027re going to have multiple instances of ResourceScheduler running around; one per NetworkContext and one for the ResourceDispatcherHostImpl.  My memory (should be checked) is that there isn\u0027t any global throttling done within the ResourceScheduler; the (current) throttling is per-tab.  So I don\u0027t think there\u0027s a problem with making it a non-singleton class.  However, we should keep in mind that this means if we want to implement future global throttling, the ResourceScheduler is no longer a reasonable place to do that throttling.  \n\nIf we wanted to keep the singleton configuration/ability to do global throttling we could try and find a way to allow non-network service configurations use the ResourceScheduler attached to the ResourceDispatcherHostImpl for NetworkContext behavior, but I think that\u0027s more work than it\u0027s worth, given that global scheduling should probably be in /net and that I don\u0027t think there\u0027s any conflicts between multiple instances of the ResourceScheduler.\n\nYutaka, could you do two things?:\n* Confirm my memory that the ResourceScheduler doesn\u0027t currently do any global (i.e. over everything that uses the class) throttling?\n* Write some tests making sure that if there are multiple instances of the ResourceScheduler instantiated, they don\u0027t interfere with each other?",
      "parentUuid": "f6d3ded6_d47cfb0a",
      "range": {
        "startLine": 127,
        "startChar": 11,
        "endLine": 127,
        "endChar": 22
      },
      "revId": "69b666f87eb65c74b4fa4c58d9b737449c771b9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e29dc46_fa49496a",
        "filename": "services/network/network_context.cc",
        "patchSetId": 31
      },
      "lineNbr": 127,
      "author": {
        "id": 1114080
      },
      "writtenOn": "2018-02-06T09:13:09Z",
      "side": 1,
      "message": "\u003e Confirm my memory that the ResourceScheduler doesn\u0027t currently do any global (i.e. over everything that uses the class) throttling?\n\nYou\u0027re right, no throttling is performed.\n\n\u003e Write some tests making sure that if there are multiple instances of the ResourceScheduler instantiated, they don\u0027t interfere with each other?\n\nAdded ResourceSchedulerTest.MultipleInstances.",
      "parentUuid": "6491c514_775d8b45",
      "range": {
        "startLine": 127,
        "startChar": 11,
        "endLine": 127,
        "endChar": 22
      },
      "revId": "69b666f87eb65c74b4fa4c58d9b737449c771b9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}