{
  "comments": [
    {
      "key": {
        "uuid": "7bfab846_004ead79",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "Since it looks weird to see “define the section read-only” for Linux bot not for macOS, when the whole point of it is to be read-only, you can leave a comment here saying that the linker invocation directed by the BUILD.gn file is responsible for making it read-only.",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d8d397d_72ed0962",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7bfab846_004ead79",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "070d10c3_467822d9",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 47,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "Blank line before this, so it doesn’t mush with the above.",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c7aefaa3_9c2b634b",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 47,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "070d10c3_467822d9",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e669676f_caddcc8c",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 48,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "const void* (or const char* if you really want “byte,” but I suspect you want to pass pointers to arbitrary types to this thing.)",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5358e67_fe7e9db9",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 48,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e669676f_caddcc8c",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a7a5d73_b8ef08bc",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 53,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "Are these for testing only? (If so, they shouldn’t be here, they should be restricted to the test or a test utility.)\n\nHow about AssertMemoryIsReadOnly()?",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdd9b63c_be614da5",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 53,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "ProtectedMemoryStart/End are not for testing only (they are used in SetReadOnly()). Neither is AssertMemoryIsReadOnly(), it\u0027s used to DCHECK() in SetReadWrite/SetReadOnly.",
      "parentUuid": "3a7a5d73_b8ef08bc",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e0cf50e5_00ac0fa7",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 53,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T22:41:50Z",
      "side": 1,
      "message": "\u003e ProtectedMemoryStart/End are not for testing only (they are used in SetReadOnly()). Neither is AssertMemoryIsReadOnly(), it\u0027s used to DCHECK() in SetReadWrite/SetReadOnly.\n\nRight, OK. Then this entire thing won’t work as-is for the component\u003dshared_library build.",
      "parentUuid": "bdd9b63c_be614da5",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4bd94b62_6f860313",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 53,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e0cf50e5_00ac0fa7",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd5ab655_3635a85f",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 64,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "This is base::g_writers, which isn’t a very descriptive or useful name. It ought to be a static class variable.\n\nFor that matter, it’s probably better to put the functions above into the class as static functions, to give them clearer naming at point of use.",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a576fc6f_0784af67",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 64,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "It can\u0027t be a static class variable since the class is templated and this variable needs to be shared across all instances. (This is the same reason why the methods above can\u0027t really be implemented as static class methods.) That said, I can rename it or move g_writers and it\u0027s lock into a descriptive static class?",
      "parentUuid": "fd5ab655_3635a85f",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bc695ab2_e9f5242e",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 64,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T22:41:50Z",
      "side": 1,
      "message": "\u003e It can\u0027t be a static class variable since the class is templated\n\nOh, true!\n\n\u003e and this variable needs to be shared across all instances. (This is the same reason why the methods above can\u0027t really be implemented as static class methods.) That said, I can rename it or move g_writers and it\u0027s lock into a descriptive static class?\n\nYes, either that or a namespace would be perfect.",
      "parentUuid": "a576fc6f_0784af67",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "feed0208_773fb05b",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 64,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bc695ab2_e9f5242e",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "425aca44_7ff4661c",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "I expected g_writers to be atomic, rather than non-atomic with a lock. Any reason you didn’t do that?",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18d9b416_51552ec7",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "This lock also protects operations that need to happen simultaneously with g_writers changes. When g_writers is 0 and SetReadWrite() is called we need to set g_writers to be read-write at the same time as we increment it to avoid races with other threads at the same time. When writers is decremented to 0, we need to set the entire protected memory section read-only before anyone else has a chance to increment it. I\u0027ll expand the description to explain that.",
      "parentUuid": "425aca44_7ff4661c",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d0c37b6_bd84ede4",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T22:41:50Z",
      "side": 1,
      "message": "\u003e This lock also protects operations that need to happen simultaneously with g_writers changes. When g_writers is 0 and SetReadWrite() is called we need to set g_writers to be read-write at the same time as we increment it to avoid races with other threads at the same time. When writers is decremented to 0, we need to set the entire protected memory section read-only before anyone else has a chance to increment it. I\u0027ll expand the description to explain that.\n\nThat’s all fine. The comment should be revised, because it’s not telling the whole story by only referring to “the writers variable.”",
      "parentUuid": "18d9b416_51552ec7",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b524dcc_776aeb52",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8d0c37b6_bd84ede4",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b2183fa_13a74bad",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "This results in a module initializer and finalizer (static constructor/destructor) if T needs one. We can’t have that. You’ll need to come up with a pattern that ensures that T is safe as a naked object at static duration, or one that reserves storage in the protected_memory section but doesn’t construct objects until the point of first use, and doesn’t destroy them at all.",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b485d987_35ef59ea",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "None of the users that I\u0027ve ported to this implementation so far have had constructors, they\u0027re just structs of function pointers. If I see a case where that\u0027s required I\u0027d plan to split the function pointers out separately from the object that requires the initializer. I could do implement a method to avoid initializing the object until it\u0027s used but I don\u0027t think it\u0027ll be required as of right now.",
      "parentUuid": "8b2183fa_13a74bad",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7971653_6ba5697d",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T22:41:50Z",
      "side": 1,
      "message": "\u003e None of the users that I\u0027ve ported to this implementation so far have had constructors, they\u0027re just structs of function pointers. If I see a case where that\u0027s required I\u0027d plan to split the function pointers out separately from the object that requires the initializer. I could do implement a method to avoid initializing the object until it\u0027s used but I don\u0027t think it\u0027ll be required as of right now.\n\nOK. It’s frightening to see it exposed in this way without any sort of guard against module initializers or finalizers. At the very least, you need to document that it’s the user’s burden to ensure that we don’t wind up with any.",
      "parentUuid": "b485d987_35ef59ea",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62215710_98e2a6e2",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T23:25:47Z",
      "side": 1,
      "message": "I think it still falls under the same initializer/finalizer mitigations (e.g. the hard coded static initializer count and -Wexit-time-destructors) that exist in the rest of Chrome, but I can document the behavior more explicitly.",
      "parentUuid": "d7971653_6ba5697d",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e0da9d7_c1af938f",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "62215710_98e2a6e2",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6c368c46_2ba129df",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 80,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "I’d prefer to see a usage pattern that used a scoper to ensure that SetReadOnly() gets called.\n\nIf possible, it’d be nice if that were the only publicly-accessible interface to SetReadWrite().",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d9ddf94_02e52361",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 80,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "6c368c46_2ba129df",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff81f8dc_c45d3f54",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 7
      },
      "lineNbr": 80,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2d9ddf94_02e52361",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f649dba4_ad4f2680",
        "filename": "base/memory/protected_memory_cfi.h",
        "patchSetId": 7
      },
      "lineNbr": 1,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "No (c)\n\n(follow the example in the other header file)",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5eb36bf_cde2ede8",
        "filename": "base/memory/protected_memory_cfi.h",
        "patchSetId": 7
      },
      "lineNbr": 1,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f649dba4_ad4f2680",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3d17ab8a_567a7bb1",
        "filename": "base/memory/protected_memory_cfi.h",
        "patchSetId": 7
      },
      "lineNbr": 28,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "Capitalize",
      "range": {
        "startLine": 28,
        "startChar": 30,
        "endLine": 28,
        "endChar": 50
      },
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e08bcdd_f7889f3d",
        "filename": "base/memory/protected_memory_cfi.h",
        "patchSetId": 7
      },
      "lineNbr": 28,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3d17ab8a_567a7bb1",
      "range": {
        "startLine": 28,
        "startChar": 30,
        "endLine": 28,
        "endChar": 50
      },
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "074f7045_94c4009b",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 63,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "Do we need to burn TWO file descriptors for this? It seems like you could do this just as easily writing to /dev/null, reading from /dev/zero, etc.\n\nFor that matter, you can easily find a syscall that’ll give you EFAULT without having to burn any FDs at all. Perhaps there aren’t any that you can restrict to a single-byte read or write, though. I can think of several syscalls that fit this pattern without any FDs off the top of my head, but none that work with byte-level granularity. (Doesn’t mean that there aren’t any, though.) Even so, since protections are applied on a per-page basis, you’d be fine with, say, clock_gettime() provided that you ensure that (timespec*)ptr and (timespec*)ptr + 1 are both on the same page. You could easily adjust ptr to make it so if it wasn’t.\n\n(I’m not asserting that clock_gettime() is the best example. You’d want to choose a syscall that a libc is minimally likely to mess around with. I know that times() is a bad example for this reason.)",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7598425_a7280fbe",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 63,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "I was using read() to get byte granularity, but getting a pointer to the page base seems like it would be easier. I could use stat() instead.",
      "parentUuid": "074f7045_94c4009b",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b5eb727_d38cab7d",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 63,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T22:41:50Z",
      "side": 1,
      "message": "\u003e I was using read() to get byte granularity, but getting a pointer to the page base seems like it would be easier. I could use stat() instead.\n\nLet’s do something that doesn’t touch the filesystem, because that might incur unnecessary overhead. Also, it’s better to not have to rely on any paths if it’s avoidable: maybe we’re sandboxed or in a weird chroot, so why take on that dependency?",
      "parentUuid": "e7598425_a7280fbe",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d1b6a72b_2061b49a",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 63,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T23:25:47Z",
      "side": 1,
      "message": "Right, I was confused by thinking that I\u0027d pass the path as the pointer but that won\u0027t work due to unclear NUL-termination on that page. I think getrlimit() should work instead--it\u0027s non-vDSO and accepts a pointer.",
      "parentUuid": "8b5eb727_d38cab7d",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c07cb43e_b911fd68",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 63,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T23:39:51Z",
      "side": 1,
      "message": "\u003e I think getrlimit() should work instead--it\u0027s non-vDSO and accepts a pointer.\n\nThat’s a good one! Both glibc and Bionic provide straightforward wrappers with no extra fuss.\n\nIt’d be nice to use something that accepts a pointer to const data. That way, even if we goof and the memory’s not protected, we’ll preserve the contents of memory before crashing (it might be significant!). setrlimit() seemed like a good candidate based on getrlimit(), but we’d have to choose the resource wisely. In any event, glibc provides a nontrivial wrapper that would crash, so it’s a no-go.\n\nIt’s not terribly important if you’d like to standardize on getrlimit().",
      "parentUuid": "d1b6a72b_2061b49a",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "809fe1f4_cdf791b8",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 63,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c07cb43e_b911fd68",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d893c5ce_570a55ad",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 66,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "We don’t really need to close the FDs at exit, do we?",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9fc3e460_f21fdd60",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 66,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d893c5ce_570a55ad",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "07bd7b73_fac48c68",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "HANDLE_EINTR the write() too. You should also check its return value, otherwise you may end up waiting forever on the read() (depends on the implementation).",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7843e05d_fae333b1",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 67,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "07bd7b73_fac48c68",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2721f75_3f1aac21",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "This won’t account for the component\u003dshared_library build when protected_memory sections exist outside of libbase. These functions will find and report exclusively on the protected_memory section in libbase.",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "44218aa6_8d7c7041",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "Nice find!",
      "parentUuid": "f2721f75_3f1aac21",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6815e1a_b69fb635",
        "filename": "base/memory/protected_memory_posix.cc",
        "patchSetId": 7
      },
      "lineNbr": 92,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "44218aa6_8d7c7041",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "15332c80_8732f96a",
        "filename": "build/config/mac/BUILD.gn",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2017-10-20T21:59:02Z",
      "side": 1,
      "message": "Rather than doing this here, is there a way to move it closer to the .h and .cc files in base, such that anyone that depends on base gets this?",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5542b46a_51c25107",
        "filename": "build/config/mac/BUILD.gn",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-20T22:30:23Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "15332c80_8732f96a",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19395a05_684a3c0a",
        "filename": "build/config/mac/BUILD.gn",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-25T00:49:02Z",
      "side": 1,
      "message": "Can you think of an example where a build target does not get this linker flag? I looked around a bit and it seems like this is applied to all link targets, but I\u0027m probably just not familiar enough with Chromium\u0027s build system to think of a counter-example.",
      "parentUuid": "5542b46a_51c25107",
      "revId": "4d67a2e3d5e00fa01a5a76f0475e4468992bb304",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}