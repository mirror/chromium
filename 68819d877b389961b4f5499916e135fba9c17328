{
  "comments": [
    {
      "key": {
        "uuid": "6c64bf64_5032c46e",
        "filename": "third_party/WebKit/Source/core/html/canvas/HTMLCanvasElement.cpp",
        "patchSetId": 7
      },
      "lineNbr": 392,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2018-01-30T21:45:40Z",
      "side": 1,
      "message": "In cases when we\u0027re not inside a requestAnimationFrame callback, FinalizeFrame() gets called before recorded draw commands get flushed. So I am not sure this is a great hook. In some case (e.g. drawing in response to a pointer event, network event, etc.) it may unlock images prematurely.  I think the hook you put in Canvas2DLayerBridge makes more sense and is a reasonable catch all.  I would recommend removing this bit from this CL.  We could try adding it later, in isolation, to see how the perf test react to it.",
      "revId": "68819d877b389961b4f5499916e135fba9c17328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "682e9876_b3cf6549",
        "filename": "third_party/WebKit/Source/core/html/canvas/HTMLCanvasElement.cpp",
        "patchSetId": 7
      },
      "lineNbr": 392,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2018-01-30T21:59:37Z",
      "side": 1,
      "message": "I wouldn\u0027t worry about this call happening before flushing recorded commands. For cases where we use use a recording canvas and raster during the main frame, this should be a no-op since images are decoded only when using the raster canvas and unlocked each time the recording is flushed. There shouldn\u0027t be anything to unlock in that case.\n\nThe only case I am afraid FlushRecording won\u0027t handle is where the canvas is not operating in deferral mode. The consequence of that would be that we unlock everything once the cache is filled to the limit, and I was wondering if we should have another hook for that case where we proactively flush.",
      "parentUuid": "6c64bf64_5032c46e",
      "revId": "68819d877b389961b4f5499916e135fba9c17328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b2122ec_19b9dde8",
        "filename": "third_party/WebKit/Source/core/html/canvas/HTMLCanvasElement.cpp",
        "patchSetId": 7
      },
      "lineNbr": 392,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2018-02-01T21:32:07Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "682e9876_b3cf6549",
      "revId": "68819d877b389961b4f5499916e135fba9c17328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04933fec_69fd40ac",
        "filename": "third_party/WebKit/Source/platform/graphics/CanvasResourceProvider.cpp",
        "patchSetId": 7
      },
      "lineNbr": 319,
      "author": {
        "id": 1203794
      },
      "writtenOn": "2018-01-30T15:46:04Z",
      "side": 1,
      "message": "IIUC while PlaybackImageProvider decodes the lazy decoded images for rasterization, it converts the images to the target color space upfront. If this is correct, using PlaybackImageProvider is expensive for canvas DrawImage, as we do not need/want early color conversion, especially if the image is sRGB and canvas is wide gamut (for which upfront color convetsion results in twice memory usage). The color conversion will be managed when drawing the image on the SkCanvas/SkSurface.",
      "revId": "68819d877b389961b4f5499916e135fba9c17328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16a00d67_6c146cf2",
        "filename": "third_party/WebKit/Source/platform/graphics/CanvasResourceProvider.cpp",
        "patchSetId": 7
      },
      "lineNbr": 319,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2018-01-30T18:54:17Z",
      "side": 1,
      "message": "Thanks for the review Mohammad. Yes, the PlaybackImageProvider decodes lazy images, uploads them and performs a color conversion. The aim is to cache the final result for the target color space in cc\u0027s cache, so it can be re-used across canvas draws. The skia code path that handles this does not cache the result from color conversion across draws (see crbug.com/791828). I\u0027m not sure I understand the twice memory usage scenario, since the image provided from cc\u0027s cache will already be a texture backed image in the target cs, SkCanvas will simply use it directly during the draw. Is there something I might be missing?\n\nAlso, the change that actually moved us to use cc\u0027s cache landed earlier. This change is only ensuring that we keep images locked during the duration of a draw, so the unlocking can be batched at the end. I\u0027ve added the unlocking of images when we flush a recording, which is where we would actually raster and lock any images, and in FinalizeFrame, so that if the canvas has deferral disabled and rasters directly when used by script, it flushes at the end of each task. Let me know if I might be missing a case where we should also unlock.",
      "parentUuid": "04933fec_69fd40ac",
      "revId": "68819d877b389961b4f5499916e135fba9c17328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc5153d6_bc6868ee",
        "filename": "third_party/WebKit/Source/platform/graphics/CanvasResourceProvider.cpp",
        "patchSetId": 7
      },
      "lineNbr": 319,
      "author": {
        "id": 1203794
      },
      "writtenOn": "2018-01-30T21:03:54Z",
      "side": 1,
      "message": "I see. Regarding the double memory usage, I misunderstood how CanvasResourceProvider is used.",
      "parentUuid": "16a00d67_6c146cf2",
      "revId": "68819d877b389961b4f5499916e135fba9c17328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}