{
  "comments": [
    {
      "key": {
        "uuid": "ea653e72_a23b38c0",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1001917
      },
      "writtenOn": "2017-07-20T21:43:35Z",
      "side": 1,
      "message": "can you do std::unordered_map?",
      "range": {
        "startLine": 24,
        "startChar": 8,
        "endLine": 24,
        "endChar": 15
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5884fae9_09661d76",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-21T01:57:50Z",
      "side": 1,
      "message": "Would the url::Origin data type work here?\n\nWherever the map goes, assuming there aren\u0027t many StorageHandlers, take a look at base::flat_map\u003c\u003e and flat_set\u003c\u003e. And instead of typefs, can you switch to...\nusing HandlerMap \u003d std::flat_map\u003cOrigin, std::flat_set\u003cHandler\u003e\u003e\n\nAnother option is to have each Handler observe changes for all origins within a context, so each CacheStorageContext has an observer list (see base::ObserverListThreadSafe). And each Handler has a flat_set\u003c\u003e of url::Origins it cares about.",
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5250fa64_acc07003",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2017-07-21T21:09:20Z",
      "side": 1,
      "message": "Let\u0027s instead register observers in CacheStorage:\n\nclass CacheStorage {\n...\nclass OriginObserver {\n  virtual ~OriginObserver() {}\n  virtual CacheStorageForOriginUpdated(const std::string\u0026 origin) \u003d 0;\n}\nvoid AddObserver(const std::string\u0026 origin, OriginObserver* observer);\nvoid RemoveObserver(const std::string\u0026 origin, OriginObserver* observer);\n...\n}\n\nThen instead of static collection, CacheStorage will have a list of observers.",
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "429738b9_fe65d703",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1001917
      },
      "writtenOn": "2017-07-21T22:55:53Z",
      "side": 1,
      "message": "So Michael\u0027s way sounds like it will involve (unless I\u0027m totally wrong - correct me)\n1. Passing all changes up to the context (cachestorage-\u003emanager-\u003econtext). This can get a lot if we start listening to all changes and not just changes to the cache names\n2. Listening to all changes without filtering before we filter in the storage handler.\n\nI think I like Dmitry\u0027s way better, this is close to what I was thinking initially. I\u0027m thinking:\n\nCacheStorage:\nclass Observer {\nvirtual void CacheNamesChanged(std::vector\u003cstd::string\u003e names);\nvirtual void CacheContentsChanged(std::string cache_name); // TODO: add more information if necessary.\n}\n\n// observer called on IO thread\nvoid RegisterCacheNamesObserver(std::unique_ptr\u003cCacheStorageObserver\u003e observer);\nvoid UnregisterCacheNamesObserver(Observer* observer);\n\nCacheManager:\n// Observer called on IO thread.\nvoid RegisterCacheNamesObserver(const GURL\u0026 origin, std::unique_ptr\u003cCacheStorage::Observer\u003e observer);\nvoid UnregisterCacheNamesObserver(const GURL\u0026 origin, CacheStorage::Observer* observer);\n\nCacheStorageContext (same - just directs to manager)\n// Called and observer called on IO thread.\nvoid RegisterCacheNamesObserver(const GURL\u0026 origin, std::unique_ptr\u003cCacheStorage::Observer\u003e observer);\nvoid UnregisterCacheNamesObserver(const GURL\u0026 origin, CacheStorage::Observer* observer);\n\nStorageHandler:\n* add a WeakPtrFactory\u003cStorageHandler\u003e in the handler\n* add a std::unordered_set\u003cstd::pair\u003cGURL,CacheStorage::Observer*\u003e\u003e registered_observers\n// Multiple calls ignored.\nvoid EnableCacheTracking(origin);\nvoid DisableCacheTrackig(origin);\n\nInternally when adding an observer - we have an implementation of the CacheSTorage::Observer (ObserverImpl) class which we create on the UI thread but then pass to IO thread (and expect to get called on IO thread). ObserverImpl should construct w/ an IO thread runner and callbacks to CacheStorage for both observation types, and each should be bound to a weakptr of StorageHandler (so it doesn\u0027t race w/ destruction). The ObserverImpl should schedule these tasks on an IO thread runner.\n\nThe response should also check the registered_observers set to make sure we still want to observe (avoid unregister then notify race case).\n\nFinally the disable call should delete from the registered_observers and unregister from the cachestoragecontext by scheduling task on IO thread.\n\nDoes that make sense? This will support both names and content changing. You can have two \u0027notifications\u0027 now, one for name changes and one for a specific cache being dirty.",
      "parentUuid": "5250fa64_acc07003",
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "601261ee_a96aecc9",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "429738b9_fe65d703",
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "00c78691_b594e5a1",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Removed during design change",
      "parentUuid": "ea653e72_a23b38c0",
      "range": {
        "startLine": 24,
        "startChar": 8,
        "endLine": 24,
        "endChar": 15
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9bda7008_58842657",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1001917
      },
      "writtenOn": "2017-07-20T21:43:35Z",
      "side": 1,
      "message": "please comment that you expect this to be used only on the UI thread.",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6216a1a7_c56372e9",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-21T01:57:50Z",
      "side": 1,
      "message": "fyi: i think we\u0027ve switch to prefering native statics for lazy instances likes this...\n\nTrackedHandlers* GetTrackedHandlers() {\n  static TrackedHandlers* instance \u003d new TrackedHandlers;\n  return instance;\n}",
      "parentUuid": "9bda7008_58842657",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f285731a_e20e0cbc",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Removed during design change",
      "parentUuid": "6216a1a7_c56372e9",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cc81373e_dc27ba07",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1001917
      },
      "writtenOn": "2017-07-20T21:43:35Z",
      "side": 1,
      "message": "so you can probably do a loop over tracked_origins_ instead, as you know that this handler is registered in those.",
      "range": {
        "startLine": 103,
        "startChar": 0,
        "endLine": 103,
        "endChar": 49
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c1e6e29_b08bfdfe",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Removed during design change",
      "parentUuid": "cc81373e_dc27ba07",
      "range": {
        "startLine": 103,
        "startChar": 0,
        "endLine": 103,
        "endChar": 49
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cf4973d2_8bb93ee3",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 1001917
      },
      "writtenOn": "2017-07-20T21:43:35Z",
      "side": 1,
      "message": "first check if handlers is empty - that should be a nice early exit for common case.",
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6352610_be4a2309",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cf4973d2_8bb93ee3",
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c3c81f81_c339966c",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 256,
      "author": {
        "id": 1001917
      },
      "writtenOn": "2017-07-20T21:43:35Z",
      "side": 1,
      "message": "so I\u0027m guessing we might want to support multiple callbacks here? I think we can avoid this if we just go the notification route instead of this callback route.\n\nIf we go this route we should have the callback return the cache names. But based on our convo with Pavel you shouldn\u0027t need this part.",
      "range": {
        "startLine": 256,
        "startChar": 4,
        "endLine": 256,
        "endChar": 27
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0bc53a83_d4572c91",
        "filename": "content/browser/devtools/protocol/storage_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 256,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c3c81f81_c339966c",
      "range": {
        "startLine": 256,
        "startChar": 4,
        "endLine": 256,
        "endChar": 27
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1a21383_6dbee39c",
        "filename": "third_party/WebKit/Source/core/inspector/browser_protocol.json",
        "patchSetId": 2
      },
      "lineNbr": 4707,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2017-07-21T21:09:20Z",
      "side": 1,
      "message": "Protocol should not talk about handlers or any implementation details.",
      "range": {
        "startLine": 4707,
        "startChar": 32,
        "endLine": 4707,
        "endChar": 76
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afa32973_6f81a21d",
        "filename": "third_party/WebKit/Source/core/inspector/browser_protocol.json",
        "patchSetId": 2
      },
      "lineNbr": 4707,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d1a21383_6dbee39c",
      "range": {
        "startLine": 4707,
        "startChar": 32,
        "endLine": 4707,
        "endChar": 76
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8092137d_73b57427",
        "filename": "third_party/WebKit/Source/devtools/front_end/sdk/ServiceWorkerCacheModel.js",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 1001917
      },
      "writtenOn": "2017-07-20T21:43:35Z",
      "side": 1,
      "message": "Unless I\u0027m wrong, this will pause the javascript forever? I\u0027ll defer to Dmitri on this part. I\u0027m guessing we just listen to the notifications instead?",
      "range": {
        "startLine": 61,
        "startChar": 0,
        "endLine": 61,
        "endChar": 59
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0762e776_766e2552",
        "filename": "third_party/WebKit/Source/devtools/front_end/sdk/ServiceWorkerCacheModel.js",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-21T01:57:50Z",
      "side": 1,
      "message": "javascript is sooooo decepetive to us c++ cave people :)",
      "parentUuid": "8092137d_73b57427",
      "range": {
        "startLine": 61,
        "startChar": 0,
        "endLine": 61,
        "endChar": 59
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b4d0a28_1fa710ce",
        "filename": "third_party/WebKit/Source/devtools/front_end/sdk/ServiceWorkerCacheModel.js",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2017-07-21T21:09:20Z",
      "side": 1,
      "message": "Yeah, we should just have notification cachesUpdated or something like that.",
      "parentUuid": "0762e776_766e2552",
      "range": {
        "startLine": 61,
        "startChar": 0,
        "endLine": 61,
        "endChar": 59
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d8bd1a8_acb2e671",
        "filename": "third_party/WebKit/Source/devtools/front_end/sdk/ServiceWorkerCacheModel.js",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 1222287
      },
      "writtenOn": "2017-07-26T23:44:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2b4d0a28_1fa710ce",
      "range": {
        "startLine": 61,
        "startChar": 0,
        "endLine": 61,
        "endChar": 59
      },
      "revId": "4386f019b8c9366096d13702a39ab6e02a24d41f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}