# 1 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.cc"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 388 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.cc" 2




# 1 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/string" 1 3
# 469 "../../buildtools/third_party/libc++/trunk/include/string" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__config" 1 3
# 22 "../../buildtools/third_party/libc++/trunk/include/__config" 3
# 179 "../../buildtools/third_party/libc++/trunk/include/__config" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/features.h" 1 3 4
# 342 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/features.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdc-predef.h" 1 3 4
# 343 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/features.h" 2 3 4
# 364 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/features.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 415 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 416 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 365 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/features.h" 2 3 4
# 388 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/features.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 389 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/features.h" 2 3 4
# 180 "../../buildtools/third_party/libc++/trunk/include/__config" 2 3
# 444 "../../buildtools/third_party/libc++/trunk/include/__config" 3
namespace std {
  inline namespace __1 {
  }
}
# 470 "../../buildtools/third_party/libc++/trunk/include/string" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/string_view" 1 3
# 169 "../../buildtools/third_party/libc++/trunk/include/string_view" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__string" 1 3
# 56 "../../buildtools/third_party/libc++/trunk/include/__string" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/algorithm" 1 3
# 639 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/initializer_list" 1 3
# 47 "../../buildtools/third_party/libc++/trunk/include/initializer_list" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cstddef" 1 3
# 41 "../../buildtools/third_party/libc++/trunk/include/cstddef" 3



# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 51 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 62 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 3
typedef long unsigned int size_t;
# 118 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 3
# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/__stddef_max_align_t.h" 1 3
# 35 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 119 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 2 3
# 45 "../../buildtools/third_party/libc++/trunk/include/cstddef" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__nullptr" 1 3
# 18 "../../buildtools/third_party/libc++/trunk/include/__nullptr" 3
# 55 "../../buildtools/third_party/libc++/trunk/include/__nullptr" 3
namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 46 "../../buildtools/third_party/libc++/trunk/include/cstddef" 2 3

namespace std {inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;




using ::max_align_t;




} }
# 48 "../../buildtools/third_party/libc++/trunk/include/initializer_list" 2 3
# 51 "../../buildtools/third_party/libc++/trunk/include/initializer_list" 3


namespace std
{



template<class _Ep>
class initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__ ((__always_inline__))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__ ((__always_inline__))
    constexpr
    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

    __attribute__ ((__always_inline__))
    constexpr
    size_t size() const noexcept {return __size_;}

    __attribute__ ((__always_inline__))
    constexpr
    const _Ep* begin() const noexcept {return __begin_;}

    __attribute__ ((__always_inline__))
    constexpr
    const _Ep* end() const noexcept {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__ ((__always_inline__))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__ ((__always_inline__))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}



}
# 640 "../../buildtools/third_party/libc++/trunk/include/algorithm" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/type_traits" 1 3
# 394 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3


namespace std {inline namespace __1 {

template <class _T1, class _T2> struct pair;
template <class _Tp> class reference_wrapper;
template <class _Tp> struct hash;

template <class>
struct __void_t { typedef void type; };

template <class _Tp>
struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __dependent_type : public _Tp {};

template <bool _Bp, class _If, class _Then>
    struct conditional {typedef _If type;};
template <class _If, class _Then>
    struct conditional<false, _If, _Then> {typedef _Then type;};


template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


template <bool, class _Tp> struct __lazy_enable_if {};
template <class _Tp> struct __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};

template <bool, class _Tp = void> struct enable_if {};
template <class _Tp> struct enable_if<true, _Tp> {typedef _Tp type;};


template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;





template <class _Tp>
inline
__attribute__((__no_sanitize__("cfi"))) __attribute__ ((__always_inline__))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
# 496 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;


struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct integral_constant
{
    static constexpr const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__always_inline__))
        constexpr operator value_type() const noexcept {return value;}

    __attribute__ ((__always_inline__))
         constexpr value_type operator ()() const noexcept {return value;}

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
# 528 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
typedef integral_constant<bool,(true)> true_type;
typedef integral_constant<bool,(false)> false_type;





template <bool _Last, class ..._Preds>
struct __lazy_and_impl;

template <class ..._Preds>
struct __lazy_and_impl<false, _Preds...> : false_type {};

template <>
struct __lazy_and_impl<true> : true_type {};

template <class _Pred>
struct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};

template <class _Hp, class ..._Tp>
struct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class ..._Pr>
struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};



template <bool _List, class ..._Preds>
struct __lazy_or_impl;

template <class ..._Preds>
struct __lazy_or_impl<true, _Preds...> : true_type {};

template <>
struct __lazy_or_impl<false> : false_type {};

template <class _Hp, class ..._Tp>
struct __lazy_or_impl<false, _Hp, _Tp...>
        : __lazy_or_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class ..._Pr>
struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};



template <class _Pred>
struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};


template<class...> struct __and_;
template<> struct __and_<> : true_type {};

template<class _B0> struct __and_<_B0> : _B0 {};

template<class _B0, class _B1>
struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};

template<class _B0, class _B1, class _B2, class... _Bn>
struct __and_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};


template<class...> struct __or_;
template<> struct __or_<> : false_type {};

template<class _B0> struct __or_<_B0> : _B0 {};

template<class _B0, class _B1>
struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};

template<class _B0, class _B1, class _B2, class... _Bn>
struct __or_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};


template<class _Tp>
struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};





template <class _Tp> struct is_const : public false_type {};
template <class _Tp> struct is_const<_Tp const> : public true_type {};
# 620 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_volatile : public false_type {};
template <class _Tp> struct is_volatile<_Tp volatile> : public true_type {};
# 630 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct remove_const {typedef _Tp type;};
template <class _Tp> struct remove_const<const _Tp> {typedef _Tp type;};

template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;




template <class _Tp> struct remove_volatile {typedef _Tp type;};
template <class _Tp> struct remove_volatile<volatile _Tp> {typedef _Tp type;};

template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;




template <class _Tp> struct remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};

template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;




template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
# 667 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp> struct is_null_pointer
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 685 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <> struct __libcpp_is_integral<__int128_t> : public true_type {};
template <> struct __libcpp_is_integral<__uint128_t> : public true_type {};


template <class _Tp> struct is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
# 718 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
# 733 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_array
    : public false_type {};
template <class _Tp> struct is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct is_array<_Tp[_Np]>
    : public true_type {};
# 747 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};
# 760 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_lvalue_reference : public false_type {};
template <class _Tp> struct is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct is_rvalue_reference : public false_type {};

template <class _Tp> struct is_rvalue_reference<_Tp&&> : public true_type {};


template <class _Tp> struct is_reference : public false_type {};
template <class _Tp> struct is_reference<_Tp&> : public true_type {};

template <class _Tp> struct is_reference<_Tp&&> : public true_type {};
# 788 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 808 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 831 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp, class _Up> struct is_same : public false_type {};
template <class _Tp> struct is_same<_Tp, _Tp> : public true_type {};
# 841 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
namespace __libcpp_is_function_imp
{
struct __dummy_type {};
template <class _Tp> char __test(_Tp*);
template <class _Tp> char __test(__dummy_type);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source(int);
template <class _Tp> __dummy_type __source(...);
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct is_function
    : public __libcpp_is_function<_Tp> {};
# 875 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};


template <class _Tp> struct __libcpp_is_member_function_pointer
    : public false_type {};

template <class _Ret, class _Class>
struct __libcpp_is_member_function_pointer<_Ret _Class::*>
    : public is_function<_Ret> {};

template <class _Tp> struct is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
# 898 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
# 911 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};
# 924 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 950 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};
# 961 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};
# 973 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct is_scalar<nullptr_t> : public true_type {};
# 989 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};
# 1002 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
# 1013 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};




template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct add_const
    {typedef typename __add_const<_Tp>::type type;};


template <class _Tp> using add_const_t = typename add_const<_Tp>::type;




template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};


template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;




template <class _Tp> struct add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};


template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;




template <class _Tp> struct remove_reference {typedef _Tp type;};
template <class _Tp> struct remove_reference<_Tp&> {typedef _Tp type;};

template <class _Tp> struct remove_reference<_Tp&&> {typedef _Tp type;};



template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;




template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };

template <class _Tp> struct add_lvalue_reference
{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;




template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };

template <class _Tp> struct add_rvalue_reference
{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;






template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);

template <class _Tp>
decltype(std::__1::__declval<_Tp>(0))
declval() noexcept;
# 1123 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
struct __uncvref {
    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
};


template <class _Tp>
using __uncvref_t = typename __uncvref<_Tp>::type;




template <class _Tp, class _Up>
struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};

struct __any
{
    __any(...);
};



template <class _Tp> struct remove_pointer {typedef _Tp type;};
template <class _Tp> struct remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct remove_pointer<_Tp* const volatile> {typedef _Tp type;};


template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;




template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                is_same<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef _Tp type;};

template <class _Tp> struct add_pointer
    {typedef typename __add_pointer_impl<_Tp>::type type;};


template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;




template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool,(_Tp(-1) < _Tp(0))> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct is_signed : public __libcpp_is_signed<_Tp> {};
# 1200 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool,(_Tp(0) < _Tp(-1))> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct is_unsigned : public __libcpp_is_unsigned<_Tp> {};
# 1220 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
# 1234 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp, unsigned _Ip = 0> struct extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
# 1252 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct remove_extent
    {typedef _Tp type;};
template <class _Tp> struct remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct remove_extent<_Tp[_Np]>
    {typedef _Tp type;};


template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;




template <class _Tp> struct remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};


template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




template <class _Up, bool>
struct __decay {
    typedef typename remove_cv<_Up>::type type;
};

template <class _Up>
struct __decay<_Up, true> {
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};

template <class _Tp>
struct decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};


template <class _Tp> using decay_t = typename decay<_Tp>::type;




template <class _Tp> struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};
# 1325 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};






template <class _Tp> struct
is_final : public integral_constant<bool, __is_final(_Tp)> {};
# 1359 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Bp, class _Dp>
struct is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 1399 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _T1, class _T2> struct is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 1489 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1525 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1550 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1567 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};
# 1577 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    static_assert(!is_void<_Aligner>::value, "");
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};


template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
# 1686 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <size_t _Len>struct aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};


template <size_t _Len>struct aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};
# 1711 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof__(_Type0),
                                                       __alignof__(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;




template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};



typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,

    __type_list<__int128_t,

    __nat

    >

    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,

    __type_list<__uint128_t,

    __nat

    >

    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};


template <class _Tp>
struct make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;


template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};


template <class _Tp>
struct make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
# 2010 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class ..._Tp>
struct common_type {};



template <class _Tp>
struct common_type<_Tp>
    : public common_type<_Tp, _Tp> {};



template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};

template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
    typename __void_t<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type>
{
    typedef typename decay<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type type;
};

template <class _Tp, class _Up,
          class _DTp = typename decay<_Tp>::type,
          class _DUp = typename decay<_Up>::type>
using __common_type2 =
  typename conditional<
    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,
    __common_type2_imp<_Tp, _Up>,
    common_type<_DTp, _DUp>
  >::type;

template <class _Tp, class _Up>
struct common_type<_Tp, _Up>
    : __common_type2<_Tp, _Up> {};



template <class ...Tp> struct __common_types;

template <class, class = void>
struct __common_type_impl {};

template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class ..._Vp>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
  : __common_type_impl<
      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >
{

};

template <class _Tp, class _Up, class ..._Vp>
struct common_type<_Tp, _Up, _Vp...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};


template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;






template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type
__is_assignable_test(int);

template <class, class>
false_type __is_assignable_test(...);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public decltype((std::__1::__is_assignable_test<_Tp, _Arg>(0))) {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};
# 2116 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 2127 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_move_assignable

    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};
# 2149 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(std::__1::declval<_Tp1&>().~_Tp1())>::type
    );

    template <typename _Tp1>
    static __two __test (...);

    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__1::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__1::false_type {};

template <>
struct is_destructible<void>
    : public std::__1::false_type {};
# 2207 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept
{
    typedef typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept
{
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!is_lvalue_reference<_Tp>::value,
                  "can not forward an rvalue as an lvalue");
    return static_cast<_Tp&&>(__t);
}
# 2277 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
inline __attribute__ ((__always_inline__))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
{
    return std::__1::forward<_Tp>(__t);
}
# 2299 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};




template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
# 2756 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};


template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};



template <class _Callable> class result_of;
# 2937 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
namespace __is_construct
{
struct __nat {};
}
# 3059 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp, class ..._Args>
struct is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};
# 3250 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
struct is_default_constructible
    : public is_constructible<_Tp>
    {};
# 3262 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
struct is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3274 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
struct is_move_constructible

    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 3294 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp, class... _Args>
struct is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
# 3422 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};
# 3433 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};
# 3444 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivially_move_constructible

    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 3461 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 3502 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3513 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};
# 3531 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivially_destructible
    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
# 3568 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;

template <class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible< true, false, _Tp, _Args...>
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
{
};

template <class _Tp>
void __implicit_conversion_to(_Tp) noexcept { }

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_constructible< true, true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
{
};

template <class _Tp, bool _IsReference, class... _Args>
struct __libcpp_is_nothrow_constructible< false, _IsReference, _Tp, _Args...>
    : public false_type
{
};

template <class _Tp, class... _Args>
struct is_nothrow_constructible
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
{
};

template <class _Tp, size_t _Ns>
struct is_nothrow_constructible<_Tp[_Ns]>
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
{
};
# 3720 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};
# 3731 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3742 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_nothrow_move_constructible

    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 3759 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>() = std::__1::declval<_Arg>()) >
{
};

template <class _Tp, class _Arg>
struct is_nothrow_assignable
    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
{
};
# 3830 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3841 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};
# 3859 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct is_nothrow_destructible<_Tp&>
    : public true_type
{
};



template <class _Tp>
struct is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 3925 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3945 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>




    {};
# 3961 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};
# 3976 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>





    {};
# 3993 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};






template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};





template <class ..._Tp> struct __check_complete;

template <>
struct __check_complete<>
{
};

template <class _Hp, class _T0, class ..._Tp>
struct __check_complete<_Hp, _T0, _Tp...>
    : private __check_complete<_Hp>,
      private __check_complete<_T0, _Tp...>
{
};

template <class _Hp>
struct __check_complete<_Hp, _Hp>
    : private __check_complete<_Hp>
{
};

template <class _Tp>
struct __check_complete<_Tp>
{
    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
};

template <class _Tp>
struct __check_complete<_Tp&>
    : private __check_complete<_Tp>
{
};

template <class _Tp>
struct __check_complete<_Tp&&>
    : private __check_complete<_Tp>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (*)(_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (*)(_Param...)>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (_Param...)>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...)>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class>
struct __check_complete<_Rp _Class::*>
    : private __check_complete<_Class>
{
};


template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
# 4223 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;

template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;



template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }



template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }



template <class _Fp, class ..._Args>
inline __attribute__ ((__always_inline__))
auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class ..._Args>
inline __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }





template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
    : private __check_complete<_Fp>
{
    using _Result = decltype(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));

    using type =
        typename conditional<
            !is_same<_Result, __nat>::value,
            typename conditional<
                is_void<_Ret>::value,
                true_type,
                is_convertible<_Result, _Ret>
            >::type,
            false_type
        >::type;
    static const bool value = type::value;
};

template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;

    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;

    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
};

template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};



template <class _Fp, class ..._Args>
class result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};


template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
# 4441 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;

template <class _Tp>
inline __attribute__ ((__always_inline__))

typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type



swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__always_inline__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value);

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

               noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>())))

{
    swap(*__a, *__b);
}



namespace __detail
{


template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);


    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

    static const bool value = !is_same<__swap1, __nat>::value
                           && !is_same<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__1::declval<_Tp>(), std::__1::declval<_Up>()))
  && noexcept(swap(std::__1::declval<_Up>(), std::__1::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};
# 4590 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};


template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
# 4613 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__ ((__always_inline__))
int __convert_to_integral(int __val) { return __val; }

inline __attribute__ ((__always_inline__))
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__ ((__always_inline__))
long __convert_to_integral(long __val) { return __val; }

inline __attribute__ ((__always_inline__))
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__ ((__always_inline__))
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__ ((__always_inline__))
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }


inline __attribute__ ((__always_inline__))
__int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__ ((__always_inline__))
__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp>
inline __attribute__ ((__always_inline__))
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }



template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(std::__1::declval<_Up>().operator&()), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(std::__1::declval<_Up>())), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};
# 4710 "../../buildtools/third_party/libc++/trunk/include/type_traits" 3
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};




template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};



} }
# 641 "../../buildtools/third_party/libc++/trunk/include/algorithm" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cstring" 1 3
# 61 "../../buildtools/third_party/libc++/trunk/include/cstring" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/string.h" 1 3
# 59 "../../buildtools/third_party/libc++/trunk/include/string.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern "C" {





# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 33 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 2 3 4
# 42 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 106 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 117 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));







# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/xlocale.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 160 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 231 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 258 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 310 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 337 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 368 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();
# 433 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 484 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 512 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
# 599 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern char *basename (const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 646 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/string.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
__mempcpy_inline (void *__restrict __dest,
    const void *__restrict __src, size_t __n)
{
  return (char *) memcpy (__dest, __src, __n) + __n;
}




}
# 62 "../../buildtools/third_party/libc++/trunk/include/string.h" 2 3
# 72 "../../buildtools/third_party/libc++/trunk/include/string.h" 3
extern "C++" {
inline __attribute__ ((__always_inline__))
char* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strchr( char* __s, int __c) {return __libcpp_strchr(__s, __c);}

inline __attribute__ ((__always_inline__))
char* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strpbrk( char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}

inline __attribute__ ((__always_inline__))
char* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strrchr( char* __s, int __c) {return __libcpp_strrchr(__s, __c);}

inline __attribute__ ((__always_inline__))
void* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      void* memchr( void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}

inline __attribute__ ((__always_inline__))
char* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
inline __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strstr( char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
}
# 62 "../../buildtools/third_party/libc++/trunk/include/cstring" 2 3
# 65 "../../buildtools/third_party/libc++/trunk/include/cstring" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;
using ::memchr;
using ::strchr;
using ::strcspn;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} }
# 642 "../../buildtools/third_party/libc++/trunk/include/algorithm" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/utility" 1 3
# 198 "../../buildtools/third_party/libc++/trunk/include/utility" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__tuple" 1 3
# 20 "../../buildtools/third_party/libc++/trunk/include/__tuple" 3



namespace std {inline namespace __1 {

template <class _Tp> class tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
class tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
class tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
class tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};







template <size_t _Ip, class _Tp> class tuple_element;

template <size_t _Ip, class _Tp>
class tuple_element<_Ip, const _Tp>
{
public:
    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class tuple_element<_Ip, volatile _Tp>
{
public:
    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class tuple_element<_Ip, const volatile _Tp>
{
public:
    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};





template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 144 "../../buildtools/third_party/libc++/trunk/include/__tuple" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;







template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};


template <class ..._Tp> class tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};

template <class ..._Tp>
class tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <size_t _Ip, class ..._Tp>
__attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;





template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;




template <class _Tp, size_t _Size> struct array;

template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__always_inline__)) constexpr
_Tp&
get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__always_inline__)) constexpr
const _Tp&
get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__always_inline__)) constexpr
_Tp&&
get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__always_inline__)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;






template <class ..._Tp> struct __tuple_types {};
# 284 "../../buildtools/third_party/libc++/trunk/include/__tuple" 3
template <size_t _Ip, class ..._Types>
class tuple_element<_Ip, __tuple_types<_Types...>>
{
public:
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __type_pack_element<_Ip, _Types...> type;
};


template <class ..._Tp>
class tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply = const volatile _Tp&;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;
# 348 "../../buildtools/third_party/libc++/trunk/include/__tuple" 3
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};

template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};

template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <bool ..._Preds>
struct __all_dummy;

template <bool ..._Pred>
using __all = is_same<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};


template <size_t _Ip, class ..._Tp>
class tuple_element<_Ip, tuple<_Tp...> >
{
public:
    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};


template <size_t _Ip, class ..._Tp>
using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;


template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size = __tuple_like_with_size_imp<
                                   __tuple_like<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;

struct __check_tuple_constructor_fail {
    template <class ...>
    static constexpr bool __enable_default() { return false; }
    template <class ...>
    static constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static constexpr bool __enable_assign() { return false; }
};
# 554 "../../buildtools/third_party/libc++/trunk/include/__tuple" 3
} }
# 199 "../../buildtools/third_party/libc++/trunk/include/utility" 2 3




# 1 "../../buildtools/third_party/libc++/trunk/include/cstdint" 1 3
# 145 "../../buildtools/third_party/libc++/trunk/include/cstdint" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/stdint.h" 1 3
# 106 "../../buildtools/third_party/libc++/trunk/include/stdint.h" 3
# 119 "../../buildtools/third_party/libc++/trunk/include/stdint.h" 3
# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stdint.h" 1 3
# 63 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stdint.h" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 1 3 4
# 26 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 2 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 2 3 4








typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;







typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 64 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stdint.h" 2 3
# 120 "../../buildtools/third_party/libc++/trunk/include/stdint.h" 2 3
# 146 "../../buildtools/third_party/libc++/trunk/include/cstdint" 2 3
# 149 "../../buildtools/third_party/libc++/trunk/include/cstdint" 3


namespace std {inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 204 "../../buildtools/third_party/libc++/trunk/include/utility" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__debug" 1 3
# 18 "../../buildtools/third_party/libc++/trunk/include/__debug" 3
# 54 "../../buildtools/third_party/libc++/trunk/include/__debug" 3
class __libcpp_debug_exception;


namespace std {inline namespace __1 {

struct __libcpp_debug_info {
  __attribute__ ((__always_inline__)) constexpr
  __libcpp_debug_info()
      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
  __attribute__ ((__always_inline__)) constexpr
  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)
    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}
  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};


typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);



extern __libcpp_debug_function_type __libcpp_debug_function;


[[noreturn]]
void __libcpp_abort_debug_function(__libcpp_debug_info const&);



 [[noreturn]]
void __libcpp_throw_debug_function(__libcpp_debug_info const&);




bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
# 299 "../../buildtools/third_party/libc++/trunk/include/__debug" 3
} }
# 205 "../../buildtools/third_party/libc++/trunk/include/utility" 2 3
# 208 "../../buildtools/third_party/libc++/trunk/include/utility" 3


namespace std {inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}




template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, (void) ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}


template<class _Tp, size_t _Np>
inline __attribute__ ((__always_inline__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value)
{
    std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__always_inline__)) constexpr

typename conditional
<
    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
    const _Tp&,
    _Tp&&
>::type



move_if_noexcept(_Tp& __x) noexcept
{
    return std::__1::move(__x);
}






struct piecewise_construct_t { };



constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
# 311 "../../buildtools/third_party/libc++/trunk/include/utility" 3
template <class _T1, class _T2>
struct pair



{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;


    pair(pair const&) = default;
    pair(pair&&) = default;
# 348 "../../buildtools/third_party/libc++/trunk/include/utility" 3
    template <bool _Val>
    using _EnableB = typename enable_if<_Val, bool>::type;

    struct _CheckArgs {
      template <class _U1, class _U2>
      static constexpr bool __enable_default() {
          return is_default_constructible<_U1>::value
              && is_default_constructible<_U2>::value;
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && (!is_convertible<_U1, first_type>::value
                  || !is_convertible<_U2, second_type>::value);
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }
    };

    template <bool _MaybeEnable>
    using _CheckArgsDep = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, pair>::value
               && !__tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_assign() {
            return __tuple_assignable<_Tuple, pair>::value;
        }
    };

    template <class _Tuple>
    using _CheckTLC = typename conditional<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >::type;

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    pair() : first(), second() {}

    template <bool _Dummy = true, _EnableB<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        : first(__t1), second(__t2) {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    pair(_T1 const& __t1, _T2 const& __t2)
        : first(__t1), second(__t2) {}

    template<class _U1, class _U2, _EnableB<
             _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    explicit pair(_U1&& __u1, _U2&& __u2)
        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    pair(_U1&& __u1, _U2&& __u2)
        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    explicit pair(pair<_U1, _U2> const& __p)
        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    pair(pair<_U1, _U2> const& __p)
        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    explicit pair(pair<_U1, _U2>&&__p)
        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    pair(pair<_U1, _U2>&& __p)
        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    explicit pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    > = false>
    __attribute__ ((__always_inline__)) constexpr
    pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template <class... _Args1, class... _Args2>
    __attribute__ ((__always_inline__))
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

    __attribute__ ((__always_inline__))
    pair& operator=(typename conditional<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat>::type const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__ ((__always_inline__))
    pair& operator=(typename conditional<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>::type&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)

    {
        first = std::__1::forward<first_type>(__p.first);
        second = std::__1::forward<second_type>(__p.second);
        return *this;
    }

    template <class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     > = false>
    __attribute__ ((__always_inline__))
    pair& operator=(_Tuple&& __p) {
        first = std::__1::get<0>(std::__1::forward<_Tuple>(__p));
        second = std::__1::get<1>(std::__1::forward<_Tuple>(__p));
        return *this;
    }


    __attribute__ ((__always_inline__))
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)

    {
        using std::__1::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__always_inline__))
        pair(piecewise_construct_t,
             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
             __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};






template <class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))

{
    __x.swap(__y);
}



template <class _Tp>
struct __make_pair_return_impl
{
    typedef _Tp type;
};

template <class _Tp>
struct __make_pair_return_impl<reference_wrapper<_Tp>>
{
    typedef _Tp& type;
};

template <class _Tp>
struct __make_pair_return
{
    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;
};

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
               (std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
}
# 657 "../../buildtools/third_party/libc++/trunk/include/utility" 3
template <class _T1, class _T2>
  class tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
class tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
class tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};

template <class _T1, class _T2>
class tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T1>(__p.first);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T1>(__p.first);}

};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T2>(__p.second);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__always_inline__)) constexpr
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T2>(__p.second);}

};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}


template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}



template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
constexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}





template<class _Tp, _Tp... _Ip>
struct integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__ ((__always_inline__))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};

template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 880 "../../buildtools/third_party/libc++/trunk/include/utility" 3
template<class _Tp, _Tp _Np>
    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;

template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;

template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;




template<class _T1, class _T2 = _T1>
inline __attribute__ ((__always_inline__))
_T1 exchange(_T1& __obj, _T2 && __new_value)
{
    _T1 __old_value = std::__1::move(__obj);
    __obj = std::__1::forward<_T2>(__new_value);
    return __old_value;
}
# 946 "../../buildtools/third_party/libc++/trunk/include/utility" 3
template <class _Arg, class _Result>
struct unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Size>
inline __attribute__ ((__always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
    case 2:
        __h ^= __data[1] << 8;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__ ((__always_inline__))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}

template<class _Tp>
struct hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};


template <>
struct hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};



template <>
struct hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};

template <>
struct hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};



template <>
struct hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__always_inline__))
    size_t operator()(float __v) const noexcept
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__always_inline__))
    size_t operator()(double __v) const noexcept
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__always_inline__))
    size_t operator()(long double __v) const noexcept
    {

        if (__v == 0)
            return 0;
# 1514 "../../buildtools/third_party/libc++/trunk/include/utility" 3
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__s.__a = 0;
        __u.__s.__b = 0;
        __u.__t = __v;
        return __u.__s.__a ^ __u.__s.__b;



    }
};



template <class _Tp, bool = is_enum<_Tp>::value>
struct __enum_hash
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>{}(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __enum_hash<_Tp, false> {
    __enum_hash() = delete;
    __enum_hash(__enum_hash const&) = delete;
    __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct hash : public __enum_hash<_Tp>
{
};
# 1573 "../../buildtools/third_party/libc++/trunk/include/utility" 3
template <class _Key, class _Hash>
using __check_hash_requirements = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;

template <class _Key, class _Hash = std::hash<_Key> >
using __has_enabled_hash = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;
# 1595 "../../buildtools/third_party/libc++/trunk/include/utility" 3
template <class _Type, class ...>
using __enable_hash_helper = _Type;




} }
# 643 "../../buildtools/third_party/libc++/trunk/include/algorithm" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/memory" 1 3
# 644 "../../buildtools/third_party/libc++/trunk/include/memory" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 1 3
# 61 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/exception" 1 3
# 82 "../../buildtools/third_party/libc++/trunk/include/exception" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cstdlib" 1 3
# 86 "../../buildtools/third_party/libc++/trunk/include/cstdlib" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/stdlib.h" 1 3
# 92 "../../buildtools/third_party/libc++/trunk/include/stdlib.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 1 3 4
# 32 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 33 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 2 3 4

extern "C" {







# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 2 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 43 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 2 3 4
# 58 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 100 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 200 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern __inline __attribute__ ((__gnu_inline__)) int
 atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
 atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
 atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}
# 266 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 30 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;





typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;







typedef __off64_t off_t;




typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 1 3 4
# 59 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
typedef __clock_t clock_t;
# 75 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
typedef __time_t time_t;
# 91 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 147 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 200 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/endian.h" 1 3 4
# 36 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/endian.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/endian.h" 2 3 4
# 60 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/endian.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 61 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/endian.h" 2 3 4
# 217 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;








# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 1 3 4
# 120 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 46 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 48 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4








typedef long int __fd_mask;
# 66 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 98 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 108 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 120 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 133 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 220 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
 gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
 gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
 gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}

}
# 223 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
# 248 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;






# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 125 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];


    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 220 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 276 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));
# 427 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;
# 441 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();




# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/alloca.h" 1 3 4
# 24 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/alloca.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 25 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 454 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 496 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 567 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 583 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 605 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64") __attribute__ ((__nonnull__ (1))) ;






extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 623 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 637 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 658 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 677 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 694 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}
# 721 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 772 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();
# 848 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 859 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 921 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 25 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
 atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
# 922 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 2 3 4
# 934 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdlib.h" 3 4
}
# 95 "../../buildtools/third_party/libc++/trunk/include/stdlib.h" 2 3



extern "C++" {
# 111 "../../buildtools/third_party/libc++/trunk/include/stdlib.h" 3
inline __attribute__ ((__always_inline__)) long abs( long __x) noexcept {return labs(__x);}

inline __attribute__ ((__always_inline__)) long long abs(long long __x) noexcept {return llabs(__x);}


inline __attribute__ ((__always_inline__)) ldiv_t div( long __x, long __y) noexcept {return ldiv(__x, __y);}

inline __attribute__ ((__always_inline__)) lldiv_t div(long long __x, long long __y) noexcept {return lldiv(__x, __y);}



}
# 87 "../../buildtools/third_party/libc++/trunk/include/cstdlib" 2 3
# 90 "../../buildtools/third_party/libc++/trunk/include/cstdlib" 3








namespace std {inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;

using ::getenv;
using ::system;

using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;

using ::at_quick_exit;
using ::quick_exit;


using ::aligned_alloc;


} }
# 83 "../../buildtools/third_party/libc++/trunk/include/exception" 2 3
# 91 "../../buildtools/third_party/libc++/trunk/include/exception" 3


namespace std
{


class exception
{
public:
    __attribute__ ((__always_inline__)) exception() noexcept {}
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class bad_exception
    : public exception
{
public:
    __attribute__ ((__always_inline__)) bad_exception() noexcept {}
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};





typedef void (*unexpected_handler)();
                 unexpected_handler set_unexpected(unexpected_handler) noexcept;
                 unexpected_handler get_unexpected() noexcept;
[[noreturn]] void unexpected();


typedef void (*terminate_handler)();
                 terminate_handler set_terminate(terminate_handler) noexcept;
                 terminate_handler get_terminate() noexcept;
[[noreturn]] void terminate() noexcept;

                 bool uncaught_exception() noexcept;
                                                          int uncaught_exceptions() noexcept;

class exception_ptr;

                 exception_ptr current_exception() noexcept;
[[noreturn]] void rethrow_exception(exception_ptr);



class exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__always_inline__)) exception_ptr() noexcept : __ptr_() {}
    __attribute__ ((__always_inline__)) exception_ptr(nullptr_t) noexcept : __ptr_() {}

    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;

    __attribute__ ((__always_inline__)) explicit operator bool() const noexcept
    {return __ptr_ != nullptr;}

    friend __attribute__ ((__always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return __x.__ptr_ == __y.__ptr_;}

    friend __attribute__ ((__always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return !(__x == __y);}

    friend exception_ptr current_exception() noexcept;
    friend void rethrow_exception(exception_ptr);
};

template<class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) noexcept
{
# 179 "../../buildtools/third_party/libc++/trunk/include/exception" 3
    ((void)__e);
    std::__1::abort();

}
# 234 "../../buildtools/third_party/libc++/trunk/include/exception" 3
class nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;


    virtual ~nested_exception() noexcept;


    [[noreturn]] void rethrow_nested() const;
    __attribute__ ((__always_inline__)) exception_ptr nested_ptr() const noexcept {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};
# 287 "../../buildtools/third_party/libc++/trunk/include/exception" 3
template <class _Tp>
[[noreturn]]
void

throw_with_nested(_Tp&& __t)



{
# 305 "../../buildtools/third_party/libc++/trunk/include/exception" 3
    ((void)__t);


}

template <class _From, class _To>
struct __can_dynamic_cast : public integral_constant<bool,(is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value))> {};




template <class _Ep>
inline __attribute__ ((__always_inline__))
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::__1::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__always_inline__))
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
}

}
# 62 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 2 3
# 70 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 3
# 80 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 3
namespace std
{

class type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);
# 103 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 3
protected:
# 113 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 3
    const char *__type_name;

    __attribute__ ((__always_inline__))
    explicit type_info(const char* __n) : __type_name(__n) {}



public:

    virtual ~type_info();
# 179 "../../buildtools/third_party/libc++/trunk/include/typeinfo" 3
    __attribute__ ((__always_inline__))
    const char* name() const noexcept
    { return __type_name; }

    __attribute__ ((__always_inline__))
    bool before(const type_info& __arg) const noexcept
    { return __type_name < __arg.__type_name; }

    __attribute__ ((__always_inline__))
    size_t hash_code() const noexcept
    { return reinterpret_cast<size_t>(__type_name); }

    __attribute__ ((__always_inline__))
    bool operator==(const type_info& __arg) const noexcept
    { return __type_name == __arg.__type_name; }



    __attribute__ ((__always_inline__))
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }
};

class bad_cast
    : public exception
{
public:
    bad_cast() noexcept;
    virtual ~bad_cast() noexcept;
    virtual const char* what() const noexcept;
};

class bad_typeid
    : public exception
{
public:
    bad_typeid() noexcept;
    virtual ~bad_typeid() noexcept;
    virtual const char* what() const noexcept;
};

}

namespace std {inline namespace __1 {
[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_bad_cast()
{



 std::__1::abort();

}
} }
# 645 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3


# 1 "../../buildtools/third_party/libc++/trunk/include/new" 1 3
# 101 "../../buildtools/third_party/libc++/trunk/include/new" 3
# 114 "../../buildtools/third_party/libc++/trunk/include/new" 3
namespace std
{


struct nothrow_t {};
extern const nothrow_t nothrow;

class bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    virtual ~bad_alloc() noexcept;
    virtual const char* what() const noexcept;
};

class bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    virtual ~bad_array_new_length() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*new_handler)();
                 new_handler set_new_handler(new_handler) noexcept;
                 new_handler get_new_handler() noexcept;



[[noreturn]] void __throw_bad_alloc();



class
    bad_array_length : public bad_alloc {
public:
    bad_array_length() noexcept;
    virtual ~bad_array_length() noexcept;
    virtual const char* what() const noexcept;
};
# 169 "../../buildtools/third_party/libc++/trunk/include/new" 3
}
# 179 "../../buildtools/third_party/libc++/trunk/include/new" 3
                             void* operator new(std::size_t __sz) ;
                             void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
                             void operator delete(void* __p) noexcept;
                             void operator delete(void* __p, const std::nothrow_t&) noexcept;

                                                                   void operator delete(void* __p, std::size_t __sz) noexcept;


                             void* operator new[](std::size_t __sz) ;
                             void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
                             void operator delete[](void* __p) noexcept;
                             void operator delete[](void* __p, const std::nothrow_t&) noexcept;

                                                                   void operator delete[](void* __p, std::size_t __sz) noexcept;
# 213 "../../buildtools/third_party/libc++/trunk/include/new" 3
inline __attribute__ ((__always_inline__)) void* operator new (std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__always_inline__)) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__always_inline__)) void operator delete (void*, void*) noexcept {}
inline __attribute__ ((__always_inline__)) void operator delete[](void*, void*) noexcept {}



namespace std {inline namespace __1 {

inline __attribute__ ((__always_inline__)) void *__allocate(size_t __size) {



  return __builtin_operator_new(__size);

}

inline __attribute__ ((__always_inline__)) void __libcpp_deallocate(void *__ptr) {



  __builtin_operator_delete(__ptr);

}


[[noreturn]] inline __attribute__ ((__always_inline__))



void __throw_bad_array_length()
{



 std::__1::abort();

}


} }
# 648 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3

# 1 "../../buildtools/third_party/libc++/trunk/include/limits" 1 3
# 117 "../../buildtools/third_party/libc++/trunk/include/limits" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 121 "../../buildtools/third_party/libc++/trunk/include/limits" 2 3


namespace std {inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return type();}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return type();}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type();}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;



    static constexpr const bool traps = true;



    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 64;
    static constexpr const int digits10 = 18;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 3.36210314311209350626e-4932L;}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.18973149535723176502e+4932L;}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 1.08420217248550443401e-19L;}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-16381);
    static constexpr const int min_exponent10 = (-4931);
    static constexpr const int max_exponent = 16384;
    static constexpr const int max_exponent10 = 4932;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return 3.64519953188247460253e-4951L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 650 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/iterator" 1 3
# 426 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/iosfwd" 1 3
# 90 "../../buildtools/third_party/libc++/trunk/include/iosfwd" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 1 3
# 113 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 3






# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 1 3 4
# 36 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 1 3 4
# 15 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 1 3 4
# 44 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;
# 64 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 18 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 2 3
# 37 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 2 3 4


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stdarg.h" 1 3 4
# 30 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 40 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 2 3 4
# 51 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 132 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 3
typedef unsigned int wint_t;
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 52 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 2 3 4
# 82 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 106 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
typedef __mbstate_t mbstate_t;
# 132 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern "C" {




struct tm;
# 147 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();
# 209 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 248 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 309 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 389 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
 btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
 wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
 mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 533 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 692 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 748 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 804 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 830 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 840 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 894 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 3 4
}
# 120 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 2 3
# 91 "../../buildtools/third_party/libc++/trunk/include/iosfwd" 2 3
# 94 "../../buildtools/third_party/libc++/trunk/include/iosfwd" 3


namespace std {inline namespace __1 {

class ios_base;

template<class _CharT> struct char_traits;
template<class _Tp> class allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;






typedef long long streamoff;


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;



template <class _Tp, class _Alloc = allocator<_Tp> >
class vector;

} }
# 427 "../../buildtools/third_party/libc++/trunk/include/iterator" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__functional_base" 1 3
# 23 "../../buildtools/third_party/libc++/trunk/include/__functional_base" 3


namespace std {inline namespace __1 {

template <class _Arg1, class _Arg2, class _Result>
struct binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};


template <class _Tp = void>



struct less : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};


template <>
struct less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};





template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_Args>()...)) type;
};
# 312 "../../buildtools/third_party/libc++/trunk/include/__functional_base" 3
template <class _Ret>
struct __invoke_void_return_wrapper
{

    template <class ..._Args>
    static _Ret __call(_Args&&... __args) {
        return __invoke(std::__1::forward<_Args>(__args)...);
    }
# 341 "../../buildtools/third_party/libc++/trunk/include/__functional_base" 3
};

template <>
struct __invoke_void_return_wrapper<void>
{

    template <class ..._Args>
    static void __call(_Args&&... __args) {
        __invoke(std::__1::forward<_Args>(__args)...);
    }
# 372 "../../buildtools/third_party/libc++/trunk/include/__functional_base" 3
};

template <class _Tp>
class reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__always_inline__)) reference_wrapper(type& __f) noexcept
        : __f_(std::__1::addressof(__f)) {}

    private: reference_wrapper(type&&); public:



    __attribute__ ((__always_inline__)) operator type& () const noexcept {return *__f_;}
    __attribute__ ((__always_inline__)) type& get() const noexcept {return *__f_;}



    template <class... _ArgTypes>
    __attribute__ ((__always_inline__))
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return __invoke(get(), std::__1::forward<_ArgTypes>(__args)...);
    }
# 510 "../../buildtools/third_party/libc++/trunk/include/__functional_base" 3
};


template <class _Tp>
inline __attribute__ ((__always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return cref(__t.get());
}


template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;



template <class _Tp, class, class = void>
struct __is_transparent : false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,
                        typename __void_t<typename _Tp::is_transparent>::type>
   : true_type {};




struct allocator_arg_t { };




constexpr allocator_arg_t allocator_arg = allocator_arg_t();




template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
# 611 "../../buildtools/third_party/libc++/trunk/include/__functional_base" 3
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef typename __uncvref<_Alloc>::type _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::__1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)..., __a);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__always_inline__))
void __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)
{
    __user_alloc_construct_impl(
             __uses_alloc_ctor<_Tp, _Allocator>(),
             __storage, __a, std::__1::forward<_Args>(__args)...
        );
}


} }
# 428 "../../buildtools/third_party/libc++/trunk/include/iterator" 2 3
# 439 "../../buildtools/third_party/libc++/trunk/include/iterator" 3


namespace std {inline namespace __1 {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template<class _Tp>
struct iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_const<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template <class _Tp>
struct __is_exactly_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__always_inline__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__always_inline__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__always_inline__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__always_inline__))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__always_inline__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__always_inline__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__always_inline__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIter>::value,
    _InputIter
>::type
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    std::__1::advance(__x, __n);
    return __x;
}

template <class _BidirectionalIter>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    __is_bidirectional_iterator<_BidirectionalIter>::value,
    _BidirectionalIter
>::type
prev(_BidirectionalIter __x,
     typename iterator_traits<_BidirectionalIter>::difference_type __n = 1)
{
    std::__1::advance(__x, -__n);
    return __x;
}


template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};

template <class _Iter>
class reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
                _Iter __t;

    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");

protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__always_inline__))
    reverse_iterator() : __t(), current() {}
    __attribute__ ((__always_inline__))
    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up>
        __attribute__ ((__always_inline__))
        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}
    template <class _Up>
        __attribute__ ((__always_inline__))
        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
            { __t = current = __u.base(); return *this; }
    __attribute__ ((__always_inline__))
    _Iter base() const {return current;}
    __attribute__ ((__always_inline__))
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__always_inline__))
    pointer operator->() const {return std::__1::addressof(operator*());}
    __attribute__ ((__always_inline__))
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__always_inline__))
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__always_inline__))
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__always_inline__))
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__always_inline__))
    reverse_iterator operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__ ((__always_inline__))
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__ ((__always_inline__))
    reverse_iterator operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__ ((__always_inline__))
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__ ((__always_inline__))
    reference operator[](difference_type __n) const {return *(*this + __n);}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
# 768 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
template <class _Iter>
inline __attribute__ ((__always_inline__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter>
inline __attribute__ ((__always_inline__))
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}


template <class _Container>
class back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__always_inline__)) explicit back_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}

    __attribute__ ((__always_inline__)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(std::__1::move(__value_)); return *this;}

    __attribute__ ((__always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__always_inline__)) explicit front_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}

    __attribute__ ((__always_inline__)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(std::__1::move(__value_)); return *this;}

    __attribute__ ((__always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__1::addressof(__x)), iter(__i) {}
    __attribute__ ((__always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}

    __attribute__ ((__always_inline__)) insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, std::__1::move(__value_)); ++iter; return *this;}

    __attribute__ ((__always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__always_inline__)) constexpr istream_iterator() : __in_stream_(0), __value_() {}
    __attribute__ ((__always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(std::__1::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__always_inline__)) const _Tp* operator->() const {return std::__1::addressof((operator*()));}
    __attribute__ ((__always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    friend __attribute__ ((__always_inline__))
    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
        {return __x.__in_stream_ == __y.__in_stream_;}

    friend __attribute__ ((__always_inline__))
    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__always_inline__)) ostream_iterator(ostream_type& __s) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(0) {}
    __attribute__ ((__always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(__delimiter) {}
    __attribute__ ((__always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__always_inline__)) constexpr istreambuf_iterator() noexcept : __sbuf_(0) {}
    __attribute__ ((__always_inline__)) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__always_inline__)) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__always_inline__)) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__always_inline__)) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__always_inline__)) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__always_inline__)) bool failed() const noexcept {return __sbuf_ == 0;}





    template <class _Ch, class _Tr>
    friend

    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);

};

template <class _Iter>
class move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef iterator_type pointer;

    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;




    __attribute__ ((__always_inline__))
    move_iterator() : __i() {}
    __attribute__ ((__always_inline__))
    explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up>
      __attribute__ ((__always_inline__))
      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}
    __attribute__ ((__always_inline__)) _Iter base() const {return __i;}
    __attribute__ ((__always_inline__))
    reference operator*() const { return static_cast<reference>(*__i); }
    __attribute__ ((__always_inline__))
    pointer operator->() const { return __i;}
    __attribute__ ((__always_inline__))
    move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__always_inline__))
    move_iterator operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__always_inline__))
    move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__always_inline__))
    move_iterator operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__always_inline__))
    move_iterator operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    __attribute__ ((__always_inline__))
    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
    __attribute__ ((__always_inline__))
    move_iterator operator- (difference_type __n) const {return move_iterator(__i - __n);}
    __attribute__ ((__always_inline__))
    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}
    __attribute__ ((__always_inline__))
    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
# 1187 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
template <class _Iter>
inline __attribute__ ((__always_inline__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__always_inline__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


template <class _Iter1, class _Iter2>
__attribute__ ((__always_inline__))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base());







template <class _Iter>
__attribute__ ((__always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept;

template <class _Ip, class _Op> _Op __attribute__ ((__always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__always_inline__)) move_backward(_B1, _B1, _B2);



template <class _Tp>
__attribute__ ((__always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);
# 1284 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__always_inline__)) __wrap_iter() noexcept

                : __i{}

    {



    }
    template <class _Up> __attribute__ ((__always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) noexcept
        : __i(__u.base())
    {



    }
# 1337 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
    __attribute__ ((__always_inline__)) reference operator*() const noexcept
    {




        return *__i;
    }
    __attribute__ ((__always_inline__)) pointer operator->() const noexcept
    {




        return (pointer)std::__1::addressof(*__i);
    }
    __attribute__ ((__always_inline__)) __wrap_iter& operator++() noexcept
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__always_inline__)) __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__ ((__always_inline__)) __wrap_iter& operator--() noexcept
    {




        --__i;
        return *this;
    }
    __attribute__ ((__always_inline__)) __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__always_inline__)) __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__always_inline__)) __wrap_iter& operator+=(difference_type __n) noexcept
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__always_inline__)) __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__ ((__always_inline__)) __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__ ((__always_inline__)) reference operator[](difference_type __n) const noexcept
    {




        return __i[__n];
    }

    __attribute__ ((__always_inline__)) iterator_type base() const noexcept {return __i;}

private:






    __attribute__ ((__always_inline__)) __wrap_iter(iterator_type __x) noexcept : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class vector;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


    template <class _Iter1, class _Iter2>
    friend
    auto
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base());







    template <class _Iter1>
    friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);


    template <class _Tp>
    friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
# 1487 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__always_inline__))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base())
{




    return __x.base() - __y.base();
}
# 1600 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
template <class _Iter>
inline __attribute__ ((__always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept
{
    __x += __n;
    return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public integral_constant<bool,(is_pointer<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};


template <class _Tp, size_t _Np>
inline __attribute__ ((__always_inline__)) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__always_inline__)) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}



template <class _Cp>
inline __attribute__ ((__always_inline__))
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}



template <class _Tp, size_t _Np>
inline __attribute__ ((__always_inline__))
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__always_inline__))
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
inline __attribute__ ((__always_inline__))
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
inline __attribute__ ((__always_inline__))
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
inline __attribute__ ((__always_inline__)) constexpr
auto cbegin(const _Cp& __c) -> decltype(std::__1::begin(__c))
{
    return std::__1::begin(__c);
}

template <class _Cp>
inline __attribute__ ((__always_inline__)) constexpr
auto cend(const _Cp& __c) -> decltype(std::__1::end(__c))
{
    return std::__1::end(__c);
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto crbegin(const _Cp& __c) -> decltype(std::__1::rbegin(__c))
{
    return std::__1::rbegin(__c);
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
auto crend(const _Cp& __c) -> decltype(std::__1::rend(__c))
{
    return std::__1::rend(__c);
}
# 1832 "../../buildtools/third_party/libc++/trunk/include/iterator" 3
} }
# 651 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3


# 1 "../../buildtools/third_party/libc++/trunk/include/tuple" 1 3
# 147 "../../buildtools/third_party/libc++/trunk/include/tuple" 3


namespace std {inline namespace __1 {






template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__ ((__always_inline__))
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;

    template <class _Tp>
    static constexpr bool __can_bind_reference() {
        using _RawTp = typename remove_reference<_Tp>::type;
        using _RawHp = typename remove_reference<_Hp>::type;
        using _CheckLValueArg = integral_constant<bool,
            is_lvalue_reference<_Tp>::value
        || is_same<_RawTp, reference_wrapper<_RawHp>>::value
        || is_same<_RawTp, reference_wrapper<typename remove_const<_RawHp>::type>>::value
        >;
        return !is_reference<_Hp>::value
            || (is_lvalue_reference<_Hp>::value && _CheckLValueArg::value)
            || (is_rvalue_reference<_Hp>::value && !is_lvalue_reference<_Tp>::value);
    }

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__always_inline__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = typename enable_if<
                  __lazy_and<
                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>
                    , is_constructible<_Hp, _Tp>
                    >::value
                >::type
            >
        __attribute__ ((__always_inline__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp>(),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp>(),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}

    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;

    template <class _Tp>
        __attribute__ ((__always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            __value_ = std::__1::forward<_Tp>(__t);
            return *this;
        }

    __attribute__ ((__always_inline__))
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__always_inline__)) constexpr _Hp& get() noexcept {return __value_;}
    __attribute__ ((__always_inline__)) constexpr const _Hp& get() const noexcept {return __value_;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__always_inline__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = typename enable_if<
                  __lazy_and<
                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>
                      , is_constructible<_Hp, _Tp>
                    >::value
                >::type
            >
        __attribute__ ((__always_inline__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t), __a) {}

    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;

    template <class _Tp>
        __attribute__ ((__always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            _Hp::operator=(std::__1::forward<_Tp>(__t));
            return *this;
        }

    __attribute__ ((__always_inline__))
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__always_inline__)) constexpr _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__ ((__always_inline__)) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__ ((__always_inline__))
void __swallow(_Tp&&...) noexcept {}

template <class ..._Tp>
struct __lazy_all : __all<_Tp::value...> {};

template <class _Tp>
struct __all_default_constructible;

template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };



template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__ ((__always_inline__))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__always_inline__)) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :

            __tuple_leaf<_Uf, _Tf>(std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__always_inline__))
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__always_inline__)) constexpr
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

            : __tuple_leaf<_Indx, _Tp>(std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__always_inline__))
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    template <class _Tuple>
        __attribute__ ((__always_inline__))
        typename enable_if
        <
            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,
            __tuple_impl&
        >::type
        operator=(_Tuple&& __t) noexcept((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

        {
            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...);
            return *this;
        }

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__ ((__always_inline__))
    __tuple_impl&
    operator=(const __tuple_impl& __t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);
        return *this;
    }

    __attribute__ ((__always_inline__))
    __tuple_impl&
    operator=(__tuple_impl&& __t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
        return *this;
    }

    __attribute__ ((__always_inline__))
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};



template <class ..._Tp>
class tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

    _BaseT __base_;




    static constexpr bool _EnableImplicitReducedArityExtension = false;


    template <class ..._Args>
    struct _PackExpandsToThisTuple : false_type {};

    template <class _Arg>
    struct _PackExpandsToThisTuple<_Arg>
        : is_same<typename __uncvref<_Arg>::type, tuple> {};

    template <bool _MaybeEnable, class _Dummy = void>
    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckArgsConstructor<true, _Dummy>
    {
        template <class ..._Args>
        static constexpr bool __enable_default() {
            return __all<is_default_constructible<_Args>::value...>::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_explicit() {
            return
                __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                !__tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_implicit() {
            return
                __tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }
    };

    template <bool _MaybeEnable,
              bool = sizeof...(_Tp) == 1,
              class _Dummy = void>
    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, false, _Dummy>
    {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, tuple>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, tuple>::value
               && !__tuple_convertible<_Tuple, tuple>::value;
        }
    };

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, true, _Dummy>
    {



        template <class _Tuple>
        using _PreferTupleLikeConstructor = __lazy_or<


            is_same<typename __uncvref<_Tuple>::type, tuple>,
            __lazy_and<
                __lazy_not<is_constructible<_Tp..., _Tuple>>,
                __lazy_not<is_convertible<_Tuple, _Tp...>>
            >
        >;

        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __lazy_and<
                __tuple_convertible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>
            >::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __lazy_and<
                __tuple_constructible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>,
                __lazy_not<__tuple_convertible<_Tuple, tuple>>
            >::value;
        }
    };

    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:

    template <bool _Dummy = true, class = typename enable_if<
        _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()
    >::type>
    __attribute__ ((__always_inline__))
    constexpr tuple()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    tuple(tuple const&) = default;
    tuple(tuple&&) = default;

    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<
        __lazy_and<
            is_same<allocator_arg_t, _AllocArgT>,
            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>
       >::value
    >::type>
    __attribute__ ((__always_inline__))
    tuple(_AllocArgT, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__always_inline__)) constexpr
    tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__always_inline__)) constexpr
    explicit tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__always_inline__))
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__always_inline__))
      explicit
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class ..._Up,
              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp)
                             && !_PackIsTuple
                         >::template __enable_implicit<_Up...>() ||
                        _CheckArgsConstructor<
                            _EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackIsTuple
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__)) constexpr
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 738 "../../buildtools/third_party/libc++/trunk/include/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) <= sizeof...(_Tp)
                             && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>() ||
                         _CheckArgsConstructor<
                            !_EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__)) constexpr
        explicit
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 771 "../../buildtools/third_party/libc++/trunk/include/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__)) constexpr
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__1::forward<_Tuple>(__t)) {}

    template <class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__)) constexpr
        explicit
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__1::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__always_inline__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;

    __attribute__ ((__always_inline__))
    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)
        noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(__t.__base_);
        return *this;
    }

    __attribute__ ((__always_inline__))
    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)
        noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(static_cast<_BaseT&&>(__t.__base_));
        return *this;
    }

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_assignable<_Tuple, tuple>::value
                      >::type
             >
        __attribute__ ((__always_inline__))
        tuple&
        operator=(_Tuple&& __t) noexcept((is_nothrow_assignable<_BaseT&, _Tuple>::value))
        {
            __base_.operator=(std::__1::forward<_Tuple>(__t));
            return *this;
        }

    __attribute__ ((__always_inline__))
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}
};

template <>
class tuple<>
{
public:
    __attribute__ ((__always_inline__))
    constexpr tuple() noexcept {}
    template <class _Alloc>
    __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__ ((__always_inline__))
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__ ((__always_inline__))
    void swap(tuple&) noexcept {}
};
# 942 "../../buildtools/third_party/libc++/trunk/include/tuple" 3
template <class ..._Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}



template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}



namespace __find_detail {

static constexpr size_t __not_found = -1;
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__ ((__always_inline__))
constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
    return !__matches ? __res :
        (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__ ((__always_inline__))
constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found :
      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class ..._Args>
struct __find_exactly_one_checked {
  static constexpr bool __matches[] = {is_same<_T1, _Args>::value...};
    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
    static_assert (value != __not_found, "type not found in type list" );
    static_assert(value != __ambiguous,"type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

}

template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
};

template <class _T1, class... _Args>
inline __attribute__ ((__always_inline__))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__always_inline__))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__always_inline__))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__ ((__always_inline__))
constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}





template <class ..._Tp>
inline __attribute__ ((__always_inline__)) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__ ((__always_inline__)) constexpr
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};

namespace {
  constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class _Tp>
struct __make_tuple_return_impl
{
    typedef _Tp type;
};

template <class _Tp>
struct __make_tuple_return_impl<reference_wrapper<_Tp> >
{
    typedef _Tp& type;
};

template <class _Tp>
struct __make_tuple_return
{
    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;
};

template <class... _Tp>
inline __attribute__ ((__always_inline__)) constexpr
tuple<typename __make_tuple_return<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __make_tuple_return<_Tp>::type...>(std::__1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__ ((__always_inline__)) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::__1::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::__1::get<_Ip-1>(__x) == std::__1::get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        if (std::__1::get<__idx>(__x) < std::__1::get<__idx>(__y))
            return true;
        if (std::__1::get<__idx>(__y) < std::__1::get<__idx>(__x))
            return false;
        return __tuple_less<_Ip-1>()(__x, __y);
    }
};

template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return false;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __y < __x;
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x < __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__y < __x);
}



template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type
                                                                           type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef tuple<> type;
};

inline __attribute__ ((__always_inline__)) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__always_inline__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        return forward_as_tuple(std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                                      std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__always_inline__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        typedef typename remove_reference<_Tuple0>::type _T0;
        typedef typename remove_reference<_Tuple1>::type _T1;
        return __tuple_cat<
           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,
           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,
           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()
                           (forward_as_tuple(
                              std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                              std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...
                            ),
                            std::__1::forward<_Tuple1>(__t1),
                            std::__1::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__ ((__always_inline__)) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::__1::forward<_Tuple0>(__t0),
                                            std::__1::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__ ((__always_inline__))
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::__1::forward<_Args1>(std::__1::get<_I1>( __first_args))...),
      second(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...)
{
}
# 1415 "../../buildtools/third_party/libc++/trunk/include/tuple" 3
} }
# 654 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/stdexcept" 1 3
# 54 "../../buildtools/third_party/libc++/trunk/include/stdexcept" 3


namespace std {inline namespace __1 {

class __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();

    const char* c_str() const noexcept {return __imp_;}
};

} }

namespace std
{

class logic_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;

    virtual ~logic_error() noexcept;

    virtual const char* what() const noexcept;
};

class runtime_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;

    virtual ~runtime_error() noexcept;

    virtual const char* what() const noexcept;
};

class domain_error
    : public logic_error
{
public:
    __attribute__ ((__always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}

    virtual ~domain_error() noexcept;
};

class invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}

    virtual ~invalid_argument() noexcept;
};

class length_error
    : public logic_error
{
public:
    __attribute__ ((__always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() noexcept;
};

class out_of_range
    : public logic_error
{
public:
    __attribute__ ((__always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}

    virtual ~out_of_range() noexcept;
};

class range_error
    : public runtime_error
{
public:
    __attribute__ ((__always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}

    virtual ~range_error() noexcept;
};

class overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~overflow_error() noexcept;
};

class underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~underflow_error() noexcept;
};

}

namespace std {inline namespace __1 {


[[noreturn]] void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_logic_error(const char*__msg)
{



    ((void)__msg);
   std::__1::abort();

}

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_domain_error(const char*__msg)
{



    ((void)__msg);
   std::__1::abort();

}

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_invalid_argument(const char*__msg)
{



    ((void)__msg);
   std::__1::abort();

}

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_length_error(const char*__msg)
{



    ((void)__msg);
   std::__1::abort();

}

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_out_of_range(const char*__msg)
{



    ((void)__msg);
   std::__1::abort();

}

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_range_error(const char*__msg)
{



    ((void)__msg);
   std::__1::abort();

}

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_overflow_error(const char*__msg)
{



    ((void)__msg);
    std::__1::abort();

}

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_underflow_error(const char*__msg)
{



    ((void)__msg);
    std::__1::abort();

}

} }
# 655 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3

# 1 "../../buildtools/third_party/libc++/trunk/include/cassert" 1 3
# 21 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/assert.h" 1 3 4
# 22 "../../buildtools/third_party/libc++/trunk/include/cassert" 2 3
# 25 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 657 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3

# 1 "../../buildtools/third_party/libc++/trunk/include/atomic" 1 3
# 550 "../../buildtools/third_party/libc++/trunk/include/atomic" 3
# 579 "../../buildtools/third_party/libc++/trunk/include/atomic" 3
namespace std {inline namespace __1 {

typedef enum memory_order
{
    memory_order_relaxed, memory_order_consume, memory_order_acquire,
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
} memory_order;
# 856 "../../buildtools/third_party/libc++/trunk/include/atomic" 3
template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
kill_dependency(_Tp __y) noexcept
{
    return __y;
}
# 890 "../../buildtools/third_party/libc++/trunk/include/atomic" 3
template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable _Atomic(_Tp) __a_;





    __attribute__ ((__always_inline__))
    bool is_lock_free() const volatile noexcept
    {

    return __c11_atomic_is_lock_free(sizeof(_Tp));



    }
    __attribute__ ((__always_inline__))
    bool is_lock_free() const noexcept
        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
    __attribute__ ((__always_inline__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__c11_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__always_inline__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__c11_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__always_inline__))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_load(&__a_, __m);}
    __attribute__ ((__always_inline__))
    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_load(&__a_, __m);}
    __attribute__ ((__always_inline__))
    operator _Tp() const volatile noexcept {return load();}
    __attribute__ ((__always_inline__))
    operator _Tp() const noexcept {return load();}
    __attribute__ ((__always_inline__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__always_inline__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}

    __attribute__ ((__always_inline__))

    __atomic_base() noexcept = default;




    __attribute__ ((__always_inline__))
    constexpr __atomic_base(_Tp __d) noexcept : __a_(__d) {}

    __atomic_base(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) volatile = delete;






};
# 1002 "../../buildtools/third_party/libc++/trunk/include/atomic" 3
template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;
    __attribute__ ((__always_inline__))
    __atomic_base() noexcept = default;
    __attribute__ ((__always_inline__))
    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__always_inline__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}

    __attribute__ ((__always_inline__))
    _Tp operator++(int) volatile noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__always_inline__))
    _Tp operator++(int) noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__always_inline__))
    _Tp operator--(int) volatile noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__always_inline__))
    _Tp operator--(int) noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__always_inline__))
    _Tp operator++() volatile noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__always_inline__))
    _Tp operator++() noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__always_inline__))
    _Tp operator--() volatile noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__always_inline__))
    _Tp operator--() noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__always_inline__))
    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__always_inline__))
    _Tp operator+=(_Tp __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__always_inline__))
    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__always_inline__))
    _Tp operator-=(_Tp __op) noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__always_inline__))
    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__always_inline__))
    _Tp operator&=(_Tp __op) noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__always_inline__))
    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__always_inline__))
    _Tp operator|=(_Tp __op) noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__always_inline__))
    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
    __attribute__ ((__always_inline__))
    _Tp operator^=(_Tp __op) noexcept {return fetch_xor(__op) ^ __op;}
};



template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    __attribute__ ((__always_inline__))
    atomic() noexcept = default;
    __attribute__ ((__always_inline__))
    constexpr atomic(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__always_inline__))
    _Tp operator=(_Tp __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__always_inline__))
    _Tp operator=(_Tp __d) noexcept
        {__base::store(__d); return __d;}
};



template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    __attribute__ ((__always_inline__))
    atomic() noexcept = default;
    __attribute__ ((__always_inline__))
    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}

    __attribute__ ((__always_inline__))
    _Tp* operator=(_Tp* __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__always_inline__))
    _Tp* operator=(_Tp* __d) noexcept
        {__base::store(__d); return __d;}

    __attribute__ ((__always_inline__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__always_inline__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}

    __attribute__ ((__always_inline__))
    _Tp* operator++(int) volatile noexcept {return fetch_add(1);}
    __attribute__ ((__always_inline__))
    _Tp* operator++(int) noexcept {return fetch_add(1);}
    __attribute__ ((__always_inline__))
    _Tp* operator--(int) volatile noexcept {return fetch_sub(1);}
    __attribute__ ((__always_inline__))
    _Tp* operator--(int) noexcept {return fetch_sub(1);}
    __attribute__ ((__always_inline__))
    _Tp* operator++() volatile noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__always_inline__))
    _Tp* operator++() noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__always_inline__))
    _Tp* operator--() volatile noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__always_inline__))
    _Tp* operator--() noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__always_inline__))
    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__always_inline__))
    _Tp* operator+=(ptrdiff_t __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__always_inline__))
    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__always_inline__))
    _Tp* operator-=(ptrdiff_t __op) noexcept {return fetch_sub(__op) - __op;}
};



template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
void
atomic_init(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    __c11_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
void
atomic_init(atomic<_Tp>* __o, _Tp __d) noexcept
{
    __c11_atomic_init(&__o->__a_, __d);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
void
atomic_store(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    __o->store(__d);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
void
atomic_store(atomic<_Tp>* __o, _Tp __d) noexcept
{
    __o->store(__d);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
void
atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->load();
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_load(const atomic<_Tp>* __o) noexcept
{
    return __o->load();
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    return __o->exchange(__d);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_exchange(atomic<_Tp>* __o, _Tp __d) noexcept
{
    return __o->exchange(__d);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
                                      _Tp __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        _Tp* __e, _Tp __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
                                        _Tp __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_add(__op);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_sub(__op);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_and(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_and(__op);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_or(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_or(__op);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_xor(__op);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_xor(__op);
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}



typedef struct atomic_flag
{
    _Atomic(bool) __a_;

    __attribute__ ((__always_inline__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_exchange(&__a_, true, __m);}
    __attribute__ ((__always_inline__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_exchange(&__a_, true, __m);}
    __attribute__ ((__always_inline__))
    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
        {__c11_atomic_store(&__a_, false, __m);}
    __attribute__ ((__always_inline__))
    void clear(memory_order __m = memory_order_seq_cst) noexcept
        {__c11_atomic_store(&__a_, false, __m);}

    __attribute__ ((__always_inline__))

    atomic_flag() noexcept = default;




    __attribute__ ((__always_inline__))
    atomic_flag(bool __b) noexcept : __a_(__b) {}


    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;






} atomic_flag;

inline __attribute__ ((__always_inline__))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__always_inline__))
bool
atomic_flag_test_and_set(atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__always_inline__))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__always_inline__))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__always_inline__))
void
atomic_flag_clear(volatile atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__always_inline__))
void
atomic_flag_clear(atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__always_inline__))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}

inline __attribute__ ((__always_inline__))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}



inline __attribute__ ((__always_inline__))
void
atomic_thread_fence(memory_order __m) noexcept
{
    __c11_atomic_thread_fence(__m);
}

inline __attribute__ ((__always_inline__))
void
atomic_signal_fence(memory_order __m) noexcept
{
    __c11_atomic_signal_fence(__m);
}



typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;

typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic< int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic< int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic< int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic< int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;




} }
# 659 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3
# 663 "../../buildtools/third_party/libc++/trunk/include/memory" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 667 "../../buildtools/third_party/libc++/trunk/include/memory" 2 3


namespace std {inline namespace __1 {

template <class _ValueType>
inline __attribute__ ((__always_inline__))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__ ((__always_inline__))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 2);



}



template <class _Tp> class allocator;

template <>
class allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};



template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp,
              typename __void_t<typename _Tp::element_type>::type> : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};



template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef _Tp type;
};
# 807 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp,
            typename __void_t<typename _Tp::difference_type>::type> : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{

    typedef typename _Tp::template rebind<_Up> type;



};



template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{

    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};
# 937 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template <class _Ptr>
struct pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;





private:
    struct __nat {};
public:
    __attribute__ ((__always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;


    template <class _Up> using rebind = _Up*;




private:
    struct __nat {};
public:
    __attribute__ ((__always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) noexcept
        {return std::__1::addressof(__r);}
};

template <class _From, class _To>
struct __rebind_pointer {

    typedef typename pointer_traits<_From>::template rebind<_To> type;



};



template <class _Tp, class = void>
struct __has_pointer_type : false_type {};

template <class _Tp>
struct __has_pointer_type<_Tp,
          typename __void_t<typename _Tp::pointer>::type> : true_type {};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};

}

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp, class = void>
struct __has_const_pointer : false_type {};

template <class _Tp>
struct __has_const_pointer<_Tp,
            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{

    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;



};

template <class _Tp, class = void>
struct __has_void_pointer : false_type {};

template <class _Tp>
struct __has_void_pointer<_Tp,
               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{

    typedef typename pointer_traits<_Ptr>::template rebind<void> type;



};

template <class _Tp, class = void>
struct __has_const_void_pointer : false_type {};

template <class _Tp>
struct __has_const_void_pointer<_Tp,
            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{

    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;



};

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
__to_raw_pointer(_Tp* __p) noexcept
{
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__always_inline__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) noexcept
{
    return std::__1::__to_raw_pointer(__p.operator->());
}

template <class _Tp, class = void>
struct __has_size_type : false_type {};

template <class _Tp>
struct __has_size_type<_Tp,
               typename __void_t<typename _Tp::size_type>::type> : true_type {};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_copy_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment<_Tp,
    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>
        : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_move_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_move_assignment<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>
               : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_swap : false_type {};

template <class _Tp>
struct __has_propagate_on_container_swap<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_swap>::type>
               : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class = void>
struct __has_is_always_equal : false_type {};

template <class _Tp>
struct __has_is_always_equal<_Tp,
           typename __void_t<typename _Tp::is_always_equal>::type>
               : true_type {};

template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal
{
    typedef typename std::__1::is_empty<_Alloc>::type type;
};

template <class _Alloc>
struct __is_always_equal<_Alloc, true>
{
    typedef typename _Alloc::is_always_equal type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};



template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>
{
    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
};

template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>
{
    typedef _Alloc<_Up, _Args...> type;
};
# 1302 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> decltype((void)__a.allocate(__sz, __p), true_type());

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> false_type;

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_allocate_hint_test(declval<_Alloc>(),
                                          declval<_SizeType>(),
                                          declval<_ConstVoidPtr>())),
            true_type>::value>
{
};
# 1335 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template <class _Alloc, class _Tp, class ..._Args>
decltype(std::__1::declval<_Alloc>().construct(std::__1::declval<_Tp*>(),
                                           std::__1::declval<_Args>()...),
                                           true_type())
__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
false_type
__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
struct __has_construct
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_construct_test(declval<_Alloc>(),
                                          declval<_Pointer>(),
                                          declval<_Args>()...)),
            true_type>::value>
{
};

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(_Alloc&& __a, _Pointer&& __p)
    -> decltype(__a.destroy(__p), true_type());

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(const _Alloc& __a, _Pointer&& __p)
    -> false_type;

template <class _Alloc, class _Pointer>
struct __has_destroy
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_destroy_test(declval<_Alloc>(),
                                        declval<_Pointer>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_max_size_test(_Alloc&& __a)
    -> decltype(__a.max_size(), true_type());

template <class _Alloc>
auto
__has_max_size_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_max_size
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_max_size_test(declval<_Alloc&>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(_Alloc&& __a)
    -> decltype(__a.select_on_container_copy_construction(), true_type());

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : integral_constant<bool,
        is_same<
            decltype(std::__1::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),
            true_type>::value>
{
};
# 1454 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};

template <class _Alloc>
struct allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;
    typedef typename __is_always_equal<allocator_type>::type
                     is_always_equal;


    template <class _Tp> using rebind_alloc =
                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;
    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;







    __attribute__ ((__always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
    __attribute__ ((__always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return __allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept
        {__a.deallocate(__p, __n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),
                         __a, __p, std::__1::forward<_Args>(__args)...);}
# 1547 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    template <class _Tp>
        __attribute__ ((__always_inline__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__always_inline__))
    static size_type max_size(const allocator_type& __a) noexcept
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__always_inline__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return __select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__always_inline__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), std::__1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            if (_Np > 0)
            {
                std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
                __begin2 += _Np;
            }
        }

    template <class _Iter, class _Ptr>
        __attribute__ ((__always_inline__))
        static
        void
        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), *__begin1);
        }

    template <class _Tp>
        __attribute__ ((__always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            typedef typename remove_const<_Tp>::type _Vp;
            ptrdiff_t _Np = __end1 - __begin1;
            if (_Np > 0)
            {
                std::__1::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
                __begin2 += _Np;
            }
        }

    template <class _Ptr>
        __attribute__ ((__always_inline__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__1::__to_raw_pointer(__end2-1), std::__1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            if (_Np > 0)
                std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__always_inline__))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__always_inline__))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__always_inline__))
        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__a.construct(__p, std::__1::forward<_Args>(__args)...);}
    template <class _Tp, class... _Args>
        __attribute__ ((__always_inline__))
        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)
            {
                ::new ((void*)__p) _Tp(std::__1::forward<_Args>(__args)...);
            }


    template <class _Tp>
        __attribute__ ((__always_inline__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__always_inline__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__always_inline__))
    static size_type __max_size(true_type, const allocator_type& __a)
            {return __a.max_size();}
    __attribute__ ((__always_inline__))
    static size_type __max_size(false_type, const allocator_type&)
            {return numeric_limits<size_type>::max() / sizeof(value_type);}

    __attribute__ ((__always_inline__))
    static allocator_type
        __select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__always_inline__))
    static allocator_type
        __select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};

template <class _Traits, class _Tp>
struct __rebind_alloc_helper
{

    typedef typename _Traits::template rebind_alloc<_Tp> type;



};



template <class _Tp>
class allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__always_inline__)) allocator() noexcept {}
    template <class _Up> __attribute__ ((__always_inline__)) allocator(const allocator<_Up>&) noexcept {}
    __attribute__ ((__always_inline__)) pointer address(reference __x) const noexcept
        {return std::__1::addressof(__x);}
    __attribute__ ((__always_inline__)) const_pointer address(const_reference __x) const noexcept
        {return std::__1::addressof(__x);}
    __attribute__ ((__always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {
        if (__n > max_size())
            __throw_length_error("allocator<T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
        }
    __attribute__ ((__always_inline__)) void deallocate(pointer __p, size_type) noexcept
        {std::__1::__libcpp_deallocate((void*)__p);}
    __attribute__ ((__always_inline__)) size_type max_size() const noexcept
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__always_inline__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
        }
# 1814 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    __attribute__ ((__always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__always_inline__)) allocator() noexcept {}
    template <class _Up> __attribute__ ((__always_inline__)) allocator(const allocator<_Up>&) noexcept {}
    __attribute__ ((__always_inline__)) const_pointer address(const_reference __x) const noexcept
        {return std::__1::addressof(__x);}
    __attribute__ ((__always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
    {
        if (__n > max_size())
            __throw_length_error("allocator<const T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
    }
    __attribute__ ((__always_inline__)) void deallocate(pointer __p, size_type) noexcept
        {std::__1::__libcpp_deallocate((void*) const_cast<_Tp *>(__p));}
    __attribute__ ((__always_inline__)) size_type max_size() const noexcept
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__always_inline__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
        }
# 1910 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    __attribute__ ((__always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}

template <class _OutputIterator, class _Tp>
class raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(&*__x_) _Tp(__element); return *this;}

    __attribute__ ((__always_inline__)) raw_storage_iterator& operator=(_Tp&& __element)
        {::new(&*__x_) _Tp(std::__1::move(__element)); return *this;}

    __attribute__ ((__always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}

    __attribute__ ((__always_inline__)) _OutputIterator base() const { return __x_; }

};

template <class _Tp>
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
void return_temporary_buffer(_Tp* __p) noexcept {::operator delete(__p);}


template <class _Tp>
struct auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__always_inline__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    __attribute__ ((__always_inline__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__always_inline__)) auto_ptr(auto_ptr<_Up>& __p) throw()
        : __ptr_(__p.release()) {}
    __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr& __p) throw()
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        {reset(__p.release()); return *this;}
    __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__always_inline__)) ~auto_ptr() throw() {delete __ptr_;}

    __attribute__ ((__always_inline__)) _Tp& operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__always_inline__)) _Tp* operator->() const throw() {return __ptr_;}
    __attribute__ ((__always_inline__)) _Tp* get() const throw() {return __ptr_;}
    __attribute__ ((__always_inline__)) _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    __attribute__ ((__always_inline__)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__always_inline__)) operator auto_ptr_ref<_Up>() throw()
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__always_inline__)) operator auto_ptr<_Up>() throw()
        {return auto_ptr<_Up>(release());}
};

template <>
class auto_ptr<void>
{
public:
    typedef void element_type;
};


template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;


  constexpr __compressed_pair_elem() : __value_() {}

  template <class _Up, class = typename enable_if<
      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_(std::__1::forward<_Up>(__u)){};

  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__always_inline__))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}





  reference __get() noexcept { return __value_; }
  const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp __value_type;


  constexpr __compressed_pair_elem() = default;

  template <class _Up, class = typename enable_if<
        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_type(std::__1::forward<_Up>(__u)){};

  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__always_inline__))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_type(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}






  reference __get() noexcept { return *this; }
  const_reference __get() const noexcept { return *this; }
};


struct __second_tag {};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
  typedef __compressed_pair_elem<_T1, 0> _Base1;
  typedef __compressed_pair_elem<_T2, 1> _Base2;





  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous "
    "implementation for this configuration");

public:

  template <bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
      >::type
  >
  __attribute__ ((__always_inline__))
  constexpr __compressed_pair() {}

  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,
                                                   __compressed_pair>::value,
                                          bool>::type = true>
  __attribute__ ((__always_inline__)) constexpr explicit
  __compressed_pair(_Tp&& __t)
      : _Base1(std::forward<_Tp>(__t)), _Base2() {}

  template <class _Tp>
  __attribute__ ((__always_inline__)) constexpr
  __compressed_pair(__second_tag, _Tp&& __t)
      : _Base1(), _Base2(std::forward<_Tp>(__t)) {}

  template <class _U1, class _U2>
  __attribute__ ((__always_inline__)) constexpr
  __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}

  template <class... _Args1, class... _Args2>
  __attribute__ ((__always_inline__))
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args)
      : _Base1(__pc, std::__1::move(__first_args),
               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::__1::move(__second_args),
               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}
# 2172 "../../buildtools/third_party/libc++/trunk/include/memory" 3
  __attribute__ ((__always_inline__))
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__ ((__always_inline__))
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__ ((__always_inline__))
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__ ((__always_inline__))
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__ ((__always_inline__))
  void swap(__compressed_pair& __x)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)

  {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__ ((__always_inline__))
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}



template <class _Tp>
struct default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");

  __attribute__ ((__always_inline__)) constexpr default_delete() noexcept = default;



  template <class _Up>
  __attribute__ ((__always_inline__))
  default_delete(const default_delete<_Up>&,
                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
                     0) noexcept {}

  __attribute__ ((__always_inline__)) void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};

public:

  __attribute__ ((__always_inline__)) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__ ((__always_inline__))
  default_delete(const default_delete<_Up[]>&,
                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__ ((__always_inline__))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};




template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};


template <class _Tp, class _Dp = default_delete<_Tp> >
class unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat { int __for_bool_; };


  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__always_inline__))
  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__always_inline__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__always_inline__))
  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__ ((__always_inline__))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__ ((__always_inline__))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>
  __attribute__ ((__always_inline__))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {}


  template <class _Up>
  __attribute__ ((__always_inline__))
  unique_ptr(auto_ptr<_Up>&& __p,
             typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                                    is_same<_Dp, default_delete<_Tp>>::value,
                                __nat>::type = __nat()) noexcept
      : __ptr_(__p.release()) {}


  __attribute__ ((__always_inline__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__always_inline__))
  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 2488 "../../buildtools/third_party/libc++/trunk/include/memory" 3
  template <class _Up>
  __attribute__ ((__always_inline__))
      typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                             is_same<_Dp, default_delete<_Tp> >::value,
                         unique_ptr&>::type
      operator=(auto_ptr<_Up> __p) {
    reset(__p.release());
    return *this;
  }


  __attribute__ ((__always_inline__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__always_inline__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__always_inline__))
  typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__ ((__always_inline__))
  pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__always_inline__))
  pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__always_inline__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__always_inline__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__always_inline__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__ ((__always_inline__))
  void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__always_inline__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};


template <class _Tp, class _Dp>
class unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};


  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;

  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__always_inline__))
  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__always_inline__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__always_inline__))
  explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__always_inline__))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__ ((__always_inline__))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__always_inline__))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__ ((__always_inline__))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__always_inline__))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  __attribute__ ((__always_inline__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__always_inline__))
  unique_ptr&
  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 2779 "../../buildtools/third_party/libc++/trunk/include/memory" 3
public:
  __attribute__ ((__always_inline__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__always_inline__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__always_inline__))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__ ((__always_inline__))
  pointer get() const noexcept {
    return __ptr_.first();
  }

  __attribute__ ((__always_inline__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__ ((__always_inline__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__always_inline__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__ ((__always_inline__))
  typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type
  reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__always_inline__))
  void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__always_inline__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }

};

template <class _Tp, class _Dp>
inline __attribute__ ((__always_inline__))
typename enable_if<
    __is_swappable<_Dp>::value,
    void
>::type
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(nullptr < __x);
}
# 3003 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};

template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};

template<class _Tp, class... _Args>
inline __attribute__ ((__always_inline__))
typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args)
{
    return unique_ptr<_Tp>(new _Tp(std::__1::forward<_Args>(__args)...));
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n)
{
    typedef typename remove_extent<_Tp>::type _Up;
    return unique_ptr<_Tp>(new _Up[__n]());
}

template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;



template <class _Tp, class _Dp>



struct hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>

{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__always_inline__))
    result_type operator()(const argument_type& __ptr) const
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t __size_;

    template <class _Tp>
    __attribute__ ((__always_inline__)) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__always_inline__)) void __process(_Tp*, true_type) noexcept
        {}

    __attribute__ ((__always_inline__)) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__ ((__always_inline__)) void __incr(true_type) noexcept
        {}

    __attribute__ ((__always_inline__)) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__ ((__always_inline__)) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__ ((__always_inline__)) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}

    template <class _Tp>
    __attribute__ ((__always_inline__)) void __incr(_Tp*) noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__always_inline__)) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__always_inline__)) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f, (void) ++__r)
            ::new (static_cast<void*>(std::__1::addressof(*__r))) value_type(*__f);
# 3141 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)
            ::new (static_cast<void*>(std::__1::addressof(*__r))) value_type(*__f);
# 3165 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f)
            ::new (static_cast<void*>(std::__1::addressof(*__f))) value_type(__x);
# 3189 "../../buildtools/third_party/libc++/trunk/include/memory" 3
}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, (void) --__n)
            ::new (static_cast<void*>(std::__1::addressof(*__f))) value_type(__x);
# 3212 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    return __f;
}
# 3368 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template <class _Tp>
inline __attribute__ ((__always_inline__)) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, 1, 0);



}

template <class _Tp>
inline __attribute__ ((__always_inline__)) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, -1, 4);



}

class bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() noexcept;
    virtual const char* what() const noexcept;
};

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_bad_weak_ptr()
{



    std::__1::abort();

}

template<class _Tp> class weak_ptr;

class __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;

public:
    __attribute__ ((__always_inline__))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}






    __attribute__ ((__always_inline__))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__ ((__always_inline__))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    __attribute__ ((__always_inline__))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};

class __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__always_inline__))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:






    __attribute__ ((__always_inline__))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__ ((__always_inline__))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__ ((__always_inline__))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() noexcept;
    __attribute__ ((__always_inline__))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;






    virtual const void* __get_deleter(const type_info&) const noexcept;

private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}





private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
};
# 3530 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;

    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:


    __attribute__ ((__always_inline__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(std::__1::move(__a)) {}

    template <class ..._Args>
        __attribute__ ((__always_inline__))
        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
            : __data_(piecewise_construct, std::__1::forward_as_tuple(__a),
                   std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)) {}
# 3592 "../../buildtools/third_party/libc++/trunk/include/memory" 3
private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
public:
    __attribute__ ((__always_inline__))
    _Tp* get() noexcept {return &__data_.second();}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};

template<class _Tp> class enable_shared_from_this;

template<class _Tp>
class shared_ptr
{
public:
    typedef _Tp element_type;




private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    __attribute__ ((__always_inline__))
    constexpr shared_ptr() noexcept;
    __attribute__ ((__always_inline__))
    constexpr shared_ptr(nullptr_t) noexcept;
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> __attribute__ ((__always_inline__)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
    __attribute__ ((__always_inline__))
    shared_ptr(const shared_ptr& __r) noexcept;
    template<class _Yp>
        __attribute__ ((__always_inline__))
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;

    __attribute__ ((__always_inline__))
    shared_ptr(shared_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__always_inline__)) shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;

    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());


    template<class _Yp>
        shared_ptr(auto_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());







    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
# 3731 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    ~shared_ptr();

    __attribute__ ((__always_inline__))
    shared_ptr& operator=(const shared_ptr& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__always_inline__))
        operator=(const shared_ptr<_Yp>& __r) noexcept;

    __attribute__ ((__always_inline__))
    shared_ptr& operator=(shared_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr<_Tp>&
        >::type
        __attribute__ ((__always_inline__))
        operator=(shared_ptr<_Yp>&& __r);

    template<class _Yp>
        __attribute__ ((__always_inline__))
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr
        >::type&
        operator=(auto_ptr<_Yp>&& __r);
# 3778 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type

        __attribute__ ((__always_inline__))
        operator=(unique_ptr<_Yp, _Dp>&& __r);





    __attribute__ ((__always_inline__))
    void swap(shared_ptr& __r) noexcept;
    __attribute__ ((__always_inline__))
    void reset() noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__always_inline__))
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__always_inline__))
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__always_inline__))
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__always_inline__))
    element_type* get() const noexcept {return __ptr_;}
    __attribute__ ((__always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const noexcept
        {return *__ptr_;}
    __attribute__ ((__always_inline__))
    element_type* operator->() const noexcept {return __ptr_;}
    __attribute__ ((__always_inline__))
    long use_count() const noexcept {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__always_inline__))
    bool unique() const noexcept {return use_count() == 1;}
    __attribute__ ((__always_inline__))
    explicit operator bool() const noexcept {return get() != 0;}
    template <class _Up>
        __attribute__ ((__always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}
# 3859 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    template<class ..._Args>
        static
        shared_ptr<_Tp>
        make_shared(_Args&& ...__args);

    template<class _Alloc, class ..._Args>
        static
        shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _Args&& ...__args);
# 3900 "../../buildtools/third_party/libc++/trunk/include/memory" 3
private:
    template <class _Yp, bool = is_function<_Yp>::value>
        struct __shared_ptr_default_allocator
        {
            typedef allocator<_Yp> type;
        };

    template <class _Yp>
        struct __shared_ptr_default_allocator<_Yp, true>
        {
            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
        };

    template <class _Yp, class _OrigPtr>
        __attribute__ ((__always_inline__))
        typename enable_if<is_convertible<_OrigPtr*,
                                          const enable_shared_from_this<_Yp>*
        >::value,
            void>::type
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,
                           _OrigPtr* __ptr) noexcept
        {
            typedef typename remove_cv<_Yp>::type _RawYp;
            if (__e && __e->__weak_this_.expired())
            {
                __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
            }
        }

    __attribute__ ((__always_inline__)) void __enable_weak_this(...) noexcept {}

    template <class _Up> friend class shared_ptr;
    template <class _Up> friend class weak_ptr;
};


template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr() noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
        __enable_weak_this(__p, __p);
# 3991 "../../buildtools/third_party/libc++/trunk/include/memory" 3
}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{




        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
# 4013 "../../buildtools/third_party/libc++/trunk/include/memory" 3
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(static_cast<void*>(std::__1::addressof(*__hold2.get())))
            _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__1::addressof(*__hold2.release());
        __enable_weak_this(__p, __p);
# 4042 "../../buildtools/third_party/libc++/trunk/include/memory" 3
}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{




        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(static_cast<void*>(std::__1::addressof(*__hold2.get())))
            _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__1::addressof(*__hold2.release());
# 4069 "../../buildtools/third_party/libc++/trunk/include/memory" 3
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}



template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}




template<class _Tp>
template<class _Yp>

shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,



                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get(), __r.get());
    __r.release();
}


template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*,
                                     reference_wrapper<typename remove_reference<_Dp>::type>,
                                     _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}



template<class _Tp>
template<class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_Args&& ...__args)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a2, std::__1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(static_cast<void*>(std::__1::addressof(*__hold2.get())))
        _CntrlBlk(__a, std::__1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = std::__1::addressof(*__hold2.release());
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
}
# 4402 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(shared_ptr&& __r) noexcept
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}


template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>
>::type&
shared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}


template<class _Tp>
template <class _Yp, class _Dp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                   typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}
# 4527 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template<class _Tp>
inline
void
shared_ptr<_Tp>::swap(shared_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::reset() noexcept
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}



template<class _Tp, class ..._Args>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
make_shared(_Args&& ...__args)
{
    return shared_ptr<_Tp>::make_shared(std::__1::forward<_Args>(__args)...);
}

template<class _Tp, class _Alloc, class ..._Args>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    return shared_ptr<_Tp>::allocate_shared(__a, std::__1::forward<_Args>(__args)...);
}
# 4677 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    typedef typename common_type<_Tp*, _Up*>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return less<_Tp*>()(__x.get(), nullptr);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return less<_Tp*>()(nullptr, __x.get());
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return nullptr < __x;
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return __x < nullptr;
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}
# 4879 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template<class _Tp>
class weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__ ((__always_inline__))
    constexpr weak_ptr() noexcept;
    template<class _Yp> __attribute__ ((__always_inline__)) weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        noexcept;
    __attribute__ ((__always_inline__))
    weak_ptr(weak_ptr const& __r) noexcept;
    template<class _Yp> __attribute__ ((__always_inline__)) weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;


    __attribute__ ((__always_inline__))
    weak_ptr(weak_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__always_inline__)) weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;

    ~weak_ptr();

    __attribute__ ((__always_inline__))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__always_inline__))
        operator=(weak_ptr<_Yp> const& __r) noexcept;



    __attribute__ ((__always_inline__))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__always_inline__))
        operator=(weak_ptr<_Yp>&& __r) noexcept;



    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__always_inline__))
        operator=(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__always_inline__))
    void swap(weak_ptr& __r) noexcept;
    __attribute__ ((__always_inline__))
    void reset() noexcept;

    __attribute__ ((__always_inline__))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__always_inline__))
    bool expired() const noexcept
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__ ((__always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class weak_ptr;
    template <class _Up> friend class shared_ptr;
};

template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}



template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}



template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)
        __throw_bad_weak_ptr();
}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}




template <class _Tp> struct owner_less;


template <class _Tp>
struct owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};
# 5221 "../../buildtools/third_party/libc++/trunk/include/memory" 3
template<class _Tp>
class enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__always_inline__)) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__ ((__always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__ ((__always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__ ((__always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}
# 5253 "../../buildtools/third_party/libc++/trunk/include/memory" 3
    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;

    __attribute__ ((__always_inline__))
    result_type operator()(const argument_type& __ptr) const noexcept
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);




class __sp_mut
{
    void* __lx;
public:
    void lock() noexcept;
    void unlock() noexcept;

private:
    constexpr __sp_mut(void*) noexcept;
    __sp_mut(const __sp_mut&);
    __sp_mut& operator=(const __sp_mut&);

    friend __sp_mut& __get_sp_mut(const void*);
};


__sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__ ((__always_inline__))
bool
atomic_is_lock_free(const shared_ptr<_Tp>*)
{
    return false;
}

template <class _Tp>

shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp>* __p)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}

template <class _Tp>
inline __attribute__ ((__always_inline__))

shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
{
    return atomic_load(__p);
}

template <class _Tp>

void
atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}

template <class _Tp>
inline __attribute__ ((__always_inline__))

void
atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    atomic_store(__p, __r);
}

template <class _Tp>

shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}

template <class _Tp>
inline __attribute__ ((__always_inline__))

shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    return atomic_exchange(__p, __r);
}

template <class _Tp>

bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    shared_ptr<_Tp> __temp;
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        std::__1::swap(__temp, *__p);
        *__p = __w;
        __m.unlock();
        return true;
    }
    std::__1::swap(__temp, *__v);
    *__v = *__p;
    __m.unlock();
    return false;
}

template <class _Tp>
inline __attribute__ ((__always_inline__))

bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))

bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                        shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__always_inline__))

bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                      shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_weak(__p, __v, __w);
}
# 5427 "../../buildtools/third_party/libc++/trunk/include/memory" 3
struct pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__always_inline__))
    pointer_safety() : __v_() {}

    __attribute__ ((__always_inline__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__always_inline__))
    operator int() const {return __v_;}
};
# 5454 "../../buildtools/third_party/libc++/trunk/include/memory" 3
inline __attribute__ ((__always_inline__))
pointer_safety get_pointer_safety() noexcept {
  return pointer_safety::relaxed;
}




                 void declare_reachable(void* __p);
                 void declare_no_pointers(char* __p, size_t __n);
                 void undeclare_no_pointers(char* __p, size_t __n);
                 void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

                 void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);


template <typename _Alloc>
inline __attribute__ ((__always_inline__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2)

    noexcept



{
    __swap_allocator(__a1, __a2,
      integral_constant<bool, std::__1::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

template <typename _Alloc>
__attribute__ ((__always_inline__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)

    noexcept



{
    using std::__1::swap;
    swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__ ((__always_inline__))
void __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}

template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
struct __noexcept_move_assign_container : public integral_constant<bool,
    _Traits::propagate_on_container_move_assignment::value



        && is_nothrow_move_assignable<_Alloc>::value

    > {};



template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;

    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
    _Alloc &__a;

    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
    _Tp & get() { return *__addr(); }

    template<class... _Args>
    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)
    { _Traits::construct(__a, __addr(), std::__1::forward<_Args>(__args)...); }

    ~__temp_value() { _Traits::destroy(__a, __addr()); }
    };


} }
# 644 "../../buildtools/third_party/libc++/trunk/include/algorithm" 2 3
# 658 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 662 "../../buildtools/third_party/libc++/trunk/include/algorithm" 2 3


namespace std {inline namespace __1 {




template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __invert
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__always_inline__)) __invert() {}

    __attribute__ ((__always_inline__))
    explicit __invert(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}
};
# 790 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
inline __attribute__ ((__always_inline__))
unsigned __ctz(unsigned __x) {

    return static_cast<unsigned>(__builtin_ctz(__x));
# 804 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
}

inline __attribute__ ((__always_inline__))
unsigned long __ctz(unsigned long __x) {

    return static_cast<unsigned long>(__builtin_ctzl(__x));




}

inline __attribute__ ((__always_inline__))
unsigned long long __ctz(unsigned long long __x) {

    return static_cast<unsigned long long>(__builtin_ctzll(__x));
# 839 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
}


inline __attribute__ ((__always_inline__))
unsigned __clz(unsigned __x) {

    return static_cast<unsigned>(__builtin_clz(__x));
# 856 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
}

inline __attribute__ ((__always_inline__))
unsigned long __clz(unsigned long __x) {

    return static_cast<unsigned long>(__builtin_clzl (__x));




}

inline __attribute__ ((__always_inline__))
unsigned long long __clz(unsigned long long __x) {

    return static_cast<unsigned long long>(__builtin_clzll(__x));
# 889 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
}

inline __attribute__ ((__always_inline__)) int __pop_count(unsigned __x) {

  return __builtin_popcount (__x);




}

inline __attribute__ ((__always_inline__)) int __pop_count(unsigned long __x) {

  return __builtin_popcountl (__x);




}

inline __attribute__ ((__always_inline__)) int __pop_count(unsigned long long __x) {

  return __builtin_popcountll(__x);




}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Function>
inline __attribute__ ((__always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return __f;
}
# 991 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
template <class _InputIterator, class _Tp>
inline __attribute__ ((__always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}



template<class _InputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{

    _ForwardIterator1 __r = __last1;
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1)
                return __r;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (__first2 == __last2)
        return __last1;
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (__first1 == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }

        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
            if (__m1 == __first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
constexpr _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
inline __attribute__ ((__always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _BinaryPredicate __pred)
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}




template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__always_inline__))
bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,
        input_iterator_tag, input_iterator_tag )
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return __first1 == __last1 && __first2 == __last2;
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__ ((__always_inline__))
bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
      random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
        return false;
    return std::__1::equal<_RandomAccessIterator1, _RandomAccessIterator2,
                        typename add_lvalue_reference<_BinaryPredicate>::type>
                       (__first1, __last1, __first2, __pred );
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )
{
    return std::__1::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}




template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{

    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return true;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);


    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
bool
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                 _BinaryPredicate __pred,
                 forward_iterator_tag, forward_iterator_tag )
{

    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return __first1 == __last1 && __first2 == __last2;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);

    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;
    _D2 __l2 = std::__1::distance(__first2, __last2);
    if (__l1 != __l2)
        return false;



    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
bool
__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,
               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,
               _BinaryPredicate __pred,
               random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
        return false;
    return std::__1::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,
                                 typename add_lvalue_reference<_BinaryPredicate>::type>
                                (__first1, __last1, __first2, __pred );
}

template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2,
               _BinaryPredicate __pred )
{
    return std::__1::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__is_permutation(__first1, __last1, __first2, __last2,
        __equal_to<__v1, __v2>(),
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}




template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1>
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return make_pair(__first1, __first1);
    while (true)
    {

        while (true)
        {
            if (__first1 == __last1)
                return make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
                return make_pair(__first1, __m1);
            if (++__m1 == __last1)
                return make_pair(__last1, __last1);
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr
pair<_RandomAccessIterator1, _RandomAccessIterator1>
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;

    const _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return make_pair(__first1, __first1);
    const _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return make_pair(__last1, __last1);
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);

    while (true)
    {
        while (true)
        {
            if (__first1 == __s)
                return make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;
         while (true)
         {
             if (++__m2 == __last2)
                 return make_pair(__first1, __first1 + __len2);
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category())
            .first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (__first == __last)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
_RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1);
    while (true)
    {

        while (true)
        {
            if (__first >= __s)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, __convert_to_integral(__count), __value_, __pred,
           typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__ ((__always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::search_n(__first, __last, __convert_to_integral(__count),
                           __value_, __equal_to<__v, _Tp>());
}


template <class _Iter>
inline __attribute__ ((__always_inline__))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}
# 1806 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = *__first;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__copy_backward(__unwrap_iter(__first),
                                  __unwrap_iter(__last),
                                  __unwrap_iter(__result));
}



template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    __is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return std::__1::copy(__first, __first + __n, __result);
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __value_;
    return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
    !is_same<_Tp, bool>::value &&
    is_integral<_Up>::value && sizeof(_Up) == 1,
    _Tp*
>::type
__fill_n(_Tp* __first, _Size __n,_Up __value_)
{
    if (__n > 0)
        std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
    return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __gen();
    return __first;
}



template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__ ((__always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        std::__1::iter_swap(__first, __last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            std::__1::iter_swap(__first, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}



template <class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__always_inline__))
_Integral
__algo_gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__algo_gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__always_inline__))
_ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__always_inline__))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__always_inline__))
_ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__always_inline__)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
_Tp
min(initializer_list<_Tp> __t)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __less<_Tp>());
}





template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator>
inline __attribute__ ((__always_inline__)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
_Tp
max(initializer_list<_Tp> __t)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __less<_Tp>());
}
# 2765 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
template <class _ForwardIterator, class _Compare>
constexpr
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__ ((__always_inline__)) constexpr
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__always_inline__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp)
{
    typedef typename initializer_list<_Tp>::const_iterator _Iter;
    _Iter __first = __t.begin();
    _Iter __last = __t.end();
    std::pair<_Tp, _Tp> __result(*__first, *__first);

    ++__first;
    if (__t.size() % 2 == 0)
    {
        if (__comp(*__first, __result.first))
            __result.first = *__first;
        else
            __result.second = *__first;
        ++__first;
    }

    while (__first != __last)
    {
        _Tp __prev = *__first++;
        if (__comp(*__first, __prev)) {
            if ( __comp(*__first, __result.first)) __result.first = *__first;
            if (!__comp(__prev, __result.second)) __result.second = __prev;
            }
        else {
            if ( __comp(__prev, __result.first)) __result.first = __prev;
            if (!__comp(*__first, __result.second)) __result.second = *__first;
            }

        __first++;
    }
    return __result;
}

template<class _Tp>
inline __attribute__ ((__always_inline__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::__1::minmax(__t, __less<_Tp>());
}







template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UIntType) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;





    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    const size_t _WRt = numeric_limits<result_type>::digits;
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WRt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WRt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}



template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:

    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __clz(_Rp) - 1;
    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}



class __rs_default;

                 __rs_default __rs_get();

class __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&);
    ~__rs_default();

    result_type operator()();

    static constexpr result_type min() {return _Min;}
    static constexpr result_type max() {return _Max;}

    friend __rs_default __rs_get();
};

                 __rs_default __rs_get();

template <class _RandomAccessIterator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        __rs_default __g = __rs_get();
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

               _RandomNumberGenerator&& __rand)



{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        for (--__last; __first < __last; ++__first, --__d)
        {
            difference_type __i = __rand(__d);
            swap(*__first, *(__first + __i));
        }
    }
}


template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output,
                         _Distance __n,
                         _UniformRandomNumberGenerator & __g,
                         input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void)++__k)
    __output[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void)++__k) {
    _Distance __r = std::__1::uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output[__r] = *__first;
  }
  return __output + std::__1::min(__n, __k);
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         forward_iterator_tag) {
  _Distance __unsampled_sz = std::__1::distance(__first, __last);
  for (__n = std::__1::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r =
        std::__1::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output++ = *__first;
      --__n;
    }
  }
  return __output;
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output,
                         _Distance __n, _UniformRandomNumberGenerator& __g) {
  typedef typename iterator_traits<_PopulationIterator>::iterator_category
        _PopCategory;
  typedef typename iterator_traits<_PopulationIterator>::difference_type
        _Difference;
  static_assert(__is_forward_iterator<_PopulationIterator>::value ||
                __is_random_access_iterator<_SampleIterator>::value,
                "SampleIterator must meet the requirements of RandomAccessIterator");
  typedef typename common_type<_Distance, _Difference>::type _CommonType;
  ((void)0);
  return std::__1::__sample(
      __first, __last, __output, _CommonType(__n),
      __g, _PopCategory());
}
# 3281 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

                 _UniformRandomNumberGenerator&& __g)



{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _InputIterator, class _Predicate>
bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template<class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__always_inline__)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }

        *__first = std::__1::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BirdirectionalIterator>
void
__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    _BirdirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BirdirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BirdirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new(__last2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type*)0);
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new(__j2) value_type(std::__1::move(*__i2));
                __d.__incr((value_type*)0);
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__1::move(*__first1));
                __d.__incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}


template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__1::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__ ((__always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}

extern template void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2,
                          _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            std::__1::move(__first1, __last1, __result);
            return;
        }

        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }

}

template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        __half_inplace_merge(_Rv(__p), _Rv(__buff),
                             _RBi(__middle), _RBi(__first),
                             _RBi(__last), __invert<_Compare>(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;
        if (__len1 <= __buff_size || __len2 <= __buff_size)
            return __buffered_inplace_merge<_Compare>
                   (__first, __middle, __last, __comp, __len1, __len2, __buff);

        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
# 4607 "../../buildtools/third_party/libc++/trunk/include/algorithm" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__1::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);







    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new (__result) value_type(std::__1::move(*__first2));
            __d.__incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
       __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
         if (__comp(*--__last1, *__first1))
        {
            ::new(__first2) value_type(std::__1::move(*__last1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)0);
        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)0);
        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
          typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sift_down(_RandomAccessIterator __first, _RandomAccessIterator ,
            _Compare __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;


    difference_type __child = __start - __first;

    if (__len < 2 || (__len - 2) / 2 < __child)
        return;

    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

        ++__child_i;
        ++__child;
    }


    if (__comp(*__child_i, *__start))

        return;

    value_type __top(std::__1::move(*__start));
    do
    {

        *__start = std::__1::move(*__child_i);
        __start = __child_i;

        if ((__len - 2) / 2 < __child)
            break;


        __child = 2 * __child + 1;
        __child_i = __first + __child;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

            ++__child_i;
            ++__child;
        }


    } while (!__comp(*__child_i, __top));
    *__start = std::__1::move(__top);
}

template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {

        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
        {
            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
        __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    __make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
        }
    }
    __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)
            *__r = *__first;
        __make_heap<_Compare>(__result_first, __r, __comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
            }
        __sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            __selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }


                    if (__nth < __i)
                        return;


                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
            else
            {

                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
        }
not_sorted:

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            if (!__comp(*__first1, *__first2))
                ++__first2;
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }
# 57 "../../buildtools/third_party/libc++/trunk/include/__string" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cstdio" 1 3
# 100 "../../buildtools/third_party/libc++/trunk/include/cstdio" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 1 3
# 106 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 1 3 4
# 29 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern "C" {




# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 34 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 2 3 4
# 74 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 1 3 4
# 31 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/_G_config.h" 1 3 4
# 15 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/_G_config.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 16 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/_G_config.h" 2 3 4




# 1 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 1 3 4
# 15 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 1 3 4
# 18 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 2 3
# 21 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 2 3 4
# 144 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 173 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 241 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 289 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 333 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 429 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 459 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 521 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/libio.h" 3 4
}
# 75 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 114 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
typedef _G_fpos64_t fpos_t;



typedef _G_fpos64_t fpos64_t;
# 166 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 167 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 200 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") ;






extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 229 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;
# 239 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 254 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 264 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 285 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __asm__ ("" "fopen64")

       ;
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


       ;







extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();
# 358 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
# 427 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 473 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 533 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 552 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 563 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 575 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 596 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);
# 624 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 651 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 667 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
# 691 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 728 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 739 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
# 751 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 783 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64");


extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");
# 808 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64");

extern int fsetpos (FILE *__stream, const fpos_t *__pos) __asm__ ("" "fsetpos64");
# 820 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;
# 848 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern void perror (const char *__s);







# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 856 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 874 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 935 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 35 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
 feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
 ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 936 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/stdio.h" 2 3 4








}
# 109 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 2 3
# 101 "../../buildtools/third_party/libc++/trunk/include/cstdio" 2 3
# 104 "../../buildtools/third_party/libc++/trunk/include/cstdio" 3


namespace std {inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::fclose;
using ::fflush;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::vfprintf;
using ::vfscanf;
using ::vsscanf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::putc;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;


using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;



using ::getchar;



using ::scanf;
using ::vscanf;



using ::printf;
using ::putchar;
using ::puts;
using ::vprintf;


} }
# 58 "../../buildtools/third_party/libc++/trunk/include/__string" 2 3
# 64 "../../buildtools/third_party/libc++/trunk/include/__string" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 68 "../../buildtools/third_party/libc++/trunk/include/__string" 2 3


namespace std {inline namespace __1 {



template <class _CharT>
struct char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void
        assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__always_inline__)) static
    size_t length(const char_type* __s);
    __attribute__ ((__always_inline__)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

template <class _CharT>
                              int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline
                              size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline
                              const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

template <class _CharT>
_CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



template <>
struct char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
            {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static inline size_t
    length(const char_type* __s) noexcept {return __builtin_strlen(__s);}
    static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}
    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);
        }
    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type((unsigned char)__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

inline
int
char_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_memcmp(__s1, __s2, __n);
# 262 "../../buildtools/third_party/libc++/trunk/include/__string" 3
}

inline
const char*
char_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return __null;

    return __builtin_char_memchr(__s, to_int_type(__a), __n);
# 283 "../../buildtools/third_party/libc++/trunk/include/__string" 3
}




template <>
struct char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static
    size_t length(const char_type* __s) noexcept;
    static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}
    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);
        }
    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((0xffffffffu));}
};

inline
int
char_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_wmemcmp(__s1, __s2, __n);
# 352 "../../buildtools/third_party/libc++/trunk/include/__string" 3
}

inline
size_t
char_traits<wchar_t>::length(const char_type* __s) noexcept
{

    return __builtin_wcslen(__s);
# 368 "../../buildtools/third_party/libc++/trunk/include/__string" 3
}

inline
const wchar_t*
char_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return __null;

        return __builtin_wmemchr(__s, __a, __n);
# 389 "../../buildtools/third_party/libc++/trunk/include/__string" 3
}




template <>
struct char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__always_inline__)) static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__always_inline__)) static
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__always_inline__)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFF);}
};

inline
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline
size_t
char_traits<char16_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__always_inline__)) static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__always_inline__)) static
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__always_inline__)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFFFFFF);}
};

inline
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline
size_t
char_traits<char32_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}






template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) noexcept
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == 0)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
inline constexpr const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) {


  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;


  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;


    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == 0)
      return __last1;






    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos > __sz)
        return __npos;

    if (__n == 0)
        return __pos;

    const _CharT *__r = __search_substring<_CharT, _Traits>(
        __p + __pos, __p + __sz, __s, __s + __n);

    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}




template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) noexcept
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__1::__find_end(
                  __p, __p + __pos, __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == 0)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == 0)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
inline __attribute__ ((__always_inline__))
size_t __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}

template <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >
struct __quoted_output_proxy
{
    _Iter __first;
    _Iter __last;
    _CharT __delim;
    _CharT __escape;

    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}

};

} }
# 170 "../../buildtools/third_party/libc++/trunk/include/string_view" 2 3
# 178 "../../buildtools/third_party/libc++/trunk/include/string_view" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 182 "../../buildtools/third_party/libc++/trunk/include/string_view" 2 3


namespace std {inline namespace __1 {

template<class _CharT, class _Traits = char_traits<_CharT> >
class basic_string_view {
public:

 typedef _Traits traits_type;
 typedef _CharT value_type;
 typedef const _CharT* pointer;
 typedef const _CharT* const_pointer;
 typedef const _CharT& reference;
 typedef const _CharT& const_reference;
 typedef const_pointer const_iterator;
 typedef const_iterator iterator;
 typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
 typedef const_reverse_iterator reverse_iterator;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 static constexpr const size_type npos = -1;

    static_assert(is_pod<value_type>::value, "Character type of basic_string_view must be a POD");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");


 constexpr __attribute__ ((__always_inline__))
 basic_string_view() noexcept : __data (nullptr), __size(0) {}

 constexpr __attribute__ ((__always_inline__))
 basic_string_view(const basic_string_view&) noexcept = default;

 constexpr __attribute__ ((__always_inline__))
 basic_string_view& operator=(const basic_string_view&) noexcept = default;

 constexpr __attribute__ ((__always_inline__))
 basic_string_view(const _CharT* __s, size_type __len) noexcept
  : __data(__s), __size(__len)
 {



 }

 constexpr __attribute__ ((__always_inline__))
 basic_string_view(const _CharT* __s)
  : __data(__s), __size(_Traits::length(__s)) {}


 constexpr __attribute__ ((__always_inline__))
 const_iterator begin() const noexcept { return cbegin(); }

 constexpr __attribute__ ((__always_inline__))
 const_iterator end() const noexcept { return cend(); }

 constexpr __attribute__ ((__always_inline__))
 const_iterator cbegin() const noexcept { return __data; }

 constexpr __attribute__ ((__always_inline__))
 const_iterator cend() const noexcept { return __data + __size; }

                               __attribute__ ((__always_inline__))
 const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }

                               __attribute__ ((__always_inline__))
 const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }

                               __attribute__ ((__always_inline__))
 const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }

                               __attribute__ ((__always_inline__))
 const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }


 constexpr __attribute__ ((__always_inline__))
 size_type size() const noexcept { return __size; }

 constexpr __attribute__ ((__always_inline__))
 size_type length() const noexcept { return __size; }

 constexpr __attribute__ ((__always_inline__))
 size_type max_size() const noexcept { return numeric_limits<size_type>::max(); }

 constexpr bool __attribute__ ((__always_inline__))
 empty() const noexcept { return __size == 0; }


 constexpr __attribute__ ((__always_inline__))
 const_reference operator[](size_type __pos) const noexcept { return __data[__pos]; }

 constexpr __attribute__ ((__always_inline__))
 const_reference at(size_type __pos) const
 {
  return __pos >= size()
   ? (__throw_out_of_range("string_view::at"), __data[0])
   : __data[__pos];
 }

 constexpr __attribute__ ((__always_inline__))
 const_reference front() const
 {
  return ((void)0), __data[0];
 }

 constexpr __attribute__ ((__always_inline__))
 const_reference back() const
 {
  return ((void)0), __data[__size-1];
 }

 constexpr __attribute__ ((__always_inline__))
 const_pointer data() const noexcept { return __data; }


 constexpr __attribute__ ((__always_inline__))
 void remove_prefix(size_type __n) noexcept
 {
  ((void)0);
  __data += __n;
  __size -= __n;
 }

 constexpr __attribute__ ((__always_inline__))
 void remove_suffix(size_type __n) noexcept
 {
  ((void)0);
  __size -= __n;
 }

 constexpr __attribute__ ((__always_inline__))
 void swap(basic_string_view& __other) noexcept
 {
  const value_type *__p = __data;
  __data = __other.__data;
  __other.__data = __p;

  size_type __sz = __size;
  __size = __other.__size;
  __other.__size = __sz;
 }

 __attribute__ ((__always_inline__))
 size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
 {
  if (__pos > size())
   __throw_out_of_range("string_view::copy");
  size_type __rlen = std::__1::min(__n, size() - __pos);
  _Traits::copy(__s, data() + __pos, __rlen);
  return __rlen;
 }

 constexpr __attribute__ ((__always_inline__))
 basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
 {
  return __pos > size()
   ? (__throw_out_of_range("string_view::substr"), basic_string_view())
   : basic_string_view(data() + __pos, std::__1::min(__n, size() - __pos));
 }

 constexpr int compare(basic_string_view __sv) const noexcept
 {
  size_type __rlen = std::__1::min( size(), __sv.size());
  int __retval = _Traits::compare(data(), __sv.data(), __rlen);
  if ( __retval == 0 )
   __retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );
  return __retval;
 }

 constexpr __attribute__ ((__always_inline__))
 int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
 {
  return substr(__pos1, __n1).compare(__sv);
 }

 constexpr __attribute__ ((__always_inline__))
 int compare( size_type __pos1, size_type __n1,
    basic_string_view __sv, size_type __pos2, size_type __n2) const
 {
  return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
 }

 constexpr __attribute__ ((__always_inline__))
 int compare(const _CharT* __s) const noexcept
 {
  return compare(basic_string_view(__s));
 }

 constexpr __attribute__ ((__always_inline__))
 int compare(size_type __pos1, size_type __n1, const _CharT* __s) const
 {
  return substr(__pos1, __n1).compare(basic_string_view(__s));
 }

 constexpr __attribute__ ((__always_inline__))
 int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const
 {
  return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
 }


 constexpr __attribute__ ((__always_inline__))
 size_type find(basic_string_view __s, size_type __pos = 0) const noexcept
 {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find(_CharT __c, size_type __pos = 0) const noexcept
 {
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find(const _CharT* __s, size_type __pos = 0) const
 {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__always_inline__))
 size_type rfind(basic_string_view __s, size_type __pos = npos) const noexcept
 {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__always_inline__))
 size_type rfind(_CharT __c, size_type __pos = npos) const noexcept
 {
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type rfind(const _CharT* __s, size_type __pos=npos) const
 {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__always_inline__))
 size_type find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept
 {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept
 { return find(__c, __pos); }

 constexpr __attribute__ ((__always_inline__))
 size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_first_of(const _CharT* __s, size_type __pos=0) const
 {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__always_inline__))
 size_type find_last_of(basic_string_view __s, size_type __pos=npos) const noexcept
 {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept
 { return rfind(__c, __pos); }

 constexpr __attribute__ ((__always_inline__))
 size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_last_of(const _CharT* __s, size_type __pos=npos) const
 {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__always_inline__))
 size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const noexcept
 {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_first_not_of(_CharT __c, size_type __pos=0) const noexcept
 {
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const
 {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__always_inline__))
 size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const noexcept
 {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_last_not_of(_CharT __c, size_type __pos=npos) const noexcept
 {
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__always_inline__))
 size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const
 {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }

private:
 const value_type* __data;
 size_type __size;
};




template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size()) return false;
 return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size()) return false;
 return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size()) return false;
 return __lhs.compare(__rhs) == 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size())
  return true;
 return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size())
  return true;
 return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size())
  return true;
 return __lhs.compare(__rhs) != 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) < 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator>(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) > 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) <= 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) >= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__always_inline__))
bool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) >= 0;
}

typedef basic_string_view<char> string_view;
typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;


template<class _CharT, class _Traits>
struct hash<basic_string_view<_CharT, _Traits> >
    : public unary_function<basic_string_view<_CharT, _Traits>, size_t>
{
    size_t operator()(const basic_string_view<_CharT, _Traits> __val) const noexcept;
};

template<class _CharT, class _Traits>
size_t
hash<basic_string_view<_CharT, _Traits> >::operator()(
        const basic_string_view<_CharT, _Traits> __val) const noexcept
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}



inline namespace literals
{
  inline namespace string_view_literals
  {
    inline __attribute__ ((__always_inline__)) constexpr
    basic_string_view<char> operator "" sv(const char *__str, size_t __len) noexcept
    {
        return basic_string_view<char> (__str, __len);
    }

    inline __attribute__ ((__always_inline__)) constexpr
    basic_string_view<wchar_t> operator "" sv(const wchar_t *__str, size_t __len) noexcept
    {
        return basic_string_view<wchar_t> (__str, __len);
    }

    inline __attribute__ ((__always_inline__)) constexpr
    basic_string_view<char16_t> operator "" sv(const char16_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char16_t> (__str, __len);
    }

    inline __attribute__ ((__always_inline__)) constexpr
    basic_string_view<char32_t> operator "" sv(const char32_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char32_t> (__str, __len);
    }
  }
}

} }
# 471 "../../buildtools/third_party/libc++/trunk/include/string" 2 3



# 1 "../../buildtools/third_party/libc++/trunk/include/cwchar" 1 3
# 107 "../../buildtools/third_party/libc++/trunk/include/cwchar" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cwctype" 1 3
# 54 "../../buildtools/third_party/libc++/trunk/include/cwctype" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cctype" 1 3
# 39 "../../buildtools/third_party/libc++/trunk/include/cctype" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/ctype.h" 1 3
# 37 "../../buildtools/third_party/libc++/trunk/include/ctype.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
extern "C" {
# 46 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 110 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();
# 136 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 182 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int isalnum (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalnum; }
extern __inline __attribute__ ((__gnu_inline__)) int isalpha (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalpha; }
extern __inline __attribute__ ((__gnu_inline__)) int iscntrl (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _IScntrl; }
extern __inline __attribute__ ((__gnu_inline__)) int isdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISdigit; }
extern __inline __attribute__ ((__gnu_inline__)) int islower (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISlower; }
extern __inline __attribute__ ((__gnu_inline__)) int isgraph (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISgraph; }
extern __inline __attribute__ ((__gnu_inline__)) int isprint (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISprint; }
extern __inline __attribute__ ((__gnu_inline__)) int ispunct (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISpunct; }
extern __inline __attribute__ ((__gnu_inline__)) int isspace (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISspace; }
extern __inline __attribute__ ((__gnu_inline__)) int isupper (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISupper; }
extern __inline __attribute__ ((__gnu_inline__)) int isxdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISxdigit; }

extern __inline __attribute__ ((__gnu_inline__)) int isblank (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISblank; }
# 214 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
 tolower (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
 toupper (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 271 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 347 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/ctype.h" 3 4
}
# 40 "../../buildtools/third_party/libc++/trunk/include/ctype.h" 2 3
# 40 "../../buildtools/third_party/libc++/trunk/include/cctype" 2 3
# 43 "../../buildtools/third_party/libc++/trunk/include/cctype" 3


namespace std {inline namespace __1 {
# 104 "../../buildtools/third_party/libc++/trunk/include/cctype" 3
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;

} }
# 55 "../../buildtools/third_party/libc++/trunk/include/cwctype" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/wctype.h" 1 3
# 52 "../../buildtools/third_party/libc++/trunk/include/wctype.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 1 3 4
# 33 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 1 3 4
# 15 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wchar.h" 1 3 4
# 18 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 2 3
# 34 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 2 3 4
# 52 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
typedef unsigned long int wctype_t;
# 71 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {
# 111 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 171 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();
# 186 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 213 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();
# 230 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/wctype.h" 3 4
extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 55 "../../buildtools/third_party/libc++/trunk/include/wctype.h" 2 3
# 56 "../../buildtools/third_party/libc++/trunk/include/cwctype" 2 3
# 59 "../../buildtools/third_party/libc++/trunk/include/cwctype" 3


namespace std {inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::iswctype;
using ::wctype;
using ::towlower;
using ::towupper;
using ::towctrans;
using ::wctrans;

} }
# 108 "../../buildtools/third_party/libc++/trunk/include/cwchar" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 1 3
# 109 "../../buildtools/third_party/libc++/trunk/include/cwchar" 2 3
# 112 "../../buildtools/third_party/libc++/trunk/include/cwchar" 3


namespace std {inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::putwc;
using ::ungetwc;
using ::wcstod;
using ::wcstof;
using ::wcstold;
using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;
using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;


using ::getwchar;
using ::vwscanf;
using ::wscanf;



using ::putwchar;
using ::vwprintf;
using ::wprintf;


} }
# 475 "../../buildtools/third_party/libc++/trunk/include/string" 2 3
# 491 "../../buildtools/third_party/libc++/trunk/include/string" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 495 "../../buildtools/third_party/libc++/trunk/include/string" 2 3


namespace std {inline namespace __1 {



template <class _StateT>
class fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__always_inline__)) operator streamoff() const {return __off_;}

    __attribute__ ((__always_inline__)) _StateT state() const {return __st_;}
    __attribute__ ((__always_inline__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__always_inline__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__always_inline__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__always_inline__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__always_inline__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__always_inline__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

template <bool>
class __basic_string_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("basic_string");
}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("basic_string");
}

extern template class __basic_string_common<true>;


template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};
# 605 "../../buildtools/third_party/libc++/trunk/include/string" 3
template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public integral_constant<bool,(( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value && !is_convertible<const _Tp&, const _CharT*>::value))> {};
# 629 "../../buildtools/third_party/libc++/trunk/include/string" 3
template<class _CharT, class _Traits, class _Allocator>
class basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef basic_string_view<_CharT, _Traits> __self_view;
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");




    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;

    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
# 696 "../../buildtools/third_party/libc++/trunk/include/string" 3
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };





    static const size_type __short_mask = 0x01;
    static const size_type __long_mask = 0x1ul;


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };



    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    static const size_type npos = -1;

    __attribute__ ((__always_inline__)) basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__always_inline__)) explicit basic_string(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value);




    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);


    __attribute__ ((__always_inline__))
    basic_string(basic_string&& __str)

        noexcept(is_nothrow_move_constructible<allocator_type>::value);




    __attribute__ ((__always_inline__))
    basic_string(basic_string&& __str, const allocator_type& __a);

    __attribute__ ((__always_inline__)) basic_string(const _CharT* __s);
    __attribute__ ((__always_inline__))
    basic_string(const _CharT* __s, const _Allocator& __a);
    __attribute__ ((__always_inline__))
    basic_string(const _CharT* __s, size_type __n);
    __attribute__ ((__always_inline__))
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    __attribute__ ((__always_inline__))
    basic_string(size_type __n, _CharT __c);
    __attribute__ ((__always_inline__))
    basic_string(size_type __n, _CharT __c, const _Allocator& __a);
    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    __attribute__ ((__always_inline__))
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());
    template<class _Tp>

        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                     const allocator_type& __a = allocator_type(),
                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);
    __attribute__ ((__always_inline__)) explicit
    basic_string(__self_view __sv);
    __attribute__ ((__always_inline__))
    basic_string(__self_view __sv, const _Allocator& __a);
    template<class _InputIterator>
        __attribute__ ((__always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator>
        __attribute__ ((__always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    basic_string(initializer_list<_CharT> __il);
    __attribute__ ((__always_inline__))
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);


    inline ~basic_string();

    __attribute__ ((__always_inline__))
    operator __self_view() const noexcept { return __self_view(data(), size()); }

    basic_string& operator=(const basic_string& __str);


    template <class = void>

    __attribute__ ((__always_inline__))
    basic_string& operator=(__self_view __sv) {return assign(__sv);}

    __attribute__ ((__always_inline__))
    basic_string& operator=(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     __attribute__ ((__always_inline__))
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}

    __attribute__ ((__always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 849 "../../buildtools/third_party/libc++/trunk/include/string" 3
    __attribute__ ((__always_inline__))
    iterator begin() noexcept
        {return iterator(__get_pointer());}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept
        {return const_iterator(__get_pointer());}
    __attribute__ ((__always_inline__))
    iterator end() noexcept
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__always_inline__)) size_type size() const noexcept
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__always_inline__)) size_type length() const noexcept {return size();}
    __attribute__ ((__always_inline__)) size_type max_size() const noexcept;
    __attribute__ ((__always_inline__)) size_type capacity() const noexcept
        {return (__is_long() ? __get_long_cap()
                             : static_cast<size_type>(__min_cap)) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__always_inline__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type __res_arg = 0);
    __attribute__ ((__always_inline__))
    void shrink_to_fit() noexcept {reserve();}
    __attribute__ ((__always_inline__))
    void clear() noexcept;
    __attribute__ ((__always_inline__)) bool empty() const noexcept {return size() == 0;}

    __attribute__ ((__always_inline__)) const_reference operator[](size_type __pos) const noexcept;
    __attribute__ ((__always_inline__)) reference operator[](size_type __pos) noexcept;

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}
    __attribute__ ((__always_inline__)) basic_string& operator+=(__self_view __sv) {return append(__sv);}
    __attribute__ ((__always_inline__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__always_inline__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}

    __attribute__ ((__always_inline__)) basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}


    __attribute__ ((__always_inline__))
    basic_string& append(const basic_string& __str);
    __attribute__ ((__always_inline__))
    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>

    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);
    template <class _ForwardIterator>

    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);
    template<class _InputIterator>

    typename enable_if
        <
            __is_exactly_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >::type
    __attribute__ ((__always_inline__))
    append(_InputIterator __first, _InputIterator __last) {
      const basic_string __temp (__first, __last, __alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template<class _ForwardIterator>

    typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value
                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
    __attribute__ ((__always_inline__))
    append(_ForwardIterator __first, _ForwardIterator __last) {
      return __append_forward_unsafe(__first, __last);
    }


    __attribute__ ((__always_inline__))
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}


    void push_back(value_type __c);
    __attribute__ ((__always_inline__))
    void pop_back();
    __attribute__ ((__always_inline__)) reference front();
    __attribute__ ((__always_inline__)) const_reference front() const;
    __attribute__ ((__always_inline__)) reference back();
    __attribute__ ((__always_inline__)) const_reference back() const;

    __attribute__ ((__always_inline__))
    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }
    __attribute__ ((__always_inline__))
    basic_string& assign(const basic_string& __str) { return *this = __str; }

    __attribute__ ((__always_inline__))
    basic_string& assign(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::__1::move(__str); return *this;}

    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>

    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>

    typename enable_if
        <
           __is_exactly_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>

    typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__always_inline__))
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}


    __attribute__ ((__always_inline__))
    basic_string& insert(size_type __pos1, const basic_string& __str);
    __attribute__ ((__always_inline__))
    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }
    template <class _Tp>

    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>

    typename enable_if
        <
           __is_exactly_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>

    typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
                    {return insert(__pos, __il.begin(), __il.end());}


    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
    __attribute__ ((__always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    template <class _Tp>

    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
    __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }
    __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>

    typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            basic_string&
        >::type
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);

    __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        {return replace(__i1, __i2, __il.begin(), __il.end());}


    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__always_inline__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__always_inline__))
    void swap(basic_string& __str)

        noexcept;





    __attribute__ ((__always_inline__))
    const value_type* c_str() const noexcept {return data();}
    __attribute__ ((__always_inline__))
    const value_type* data() const noexcept {return std::__1::__to_raw_pointer(__get_pointer());}





    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return __alloc();}

    __attribute__ ((__always_inline__))
    size_type find(const basic_string& __str, size_type __pos = 0) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find(const value_type* __s, size_type __pos = 0) const noexcept;
    size_type find(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__always_inline__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const noexcept;
    __attribute__ ((__always_inline__))
    size_type rfind(__self_view __sv, size_type __pos = npos) const noexcept;
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__always_inline__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const noexcept;
    size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__always_inline__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_first_of(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__always_inline__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_last_of(__self_view __sv, size_type __pos = npos) const noexcept;
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__always_inline__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__always_inline__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_last_not_of(__self_view __sv, size_type __pos = npos) const noexcept;
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__always_inline__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__always_inline__))
    int compare(const basic_string& __str) const noexcept;
    __attribute__ ((__always_inline__))
    int compare(__self_view __sv) const noexcept;
    __attribute__ ((__always_inline__))
    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;
    __attribute__ ((__always_inline__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;
    template <class _Tp>
    inline __attribute__ ((__always_inline__))
        typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >::type
        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const noexcept;
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;

    __attribute__ ((__always_inline__)) bool __invariants() const;

    __attribute__ ((__always_inline__))
    bool __is_long() const noexcept
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1232 "../../buildtools/third_party/libc++/trunk/include/string" 3
private:
    __attribute__ ((__always_inline__))
    allocator_type& __alloc() noexcept
        {return __r_.second();}
    __attribute__ ((__always_inline__))
    const allocator_type& __alloc() const noexcept
        {return __r_.second();}
# 1260 "../../buildtools/third_party/libc++/trunk/include/string" 3
    __attribute__ ((__always_inline__))
    void __set_short_size(size_type __s) noexcept



        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}


    __attribute__ ((__always_inline__))
    size_type __get_short_size() const noexcept



        {return __r_.first().__s.__size_ >> 1;}




    __attribute__ ((__always_inline__))
    void __set_long_size(size_type __s) noexcept
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__always_inline__))
    size_type __get_long_size() const noexcept
        {return __r_.first().__l.__size_;}
    __attribute__ ((__always_inline__))
    void __set_size(size_type __s) noexcept
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__always_inline__))
    void __set_long_cap(size_type __s) noexcept
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__always_inline__))
    size_type __get_long_cap() const noexcept
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__always_inline__))
    void __set_long_pointer(pointer __p) noexcept
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__always_inline__))
    pointer __get_long_pointer() noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__always_inline__))
    const_pointer __get_long_pointer() const noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__always_inline__))
    pointer __get_short_pointer() noexcept
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__always_inline__))
    const_pointer __get_short_pointer() const noexcept
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__always_inline__))
    pointer __get_pointer() noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__always_inline__))
    const_pointer __get_pointer() const noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__always_inline__))
    void __zero() noexcept
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__always_inline__))
        size_type __align_it(size_type __s) noexcept
            {return (__s + (__a-1)) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__always_inline__))
    size_type __recommend(size_type __s) noexcept
        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :
                 __align_it<sizeof(value_type) < __alignment ?
                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}

    inline
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline
    void __init(const value_type* __s, size_type __sz);
    inline
    void __init(size_type __n, value_type __c);

    template <class _InputIterator>
    inline
    typename enable_if
    <
        __is_exactly_input_iterator<_InputIterator>::value,
        void
    >::type
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    inline
    typename enable_if
    <
        __is_forward_iterator<_ForwardIterator>::value,
        void
    >::type
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    __attribute__ ((__always_inline__))
    void __erase_to_end(size_type __pos);

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() == __str.__alloc())
                __alloc() = __str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    clear();
                    shrink_to_fit();
                    __alloc() = __str.__alloc();
                }
                else
                {
                    allocator_type __a = __str.__alloc();
                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
                    clear();
                    shrink_to_fit();
                    __alloc() = std::__1::move(__a);
                    __set_long_pointer(__p);
                    __set_long_cap(__str.__get_long_cap());
                    __set_long_size(__str.size());
                }
            }
        }

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const basic_string&, false_type) noexcept
        {}


    __attribute__ ((__always_inline__))
    void __move_assign(basic_string& __str, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__always_inline__))
    void __move_assign(basic_string& __str, true_type)



        noexcept(is_nothrow_move_assignable<allocator_type>::value);



    __attribute__ ((__always_inline__))
    void
    __move_assign_alloc(basic_string& __str)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(basic_string& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(basic_string&, false_type)
        noexcept
        {}

    __attribute__ ((__always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__always_inline__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1488 "../../buildtools/third_party/libc++/trunk/include/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value)



: __r_(__second_tag(), __a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__second_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string& __str, const allocator_type& __a)
    : __r_(__second_tag(), __a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)

        noexcept(is_nothrow_move_constructible<allocator_type>::value)



    : __r_(std::__1::move(__str.__r_))
{
    __str.__zero();





}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)
    : __r_(__second_tag(), __a)
{
    if (__str.__is_long() && __a != __str.__alloc())
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
    else
    {
        __r_.first().__r = __str.__r_.first().__r;
        __str.__zero();
    }





}



template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,
                                                        size_type __pos, size_type __n,
                                                        const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,
                                                        const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,
    typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)
    : __r_(__second_tag(), __a)
{
 __self_view __sv = __self_view(__t).substr(__pos, __n);
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)
{
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_exactly_input_iterator<_InputIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();




    for (; __first != __last; ++__first)
        push_back(*__first);
# 1815 "../../buildtools/third_party/libc++/trunk/include/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, (void) ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__second_tag(), __a)
{
    __init(__first, __last);



}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il)
{
    __init(__il.begin(), __il.end());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))

basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    __init(__il.begin(), __il.end());



}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    if (__cap >= __n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        traits_type::move(__p, __s, __n);
        traits_type::assign(__p[__n], value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        size_type __sz = size();
        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
    if (this != &__str)
    {
        __copy_assign_alloc(__str);
        assign(__str.data(), __str.size());
    }
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__alloc() != __str.__alloc())
        assign(__str);
    else
        __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)



    noexcept(is_nothrow_move_assignable<allocator_type>::value)

{
    clear();
    shrink_to_fit();
    __r_.first() = __str.__r_.first();
    __move_assign_alloc(__str);
    __str.__zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__str, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_exactly_input_iterator <_InputIterator>::value
          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    const basic_string __temp(__first, __last, __alloc());
    assign(__temp.data(), __temp.size());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value
         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return assign(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _Tp>
bool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)
{
    return __first <= __p && __p < __last;
}

template <class _Tp1, class _Tp2>
bool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)
{
    return false;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(
    _ForwardIterator __first, _ForwardIterator __last)
{
    static_assert(__is_forward_iterator<_ForwardIterator>::value,
                  "function requires a ForwardIterator");
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_ref = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_ref), data(), data() + size()))
        {
            const basic_string __temp (__first, __last, __alloc());
            append(__temp.data(), __temp.size());
        }
        else
        {
            if (__cap - __sz < __n)
                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
            pointer __p = __get_pointer() + __sz;
            for (; __first != __last; ++__p, ++__first)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            __set_size(__sz + __n);
        }
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
    typename enable_if
    <
        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        basic_string<_CharT, _Traits, _Allocator>&
    >::type
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
   __is_exactly_input_iterator<_InputIterator>::value
        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
   typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    const basic_string __temp(__first, __last, __alloc());
    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value
        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_char = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_char), data(), data() + size()))
        {
            const basic_string __temp(__first, __last, __alloc());
            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        }

        size_type __sz = size();
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,
                                                  size_type __pos2, size_type __n)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __sv.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:


        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    const basic_string __temp(__j1, __j2, __alloc());
    return this->replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
 __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,
                                                   size_type __pos2, size_type __n2)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __sv.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::clear() noexcept
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)
{
    if (__res_arg > max_size())
        this->__throw_length_error();
    size_type __cap = capacity();
    size_type __sz = size();
    __res_arg = std::__1::max(__res_arg, __sz);
    __res_arg = __recommend(__res_arg);
    if (__res_arg != __cap)
    {
        pointer __new_data, __p;
        bool __was_long, __now_long;
        if (__res_arg == __min_cap - 1)
        {
            __was_long = true;
            __now_long = false;
            __new_data = __get_short_pointer();
            __p = __get_long_pointer();
        }
        else
        {
            if (__res_arg > __cap)
                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
            else
            {




                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);







                if (__new_data == nullptr)
                    return;

            }
            __now_long = true;
            __was_long = __is_long();
            __p = __get_pointer();
        }
        traits_type::copy(std::__1::__to_raw_pointer(__new_data),
                          std::__1::__to_raw_pointer(__p), size()+1);
        if (__was_long)
            __alloc_traits::deallocate(__alloc(), __p, __cap+1);
        if (__now_long)
        {
            __set_long_cap(__res_arg+1);
            __set_long_size(__sz);
            __set_long_pointer(__new_data);
        }
        else
            __set_short_size(__sz);
        __invalidate_all_iterators();
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const noexcept
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) noexcept
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front()
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)

        noexcept




{







    ((void)0);



    std::__1::swap(__r_.first(), __str.__r_.first());
    __swap_allocator(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__always_inline__))
    bool operator()(const char_type& __x, const char_type& __y) noexcept
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const noexcept
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const noexcept
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const noexcept
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const noexcept
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const noexcept
{
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept
{
    return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   __self_view __sv) const
{
    return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
 __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 int
>::type
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    __self_view __sv = __t;
    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == 0)
        return false;
    if (data()[size()] != value_type(0))
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __lhs_len = _Traits::length(__lhs);
    if (__lhs_len != __rhs.size()) return false;
    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __rhs_len = _Traits::length(__rhs);
    if (__rhs_len != __lhs.size()) return false;
    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs == __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs.compare(__lhs) > 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    __rhs.insert(__rhs.begin(), __lhs);
    return std::__1::move(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
{
    __lhs.push_back(__rhs);
    return std::__1::move(__lhs);
}





template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)
     noexcept(noexcept(__lhs.swap(__rhs)))
{
    __lhs.swap(__rhs);
}



typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;



                 int stoi (const string& __str, size_t* __idx = 0, int __base = 10);
                 long stol (const string& __str, size_t* __idx = 0, int __base = 10);
                 unsigned long stoul (const string& __str, size_t* __idx = 0, int __base = 10);
                 long long stoll (const string& __str, size_t* __idx = 0, int __base = 10);
                 unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);

                 float stof (const string& __str, size_t* __idx = 0);
                 double stod (const string& __str, size_t* __idx = 0);
                 long double stold(const string& __str, size_t* __idx = 0);

                 string to_string(int __val);
                 string to_string(unsigned __val);
                 string to_string(long __val);
                 string to_string(unsigned long __val);
                 string to_string(long long __val);
                 string to_string(unsigned long long __val);
                 string to_string(float __val);
                 string to_string(double __val);
                 string to_string(long double __val);

                 int stoi (const wstring& __str, size_t* __idx = 0, int __base = 10);
                 long stol (const wstring& __str, size_t* __idx = 0, int __base = 10);
                 unsigned long stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
                 long long stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
                 unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);

                 float stof (const wstring& __str, size_t* __idx = 0);
                 double stod (const wstring& __str, size_t* __idx = 0);
                 long double stold(const wstring& __str, size_t* __idx = 0);

                 wstring to_wstring(int __val);
                 wstring to_wstring(unsigned __val);
                 wstring to_wstring(long __val);
                 wstring to_wstring(unsigned long __val);
                 wstring to_wstring(long long __val);
                 wstring to_wstring(unsigned long long __val);
                 wstring to_wstring(float __val);
                 wstring to_wstring(double __val);
                 wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
                   basic_string<_CharT, _Traits, _Allocator>::npos;

template<class _CharT, class _Traits, class _Allocator>
struct hash<basic_string<_CharT, _Traits, _Allocator> >
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
{
    size_t
        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const noexcept;
};

template<class _CharT, class _Traits, class _Allocator>
size_t
hash<basic_string<_CharT, _Traits, _Allocator> >::operator()(
        const basic_string<_CharT, _Traits, _Allocator>& __val) const noexcept
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}

template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4002 "../../buildtools/third_party/libc++/trunk/include/string" 3
extern template class basic_string<char>;
extern template class basic_string<wchar_t>;



inline namespace literals
{
  inline namespace string_literals
  {
    inline __attribute__ ((__always_inline__))
    basic_string<char> operator "" s( const char *__str, size_t __len )
    {
        return basic_string<char> (__str, __len);
    }

    inline __attribute__ ((__always_inline__))
    basic_string<wchar_t> operator "" s( const wchar_t *__str, size_t __len )
    {
        return basic_string<wchar_t> (__str, __len);
    }

    inline __attribute__ ((__always_inline__))
    basic_string<char16_t> operator "" s( const char16_t *__str, size_t __len )
    {
        return basic_string<char16_t> (__str, __len);
    }

    inline __attribute__ ((__always_inline__))
    basic_string<char32_t> operator "" s( const char32_t *__str, size_t __len )
    {
        return basic_string<char32_t> (__str, __len);
    }
  }
}


} }
# 9 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.h" 2
# 1 "../../base/macros.h" 1
# 13 "../../base/macros.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 44 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 47 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3



extern "C++" {

using std::nullptr_t;
}
# 14 "../../base/macros.h" 2
# 53 "../../base/macros.h"
template <typename T, size_t N> char (&ArraySizeHelper(T (&array)[N]))[N];
# 64 "../../base/macros.h"
template<typename T>
inline void ignore_result(const T&) {
}

namespace base {







}
# 10 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.h" 2
# 1 "../../base/trace_event/trace_event.h" 1
# 12 "../../base/trace_event/trace_event.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 13 "../../base/trace_event/trace_event.h" 2




# 1 "../../base/atomicops.h" 1
# 39 "../../base/atomicops.h"
# 1 "../../base/base_export.h" 1
# 40 "../../base/atomicops.h" 2
# 1 "../../build/build_config.h" 1
# 45 "../../build/build_config.h"
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern "C" {
# 205 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 2 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 2 3 4
# 229 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 230 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 2 3 4
# 277 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 290 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 340 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) throw () __asm__ ("" "lseek64");







extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 391 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") ;


extern ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64") ;
# 407 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 435 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 447 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 472 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 514 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 663 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();




extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 873 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/getopt.h" 1 3 4
# 48 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/getopt.h" 3 4
extern "C" {
# 57 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 185 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/getopt.h" 3 4
}
# 874 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 999 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off64_t __length) throw () __asm__ ("" "truncate64") __attribute__ ((__nonnull__ (1))) ;







extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1021 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) throw () __asm__ ("" "ftruncate64") ;






extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1039 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1060 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1086 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64") ;






extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1114 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1166 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/unistd.h" 3 4
}
# 46 "../../build/build_config.h" 2
# 41 "../../base/atomicops.h" 2
# 51 "../../base/atomicops.h"
namespace base {
namespace subtle {

typedef int32_t Atomic32;
# 63 "../../base/atomicops.h"
typedef intptr_t Atomic64;





typedef intptr_t AtomicWord;
# 81 "../../base/atomicops.h"
Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,
                                  Atomic32 old_value,
                                  Atomic32 new_value);



Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr, Atomic32 new_value);



Atomic32 NoBarrier_AtomicIncrement(volatile Atomic32* ptr, Atomic32 increment);

Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
                                 Atomic32 increment);
# 105 "../../base/atomicops.h"
Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,
                                Atomic32 old_value,
                                Atomic32 new_value);
Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,
                                Atomic32 old_value,
                                Atomic32 new_value);

void MemoryBarrier();
void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value);
void Acquire_Store(volatile Atomic32* ptr, Atomic32 value);
void Release_Store(volatile Atomic32* ptr, Atomic32 value);

Atomic32 NoBarrier_Load(volatile const Atomic32* ptr);
Atomic32 Acquire_Load(volatile const Atomic32* ptr);
Atomic32 Release_Load(volatile const Atomic32* ptr);



Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,
                                  Atomic64 old_value,
                                  Atomic64 new_value);
Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr, Atomic64 new_value);
Atomic64 NoBarrier_AtomicIncrement(volatile Atomic64* ptr, Atomic64 increment);
Atomic64 Barrier_AtomicIncrement(volatile Atomic64* ptr, Atomic64 increment);

Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,
                                Atomic64 old_value,
                                Atomic64 new_value);
Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,
                                Atomic64 old_value,
                                Atomic64 new_value);
void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value);
void Acquire_Store(volatile Atomic64* ptr, Atomic64 value);
void Release_Store(volatile Atomic64* ptr, Atomic64 value);
Atomic64 NoBarrier_Load(volatile const Atomic64* ptr);
Atomic64 Acquire_Load(volatile const Atomic64* ptr);
Atomic64 Release_Load(volatile const Atomic64* ptr);


}
}







# 1 "../../base/atomicops_internals_portable.h" 1
# 39 "../../base/atomicops_internals_portable.h"
namespace base {
namespace subtle {
# 51 "../../base/atomicops_internals_portable.h"
typedef volatile std::atomic<Atomic32>* AtomicLocation32;
static_assert(sizeof(*(AtomicLocation32) nullptr) == sizeof(Atomic32),
              "incompatible 32-bit atomic layout");

inline void MemoryBarrier() {





  std::atomic_thread_fence(std::memory_order_seq_cst);

}

inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,
                                         Atomic32 old_value,
                                         Atomic32 new_value) {
  ((AtomicLocation32)ptr)
      ->compare_exchange_strong(old_value,
                                new_value,
                                std::memory_order_relaxed,
                                std::memory_order_relaxed);
  return old_value;
}

inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,
                                         Atomic32 new_value) {
  return ((AtomicLocation32)ptr)
      ->exchange(new_value, std::memory_order_relaxed);
}

inline Atomic32 NoBarrier_AtomicIncrement(volatile Atomic32* ptr,
                                          Atomic32 increment) {
  return increment +
         ((AtomicLocation32)ptr)
             ->fetch_add(increment, std::memory_order_relaxed);
}

inline Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
                                        Atomic32 increment) {
  return increment + ((AtomicLocation32)ptr)->fetch_add(increment);
}

inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,
                                       Atomic32 old_value,
                                       Atomic32 new_value) {
  ((AtomicLocation32)ptr)
      ->compare_exchange_strong(old_value,
                                new_value,
                                std::memory_order_acquire,
                                std::memory_order_acquire);
  return old_value;
}

inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,
                                       Atomic32 old_value,
                                       Atomic32 new_value) {
  ((AtomicLocation32)ptr)
      ->compare_exchange_strong(old_value,
                                new_value,
                                std::memory_order_release,
                                std::memory_order_relaxed);
  return old_value;
}

inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {
  ((AtomicLocation32)ptr)->store(value, std::memory_order_relaxed);
}

inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {
  ((AtomicLocation32)ptr)->store(value, std::memory_order_relaxed);
  MemoryBarrier();
}

inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {
  ((AtomicLocation32)ptr)->store(value, std::memory_order_release);
}

inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {
  return ((AtomicLocation32)ptr)->load(std::memory_order_relaxed);
}

inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {
  return ((AtomicLocation32)ptr)->load(std::memory_order_acquire);
}

inline Atomic32 Release_Load(volatile const Atomic32* ptr) {
  MemoryBarrier();
  return ((AtomicLocation32)ptr)->load(std::memory_order_relaxed);
}



typedef volatile std::atomic<Atomic64>* AtomicLocation64;
static_assert(sizeof(*(AtomicLocation64) nullptr) == sizeof(Atomic64),
              "incompatible 64-bit atomic layout");

inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,
                                         Atomic64 old_value,
                                         Atomic64 new_value) {
  ((AtomicLocation64)ptr)
      ->compare_exchange_strong(old_value,
                                new_value,
                                std::memory_order_relaxed,
                                std::memory_order_relaxed);
  return old_value;
}

inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,
                                         Atomic64 new_value) {
  return ((AtomicLocation64)ptr)
      ->exchange(new_value, std::memory_order_relaxed);
}

inline Atomic64 NoBarrier_AtomicIncrement(volatile Atomic64* ptr,
                                          Atomic64 increment) {
  return increment +
         ((AtomicLocation64)ptr)
             ->fetch_add(increment, std::memory_order_relaxed);
}

inline Atomic64 Barrier_AtomicIncrement(volatile Atomic64* ptr,
                                        Atomic64 increment) {
  return increment + ((AtomicLocation64)ptr)->fetch_add(increment);
}

inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,
                                       Atomic64 old_value,
                                       Atomic64 new_value) {
  ((AtomicLocation64)ptr)
      ->compare_exchange_strong(old_value,
                                new_value,
                                std::memory_order_acquire,
                                std::memory_order_acquire);
  return old_value;
}

inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,
                                       Atomic64 old_value,
                                       Atomic64 new_value) {
  ((AtomicLocation64)ptr)
      ->compare_exchange_strong(old_value,
                                new_value,
                                std::memory_order_release,
                                std::memory_order_relaxed);
  return old_value;
}

inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {
  ((AtomicLocation64)ptr)->store(value, std::memory_order_relaxed);
}

inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {
  ((AtomicLocation64)ptr)->store(value, std::memory_order_relaxed);
  MemoryBarrier();
}

inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {
  ((AtomicLocation64)ptr)->store(value, std::memory_order_release);
}

inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {
  return ((AtomicLocation64)ptr)->load(std::memory_order_relaxed);
}

inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {
  return ((AtomicLocation64)ptr)->load(std::memory_order_acquire);
}

inline Atomic64 Release_Load(volatile const Atomic64* ptr) {
  MemoryBarrier();
  return ((AtomicLocation64)ptr)->load(std::memory_order_relaxed);
}


}
}
# 153 "../../base/atomicops.h" 2
# 18 "../../base/trace_event/trace_event.h" 2
# 1 "gen/base/debug/debugging_flags.h" 1






# 1 "../../build/buildflag.h" 1
# 8 "gen/base/debug/debugging_flags.h" 2
# 19 "../../base/trace_event/trace_event.h" 2

# 1 "../../base/time/time.h" 1
# 55 "../../base/time/time.h"
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 1 3 4
# 29 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
extern "C" {








# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 38 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 2 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 88 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 25 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 89 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 2 3 4
# 133 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 161 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 189 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 56 "../../base/time/time.h" 2





# 1 "../../base/compiler_specific.h" 1
# 62 "../../base/time/time.h" 2
# 1 "../../base/logging.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/logging.h" 2

# 1 "../../buildtools/third_party/libc++/trunk/include/cassert" 1 3
# 21 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/assert.h" 1 3 4
# 22 "../../buildtools/third_party/libc++/trunk/include/cassert" 2 3
# 25 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 11 "../../base/logging.h" 2

# 1 "../../buildtools/third_party/libc++/trunk/include/sstream" 1 3
# 174 "../../buildtools/third_party/libc++/trunk/include/sstream" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/ostream" 1 3
# 138 "../../buildtools/third_party/libc++/trunk/include/ostream" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/ios" 1 3
# 216 "../../buildtools/third_party/libc++/trunk/include/ios" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__locale" 1 3
# 18 "../../buildtools/third_party/libc++/trunk/include/__locale" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/mutex" 1 3
# 191 "../../buildtools/third_party/libc++/trunk/include/mutex" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 1 3
# 15 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/chrono" 1 3
# 303 "../../buildtools/third_party/libc++/trunk/include/chrono" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/ctime" 1 3
# 52 "../../buildtools/third_party/libc++/trunk/include/ctime" 3


namespace std {inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;

using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;

using ::strftime;

} }
# 304 "../../buildtools/third_party/libc++/trunk/include/chrono" 2 3

# 1 "../../buildtools/third_party/libc++/trunk/include/ratio" 1 3
# 83 "../../buildtools/third_party/libc++/trunk/include/ratio" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/climits" 1 3
# 42 "../../buildtools/third_party/libc++/trunk/include/climits" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/limits.h" 1 3
# 45 "../../buildtools/third_party/libc++/trunk/include/limits.h" 3
# 58 "../../buildtools/third_party/libc++/trunk/include/limits.h" 3
# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/limits.h" 1 3
# 37 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/limits.h" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/limits.h" 1 3 4
# 143 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/limits.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/linux/limits.h" 1 3 4
# 39 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/limits.h" 2 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/limits.h" 2 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 33 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 34 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 152 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/limits.h" 2 3 4
# 38 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/limits.h" 2 3
# 59 "../../buildtools/third_party/libc++/trunk/include/limits.h" 2 3
# 43 "../../buildtools/third_party/libc++/trunk/include/climits" 2 3
# 46 "../../buildtools/third_party/libc++/trunk/include/climits" 3
# 84 "../../buildtools/third_party/libc++/trunk/include/ratio" 2 3
# 88 "../../buildtools/third_party/libc++/trunk/include/ratio" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 92 "../../buildtools/third_party/libc++/trunk/include/ratio" 2 3


namespace std {inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
# 318 "../../buildtools/third_party/libc++/trunk/include/ratio" 3
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
# 345 "../../buildtools/third_party/libc++/trunk/include/ratio" 3
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
# 380 "../../buildtools/third_party/libc++/trunk/include/ratio" 3
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
# 417 "../../buildtools/third_party/libc++/trunk/include/ratio" 3
template <class _R1, class _R2>
struct ratio_equal
    : public integral_constant<bool,((_R1::num == _R2::num && _R1::den == _R2::den))> {};

template <class _R1, class _R2>
struct ratio_not_equal
    : public integral_constant<bool,((!ratio_equal<_R1, _R2>::value))> {};



template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct ratio_less
    : public integral_constant<bool,((__ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct ratio_less_equal
    : public integral_constant<bool,((!ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct ratio_greater
    : public integral_constant<bool,((ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct ratio_greater_equal
    : public integral_constant<bool,((!ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};
# 523 "../../buildtools/third_party/libc++/trunk/include/ratio" 3
} }
# 306 "../../buildtools/third_party/libc++/trunk/include/chrono" 2 3
# 310 "../../buildtools/third_party/libc++/trunk/include/chrono" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 314 "../../buildtools/third_party/libc++/trunk/include/chrono" 2 3


namespace std {inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct treat_as_floating_point : is_floating_point<_Rep> {};






template <class _Rep>
struct duration_values
{
public:
    __attribute__ ((__always_inline__)) static constexpr _Rep zero() {return _Rep(0);}
    __attribute__ ((__always_inline__)) static constexpr _Rep max() {return numeric_limits<_Rep>::max();}
    __attribute__ ((__always_inline__)) static constexpr _Rep min() {return numeric_limits<_Rep>::lowest();}
};
# 489 "../../buildtools/third_party/libc++/trunk/include/chrono" 3
template <class _Rep, class _Period>
class duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:

    __attribute__ ((__always_inline__)) constexpr

        duration() = default;




    template <class _Rep2>
        __attribute__ ((__always_inline__)) constexpr
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = 0)
                : __rep_(__r) {}


    template <class _Rep2, class _Period2>
        __attribute__ ((__always_inline__)) constexpr
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = 0)
                : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}



    __attribute__ ((__always_inline__)) constexpr rep count() const {return __rep_;}



    __attribute__ ((__always_inline__)) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
    __attribute__ ((__always_inline__)) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
    __attribute__ ((__always_inline__)) duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__always_inline__)) duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__always_inline__)) duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__always_inline__)) duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__always_inline__)) duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__always_inline__)) duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__always_inline__)) duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__always_inline__)) duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__always_inline__)) duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__always_inline__)) duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}



    __attribute__ ((__always_inline__)) static constexpr duration zero() {return duration(duration_values<rep>::zero());}
    __attribute__ ((__always_inline__)) static constexpr duration min() {return duration(duration_values<rep>::min());}
    __attribute__ ((__always_inline__)) static constexpr duration max() {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;



template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}



template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
struct __duration_divide_result
{
};

template <class _Duration, class _Rep2,
    bool = is_convertible<_Rep2,
                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>
struct __duration_divide_imp
{
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>
{
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>
{
};

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__always_inline__))
constexpr
typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__always_inline__))
constexpr
typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}





template <class _Clock, class _Duration = typename _Clock::duration>
class time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__always_inline__)) constexpr time_point() : __d_(duration::zero()) {}
    __attribute__ ((__always_inline__)) constexpr explicit time_point(const duration& __d) : __d_(__d) {}


    template <class _Duration2>
    __attribute__ ((__always_inline__)) constexpr
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = 0)
            : __d_(t.time_since_epoch()) {}



    __attribute__ ((__always_inline__)) constexpr duration time_since_epoch() const {return __d_;}



    __attribute__ ((__always_inline__)) time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__always_inline__)) time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}



    __attribute__ ((__always_inline__)) static constexpr time_point min() {return time_point(duration::min());}
    __attribute__ ((__always_inline__)) static constexpr time_point max() {return time_point(duration::max());}
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__always_inline__)) constexpr
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}
# 945 "../../buildtools/third_party/libc++/trunk/include/chrono" 3
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__always_inline__)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
    return _Ret(__lhs.time_since_epoch() -__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__always_inline__)) constexpr
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static constexpr const bool is_steady = false;

    static time_point now() noexcept;
    static time_t to_time_t (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};


class steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static constexpr const bool is_steady = true;

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;




}



inline namespace literals
{
  inline namespace chrono_literals
  {

    constexpr chrono::hours operator""h(unsigned long long __h)
    {
        return chrono::hours(static_cast<chrono::hours::rep>(__h));
    }

    constexpr chrono::duration<long double, ratio<3600,1>> operator""h(long double __h)
    {
        return chrono::duration<long double, ratio<3600,1>>(__h);
    }


    constexpr chrono::minutes operator""min(unsigned long long __m)
    {
        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
    }

    constexpr chrono::duration<long double, ratio<60,1>> operator""min(long double __m)
    {
        return chrono::duration<long double, ratio<60,1>> (__m);
    }


    constexpr chrono::seconds operator""s(unsigned long long __s)
    {
        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
    }

    constexpr chrono::duration<long double> operator""s(long double __s)
    {
        return chrono::duration<long double> (__s);
    }


    constexpr chrono::milliseconds operator""ms(unsigned long long __ms)
    {
        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
    }

    constexpr chrono::duration<long double, milli> operator""ms(long double __ms)
    {
        return chrono::duration<long double, milli>(__ms);
    }


    constexpr chrono::microseconds operator""us(unsigned long long __us)
    {
        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
    }

    constexpr chrono::duration<long double, micro> operator""us(long double __us)
    {
        return chrono::duration<long double, micro> (__us);
    }


    constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)
    {
        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
    }

    constexpr chrono::duration<long double, nano> operator""ns(long double __ns)
    {
        return chrono::duration<long double, nano> (__ns);
    }

}}

namespace chrono {
   using namespace literals::chrono_literals;
}



} }
# 16 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/system_error" 1 3
# 229 "../../buildtools/third_party/libc++/trunk/include/system_error" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cerrno" 1 3
# 27 "../../buildtools/third_party/libc++/trunk/include/cerrno" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/errno.h" 1 3
# 30 "../../buildtools/third_party/libc++/trunk/include/errno.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/errno.h" 1 3 4
# 31 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/errno.h" 3 4
extern "C" {




# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/linux/errno.h" 1 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/asm-generic/errno.h" 1 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/asm-generic/errno.h" 2 3 4
# 2 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/linux/errno.h" 2 3 4
# 25 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 36 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/errno.h" 2 3 4
# 54 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 68 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/errno.h" 3 4
typedef int error_t;
# 33 "../../buildtools/third_party/libc++/trunk/include/errno.h" 2 3
# 28 "../../buildtools/third_party/libc++/trunk/include/cerrno" 2 3
# 31 "../../buildtools/third_party/libc++/trunk/include/cerrno" 3
# 230 "../../buildtools/third_party/libc++/trunk/include/system_error" 2 3
# 237 "../../buildtools/third_party/libc++/trunk/include/system_error" 3


namespace std {inline namespace __1 {



template <class _Tp>
struct is_error_code_enum
    : public false_type {};
# 254 "../../buildtools/third_party/libc++/trunk/include/system_error" 3
template <class _Tp>
struct is_error_condition_enum
    : public false_type {};
# 267 "../../buildtools/third_party/libc++/trunk/include/system_error" 3
enum class errc
{
    address_family_not_supported = 97,
    address_in_use = 98,
    address_not_available = 99,
    already_connected = 106,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 74,
    broken_pipe = 32,
    connection_aborted = 103,
    connection_already_in_progress = 114,
    connection_refused = 111,
    connection_reset = 104,
    cross_device_link = 18,
    destination_address_required = 89,
    device_or_resource_busy = 16,
    directory_not_empty = 39,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 36,
    function_not_supported = 38,
    host_unreachable = 113,
    identifier_removed = 43,
    illegal_byte_sequence = 84,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 90,
    network_down = 100,
    network_reset = 102,
    network_unreachable = 101,
    no_buffer_space = 105,
    no_child_process = 10,
    no_link = 67,
    no_lock_available = 37,

    no_message_available = 61,



    no_message = 42,
    no_protocol_option = 92,
    no_space_on_device = 28,

    no_stream_resources = 63,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 88,

    not_a_stream = 60,



    not_connected = 107,
    not_enough_memory = 12,
    not_supported = 95,
    operation_canceled = 125,
    operation_in_progress = 115,
    operation_not_permitted = 1,
    operation_not_supported = 95,
    operation_would_block = 11,
    owner_dead = 130,
    permission_denied = 13,
    protocol_error = 71,
    protocol_not_supported = 93,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 35,
    resource_unavailable_try_again = 11,
    result_out_of_range = 34,
    state_not_recoverable = 131,

    stream_timeout = 62,



    text_file_busy = 26,
    timed_out = 110,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 40,
    value_too_large = 75,
    wrong_protocol_type = 91
};


template <>
struct is_error_condition_enum<errc>
    : true_type { };







class error_condition;
class error_code;



class __do_message;

class error_category
{
public:
    virtual ~error_category() noexcept;





    __attribute__ ((__always_inline__))
    constexpr error_category() noexcept = default;

private:
    error_category(const error_category&);
    error_category& operator=(const error_category&);

public:
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int __ev) const noexcept;
    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
    virtual string message(int __ev) const = 0;

    __attribute__ ((__always_inline__))
    bool operator==(const error_category& __rhs) const noexcept {return this == &__rhs;}

    __attribute__ ((__always_inline__))
    bool operator!=(const error_category& __rhs) const noexcept {return !(*this == __rhs);}

    __attribute__ ((__always_inline__))
    bool operator< (const error_category& __rhs) const noexcept {return this < &__rhs;}

    friend class __do_message;
};

class __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

                 const error_category& generic_category() noexcept;
                 const error_category& system_category() noexcept;

class error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__always_inline__))
    error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__always_inline__))
    error_condition(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__always_inline__))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = 0
                                                                     ) noexcept
            {*this = make_error_condition(__e);}

    __attribute__ ((__always_inline__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__always_inline__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__always_inline__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__always_inline__))
    const error_category& category() const noexcept {return *__cat_;}
    string message() const;

    __attribute__ ((__always_inline__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__always_inline__))
error_condition
make_error_condition(errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__always_inline__))
bool
operator<(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}



class error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__always_inline__))
    error_code() noexcept : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__always_inline__))
    error_code(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__always_inline__))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0
                                                                     ) noexcept
            {*this = make_error_code(__e);}

    __attribute__ ((__always_inline__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__always_inline__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__always_inline__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__always_inline__))
    const error_category& category() const noexcept {return *__cat_;}

    __attribute__ ((__always_inline__))
    error_condition default_error_condition() const noexcept
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__always_inline__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__always_inline__))
error_code
make_error_code(errc __e) noexcept
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__always_inline__))
bool
operator<(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__always_inline__))
bool
operator==(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__always_inline__))
bool
operator==(const error_code& __x, const error_condition& __y) noexcept
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__always_inline__))
bool
operator==(const error_condition& __x, const error_code& __y) noexcept
{
    return __y == __x;
}

inline __attribute__ ((__always_inline__))
bool
operator==(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__always_inline__))
bool
operator!=(const error_code& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__always_inline__))
bool
operator!=(const error_code& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__always_inline__))
bool
operator!=(const error_condition& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__always_inline__))
bool
operator!=(const error_condition& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

template <>
struct hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(const error_code& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};

template <>
struct hash<error_condition>
    : public unary_function<error_condition, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(const error_condition& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};



class system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    ~system_error() noexcept;

    __attribute__ ((__always_inline__))
    const error_code& code() const noexcept {return __ec_;}

private:
    static string __init(const error_code&, string);
};

[[noreturn]]
void __throw_system_error(int ev, const char* what_arg);

} }
# 17 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__threading_support" 1 3
# 20 "../../buildtools/third_party/libc++/trunk/include/__threading_support" 3







# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 1 3 4
# 23 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/sched.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/sched.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 29 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/sched.h" 2 3 4
# 43 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/sched.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 73 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 119 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 202 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 44 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 118 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 2 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 2 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 114 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 155 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 190 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 228 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 494 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 506 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 540 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 680 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
                            ;
# 692 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
                         ;
# 715 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
                            ;
# 728 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
                         ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
                             __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 806 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 888 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1000 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1044 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1111 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1145 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
 pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 28 "../../buildtools/third_party/libc++/trunk/include/__threading_support" 2 3








# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 37 "../../buildtools/third_party/libc++/trunk/include/__threading_support" 2 3
# 52 "../../buildtools/third_party/libc++/trunk/include/__threading_support" 3
namespace std {inline namespace __1 {



typedef pthread_mutex_t __libcpp_mutex_t;


typedef pthread_mutex_t __libcpp_recursive_mutex_t;


typedef pthread_cond_t __libcpp_condvar_t;



typedef pthread_once_t __libcpp_exec_once_flag;



typedef pthread_t __libcpp_thread_id;




typedef pthread_t __libcpp_thread_t;


typedef pthread_key_t __libcpp_tls_key;
# 111 "../../buildtools/third_party/libc++/trunk/include/__threading_support" 3
inline __attribute__ ((__always_inline__))
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__always_inline__))
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__always_inline__))
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__always_inline__))
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__always_inline__))
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__always_inline__))
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);

inline __attribute__ ((__always_inline__))
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);

inline __attribute__ ((__always_inline__))
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);

inline __attribute__ ((__always_inline__))
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);


inline __attribute__ ((__always_inline__))
int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);

inline __attribute__ ((__always_inline__))
int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);

inline __attribute__ ((__always_inline__))
int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);

inline __attribute__ ((__always_inline__))
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               timespec *__ts);

inline __attribute__ ((__always_inline__))
int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);


inline __attribute__ ((__always_inline__))
int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)(void));


inline __attribute__ ((__always_inline__))
bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);

inline __attribute__ ((__always_inline__))
bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);


inline __attribute__ ((__always_inline__))
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);

inline __attribute__ ((__always_inline__))
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg);

inline __attribute__ ((__always_inline__))
__libcpp_thread_id __libcpp_thread_get_current_id();

inline __attribute__ ((__always_inline__))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);

inline __attribute__ ((__always_inline__))
int __libcpp_thread_join(__libcpp_thread_t *__t);

inline __attribute__ ((__always_inline__))
int __libcpp_thread_detach(__libcpp_thread_t *__t);

inline __attribute__ ((__always_inline__))
void __libcpp_thread_yield();

inline __attribute__ ((__always_inline__))
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);


inline __attribute__ ((__always_inline__))
int __libcpp_tls_create(__libcpp_tls_key* __key,
                        void(* __at_exit)(void*));

inline __attribute__ ((__always_inline__))
void *__libcpp_tls_get(__libcpp_tls_key __key);

inline __attribute__ ((__always_inline__))
int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);






int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
{
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &attr);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_recursive_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}

int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}


int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
{
  return pthread_cond_signal(__cv);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
{
  return pthread_cond_broadcast(__cv);
}

int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
{
  return pthread_cond_wait(__cv, __m);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               timespec *__ts)
{
  return pthread_cond_timedwait(__cv, __m, __ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
{
  return pthread_cond_destroy(__cv);
}


int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)(void)) {
  return pthread_once(flag, init_routine);
}



bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return pthread_equal(t1, t2) != 0;
}


bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return t1 < t2;
}


bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
  return *__t == 0;
}

int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg)
{
  return pthread_create(__t, 0, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id()
{
  return pthread_self();
}

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
{
  return *__t;
}

int __libcpp_thread_join(__libcpp_thread_t *__t)
{
  return pthread_join(*__t, 0);
}

int __libcpp_thread_detach(__libcpp_thread_t *__t)
{
  return pthread_detach(*__t);
}

void __libcpp_thread_yield()
{
  sched_yield();
}

void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
{
   using namespace chrono;
   seconds __s = duration_cast<seconds>(__ns);
   timespec __ts;
   typedef decltype(__ts.tv_sec) ts_sec;
   constexpr ts_sec __ts_sec_max = numeric_limits<ts_sec>::max();

   if (__s.count() < __ts_sec_max)
   {
     __ts.tv_sec = static_cast<ts_sec>(__s.count());
     __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
   }
   else
   {
     __ts.tv_sec = __ts_sec_max;
     __ts.tv_nsec = 999999999;
   }

   while (nanosleep(&__ts, &__ts) == -1 && (*__errno_location ()) == 4);
}


int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *))
{
  return pthread_key_create(__key, __at_exit);
}

void *__libcpp_tls_get(__libcpp_tls_key __key)
{
  return pthread_getspecific(__key);
}

int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
{
    return pthread_setspecific(__key, __p);
}
# 633 "../../buildtools/third_party/libc++/trunk/include/__threading_support" 3
} }
# 18 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 2 3
# 22 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 26 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 2 3


namespace std {inline namespace __1 {
# 40 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 3
class mutex
{

    __libcpp_mutex_t __m_ = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




public:
    __attribute__ ((__always_inline__))

    constexpr mutex() = default;



    ~mutex();

private:
    mutex(const mutex&);
    mutex& operator=(const mutex&);

public:
    void lock() ;
    bool try_lock() noexcept ;
    void unlock() noexcept ;

    typedef __libcpp_mutex_t* native_handle_type;
    __attribute__ ((__always_inline__)) native_handle_type native_handle() {return &__m_;}
};

static_assert(is_nothrow_default_constructible<mutex>::value,
              "the default constructor for std::mutex must be nothrow");

struct defer_lock_t {};
struct try_to_lock_t {};
struct adopt_lock_t {};
# 85 "../../buildtools/third_party/libc++/trunk/include/__mutex_base" 3
constexpr defer_lock_t defer_lock = defer_lock_t();
constexpr try_to_lock_t try_to_lock = try_to_lock_t();
constexpr adopt_lock_t adopt_lock = adopt_lock_t();



template <class _Mutex>
class
lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type& __m_;
public:

    __attribute__ ((__always_inline__))
    explicit lock_guard(mutex_type& __m)
        : __m_(__m) {__m_.lock();}
    __attribute__ ((__always_inline__))
    lock_guard(mutex_type& __m, adopt_lock_t)
        : __m_(__m) {}
    __attribute__ ((__always_inline__))
    ~lock_guard() {__m_.unlock();}

private:
    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};

template <class _Mutex>
class unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    __attribute__ ((__always_inline__))
    unique_lock() noexcept : __m_(nullptr), __owns_(false) {}
    __attribute__ ((__always_inline__))
    explicit unique_lock(mutex_type& __m)
        : __m_(std::__1::addressof(__m)), __owns_(true) {__m_->lock();}
    __attribute__ ((__always_inline__))
    unique_lock(mutex_type& __m, defer_lock_t) noexcept
        : __m_(std::__1::addressof(__m)), __owns_(false) {}
    __attribute__ ((__always_inline__))
    unique_lock(mutex_type& __m, try_to_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock()) {}
    __attribute__ ((__always_inline__))
    unique_lock(mutex_type& __m, adopt_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(true) {}
    template <class _Clock, class _Duration>
    __attribute__ ((__always_inline__))
        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}
    template <class _Rep, class _Period>
    __attribute__ ((__always_inline__))
        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}
    __attribute__ ((__always_inline__))
    ~unique_lock()
    {
        if (__owns_)
            __m_->unlock();
    }

private:
    unique_lock(unique_lock const&);
    unique_lock& operator=(unique_lock const&);

public:

    __attribute__ ((__always_inline__))
    unique_lock(unique_lock&& __u) noexcept
        : __m_(__u.__m_), __owns_(__u.__owns_)
        {__u.__m_ = nullptr; __u.__owns_ = false;}
    __attribute__ ((__always_inline__))
    unique_lock& operator=(unique_lock&& __u) noexcept
        {
            if (__owns_)
                __m_->unlock();
            __m_ = __u.__m_;
            __owns_ = __u.__owns_;
            __u.__m_ = nullptr;
            __u.__owns_ = false;
            return *this;
        }



    void lock();
    bool try_lock();

    template <class _Rep, class _Period>
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);

    void unlock();

    __attribute__ ((__always_inline__))
    void swap(unique_lock& __u) noexcept
    {
        std::__1::swap(__m_, __u.__m_);
        std::__1::swap(__owns_, __u.__owns_);
    }
    __attribute__ ((__always_inline__))
    mutex_type* release() noexcept
    {
        mutex_type* __m = __m_;
        __m_ = nullptr;
        __owns_ = false;
        return __m;
    }

    __attribute__ ((__always_inline__))
    bool owns_lock() const noexcept {return __owns_;}
    __attribute__ ((__always_inline__))
    explicit
        operator bool () const noexcept {return __owns_;}
    __attribute__ ((__always_inline__))
    mutex_type* mutex() const noexcept {return __m_;}
};

template <class _Mutex>
void
unique_lock<_Mutex>::lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::lock: references null mutex");
    if (__owns_)
        __throw_system_error(35, "unique_lock::lock: already locked");
    __m_->lock();
    __owns_ = true;
}

template <class _Mutex>
bool
unique_lock<_Mutex>::try_lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock: references null mutex");
    if (__owns_)
        __throw_system_error(35, "unique_lock::try_lock: already locked");
    __owns_ = __m_->try_lock();
    return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool
unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
    if (__owns_)
        __throw_system_error(35, "unique_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_for(__d);
    return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool
unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
    if (__owns_)
        __throw_system_error(35, "unique_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_until(__t);
    return __owns_;
}

template <class _Mutex>
void
unique_lock<_Mutex>::unlock()
{
    if (!__owns_)
        __throw_system_error(1, "unique_lock::unlock: not locked");
    __m_->unlock();
    __owns_ = false;
}

template <class _Mutex>
inline __attribute__ ((__always_inline__))
void
swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept
    {__x.swap(__y);}


enum class cv_status
{
    no_timeout,
    timeout
};


class condition_variable
{

    __libcpp_condvar_t __cv_ = { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } };




public:
    __attribute__ ((__always_inline__))

    constexpr condition_variable() noexcept = default;



    ~condition_variable();

private:
    condition_variable(const condition_variable&);
    condition_variable& operator=(const condition_variable&);

public:
    void notify_one() noexcept;
    void notify_all() noexcept;

    void wait(unique_lock<mutex>& __lk) noexcept;
    template <class _Predicate>

        void wait(unique_lock<mutex>& __lk, _Predicate __pred);

    template <class _Clock, class _Duration>

        cv_status
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t);

    template <class _Clock, class _Duration, class _Predicate>

        bool
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred);

    template <class _Rep, class _Period>

        cv_status
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d);

    template <class _Rep, class _Period, class _Predicate>
        bool
        __attribute__ ((__always_inline__))
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d,
                 _Predicate __pred);

    typedef __libcpp_condvar_t* native_handle_type;
    __attribute__ ((__always_inline__)) native_handle_type native_handle() {return &__cv_;}

private:
    void __do_timed_wait(unique_lock<mutex>& __lk,
       chrono::time_point<chrono::system_clock, chrono::nanoseconds>) noexcept;
};


template <class _To, class _Rep, class _Period>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    chrono::__is_duration<_To>::value,
    _To
>::type
__ceil(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    _To __r = duration_cast<_To>(__d);
    if (__r < __d)
        ++__r;
    return __r;
}


template <class _Predicate>
void
condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)
{
    while (!__pred())
        wait(__lk);
}

template <class _Clock, class _Duration>
cv_status
condition_variable::wait_until(unique_lock<mutex>& __lk,
                               const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    wait_for(__lk, __t - _Clock::now());
    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool
condition_variable::wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred)
{
    while (!__pred())
    {
        if (wait_until(__lk, __t) == cv_status::timeout)
            return __pred();
    }
    return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d)
{
    using namespace chrono;
    if (__d <= __d.zero())
        return cv_status::timeout;
    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;
    typedef time_point<system_clock, nanoseconds> __sys_tpi;
    __sys_tpf _Max = __sys_tpi::max();
    steady_clock::time_point __c_now = steady_clock::now();
    system_clock::time_point __s_now = system_clock::now();
    if (_Max - __d > __s_now)
        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
    else
        __do_timed_wait(__lk, __sys_tpi::max());
    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :
                                                 cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline
bool
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d,
                             _Predicate __pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}



} }
# 192 "../../buildtools/third_party/libc++/trunk/include/mutex" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/functional" 1 3
# 495 "../../buildtools/third_party/libc++/trunk/include/functional" 3


namespace std {inline namespace __1 {


template <class _Tp = void>



struct plus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};


template <>
struct plus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct minus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};


template <>
struct minus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct multiplies : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};


template <>
struct multiplies<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct divides : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};


template <>
struct divides<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct modulus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};


template <>
struct modulus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct negate : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};


template <>
struct negate<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(- std::__1::forward<_Tp>(__x)))
    -> decltype (- std::__1::forward<_Tp>(__x))
        { return - std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};


template <>
struct equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct not_equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};


template <>
struct not_equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct greater : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};


template <>
struct greater<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};






template <class _Tp = void>



struct greater_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};


template <>
struct greater_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct less_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};


template <>
struct less_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct logical_and : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};


template <>
struct logical_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct logical_or : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};


template <>
struct logical_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct logical_not : unary_function<_Tp, bool>
{
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};


template <>
struct logical_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(!std::__1::forward<_Tp>(__x)))
    -> decltype (!std::__1::forward<_Tp>(__x))
        { return !std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct bit_and : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};


template <>
struct bit_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct bit_or : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};


template <>
struct bit_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct bit_xor : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};


template <>
struct bit_xor<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>
struct bit_not : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};

template <>
struct bit_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__always_inline__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(~std::__1::forward<_Tp>(__x)))
    -> decltype (~std::__1::forward<_Tp>(__x))
        { return ~std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};


template <class _Predicate>
class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
    constexpr __attribute__ ((__always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    constexpr __attribute__ ((__always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline constexpr __attribute__ ((__always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__always_inline__)) explicit constexpr
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

    constexpr __attribute__ ((__always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline constexpr __attribute__ ((__always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}


template <class __Operation>
class binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    __attribute__ ((__always_inline__)) binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__always_inline__))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__always_inline__))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__always_inline__))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    __attribute__ ((__always_inline__)) _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline __attribute__ ((__always_inline__))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    __attribute__ ((__always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline __attribute__ ((__always_inline__))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__always_inline__))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__always_inline__))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__always_inline__))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__always_inline__))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__always_inline__))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__always_inline__))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__always_inline__))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__always_inline__))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}






template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__always_inline__)) __mem_fn(type __f) noexcept : __f_(__f) {}



    template <class... _ArgTypes>
    __attribute__ ((__always_inline__))
    typename __invoke_return<type, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return __invoke(__f_, std::__1::forward<_ArgTypes>(__args)...);
    }
# 1375 "../../buildtools/third_party/libc++/trunk/include/functional" 3
};

template<class _Rp, class _Tp>
inline __attribute__ ((__always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm) noexcept
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}







class bad_function_call
    : public exception
{






};

[[noreturn]] inline __attribute__ ((__always_inline__))
void __throw_bad_function_call()
{



 std::__1::abort();

}

template<class _Fp> class function;

namespace __function
{

template<class _Rp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Rp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Fp>
__attribute__ ((__always_inline__))
bool __not_null(_Fp const&) { return true; }

template <class _Fp>
__attribute__ ((__always_inline__))
bool __not_null(_Fp* __ptr) { return __ptr; }

template <class _Ret, class _Class>
__attribute__ ((__always_inline__))
bool __not_null(_Ret _Class::*__ptr) { return __ptr; }

template <class _Fp>
__attribute__ ((__always_inline__))
bool __not_null(function<_Fp> const& __f) { return !!__f; }

}



namespace __function {

template<class _Fp> class __base;

template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __attribute__ ((__always_inline__)) __base() {}
    __attribute__ ((__always_inline__)) virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() noexcept = 0;
    virtual void destroy_deallocate() noexcept = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;




};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__always_inline__))
    explicit __func(_Fp&& __f)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
                                    std::__1::forward_as_tuple()) {}
    __attribute__ ((__always_inline__))
    explicit __func(const _Fp& __f, const _Alloc& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
                                    std::__1::forward_as_tuple(__a)) {}

    __attribute__ ((__always_inline__))
    explicit __func(const _Fp& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
                                    std::__1::forward_as_tuple(std::__1::move(__a))) {}

    __attribute__ ((__always_inline__))
    explicit __func(_Fp&& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
                                    std::__1::forward_as_tuple(std::__1::move(__a))) {}
    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() noexcept;
    virtual void destroy_deallocate() noexcept;
    virtual _Rp operator()(_ArgTypes&& ... __arg);




};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
__base<_Rp(_ArgTypes...)>*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(__f_.first(), std::__1::forward<_ArgTypes>(__arg)...);
}
# 1585 "../../buildtools/third_party/libc++/trunk/include/functional" 3
}

template<class _Rp, class ..._ArgTypes>
class function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
{
    typedef __function::__base<_Rp(_ArgTypes...)> __base;
    typename aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    __attribute__((__no_sanitize__("cfi"))) static __base *__as_base(void *p) {
      return reinterpret_cast<__base*>(p);
    }

    template <class _Fp, bool = __lazy_and<
        integral_constant<bool, !is_same<__uncvref_t<_Fp>, function>::value>,
        __invokable<_Fp&, _ArgTypes...>
    >::value>
    struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value = is_same<void, _Rp>::value ||
                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,
                               _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };

  template <class _Fp>
  using _EnableIfCallable = typename enable_if<__callable<_Fp>::value>::type;
public:
    typedef _Rp result_type;


    __attribute__ ((__always_inline__))
    function() noexcept : __f_(0) {}
    __attribute__ ((__always_inline__))
    function(nullptr_t) noexcept : __f_(0) {}
    function(const function&);
    function(function&&) noexcept;
    template<class _Fp, class = _EnableIfCallable<_Fp>>
    function(_Fp);


    template<class _Alloc>
      __attribute__ ((__always_inline__))
      function(allocator_arg_t, const _Alloc&) noexcept : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, function&&);
    template<class _Fp, class _Alloc, class = _EnableIfCallable<_Fp>>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f);


    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class _Fp, class = _EnableIfCallable<_Fp>>
    function& operator=(_Fp&&);

    ~function();


    void swap(function&) noexcept;


    template<class _Fp, class _Alloc>
      __attribute__ ((__always_inline__))
      void assign(_Fp&& __f, const _Alloc& __a)
        {function(allocator_arg, __a, std::__1::forward<_Fp>(__f)).swap(*this);}



    __attribute__ ((__always_inline__))
        explicit operator bool() const noexcept {return __f_;}


    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:

    _Rp operator()(_ArgTypes...) const;







};

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}


template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}


template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) noexcept
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}


template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     function&& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}


template<class _Rp, class ..._ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f)
    : __f_(0)
{
    if (__function::__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)
        {
            __f_ = ::new((void*)&__buf_) _FF(std::__1::move(__f));
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(std::__1::move(__f), allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}


template<class _Rp, class ..._ArgTypes>
template <class _Fp, class _Alloc, class>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__function::__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;
        typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
        _Ap __a(__a0);
        if (sizeof(_FF) <= sizeof(__buf_) &&
            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)
        {
            __f_ = ::new((void*)&__buf_) _FF(std::__1::move(__f), _Alloc(__a));
        }
        else
        {
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(std::__1::move(__f), _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}


template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) noexcept
{
    if ((void *)__f_ == &__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) noexcept
{
    if ((void *)__f_ == &__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(std::__1::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function()
{
    if ((void *)__f_ == &__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) noexcept
{
    if (std::__1::addressof(__f) == this)
      return;
    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = __as_base(&__tempbuf);
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone(__as_base(&__buf_));
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = __as_base(&__buf_);
        __t->__clone(__as_base(&__f.__buf_));
        __t->destroy();
        __f.__f_ = __as_base(&__f.__buf_);
    }
    else if ((void *)__f_ == &__buf_)
    {
        __f_->__clone(__as_base(&__f.__buf_));
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = __as_base(&__f.__buf_);
    }
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f.__f_->__clone(__as_base(&__buf_));
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = __as_base(&__buf_);
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    if (__f_ == 0)
        __throw_bad_function_call();
    return (*__f_)(std::__1::forward<_ArgTypes>(__arg)...);
}
# 1952 "../../buildtools/third_party/libc++/trunk/include/functional" 3
template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__always_inline__))
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__always_inline__))
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__always_inline__))
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__always_inline__))
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__always_inline__))
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) noexcept
{return __x.swap(__y);}
# 1988 "../../buildtools/third_party/libc++/trunk/include/functional" 3
template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};






template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};






namespace placeholders
{

template <int _Np> struct __ph {};
# 2023 "../../buildtools/third_party/libc++/trunk/include/functional" 3
constexpr __ph<1> _1{};
constexpr __ph<2> _2{};
constexpr __ph<3> _3{};
constexpr __ph<4> _4{};
constexpr __ph<5> _5{};
constexpr __ph<6> _6{};
constexpr __ph<7> _7{};
constexpr __ph<8> _8{};
constexpr __ph<9> _9{};
constexpr __ph<10> _10{};


}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};




template <class _Tp, class _Uj>
inline __attribute__ ((__always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline __attribute__ ((__always_inline__))
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(std::__1::forward<_Uj>(std::__1::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline __attribute__ ((__always_inline__))
typename __lazy_enable_if
<
    is_bind_expression<_Ti>::value,
    __invoke_of<_Ti&, _Uj...>
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return std::__1::forward<typename tuple_element<_Indx, _Uj>::type>(std::__1::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct ____mu_return;

template <bool _Invokable, class _Ti, class ..._Uj>
struct ____mu_return_invokable
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >
    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public ____mu_return<_Ti,
                           __is_reference_wrapper<_Ti>::value,
                           is_bind_expression<_Ti>::value,
                           0 < is_placeholder<_Ti>::value &&
                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                           _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline __attribute__ ((__always_inline__))
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return std::__1::__invoke(__f, std::__1::__mu(std::__1::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      __attribute__ ((__always_inline__))
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(std::__1::forward<_Gp>(__f)),
          __bound_args_(std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__always_inline__))
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        __attribute__ ((__always_inline__))
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;


    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      __attribute__ ((__always_inline__))
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(std::__1::forward<_Gp>(__f),
               std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base&>(*this), std::__1::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base const&>(*this), std::__1::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline __attribute__ ((__always_inline__))
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline __attribute__ ((__always_inline__))
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}
# 2414 "../../buildtools/third_party/libc++/trunk/include/functional" 3
} }
# 193 "../../buildtools/third_party/libc++/trunk/include/mutex" 2 3
# 201 "../../buildtools/third_party/libc++/trunk/include/mutex" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 205 "../../buildtools/third_party/libc++/trunk/include/mutex" 2 3


namespace std {inline namespace __1 {



class recursive_mutex
{
    __libcpp_recursive_mutex_t __m_;

public:
     recursive_mutex();
     ~recursive_mutex();

private:
    recursive_mutex(const recursive_mutex&);
    recursive_mutex& operator=(const recursive_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    void unlock() noexcept;

    typedef __libcpp_recursive_mutex_t* native_handle_type;

    __attribute__ ((__always_inline__))
    native_handle_type native_handle() {return &__m_;}
};

class timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
     timed_mutex();
     ~timed_mutex();

private:
    timed_mutex(const timed_mutex&);
    timed_mutex& operator=(const timed_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    template <class _Rep, class _Period>
        __attribute__ ((__always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>

        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool
timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    unique_lock<mutex> __lk(__m_);
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __locked_)
        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
    if (!__locked_)
    {
        __locked_ = true;
        return true;
    }
    return false;
}

class recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    __libcpp_thread_id __id_;
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

private:
    recursive_timed_mutex(const recursive_timed_mutex&);
    recursive_timed_mutex& operator=(const recursive_timed_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    template <class _Rep, class _Period>
        __attribute__ ((__always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>

        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool
recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    __libcpp_thread_id __id = __libcpp_thread_get_current_id();
    unique_lock<mutex> lk(__m_);
    if (__libcpp_thread_id_equal(__id, __id_))
    {
        if (__count_ == numeric_limits<size_t>::max())
            return false;
        ++__count_;
        return true;
    }
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __count_ != 0)
        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
    if (__count_ == 0)
    {
        __count_ = 1;
        __id_ = __id;
        return true;
    }
    return false;
}

template <class _L0, class _L1>
int
try_lock(_L0& __l0, _L1& __l1)
{
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        if (__l1.try_lock())
        {
            __u0.release();
            return -1;
        }
        else
            return 1;
    }
    return 0;
}



template <class _L0, class _L1, class _L2, class... _L3>
int
try_lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3)
{
    int __r = 0;
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        __r = try_lock(__l1, __l2, __l3...);
        if (__r == -1)
            __u0.release();
        else
            ++__r;
    }
    return __r;
}



template <class _L0, class _L1>
void
lock(_L0& __l0, _L1& __l1)
{
    while (true)
    {
        {
            unique_lock<_L0> __u0(__l0);
            if (__l1.try_lock())
            {
                __u0.release();
                break;
            }
        }
        __libcpp_thread_yield();
        {
            unique_lock<_L1> __u1(__l1);
            if (__l0.try_lock())
            {
                __u1.release();
                break;
            }
        }
        __libcpp_thread_yield();
    }
}



template <class _L0, class _L1, class _L2, class ..._L3>
void
__lock_first(int __i, _L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
{
    while (true)
    {
        switch (__i)
        {
        case 0:
            {
                unique_lock<_L0> __u0(__l0);
                __i = try_lock(__l1, __l2, __l3...);
                if (__i == -1)
                {
                    __u0.release();
                    return;
                }
            }
            ++__i;
            __libcpp_thread_yield();
            break;
        case 1:
            {
                unique_lock<_L1> __u1(__l1);
                __i = try_lock(__l2, __l3..., __l0);
                if (__i == -1)
                {
                    __u1.release();
                    return;
                }
            }
            if (__i == sizeof...(_L3) + 1)
                __i = 0;
            else
                __i += 2;
            __libcpp_thread_yield();
            break;
        default:
            __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
            return;
        }
    }
}

template <class _L0, class _L1, class _L2, class ..._L3>
inline __attribute__ ((__always_inline__))
void
lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
{
    __lock_first(0, __l0, __l1, __l2, __l3...);
}

template <class _L0>
inline __attribute__ ((__always_inline__))
void __unlock(_L0& __l0) {
    __l0.unlock();
}

template <class _L0, class _L1>
inline __attribute__ ((__always_inline__))
void __unlock(_L0& __l0, _L1& __l1) {
    __l0.unlock();
    __l1.unlock();
}

template <class _L0, class _L1, class _L2, class ..._L3>
inline __attribute__ ((__always_inline__))
void __unlock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3) {
    __l0.unlock();
    __l1.unlock();
    std::__1::__unlock(__l2, __l3...);
}
# 552 "../../buildtools/third_party/libc++/trunk/include/mutex" 3
struct once_flag;



template<class _Callable, class... _Args>
__attribute__ ((__always_inline__))
void call_once(once_flag&, _Callable&&, _Args&&...);
# 572 "../../buildtools/third_party/libc++/trunk/include/mutex" 3
struct once_flag
{
    __attribute__ ((__always_inline__))
    constexpr
        once_flag() noexcept : __state_(0) {}

private:
    once_flag(const once_flag&);
    once_flag& operator=(const once_flag&);

    unsigned long __state_;


    template<class _Callable, class... _Args>
    friend
    void call_once(once_flag&, _Callable&&, _Args&&...);
# 597 "../../buildtools/third_party/libc++/trunk/include/mutex" 3
};



template <class _Fp>
class __call_once_param
{
    _Fp& __f_;
public:
    __attribute__ ((__always_inline__))
    explicit __call_once_param(_Fp& __f) : __f_(__f) {}

    __attribute__ ((__always_inline__))
    void operator()()
    {
        typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
        __execute(_Index());
    }

private:
    template <size_t ..._Indices>
    __attribute__ ((__always_inline__))
    void __execute(__tuple_indices<_Indices...>)
    {
        __invoke(std::__1::get<0>(std::__1::move(__f_)), std::__1::get<_Indices>(std::__1::move(__f_))...);
    }
};
# 644 "../../buildtools/third_party/libc++/trunk/include/mutex" 3
template <class _Fp>
void
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

                 void __call_once(volatile unsigned long&, void*, void(*)(void*));



template<class _Callable, class... _Args>
inline __attribute__ ((__always_inline__))
void
call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
{
    if (__libcpp_acquire_load(&__flag.__state_) != ~0ul)
    {
        typedef tuple<_Callable&&, _Args&&...> _Gp;
        _Gp __f(std::__1::forward<_Callable>(__func), std::__1::forward<_Args>(__args)...);
        __call_once_param<_Gp> __p(__f);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
    }
}
# 698 "../../buildtools/third_party/libc++/trunk/include/mutex" 3
} }
# 19 "../../buildtools/third_party/libc++/trunk/include/__locale" 2 3


# 1 "../../buildtools/third_party/libc++/trunk/include/locale.h" 1 3
# 41 "../../buildtools/third_party/libc++/trunk/include/locale.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 3 4
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3 4
# 16 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 3


# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/stddef.h" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 2 3
# 29 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 2 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 2 3 4

extern "C" {
# 53 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 151 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
# 186 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 44 "../../buildtools/third_party/libc++/trunk/include/locale.h" 2 3
# 22 "../../buildtools/third_party/libc++/trunk/include/__locale" 2 3
# 48 "../../buildtools/third_party/libc++/trunk/include/__locale" 3


namespace std {inline namespace __1 {


struct __libcpp_locale_guard {
  __attribute__ ((__always_inline__))
  __libcpp_locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {}

  __attribute__ ((__always_inline__))
  ~__libcpp_locale_guard() {
    if (__old_loc_)
      uselocale(__old_loc_);
  }

  locale_t __old_loc_;
private:
  __libcpp_locale_guard(__libcpp_locale_guard const&);
  __libcpp_locale_guard& operator=(__libcpp_locale_guard const&);
};



class locale;

template <class _Facet>
__attribute__ ((__always_inline__))
bool
has_facet(const locale&) noexcept;

template <class _Facet>
__attribute__ ((__always_inline__))
const _Facet&
use_facet(const locale&);

class locale
{
public:

    class facet;
    class id;

    typedef int category;

    static const category
        none = 0,
        collate = (1 << 3),
        ctype = (1 << 0),
        monetary = (1 << 4),
        numeric = (1 << 1),
        time = (1 << 2),
        messages = (1 << 5),
        all = collate | ctype | monetary | numeric | time | messages;


    locale() noexcept;
    locale(const locale&) noexcept;
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__always_inline__)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) noexcept;

    template <class _Facet>

      locale combine(const locale&) const;


    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>

      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;


    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) noexcept;
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__always_inline__))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();



private:
    virtual void __on_zero_shared() noexcept;
};

class locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__always_inline__)) constexpr id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&);
    id(const id&);
public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__always_inline__))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{
    if (!std::__1::has_facet<_Facet>(__other))
        __throw_runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__always_inline__))
bool
has_facet(const locale& __l) noexcept
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__always_inline__))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }

    __attribute__ ((__always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__always_inline__))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class collate<char>;
extern template class collate<wchar_t>;



template <class _CharT> class collate_byname;

template <>
class collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <>
class collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}



class ctype_base
{
public:

    typedef unsigned short mask;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask cntrl = _IScntrl;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask punct = _ISpunct;
    static const mask xdigit = _ISxdigit;
    static const mask blank = _ISblank;
# 447 "../../buildtools/third_party/libc++/trunk/include/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__always_inline__)) ctype_base() {}
};

template <class _CharT> class ctype;

template <>
class ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__always_inline__))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__always_inline__))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__always_inline__))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <>
class ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);

    __attribute__ ((__always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return (((__c) & ~0x7f) == 0) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = (((*__low) & ~0x7f) == 0) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__always_inline__))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if ((((*__low) & ~0x7f) == 0) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!((((*__low) & ~0x7f) == 0) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__always_inline__))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;




    static const size_t table_size = 256;

    __attribute__ ((__always_inline__)) const mask* table() const noexcept {return __tab_;}
    static const mask* classic_table() noexcept;

    static const int* __classic_upper_table() noexcept;
    static const int* __classic_lower_table() noexcept;






protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT> class ctype_byname;

template <>
class ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template <>
class ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__always_inline__))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class codecvt_base
{
public:
    __attribute__ ((__always_inline__)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template <class _InternT, class _ExternT, class _StateT> class codecvt;



template <>
class codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <class _InternT, class _ExternT, class _StateT>
class codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__always_inline__))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__always_inline__))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}

extern template class codecvt_byname<char, char, mbstate_t>;
extern template class codecvt_byname<wchar_t, char, mbstate_t>;
extern template class codecvt_byname<char16_t, char, mbstate_t>;
extern template class codecvt_byname<char32_t, char, mbstate_t>;

[[noreturn]] void __throw_runtime_error(const char*);

template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

template <>
struct __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__always_inline__))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <>
struct __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__always_inline__))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

template <>
struct __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__always_inline__))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};

template <>
struct __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__always_inline__))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};



template <class _CharT> class numpunct;

template <>
class numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template <>
class numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};



template <class _CharT> class numpunct_byname;

template <>
class numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template <>
class numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }
# 217 "../../buildtools/third_party/libc++/trunk/include/ios" 2 3
# 225 "../../buildtools/third_party/libc++/trunk/include/ios" 3


namespace std {inline namespace __1 {

typedef ptrdiff_t streamsize;

class ios_base
{
public:
    class failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};


    typedef iostate io_state;
    typedef openmode open_mode;
    typedef seekdir seek_dir;

    typedef std::__1::streamoff streamoff;
    typedef std::__1::streampos streampos;


    class Init;


    __attribute__ ((__always_inline__)) fmtflags flags() const;
    __attribute__ ((__always_inline__)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__always_inline__)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__always_inline__)) void unsetf(fmtflags __mask);

    __attribute__ ((__always_inline__)) streamsize precision() const;
    __attribute__ ((__always_inline__)) streamsize precision(streamsize __prec);
    __attribute__ ((__always_inline__)) streamsize width() const;
    __attribute__ ((__always_inline__)) streamsize width(streamsize __wide);


    locale imbue(const locale& __loc);
    locale getloc() const;


    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&);
    ios_base& operator=(const ios_base&);

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__always_inline__)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__always_inline__)) void setstate(iostate __state);

    __attribute__ ((__always_inline__)) bool good() const;
    __attribute__ ((__always_inline__)) bool eof() const;
    __attribute__ ((__always_inline__)) bool fail() const;
    __attribute__ ((__always_inline__)) bool bad() const;

    __attribute__ ((__always_inline__)) iostate exceptions() const;
    __attribute__ ((__always_inline__)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

protected:
    __attribute__ ((__always_inline__))
    ios_base() {
               }

    void init(void* __sb);
    __attribute__ ((__always_inline__)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__always_inline__))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) noexcept;

    __attribute__ ((__always_inline__))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static atomic<int> __xindex_;



    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


enum class io_errc
{
    stream = 1
};


template <>
struct is_error_code_enum<io_errc> : public true_type { };







const error_category& iostream_category() noexcept;

inline __attribute__ ((__always_inline__))
error_code
make_error_code(io_errc __e) noexcept
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__always_inline__))
error_condition
make_error_condition(io_errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    virtual ~failure() throw();
};

class ios_base::Init
{
public:
    Init();
    ~Init();
};



inline __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__always_inline__))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}



inline __attribute__ ((__always_inline__))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__always_inline__))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}



inline __attribute__ ((__always_inline__))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__always_inline__))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}



inline __attribute__ ((__always_inline__))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__always_inline__))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__always_inline__))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__always_inline__))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__always_inline__))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__always_inline__))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__always_inline__))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__always_inline__))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}
# 582 "../../buildtools/third_party/libc++/trunk/include/ios" 3
template <class _CharT, class _Traits>
class basic_ios
    : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
# 604 "../../buildtools/third_party/libc++/trunk/include/ios" 3
    __attribute__ ((__always_inline__))
    explicit operator bool() const {return !fail();}


    __attribute__ ((__always_inline__)) bool operator!() const {return fail();}
    __attribute__ ((__always_inline__)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__always_inline__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__always_inline__)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__always_inline__)) bool good() const {return ios_base::good();}
    __attribute__ ((__always_inline__)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__always_inline__)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__always_inline__)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__always_inline__)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__always_inline__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    __attribute__ ((__always_inline__))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();


    __attribute__ ((__always_inline__))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__always_inline__))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__always_inline__))
    char_type fill() const;
    __attribute__ ((__always_inline__))
    char_type fill(char_type __ch);

    __attribute__ ((__always_inline__))
    locale imbue(const locale& __loc);

    __attribute__ ((__always_inline__))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__always_inline__))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__always_inline__))
    basic_ios() {
                }
    __attribute__ ((__always_inline__))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__always_inline__))
    void move(basic_ios& __rhs);

    __attribute__ ((__always_inline__))
    void move(basic_ios&& __rhs) {move(__rhs);}

    __attribute__ ((__always_inline__))
    void swap(basic_ios& __rhs) noexcept;
    __attribute__ ((__always_inline__))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
     mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = 0;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = 0;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) noexcept
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, __rhs.__tie_);
    std::__1::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline __attribute__ ((__always_inline__))
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__always_inline__))
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__always_inline__))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__always_inline__))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 139 "../../buildtools/third_party/libc++/trunk/include/ostream" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/streambuf" 1 3
# 117 "../../buildtools/third_party/libc++/trunk/include/streambuf" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 121 "../../buildtools/third_party/libc++/trunk/include/streambuf" 2 3

namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class basic_streambuf
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();


    inline __attribute__((__always_inline__))
    locale pubimbue(const locale& __loc) {
        imbue(__loc);
        locale __r = __loc_;
        __loc_ = __loc;
        return __r;
    }

    inline __attribute__((__always_inline__))
    locale getloc() const { return __loc_; }


    inline __attribute__((__always_inline__))
    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)
    { return setbuf(__s, __n); }

    inline __attribute__((__always_inline__))
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekoff(__off, __way, __which); }

    inline __attribute__((__always_inline__))
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekpos(__sp, __which); }

    inline __attribute__((__always_inline__))
    int pubsync() { return sync(); }



    inline __attribute__((__always_inline__))
    streamsize in_avail() {
        if (__ninp_ < __einp_)
            return static_cast<streamsize>(__einp_ - __ninp_);
        return showmanyc();
    }

    inline __attribute__((__always_inline__))
    int_type snextc() {
        if (sbumpc() == traits_type::eof())
            return traits_type::eof();
        return sgetc();
    }

    inline __attribute__((__always_inline__))
    int_type sbumpc() {
        if (__ninp_ == __einp_)
            return uflow();
        return traits_type::to_int_type(*__ninp_++);
    }

    inline __attribute__((__always_inline__))
    int_type sgetc() {
        if (__ninp_ == __einp_)
            return underflow();
        return traits_type::to_int_type(*__ninp_);
    }

    inline __attribute__((__always_inline__))
    streamsize sgetn(char_type* __s, streamsize __n)
    { return xsgetn(__s, __n); }


    inline __attribute__((__always_inline__))
    int_type sputbackc(char_type __c) {
        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
            return pbackfail(traits_type::to_int_type(__c));
        return traits_type::to_int_type(*--__ninp_);
    }

    inline __attribute__((__always_inline__))
    int_type sungetc() {
        if (__binp_ == __ninp_)
          return pbackfail();
        return traits_type::to_int_type(*--__ninp_);
    }


    inline __attribute__((__always_inline__))
    int_type sputc(char_type __c) {
        if (__nout_ == __eout_)
            return overflow(traits_type::to_int_type(__c));
        *__nout_++ = __c;
        return traits_type::to_int_type(__c);
    }

    inline __attribute__((__always_inline__))
    streamsize sputn(const char_type* __s, streamsize __n)
    { return xsputn(__s, __n); }

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);


    __attribute__ ((__always_inline__)) char_type* eback() const {return __binp_;}
    __attribute__ ((__always_inline__)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__always_inline__)) char_type* egptr() const {return __einp_;}

    inline __attribute__((__always_inline__))
    void gbump(int __n) { __ninp_ += __n; }

    inline __attribute__((__always_inline__))
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
        __binp_ = __gbeg;
        __ninp_ = __gnext;
        __einp_ = __gend;
    }


    __attribute__ ((__always_inline__)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__always_inline__)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__always_inline__)) char_type* epptr() const {return __eout_;}

    inline __attribute__((__always_inline__))
    void pbump(int __n) { __nout_ += __n; }

    __attribute__ ((__always_inline__))
    void __pbump(streamsize __n) { __nout_ += __n; }

    inline __attribute__((__always_inline__))
    void setp(char_type* __pbeg, char_type* __pend) {
        __bout_ = __nout_ = __pbeg;
        __eout_ = __pend;
    }



    virtual void imbue(const locale& __loc);


    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(0),
      __ninp_(0),
      __einp_(0),
      __bout_(0),
      __nout_(0),
      __eout_(0)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__1::swap(__loc_, __sb.__loc_);
    std::__1::swap(__binp_, __sb.__binp_);
    std::__1::swap(__ninp_, __sb.__ninp_);
    std::__1::swap(__einp_, __sb.__einp_);
    std::__1::swap(__bout_, __sb.__bout_);
    std::__1::swap(__nout_, __sb.__nout_);
    std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    while(__i < __n)
    {
        if (__ninp_ < __einp_)
        {
            const streamsize __len = std::__1::min(static_cast<streamsize>(2147483647),
                                std::__1::min(__einp_ - __ninp_, __n - __i));
            traits_type::copy(__s, __ninp_, __len);
            __s += __len;
            __i += __len;
            this->gbump(__len);
        }
        else if ((__c = uflow()) != __eof)
        {
            *__s = traits_type::to_char_type(__c);
            ++__s;
            ++__i;
        }
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    while( __i < __n)
    {
        if (__nout_ >= __eout_)
        {
            if (overflow(traits_type::to_int_type(*__s)) == __eof)
                break;
            ++__s;
            ++__i;
        }
        else
        {
            streamsize __chunk_size = std::__1::min(__eout_ - __nout_, __n - __i);
            traits_type::copy(__nout_, __s, __chunk_size);
            __nout_ += __chunk_size;
            __s += __chunk_size;
            __i += __chunk_size;
        }
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}


extern template class basic_streambuf<char>;
extern template class basic_streambuf<wchar_t>;

extern template class basic_ios<char>;
extern template class basic_ios<wchar_t>;


} }
# 140 "../../buildtools/third_party/libc++/trunk/include/ostream" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/locale" 1 3
# 191 "../../buildtools/third_party/libc++/trunk/include/locale" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/cstdarg" 1 3
# 40 "../../buildtools/third_party/libc++/trunk/include/cstdarg" 3


namespace std {inline namespace __1 {

using ::va_list;

} }
# 192 "../../buildtools/third_party/libc++/trunk/include/locale" 2 3





# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/nl_types.h" 1 3 4
# 30 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/nl_types.h" 3 4
extern "C" {


typedef void *nl_catd;


typedef int nl_item;





extern nl_catd catopen (const char *__cat_name, int __flag) __attribute__ ((__nonnull__ (1)));



extern char *catgets (nl_catd __catalog, int __set, int __number,
        const char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern int catclose (nl_catd __catalog) throw () __attribute__ ((__nonnull__ (1)));

}
# 198 "../../buildtools/third_party/libc++/trunk/include/locale" 2 3
# 207 "../../buildtools/third_party/libc++/trunk/include/locale" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__bsd_locale_fallbacks.h" 1 3
# 17 "../../buildtools/third_party/libc++/trunk/include/__bsd_locale_fallbacks.h" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/stdlib.h" 1 3
# 18 "../../buildtools/third_party/libc++/trunk/include/__bsd_locale_fallbacks.h" 2 3
# 23 "../../buildtools/third_party/libc++/trunk/include/__bsd_locale_fallbacks.h" 3


namespace std {inline namespace __1 {

inline __attribute__ ((__always_inline__))
decltype((__ctype_get_mb_cur_max ())) __libcpp_mb_cur_max_l(locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return (__ctype_get_mb_cur_max ());
}

inline __attribute__ ((__always_inline__))
wint_t __libcpp_btowc_l(int __c, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return btowc(__c);
}

inline __attribute__ ((__always_inline__))
int __libcpp_wctob_l(wint_t __c, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wctob(__c);
}

inline __attribute__ ((__always_inline__))
size_t __libcpp_wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,
                         size_t __len, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wcsnrtombs(__dest, __src, __nwc, __len, __ps);
}

inline __attribute__ ((__always_inline__))
size_t __libcpp_wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wcrtomb(__s, __wc, __ps);
}

inline __attribute__ ((__always_inline__))
size_t __libcpp_mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,
                      size_t __len, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbsnrtowcs(__dest, __src, __nms, __len, __ps);
}

inline __attribute__ ((__always_inline__))
size_t __libcpp_mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,
                   mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbrtowc(__pwc, __s, __n, __ps);
}

inline __attribute__ ((__always_inline__))
int __libcpp_mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbtowc(__pwc, __pmb, __max);
}

inline __attribute__ ((__always_inline__))
size_t __libcpp_mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbrlen(__s, __n, __ps);
}

inline __attribute__ ((__always_inline__))
lconv *__libcpp_localeconv_l(locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return localeconv();
}

inline __attribute__ ((__always_inline__))
size_t __libcpp_mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,
                     mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbsrtowcs(__dest, __src, __len, __ps);
}

inline
int __libcpp_snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);
    int __res = vsnprintf(__s, __n, __format, __va);
    __builtin_va_end(__va);
    return __res;
}

inline
int __libcpp_asprintf_l(char **__s, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);
    int __res = vasprintf(__s, __format, __va);
    __builtin_va_end(__va);
    return __res;
}

inline
int __libcpp_sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);
    int __res = vsscanf(__s, __format, __va);
    __builtin_va_end(__va);
    return __res;
}

} }
# 208 "../../buildtools/third_party/libc++/trunk/include/locale" 2 3
# 212 "../../buildtools/third_party/libc++/trunk/include/locale" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 216 "../../buildtools/third_party/libc++/trunk/include/locale" 2 3


namespace std {inline namespace __1 {
# 227 "../../buildtools/third_party/libc++/trunk/include/locale" 3
                    locale_t __cloc();
# 249 "../../buildtools/third_party/libc++/trunk/include/locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>

_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == 0)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {

        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;






        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (__b == __e)
        __err |= ios_base::eofbit;

    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};


void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);

    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);

    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
# 423 "../../buildtools/third_party/libc++/trunk/include/locale" 3
};


template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}


template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int

__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)






{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __num_get<char>;
extern template struct __num_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__always_inline__))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    ~num_get() {}

    template <class _Fp>

    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>

    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>

    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
_Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*__errno_location ()))>::type __save_errno = (*__errno_location ());
        (*__errno_location ()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, __cloc());
        typename remove_reference<decltype((*__errno_location ()))>::type __current_errno = (*__errno_location ());
        if (__current_errno == 0)
            (*__errno_location ()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        if (*__a == '-')
        {
            __err = ios_base::failbit;
            return 0;
        }
        typename remove_reference<decltype((*__errno_location ()))>::type __save_errno = (*__errno_location ());
        (*__errno_location ()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, __cloc());
        typename remove_reference<decltype((*__errno_location ()))>::type __current_errno = (*__errno_location ());
        if (__current_errno == 0)
            (*__errno_location ()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__always_inline__))
_Tp __do_strtod(const char* __a, char** __p2);

template <>
inline __attribute__ ((__always_inline__))
float __do_strtod<float>(const char* __a, char** __p2) {
    return strtof_l(__a, __p2, __cloc());
}

template <>
inline __attribute__ ((__always_inline__))
double __do_strtod<double>(const char* __a, char** __p2) {
    return strtod_l(__a, __p2, __cloc());
}

template <>
inline __attribute__ ((__always_inline__))
long double __do_strtod<long double>(const char* __a, char** __p2) {
    return strtold_l(__a, __p2, __cloc());
}

template <class _Tp>

_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*__errno_location ()))>::type __save_errno = (*__errno_location ());
        (*__errno_location ()) = 0;
        char *__p2;
        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
        typename remove_reference<decltype((*__errno_location ()))>::type __current_errno = (*__errno_location ());
        if (__current_errno == 0)
            (*__errno_location ()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return __ld;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,
                                            __ct, __err);
    __v = __i == __names;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_float<_Fp>(__a, __a_end, __err);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }

    __buf.resize(__a_end - __a);
    if (__libcpp_sscanf_l(__buf.c_str(), __cloc(), "%p", &__v) != 1)
        __err = ios_base::failbit;

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class num_get<char>;
extern template class num_get<wchar_t>;

struct __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!((((__cloc())))->__ctype_b[(int) (((*__ns)))] & (unsigned short int) _ISxdigit))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!((((__cloc())))->__ctype_b[(int) (((*__ns)))] & (unsigned short int) _ISdigit))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __num_put<char>;
extern template struct __num_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__always_inline__))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>

_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}





template <class _CharT, class _Traits>

ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == nullptr)
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}



template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
                          + ((numeric_limits<long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
                          + ((numeric_limits<long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt,
                                   (int)__iob.precision(), __v);
    else
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);
        else
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, __v);
        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt,
                                   (int)__iob.precision(), __v);
    else
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);
        else
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, __v);
        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{

    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class num_put<char>;
extern template class num_put<wchar_t>;

template <class _CharT, class _InputIterator>

int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{

    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
    {

        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;

    __attribute__ ((__always_inline__))
    ~__time_get_c_storage() {}
};

template <> const string* __time_get_c_storage<char>::__weeks() const;
template <> const string* __time_get_c_storage<char>::__months() const;
template <> const string* __time_get_c_storage<char>::__am_pm() const;
template <> const string& __time_get_c_storage<char>::__c() const;
template <> const string& __time_get_c_storage<char>::__r() const;
template <> const string& __time_get_c_storage<char>::__x() const;
template <> const string& __time_get_c_storage<char>::__X() const;

template <> const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <> const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <> const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <> const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <> const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <> const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <> const wstring& __time_get_c_storage<wchar_t>::__X() const;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__always_inline__))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__always_inline__))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__always_inline__))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__always_inline__))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__always_inline__))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{

    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{

    const string_type* __month = this->__months();
    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class time_get<char>;
extern template class time_get<wchar_t>;

class __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__always_inline__)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__always_inline__))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__always_inline__))
    ~time_get_byname() {}

    __attribute__ ((__always_inline__))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__always_inline__))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__always_inline__))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__always_inline__))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__always_inline__))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__always_inline__))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__always_inline__))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__always_inline__))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class time_get_byname<char>;
extern template class time_get_byname<wchar_t>;

class __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__always_inline__)) __time_put() : __loc_(__cloc()) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__always_inline__))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__always_inline__))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__always_inline__))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__1::copy(__nb, __ne, __s);
}

extern template class time_put<char>;
extern template class time_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__always_inline__))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__always_inline__))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__always_inline__))
    ~time_put_byname() {}
};

extern template class time_put_byname<char>;
extern template class time_put_byname<wchar_t>;



class money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__always_inline__)) money_base() {}
};



template <class _CharT, bool _International = false>
class moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__always_inline__)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__always_inline__)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__always_inline__)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__always_inline__)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__always_inline__)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__always_inline__)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__always_inline__))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class moneypunct<char, false>;
extern template class moneypunct<char, true>;
extern template class moneypunct<wchar_t, false>;
extern template class moneypunct<wchar_t, true>;



template <class _CharT, bool _International = false>
class moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__always_inline__))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__always_inline__))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> void moneypunct_byname<char, false>::init(const char*);
template<> void moneypunct_byname<char, true>::init(const char*);
template<> void moneypunct_byname<wchar_t, false>::init(const char*);
template<> void moneypunct_byname<wchar_t, true>::init(const char*);

extern template class moneypunct_byname<char, false>;
extern template class moneypunct_byname<char, true>;
extern template class moneypunct_byname<wchar_t, false>;
extern template class moneypunct_byname<wchar_t, true>;



template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __money_get<char>;
extern template class __money_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__always_inline__))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

                 void __do_nothing(void*);

template <class _Tp>

void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    if (__new_cap == 0)
        __new_cap = sizeof(_Tp);
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            ((void)0);
        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                {
                    if (__psn.size() > 0)
                    {
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(0, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == 0)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class money_get<char>;
extern template class money_get<wchar_t>;



template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {

            char_type* __t = __me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }

            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }

            reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() > 1)
        __me = std::__1::copy(__sn.begin()+1, __sn.end(), __me);

    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __money_put<char>;
extern template class __money_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__always_inline__))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
    unique_ptr<char, void(*)(void*)> __hn(0, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);

    if (__n > __bs-1)
    {
        __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, __cloc(), "%.0Lf", __units));
        if (__bb == 0)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
        if (__hd == nullptr)
            __throw_bad_alloc();
        __db = __hd.get();
    }

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = static_cast<int>(__n) > __fd ?
                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +
                    __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class money_put<char>;
extern template class money_put<wchar_t>;



class messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__always_inline__)) messages_base() {}
};

template <class _CharT>
class messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__always_inline__))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__always_inline__))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__always_inline__))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__always_inline__))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__always_inline__))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{

    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;



}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{

    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(back_inserter(__w),
                                                        __n, __n + strlen(__n));
    return __w;



}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);

}

extern template class messages<char>;
extern template class messages<wchar_t>;

template <class _CharT>
class messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__always_inline__))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__always_inline__))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__always_inline__))
    ~messages_byname() {}
};

extern template class messages_byname<char>;
extern template class messages_byname<wchar_t>;

template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:
    __attribute__ ((__always_inline__))
    explicit wstring_convert(_Codecvt* __pcvt = new _Codecvt);
    __attribute__ ((__always_inline__))
    wstring_convert(_Codecvt* __pcvt, state_type __state);
    explicit wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());

    __attribute__ ((__always_inline__))
    wstring_convert(wstring_convert&& __wc);

    ~wstring_convert();

    __attribute__ ((__always_inline__))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__always_inline__))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__always_inline__))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__always_inline__))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__always_inline__))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__always_inline__))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__always_inline__))
    size_t converted() const noexcept {return __cvtcount_;}
    __attribute__ ((__always_inline__))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(wstring_convert&& __wc)
        : __byte_err_string_(std::__1::move(__wc.__byte_err_string_)),
          __wide_err_string_(std::__1::move(__wc.__wide_err_string_)),
          __cvtptr_(__wc.__cvtptr_),
          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)
{
    __wc.__cvtptr_ = nullptr;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);

                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        __throw_range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);

                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        __throw_range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:

    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);
public:
    explicit wbuffer_convert(streambuf* __bytebuf = 0,
            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
    ~wbuffer_convert();

    __attribute__ ((__always_inline__))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__always_inline__))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__always_inline__))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
             ((void)0);
             if (__extbufend_ != __extbufnext_)
                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;


            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                               (char_type*) const_cast<char *>(__extbufend_));
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type *>(__e), this->pptr());
                        this->__pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
        return pos_type(off_type(-1));
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = 0;
    if (__cv_ != 0 && __bufptr_ != 0)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = 0;
    }
    return __rt;
}

} }
# 141 "../../buildtools/third_party/libc++/trunk/include/ostream" 2 3

# 1 "../../buildtools/third_party/libc++/trunk/include/bitset" 1 3
# 117 "../../buildtools/third_party/libc++/trunk/include/bitset" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__bit_reference" 1 3
# 19 "../../buildtools/third_party/libc++/trunk/include/__bit_reference" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 23 "../../buildtools/third_party/libc++/trunk/include/__bit_reference" 2 3


namespace std {inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;

    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__always_inline__)) operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__always_inline__)) bool operator ~() const noexcept
        {return !static_cast<bool>(*this);}

    __attribute__ ((__always_inline__))
    __bit_reference& operator=(bool __x) noexcept
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__always_inline__))
    __bit_reference& operator=(const __bit_reference& __x) noexcept
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__always_inline__)) void flip() noexcept {*__seg_ ^= __mask_;}
    __attribute__ ((__always_inline__)) __bit_iterator<_Cp, false> operator&() const noexcept
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__always_inline__))
    __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
void
swap(__bit_reference<_Cp> __x, bool& __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
void
swap(bool& __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;
    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__always_inline__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__always_inline__)) constexpr operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__always_inline__)) __bit_iterator<_Cp, true> operator&() const noexcept
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__always_inline__))
    constexpr
    __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference& __x);
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__always_inline__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__always_inline__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__always_inline__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            __fill_n_true(__first, __n);
        else
            __fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__always_inline__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return __copy_aligned(__first, __last, __result);
    return __copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return __copy_backward_aligned(__first, __last, __result);
    return __copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy_backward(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__always_inline__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __swap_ranges_aligned(__first1, __last1, __first2);
    return __swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__always_inline__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__always_inline__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__always_inline__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__always_inline__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __equal_aligned(__first1, __last1, __first2);
    return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__always_inline__)) __bit_iterator() noexcept

    : __seg_(nullptr), __ctz_(0)

    {}

    __attribute__ ((__always_inline__))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) noexcept
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    __attribute__ ((__always_inline__)) reference operator*() const noexcept
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__always_inline__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__always_inline__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__always_inline__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__always_inline__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__always_inline__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__always_inline__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__always_inline__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__always_inline__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__always_inline__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__always_inline__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__always_inline__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
        : __seg_(__s), __ctz_(__ctz) {}

    friend typename _Cp::__self;

    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 118 "../../buildtools/third_party/libc++/trunk/include/bitset" 2 3
# 127 "../../buildtools/third_party/libc++/trunk/include/bitset" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 131 "../../buildtools/third_party/libc++/trunk/include/bitset" 2 3


namespace std {inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__always_inline__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__always_inline__)) reference __make_ref(size_t __pos) noexcept
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__always_inline__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__always_inline__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__always_inline__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__always_inline__))
    void operator^=(const __bitset& __v) noexcept;

    void flip() noexcept;
    __attribute__ ((__always_inline__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__always_inline__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const noexcept;
    bool any() const noexcept;
    __attribute__ ((__always_inline__))
    size_t __hash_code() const noexcept;
private:





    unsigned long to_ulong(false_type) const;
    __attribute__ ((__always_inline__))
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    __attribute__ ((__always_inline__))
    unsigned long long to_ullong(true_type) const;
    __attribute__ ((__always_inline__))
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset() noexcept

    : __first_{0}

{



}
# 256 "../../buildtools/third_party/libc++/trunk/include/bitset" 3
template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept


    : __first_{__v}






{



}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() noexcept
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ulong overflow error");

    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ullong overflow error");

    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline
size_t
__bitset<_N_words, _Size>::__hash_code() const noexcept
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__always_inline__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__always_inline__)) reference __make_ref(size_t __pos) noexcept
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__always_inline__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__always_inline__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__always_inline__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__always_inline__))
    void operator^=(const __bitset& __v) noexcept;

    __attribute__ ((__always_inline__))
    void flip() noexcept;

    __attribute__ ((__always_inline__))
    unsigned long to_ulong() const;
    __attribute__ ((__always_inline__))
    unsigned long long to_ullong() const;

    __attribute__ ((__always_inline__))
    bool all() const noexcept;
    __attribute__ ((__always_inline__))
    bool any() const noexcept;

    __attribute__ ((__always_inline__))
    size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset() noexcept
    : __first_(0)
{
}

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(static_cast<__storage_type>(__v))
{
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::flip() noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::all() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::any() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline
size_t
__bitset<1, _Size>::__hash_code() const noexcept
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__always_inline__))
    explicit constexpr __bitset(unsigned long long) noexcept;

    __attribute__ ((__always_inline__)) reference __make_ref(size_t) noexcept
        {return reference(0, 1);}
    __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t) const noexcept
        {return const_reference(0, 1);}
    __attribute__ ((__always_inline__)) iterator __make_iter(size_t) noexcept
        {return iterator(0, 0);}
    __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t) const noexcept
        {return const_iterator(0, 0);}

    __attribute__ ((__always_inline__)) void operator&=(const __bitset&) noexcept {}
    __attribute__ ((__always_inline__)) void operator|=(const __bitset&) noexcept {}
    __attribute__ ((__always_inline__)) void operator^=(const __bitset&) noexcept {}

    __attribute__ ((__always_inline__)) void flip() noexcept {}

    __attribute__ ((__always_inline__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__always_inline__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__always_inline__)) bool all() const noexcept {return true;}
    __attribute__ ((__always_inline__)) bool any() const noexcept {return false;}

    __attribute__ ((__always_inline__)) size_t __hash_code() const noexcept {return 0;}
};

inline
constexpr
__bitset<0, 0>::__bitset() noexcept
{
}

inline
constexpr
__bitset<0, 0>::__bitset(unsigned long long) noexcept
{
}

template <size_t _Size> class bitset;
template <size_t _Size> struct hash<bitset<_Size> >;

template <size_t _Size>
class bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__always_inline__)) constexpr bitset() noexcept {}
    __attribute__ ((__always_inline__)) constexpr
        bitset(unsigned long long __v) noexcept : base(__v) {}
    template<class _CharT>
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    __attribute__ ((__always_inline__))
    bitset& operator&=(const bitset& __rhs) noexcept;
    __attribute__ ((__always_inline__))
    bitset& operator|=(const bitset& __rhs) noexcept;
    __attribute__ ((__always_inline__))
    bitset& operator^=(const bitset& __rhs) noexcept;
    bitset& operator<<=(size_t __pos) noexcept;
    bitset& operator>>=(size_t __pos) noexcept;
    __attribute__ ((__always_inline__))
    bitset& set() noexcept;
    bitset& set(size_t __pos, bool __val = true);
    __attribute__ ((__always_inline__))
    bitset& reset() noexcept;
    bitset& reset(size_t __pos);
    __attribute__ ((__always_inline__))
    bitset operator~() const noexcept;
    __attribute__ ((__always_inline__))
    bitset& flip() noexcept;
    bitset& flip(size_t __pos);


    __attribute__ ((__always_inline__)) constexpr
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__always_inline__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    __attribute__ ((__always_inline__))
    unsigned long to_ulong() const;
    __attribute__ ((__always_inline__))
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        __attribute__ ((__always_inline__))
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        __attribute__ ((__always_inline__))
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    __attribute__ ((__always_inline__))
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    __attribute__ ((__always_inline__))
    size_t count() const noexcept;
    __attribute__ ((__always_inline__)) constexpr size_t size() const noexcept {return _Size;}
    __attribute__ ((__always_inline__))
    bool operator==(const bitset& __rhs) const noexcept;
    __attribute__ ((__always_inline__))
    bool operator!=(const bitset& __rhs) const noexcept;
    bool test(size_t __pos) const;
    __attribute__ ((__always_inline__))
    bool all() const noexcept;
    __attribute__ ((__always_inline__))
    bool any() const noexcept;
    __attribute__ ((__always_inline__)) bool none() const noexcept {return !any();}
    __attribute__ ((__always_inline__))
    bitset operator<<(size_t __pos) const noexcept;
    __attribute__ ((__always_inline__))
    bitset operator>>(size_t __pos) const noexcept;

private:

    __attribute__ ((__always_inline__))
    size_t __hash_code() const noexcept {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())
        __throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) noexcept
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) noexcept
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) noexcept
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::set() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset set argument out of range");

    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::reset() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset reset argument out of range");

    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator~() const noexcept
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::flip() noexcept
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset flip argument out of range");

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline
size_t
bitset<_Size>::count() const noexcept
{
    return static_cast<size_t>(std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator==(const bitset& __rhs) const noexcept
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator!=(const bitset& __rhs) const noexcept
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset test argument out of range");

    return (*this)[__pos];
}

template <size_t _Size>
inline
bool
bitset<_Size>::all() const noexcept
{
    return base::all();
}

template <size_t _Size>
inline
bool
bitset<_Size>::any() const noexcept
{
    return base::any();
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__always_inline__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__always_inline__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__always_inline__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(const bitset<_Size>& __bs) const noexcept
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 143 "../../buildtools/third_party/libc++/trunk/include/ostream" 2 3
# 146 "../../buildtools/third_party/libc++/trunk/include/ostream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__((__always_inline__))
    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
    { this->init(__sb); }
    virtual ~basic_ostream();
protected:

    inline __attribute__ ((__always_inline__))
    basic_ostream(basic_ostream&& __rhs);


    inline __attribute__ ((__always_inline__))
    basic_ostream& operator=(basic_ostream&& __rhs);

    inline __attribute__((__always_inline__))
    void swap(basic_ostream& __rhs)
    { basic_ios<char_type, traits_type>::swap(__rhs); }


    basic_ostream (const basic_ostream& __rhs) = delete;
    basic_ostream& operator=(const basic_ostream& __rhs) = delete;




public:


    class sentry;


    inline __attribute__((__always_inline__))
    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))
    { return __pf(*this); }

    inline __attribute__((__always_inline__))
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__((__always_inline__))
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);


    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();


    inline __attribute__((__always_inline__))
    pos_type tellp();
    inline __attribute__((__always_inline__))
    basic_ostream& seekp(pos_type __pos);
    inline __attribute__((__always_inline__))
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__always_inline__))
    basic_ostream() {}
};

template <class _CharT, class _Traits>
class basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__always_inline__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {




            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);






    }
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)
{
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{




        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {




                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);







            }
            else
                this->setstate(ios_base::badbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{




        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{




        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }







    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }







    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }







    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{




        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{




        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{




        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }







    return *this;
}

template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}



template <class _Stream, class _Tp>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    !is_lvalue_reference<_Stream>::value &&
    is_base_of<ios_base, _Stream>::value,
    _Stream&&
>::type
operator<<(_Stream&& __os, const _Tp& __x)
{
    __os << __x;
    return std::__1::move(__os);
}



template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string_view<_CharT, _Traits> __sv)
{
    return std::__1::__put_character_sequence(__os, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}


extern template class basic_ostream<char>;
extern template class basic_ostream<wchar_t>;


} }
# 175 "../../buildtools/third_party/libc++/trunk/include/sstream" 2 3
# 1 "../../buildtools/third_party/libc++/trunk/include/istream" 1 3
# 167 "../../buildtools/third_party/libc++/trunk/include/istream" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 171 "../../buildtools/third_party/libc++/trunk/include/istream" 2 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__((__always_inline__))
    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)
    { this->init(__sb); }
    virtual ~basic_istream();
protected:

    inline __attribute__ ((__always_inline__))
    basic_istream(basic_istream&& __rhs);


    inline __attribute__ ((__always_inline__))
    basic_istream& operator=(basic_istream&& __rhs);


    inline __attribute__((__always_inline__))
    void swap(basic_istream& __rhs) {
      std::__1::swap(__gc_, __rhs.__gc_);
      basic_ios<char_type, traits_type>::swap(__rhs);
    }


    basic_istream (const basic_istream& __rhs) = delete;
    basic_istream& operator=(const basic_istream& __rhs) = delete;

public:


    class sentry;


    inline __attribute__((__always_inline__))
    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))
    { return __pf(*this); }

    inline __attribute__((__always_inline__))
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__((__always_inline__))
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    basic_istream& operator>>(float& __f);
    basic_istream& operator>>(double& __f);
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);


    __attribute__ ((__always_inline__))
    streamsize gcount() const {return __gc_;}
    int_type get();

    inline __attribute__((__always_inline__))
    basic_istream& get(char_type& __c) {
      int_type __ch = get();
      if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
      return *this;
    }

    inline __attribute__((__always_inline__))
    basic_istream& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);

    inline __attribute__((__always_inline__))
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)
    { return get(__sb, this->widen('\n')); }

    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    inline __attribute__((__always_inline__))
    basic_istream& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);


    __attribute__ ((__always_inline__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)
    : __gc_(__rhs.__gc_)
{
    __rhs.__gc_ = 0;
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<short>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::min();
            }
            else if (__temp > numeric_limits<short>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::max();
            }
            else
                __n = static_cast<short>(__temp);
            this->setstate(__err);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<int>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::min();
            }
            else if (__temp > numeric_limits<int>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::max();
            }
            else
                __n = static_cast<int>(__temp);
            this->setstate(__err);
        }







    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{




        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n-1)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }







    return __is;
}

template<class _Traits>
inline __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{




        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __is.setstate(ios_base::eofbit | ios_base::failbit);
            else
                __c = _Traits::to_char_type(__i);
        }







    return __is;
}

template<class _Traits>
inline __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    __gc_ = 0;




        sentry __s(*this, true);
        if (__s)
        {
            if (__sb)
            {




                    ios_base::iostate __err = ios_base::goodbit;
                    while (true)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sgetc();
                        if (traits_type::eq_int_type(__i, _Traits::eof()))
                        {
                           __err |= ios_base::eofbit;
                           break;
                        }
                        if (traits_type::eq_int_type(
                                __sb->sputc(traits_type::to_char_type(__i)),
                                traits_type::eof()))
                            break;
                        ++__gc_;
                        this->rdbuf()->sbumpc();
                    }
                    if (__gc_ == 0)
                       __err |= ios_base::failbit;
                    this->setstate(__err);
# 890 "../../buildtools/third_party/libc++/trunk/include/istream" 3
            }
            else
                this->setstate(ios_base::failbit);
        }







    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();




        sentry __s(*this, true);
        if (__s)
        {
            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               this->setstate(ios_base::failbit | ios_base::eofbit);
            else
                __gc_ = 1;
        }







    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;




        sentry __sen(*this, true);
        if (__sen)
        {
            if (__n > 0)
            {
                ios_base::iostate __err = ios_base::goodbit;
                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                *__s = char_type();
                if (__gc_ == 0)
                   __err |= ios_base::failbit;
                this->setstate(__err);
            }
            else
                this->setstate(ios_base::failbit);
        }







    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    __gc_ = 0;




        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;




                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }






            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }







    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;




        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __err |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }
            if (__n > 0)
                *__s = char_type();
            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }







    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    __gc_ = 0;




        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            this->setstate(__err);
        }







    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();




        sentry __sen(*this, true);
        if (__sen)
        {
            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                this->setstate(ios_base::eofbit);
        }







    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    __gc_ = 0;




        sentry __sen(*this, true);
        if (__sen)
        {
            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                this->setstate(ios_base::failbit | ios_base::eofbit);
        }
        else
            this->setstate(ios_base::failbit);







    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    __gc_ = 0;




        sentry __sen(*this, true);
        if (__sen)
        {
            streamsize __c = this->rdbuf()->in_avail();
            switch (__c)
            {
            case -1:
                this->setstate(ios_base::eofbit);
                break;
            case 0:
                break;
            default:
                read(__s, std::__1::min(__c, __n));
                break;
            }
        }
        else
            this->setstate(ios_base::failbit);







    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    __gc_ = 0;




        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);







    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    __gc_ = 0;




        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);







    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    int __r = 0;




        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                this->setstate(ios_base::badbit);
                return -1;
            }
        }







    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    pos_type __r(-1);




        sentry __sen(*this, true);
        if (__sen)
            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);







    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{




        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }







    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{




        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{




        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __is.setstate(ios_base::eofbit);
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }
        }







    return __is;
}



template <class _CharT, class _Traits, class _Tp>
inline __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x)
{
    __is >> std::__1::forward<_Tp>(__x);
    return __is;
}



template <class _CharT, class _Traits>
class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__((__always_inline__))
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
      : basic_istream<_CharT, _Traits>(__sb)
    {}

    virtual ~basic_iostream();
protected:

    inline __attribute__ ((__always_inline__))
    basic_iostream(basic_iostream&& __rhs);


    inline __attribute__ ((__always_inline__))
    basic_iostream& operator=(basic_iostream&& __rhs);

    inline __attribute__((__always_inline__))
    void swap(basic_iostream& __rhs)
    { basic_istream<char_type, traits_type>::swap(__rhs); }
public:
};



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)
    : basic_istream<_CharT, _Traits>(std::__1::move(__rhs))
{
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>&
basic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{




        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);







    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{




        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            __str.clear();
            ios_base::iostate __err = ios_base::goodbit;
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __err |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }







    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    return getline(__is, __str, __dlm);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{




        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            size_t __c = 0;
            ios_base::iostate __err = ios_base::goodbit;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);







    return __is;
}


extern template class basic_istream<char>;
extern template class basic_istream<wchar_t>;
extern template class basic_iostream<char>;


} }
# 176 "../../buildtools/third_party/libc++/trunk/include/sstream" 2 3
# 180 "../../buildtools/third_party/libc++/trunk/include/sstream" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 184 "../../buildtools/third_party/libc++/trunk/include/sstream" 2 3


namespace std {inline namespace __1 {



template <class _CharT, class _Traits, class _Allocator>
class basic_stringbuf
    : public basic_streambuf<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:

    string_type __str_;
    mutable char_type* __hm_;
    ios_base::openmode __mode_;

public:

    inline __attribute__ ((__always_inline__))
    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);
    inline __attribute__ ((__always_inline__))
    explicit basic_stringbuf(const string_type& __s,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);

    basic_stringbuf(basic_stringbuf&& __rhs);


    basic_stringbuf& operator=(basic_stringbuf&& __rhs);

    void swap(basic_stringbuf& __rhs);


    string_type str() const;
    void str(const string_type& __s);

protected:

    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    inline __attribute__ ((__always_inline__))
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
};

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)
    : __hm_(0),
      __mode_(__wch)
{
    str(string_type());
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,
                             ios_base::openmode __wch)
    : __str_(__s.get_allocator()),
      __hm_(0),
      __mode_(__wch)
{
    str(__s);
}



template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)
    : __mode_(__rhs.__mode_)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __binp = -1;
    ptrdiff_t __ninp = -1;
    ptrdiff_t __einp = -1;
    if (__rhs.eback() != nullptr)
    {
        __binp = __rhs.eback() - __p;
        __ninp = __rhs.gptr() - __p;
        __einp = __rhs.egptr() - __p;
    }
    ptrdiff_t __bout = -1;
    ptrdiff_t __nout = -1;
    ptrdiff_t __eout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __bout = __rhs.pbase() - __p;
        __nout = __rhs.pptr() - __p;
        __eout = __rhs.epptr() - __p;
    }
    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __str_ = std::__1::move(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__binp != -1)
        this->setg(__p + __binp, __p + __ninp, __p + __einp);
    if (__bout != -1)
    {
        this->setp(__p + __bout, __p + __eout);
        this->__pbump(__nout);
    }
    __hm_ = __hm == -1 ? nullptr : __p + __hm;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    __rhs.setg(__p, __p, __p);
    __rhs.setp(__p, __p);
    __rhs.__hm_ = __p;
    this->pubimbue(__rhs.getloc());
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>&
basic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __binp = -1;
    ptrdiff_t __ninp = -1;
    ptrdiff_t __einp = -1;
    if (__rhs.eback() != nullptr)
    {
        __binp = __rhs.eback() - __p;
        __ninp = __rhs.gptr() - __p;
        __einp = __rhs.egptr() - __p;
    }
    ptrdiff_t __bout = -1;
    ptrdiff_t __nout = -1;
    ptrdiff_t __eout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __bout = __rhs.pbase() - __p;
        __nout = __rhs.pptr() - __p;
        __eout = __rhs.epptr() - __p;
    }
    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __str_ = std::__1::move(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__binp != -1)
        this->setg(__p + __binp, __p + __ninp, __p + __einp);
    else
        this->setg(nullptr, nullptr, nullptr);
    if (__bout != -1)
    {
        this->setp(__p + __bout, __p + __eout);
        this->__pbump(__nout);
    }
    else
        this->setp(nullptr, nullptr);

    __hm_ = __hm == -1 ? nullptr : __p + __hm;
    __mode_ = __rhs.__mode_;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    __rhs.setg(__p, __p, __p);
    __rhs.setp(__p, __p);
    __rhs.__hm_ = __p;
    this->pubimbue(__rhs.getloc());
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void
basic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __rbinp = -1;
    ptrdiff_t __rninp = -1;
    ptrdiff_t __reinp = -1;
    if (__rhs.eback() != nullptr)
    {
        __rbinp = __rhs.eback() - __p;
        __rninp = __rhs.gptr() - __p;
        __reinp = __rhs.egptr() - __p;
    }
    ptrdiff_t __rbout = -1;
    ptrdiff_t __rnout = -1;
    ptrdiff_t __reout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __rbout = __rhs.pbase() - __p;
        __rnout = __rhs.pptr() - __p;
        __reout = __rhs.epptr() - __p;
    }
    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __p = const_cast<char_type*>(__str_.data());
    ptrdiff_t __lbinp = -1;
    ptrdiff_t __lninp = -1;
    ptrdiff_t __leinp = -1;
    if (this->eback() != nullptr)
    {
        __lbinp = this->eback() - __p;
        __lninp = this->gptr() - __p;
        __leinp = this->egptr() - __p;
    }
    ptrdiff_t __lbout = -1;
    ptrdiff_t __lnout = -1;
    ptrdiff_t __leout = -1;
    if (this->pbase() != nullptr)
    {
        __lbout = this->pbase() - __p;
        __lnout = this->pptr() - __p;
        __leout = this->epptr() - __p;
    }
    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;
    std::__1::swap(__mode_, __rhs.__mode_);
    __str_.swap(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__rbinp != -1)
        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);
    else
        this->setg(nullptr, nullptr, nullptr);
    if (__rbout != -1)
    {
        this->setp(__p + __rbout, __p + __reout);
        this->__pbump(__rnout);
    }
    else
        this->setp(nullptr, nullptr);
    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    if (__lbinp != -1)
        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);
    else
        __rhs.setg(nullptr, nullptr, nullptr);
    if (__lbout != -1)
    {
        __rhs.setp(__p + __lbout, __p + __leout);
        __rhs.__pbump(__lnout);
    }
    else
        __rhs.setp(nullptr, nullptr);
    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;
    locale __tl = __rhs.getloc();
    __rhs.pubimbue(this->getloc());
    this->pubimbue(__tl);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::str() const
{
    if (__mode_ & ios_base::out)
    {
        if (__hm_ < this->pptr())
            __hm_ = this->pptr();
        return string_type(this->pbase(), __hm_, __str_.get_allocator());
    }
    else if (__mode_ & ios_base::in)
        return string_type(this->eback(), this->egptr(), __str_.get_allocator());
    return string_type(__str_.get_allocator());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)
{
    __str_ = __s;
    __hm_ = 0;
    if (__mode_ & ios_base::in)
    {
        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();
        this->setg(const_cast<char_type*>(__str_.data()),
                   const_cast<char_type*>(__str_.data()),
                   __hm_);
    }
    if (__mode_ & ios_base::out)
    {
        typename string_type::size_type __sz = __str_.size();
        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;
        __str_.resize(__str_.capacity());
        this->setp(const_cast<char_type*>(__str_.data()),
                   const_cast<char_type*>(__str_.data()) + __str_.size());
        if (__mode_ & (ios_base::app | ios_base::ate))
        {
            while (__sz > 2147483647)
            {
             this->pbump(2147483647);
             __sz -= 2147483647;
            }
            if (__sz > 0)
             this->pbump(__sz);
     }
    }
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::underflow()
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if (__mode_ & ios_base::in)
    {
        if (this->egptr() < __hm_)
            this->setg(this->eback(), this->gptr(), __hm_);
        if (this->gptr() < this->egptr())
            return traits_type::to_int_type(*this->gptr());
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if (this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->setg(this->eback(), this->gptr()-1, __hm_);
            return traits_type::not_eof(__c);
        }
        if ((__mode_ & ios_base::out) ||
            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->setg(this->eback(), this->gptr()-1, __hm_);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)
{
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        ptrdiff_t __ninp = this->gptr() - this->eback();
        if (this->pptr() == this->epptr())
        {
            if (!(__mode_ & ios_base::out))
                return traits_type::eof();




                ptrdiff_t __nout = this->pptr() - this->pbase();
                ptrdiff_t __hm = __hm_ - this->pbase();
                __str_.push_back(char_type());
                __str_.resize(__str_.capacity());
                char_type* __p = const_cast<char_type*>(__str_.data());
                this->setp(__p, __p + __str_.size());
                this->__pbump(__nout);
                __hm_ = this->pbase() + __hm;







        }
        __hm_ = std::__1::max(this->pptr() + 1, __hm_);
        if (__mode_ & ios_base::in)
        {
            char_type* __p = const_cast<char_type*>(__str_.data());
            this->setg(__p, __p + __ninp, __hm_);
        }
        return this->sputc(__c);
    }
    return traits_type::not_eof(__c);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
basic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,
                                                      ios_base::seekdir __way,
                                                      ios_base::openmode __wch)
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if ((__wch & (ios_base::in | ios_base::out)) == 0)
        return pos_type(-1);
    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)
        && __way == ios_base::cur)
        return pos_type(-1);
    off_type __noff;
    switch (__way)
    {
    case ios_base::beg:
        __noff = 0;
        break;
    case ios_base::cur:
        if (__wch & ios_base::in)
            __noff = this->gptr() - this->eback();
        else
            __noff = this->pptr() - this->pbase();
        break;
    case ios_base::end:
        __noff = __hm_ - __str_.data();
        break;
    default:
        return pos_type(-1);
    }
    __noff += __off;
    if (__noff < 0 || __hm_ - __str_.data() < __noff)
        return pos_type(-1);
    if (__noff != 0)
    {
        if ((__wch & ios_base::in) && this->gptr() == 0)
            return pos_type(-1);
        if ((__wch & ios_base::out) && this->pptr() == 0)
            return pos_type(-1);
    }
    if (__wch & ios_base::in)
        this->setg(this->eback(), this->eback() + __noff, __hm_);
    if (__wch & ios_base::out)
    {
        this->setp(this->pbase(), this->epptr());
        this->pbump(__noff);
    }
    return pos_type(__noff);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
basic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,
                                                      ios_base::openmode __wch)
{
    return seekoff(__sp, ios_base::beg, __wch);
}



template <class _CharT, class _Traits, class _Allocator>
class basic_istringstream
    : public basic_istream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

    inline __attribute__ ((__always_inline__))
    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);
    inline __attribute__ ((__always_inline__))
    explicit basic_istringstream(const string_type& __s,
                                 ios_base::openmode __wch = ios_base::in);

    inline __attribute__ ((__always_inline__))
    basic_istringstream(basic_istringstream&& __rhs);


    basic_istringstream& operator=(basic_istringstream&& __rhs);

    inline __attribute__ ((__always_inline__))
    void swap(basic_istringstream& __rhs);


    inline __attribute__ ((__always_inline__))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
    inline __attribute__ ((__always_inline__))
    string_type str() const;
    inline __attribute__ ((__always_inline__))
    void str(const string_type& __s);
};

template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)
    : basic_istream<_CharT, _Traits>(&__sb_),
      __sb_(__wch | ios_base::in)
{
}

template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,
                                                                      ios_base::openmode __wch)
    : basic_istream<_CharT, _Traits>(&__sb_),
      __sb_(__s, __wch | ios_base::in)
{
}



template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)
    : basic_istream<_CharT, _Traits>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>&
basic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)
{
    basic_istream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void basic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)
{
    basic_istream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
     basic_istringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>*
basic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const
{
    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::str() const
{
    return __sb_.str();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)
{
    __sb_.str(__s);
}



template <class _CharT, class _Traits, class _Allocator>
class basic_ostringstream
    : public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

    inline __attribute__ ((__always_inline__))
    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);
    inline __attribute__ ((__always_inline__))
    explicit basic_ostringstream(const string_type& __s,
                                 ios_base::openmode __wch = ios_base::out);

    inline __attribute__ ((__always_inline__))
    basic_ostringstream(basic_ostringstream&& __rhs);


    basic_ostringstream& operator=(basic_ostringstream&& __rhs);

    inline __attribute__ ((__always_inline__))
    void swap(basic_ostringstream& __rhs);


    inline __attribute__ ((__always_inline__))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
    inline __attribute__ ((__always_inline__))
    string_type str() const;
    inline __attribute__ ((__always_inline__))
    void str(const string_type& __s);
};

template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)
    : basic_ostream<_CharT, _Traits>(&__sb_),
      __sb_(__wch | ios_base::out)
{
}

template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,
                                                                      ios_base::openmode __wch)
    : basic_ostream<_CharT, _Traits>(&__sb_),
      __sb_(__s, __wch | ios_base::out)
{
}



template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)
    : basic_ostream<_CharT, _Traits>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>&
basic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)
{
    basic_ostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void
basic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)
{
    basic_ostream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>*
basic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const
{
    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::str() const
{
    return __sb_.str();
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)
{
    __sb_.str(__s);
}



template <class _CharT, class _Traits, class _Allocator>
class basic_stringstream
    : public basic_iostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

    inline __attribute__ ((__always_inline__))
    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);
    inline __attribute__ ((__always_inline__))
    explicit basic_stringstream(const string_type& __s,
                                ios_base::openmode __wch = ios_base::in | ios_base::out);

    inline __attribute__ ((__always_inline__))
    basic_stringstream(basic_stringstream&& __rhs);


    basic_stringstream& operator=(basic_stringstream&& __rhs);

    inline __attribute__ ((__always_inline__))
    void swap(basic_stringstream& __rhs);


    inline __attribute__ ((__always_inline__))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
    inline __attribute__ ((__always_inline__))
    string_type str() const;
    inline __attribute__ ((__always_inline__))
    void str(const string_type& __s);
};

template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)
    : basic_iostream<_CharT, _Traits>(&__sb_),
      __sb_(__wch)
{
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,
                                                                    ios_base::openmode __wch)
    : basic_iostream<_CharT, _Traits>(&__sb_),
      __sb_(__s, __wch)
{
}



template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)
    : basic_iostream<_CharT, _Traits>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>&
basic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)
{
    basic_iostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void
basic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)
{
    basic_iostream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
     basic_stringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>*
basic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const
{
    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::str() const
{
    return __sb_.str();
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)
{
    __sb_.str(__s);
}

} }
# 13 "../../base/logging.h" 2





# 1 "../../base/callback_forward.h" 1







namespace base {

template <typename Signature>
class OnceCallback;

template <typename Signature>
class RepeatingCallback;

template <typename Signature>
using Callback = RepeatingCallback<Signature>;



using OnceClosure = OnceCallback<void()>;
using RepeatingClosure = RepeatingCallback<void()>;
using Closure = Callback<void()>;

}
# 19 "../../base/logging.h" 2

# 1 "../../base/debug/debugger.h" 1
# 14 "../../base/debug/debugger.h"
namespace base {
namespace debug {



            bool WaitForDebugger(int wait_seconds, bool silent);
# 28 "../../base/debug/debugger.h"
            bool BeingDebugged();


            void BreakDebugger();






            void SetSuppressDebugUI(bool suppress);
            bool IsDebugUISuppressed();

}
}
# 21 "../../base/logging.h" 2

# 1 "../../base/strings/string_piece_forward.h" 1
# 12 "../../base/strings/string_piece_forward.h"
# 1 "../../base/strings/string16.h" 1
# 29 "../../base/strings/string16.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 30 "../../base/strings/string16.h" 2

# 1 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 1 3
# 32 "../../base/strings/string16.h" 2
# 50 "../../base/strings/string16.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 1 3
# 51 "../../base/strings/string16.h" 2

namespace base {

typedef uint16_t char16;




            int c16memcmp(const char16* s1, const char16* s2, size_t n);
            size_t c16len(const char16* s);
            const char16* c16memchr(const char16* s, char16 c, size_t n);
            char16* c16memmove(char16* s1, const char16* s2, size_t n);
            char16* c16memcpy(char16* s1, const char16* s2, size_t n);
            char16* c16memset(char16* s, char16 c, size_t n);




namespace string16_internals {

struct string16_char_traits {
  typedef char16 char_type;
  typedef int int_type;



  static_assert(sizeof(int_type) > sizeof(char_type),
                "int must be larger than 16 bits wide");

  typedef std::streamoff off_type;
  typedef mbstate_t state_type;
  typedef std::fpos<state_type> pos_type;

  static void assign(char_type& c1, const char_type& c2) {
    c1 = c2;
  }

  static bool eq(const char_type& c1, const char_type& c2) {
    return c1 == c2;
  }
  static bool lt(const char_type& c1, const char_type& c2) {
    return c1 < c2;
  }

  static int compare(const char_type* s1, const char_type* s2, size_t n) {
    return c16memcmp(s1, s2, n);
  }

  static size_t length(const char_type* s) {
    return c16len(s);
  }

  static const char_type* find(const char_type* s, size_t n,
                               const char_type& a) {
    return c16memchr(s, a, n);
  }

  static char_type* move(char_type* s1, const char_type* s2, size_t n) {
    return c16memmove(s1, s2, n);
  }

  static char_type* copy(char_type* s1, const char_type* s2, size_t n) {
    return c16memcpy(s1, s2, n);
  }

  static char_type* assign(char_type* s, size_t n, char_type a) {
    return c16memset(s, a, n);
  }

  static int_type not_eof(const int_type& c) {
    return eq_int_type(c, eof()) ? 0 : c;
  }

  static char_type to_char_type(const int_type& c) {
    return char_type(c);
  }

  static int_type to_int_type(const char_type& c) {
    return int_type(c);
  }

  static bool eq_int_type(const int_type& c1, const int_type& c2) {
    return c1 == c2;
  }

  static int_type eof() {
    return static_cast<int_type>((-1));
  }
};

}

typedef std::basic_string<char16,
                          base::string16_internals::string16_char_traits>
    string16;

namespace string16_internals {

            extern std::ostream& operator<<(std::ostream& out,
                                            const string16& str);


            extern void PrintTo(const string16& str, std::ostream* out);

}

}
# 198 "../../base/strings/string16.h"
extern template class
    std::basic_string<base::char16,
                      base::string16_internals::string16_char_traits>;




namespace std {
template <>
struct hash<base::string16> {
  std::size_t operator()(const base::string16& s) const {
    std::size_t result = 0;
    for (base::char16 c : s)
      result = (result * 131) + c;
    return result;
  }
};
}
# 13 "../../base/strings/string_piece_forward.h" 2

namespace base {

template <typename STRING_TYPE>
class BasicStringPiece;
typedef BasicStringPiece<std::string> StringPiece;
typedef BasicStringPiece<string16> StringPiece16;

}
# 23 "../../base/logging.h" 2
# 1 "../../base/template_util.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/template_util.h" 2
# 38 "../../base/template_util.h"
namespace base {

template <class T> struct is_non_const_reference : std::false_type {};
template <class T> struct is_non_const_reference<T&> : std::true_type {};
template <class T> struct is_non_const_reference<const T&> : std::false_type {};

namespace internal {


template <typename...>
struct make_void {
  using type = void;
};

}







template <typename... Ts>
using void_t = typename ::base::internal::make_void<Ts...>::type;

namespace internal {


template <typename T, typename = void>
struct SupportsOstreamOperator : std::false_type {};
template <typename T>
struct SupportsOstreamOperator<T,
                               decltype(void(std::declval<std::ostream&>()
                                             << std::declval<T>()))>
    : std::true_type {};




template <typename T, typename = void>
struct is_iterator : std::false_type {};

template <typename T>
struct is_iterator<T,
                   void_t<typename std::iterator_traits<T>::iterator_category>>
    : std::true_type {};

}
# 113 "../../base/template_util.h"
template <typename T>
struct is_trivially_copyable {






  static constexpr bool value =
      __has_trivial_copy(T) && __has_trivial_destructor(T);

};





}
# 24 "../../base/logging.h" 2
# 146 "../../base/logging.h"
namespace logging {





typedef char PathChar;




enum LoggingDestination {
  LOG_NONE = 0,
  LOG_TO_FILE = 1 << 0,
  LOG_TO_SYSTEM_DEBUG_LOG = 1 << 1,

  LOG_TO_ALL = LOG_TO_FILE | LOG_TO_SYSTEM_DEBUG_LOG,







  LOG_DEFAULT = LOG_TO_SYSTEM_DEBUG_LOG,

};
# 181 "../../base/logging.h"
enum LogLockingState { LOCK_LOG_FILE, DONT_LOCK_LOG_FILE };



enum OldFileDeletionState { DELETE_OLD_LOG_FILE, APPEND_TO_OLD_LOG_FILE };

struct LoggingSettings {






  LoggingSettings();

  LoggingDestination logging_dest;



  const PathChar* log_file;
  LogLockingState lock_log;
  OldFileDeletionState delete_old;
};
# 218 "../../base/logging.h"
            bool BaseInitLoggingImpl_built_with_NDEBUG(const LoggingSettings& settings);
# 234 "../../base/logging.h"
inline bool InitLogging(const LoggingSettings& settings) {
  return BaseInitLoggingImpl_built_with_NDEBUG(settings);
}







            void SetMinLogLevel(int level);


            int GetMinLogLevel();


            bool ShouldCreateLogMessage(int severity);


            int GetVlogVerbosity();


            int GetVlogLevelHelper(const char* file_start, size_t N);


template <size_t N>
int GetVlogLevel(const char (&file)[N]) {
  return GetVlogLevelHelper(file, N);
}





            void SetLogItems(bool enable_process_id, bool enable_thread_id,
                             bool enable_timestamp, bool enable_tickcount);




            void SetShowErrorDialogs(bool enable_dialogs);






using LogAssertHandlerFunction =
    base::Callback<void(const char* file,
                        int line,
                        const base::StringPiece message,
                        const base::StringPiece stack_trace)>;

class ScopedLogAssertHandler {
 public:
  explicit ScopedLogAssertHandler(LogAssertHandlerFunction handler);
  ~ScopedLogAssertHandler();

 private:
  ScopedLogAssertHandler(const ScopedLogAssertHandler&) = delete; ScopedLogAssertHandler& operator=(const ScopedLogAssertHandler&) = delete;
};





typedef bool (*LogMessageHandlerFunction)(int severity,
    const char* file, int line, size_t message_start, const std::string& str);
            void SetLogMessageHandler(LogMessageHandlerFunction handler);
            LogMessageHandlerFunction GetLogMessageHandler();
# 337 "../../base/logging.h"
typedef int LogSeverity;
const LogSeverity LOG_VERBOSE = -1;


const LogSeverity LOG_INFO = 0;
const LogSeverity LOG_WARNING = 1;
const LogSeverity LOG_ERROR = 2;
const LogSeverity LOG_FATAL = 3;
const LogSeverity LOG_NUM_SEVERITIES = 4;



const LogSeverity LOG_DFATAL = LOG_ERROR;
# 474 "../../base/logging.h"
            extern std::ostream* g_swallow_stream;
# 494 "../../base/logging.h"
class CheckOpResult {
 public:

  CheckOpResult(std::string* message) : message_(message) {}

  operator bool() const { return !message_; }

  std::string* message() { return message_; }

 private:
  std::string* message_;
};
# 665 "../../base/logging.h"
template <typename T>
inline typename std::enable_if<
    base::internal::SupportsOstreamOperator<const T&>::value &&
        !std::is_function<typename std::remove_pointer<T>::type>::value,
    void>::type
MakeCheckOpValueString(std::ostream* os, const T& v) {
  (*os) << v;
}






template <typename T>
inline typename std::enable_if<
    std::is_function<typename std::remove_pointer<T>::type>::value,
    void>::type
MakeCheckOpValueString(std::ostream* os, const T& v) {
  (*os) << reinterpret_cast<const void*>(v);
}



template <typename T>
inline typename std::enable_if<
    !base::internal::SupportsOstreamOperator<const T&>::value &&
        std::is_enum<T>::value,
    void>::type
MakeCheckOpValueString(std::ostream* os, const T& v) {
  (*os) << static_cast<typename std::underlying_type<T>::type>(v);
}


            void MakeCheckOpValueString(std::ostream* os, std::nullptr_t p);





template<class t1, class t2>
std::string* MakeCheckOpString(const t1& v1, const t2& v2, const char* names) {
  std::ostringstream ss;
  ss << names << " (";
  MakeCheckOpValueString(&ss, v1);
  ss << " vs. ";
  MakeCheckOpValueString(&ss, v2);
  ss << ")";
  std::string* msg = new std::string(ss.str());
  return msg;
}



extern template std::string* MakeCheckOpString<int, int>(
    const int&, const int&, const char* names);
extern template
std::string* MakeCheckOpString<unsigned long, unsigned long>(
    const unsigned long&, const unsigned long&, const char* names);
extern template
std::string* MakeCheckOpString<unsigned long, unsigned int>(
    const unsigned long&, const unsigned int&, const char* names);
extern template
std::string* MakeCheckOpString<unsigned int, unsigned long>(
    const unsigned int&, const unsigned long&, const char* names);
extern template
std::string* MakeCheckOpString<std::string, std::string>(
    const std::string&, const std::string&, const char* name);
# 757 "../../base/logging.h"
template <class t1, class t2> inline std::string* CheckEQImpl(const t1& v1, const t2& v2, const char* names) { if ((v1 == v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); } inline std::string* CheckEQImpl(int v1, int v2, const char* names) { if ((v1 == v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); }
template <class t1, class t2> inline std::string* CheckNEImpl(const t1& v1, const t2& v2, const char* names) { if ((v1 != v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); } inline std::string* CheckNEImpl(int v1, int v2, const char* names) { if ((v1 != v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); }
template <class t1, class t2> inline std::string* CheckLEImpl(const t1& v1, const t2& v2, const char* names) { if ((v1 <= v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); } inline std::string* CheckLEImpl(int v1, int v2, const char* names) { if ((v1 <= v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); }
template <class t1, class t2> inline std::string* CheckLTImpl(const t1& v1, const t2& v2, const char* names) { if ((v1 < v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); } inline std::string* CheckLTImpl(int v1, int v2, const char* names) { if ((v1 < v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); }
template <class t1, class t2> inline std::string* CheckGEImpl(const t1& v1, const t2& v2, const char* names) { if ((v1 >= v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); } inline std::string* CheckGEImpl(int v1, int v2, const char* names) { if ((v1 >= v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); }
template <class t1, class t2> inline std::string* CheckGTImpl(const t1& v1, const t2& v2, const char* names) { if ((v1 > v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); } inline std::string* CheckGTImpl(int v1, int v2, const char* names) { if ((v1 > v2)) return __null; else return ::logging::MakeCheckOpString(v1, v2, names); }
# 828 "../../base/logging.h"
const LogSeverity LOG_DCHECK = LOG_FATAL;
# 962 "../../base/logging.h"
class LogMessage {
 public:

  LogMessage(const char* file, int line, LogSeverity severity);


  LogMessage(const char* file, int line, const char* condition);



  LogMessage(const char* file, int line, std::string* result);


  LogMessage(const char* file, int line, LogSeverity severity,
             std::string* result);

  ~LogMessage();

  std::ostream& stream() { return stream_; }

  LogSeverity severity() { return severity_; }
  std::string str() { return stream_.str(); }

 private:
  void Init(const char* file, int line);

  LogSeverity severity_;
  std::ostringstream stream_;
  size_t message_start_;


  const char* file_;
  const int line_;
# 1016 "../../base/logging.h"
  LogMessage(const LogMessage&) = delete; LogMessage& operator=(const LogMessage&) = delete;
};




class LogMessageVoidify {
 public:
  LogMessageVoidify() { }


  void operator&(std::ostream&) { }
};




typedef int SystemErrorCode;




            SystemErrorCode GetLastSystemErrorCode();
            std::string SystemErrorCodeToString(SystemErrorCode error_code);
# 1063 "../../base/logging.h"
class ErrnoLogMessage {
 public:
  ErrnoLogMessage(const char* file,
                  int line,
                  LogSeverity severity,
                  SystemErrorCode err);


  ~ErrnoLogMessage();

  std::ostream& stream() { return log_message_.stream(); }

 private:
  SystemErrorCode err_;
  LogMessage log_message_;

  ErrnoLogMessage(const ErrnoLogMessage&) = delete; ErrnoLogMessage& operator=(const ErrnoLogMessage&) = delete;
};






            void CloseLogFile();


            void RawLog(int level, const char* message);
# 1110 "../../base/logging.h"
}
# 1120 "../../base/logging.h"
namespace std {






            std::ostream& operator<<(std::ostream& out, const wchar_t* wstr);
inline std::ostream& operator<<(std::ostream& out, const std::wstring& wstr) {
  return out << wstr.c_str();
}
}
# 63 "../../base/time/time.h" 2
# 1 "../../base/numerics/safe_math.h" 1







# 1 "../../base/numerics/checked_math.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/numerics/checked_math.h" 2




# 1 "../../base/numerics/checked_math_impl.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/numerics/checked_math_impl.h" 2



# 1 "../../buildtools/third_party/libc++/trunk/include/cmath" 1 3
# 305 "../../buildtools/third_party/libc++/trunk/include/cmath" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/math.h" 1 3
# 299 "../../buildtools/third_party/libc++/trunk/include/math.h" 3


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
extern "C" {



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 32 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
# 36 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4

# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
# 38 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
# 39 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
# 42 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4


# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
# 45 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4



# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 49 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4
# 83 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 54 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();
# 153 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();
# 178 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));
# 208 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));
# 247 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();
# 382 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));






extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 84 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4
# 104 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 54 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();
# 153 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();
# 178 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));
# 204 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));



extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));






extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();
# 382 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));






extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 105 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4
# 151 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 54 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();
# 153 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();
# 178 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));
# 204 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));



extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));






extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();
# 382 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));






extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 152 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4
# 168 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
extern int signgam;
# 209 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 347 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 370 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 472 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathinline.h" 1 3 4
# 126 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/mathinline.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
 __signbitf (float __x) throw ()
{

  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return (__m & 0x8) != 0;




}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
 __signbit (double __x) throw ()
{

  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return (__m & 0x80) != 0;




}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
 __signbitl (long double __x) throw ()
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}
# 473 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 2 3 4
# 534 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/math.h" 3 4
}
# 302 "../../buildtools/third_party/libc++/trunk/include/math.h" 2 3





extern "C++" {
# 316 "../../buildtools/third_party/libc++/trunk/include/math.h" 3
template <class _A1>
__attribute__ ((__always_inline__))
bool
__libcpp_signbit(_A1 __lcpp_x) noexcept
{
    return (sizeof (__lcpp_x) == sizeof (float) ? __builtin_signbitf (__lcpp_x) : sizeof (__lcpp_x) == sizeof (double) ? __builtin_signbit (__lcpp_x) : __builtin_signbitl (__lcpp_x));
}



template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<
    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{ return __lcpp_x < 0; }

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<
    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
signbit(_A1) noexcept
{ return false; }
# 378 "../../buildtools/third_party/libc++/trunk/include/math.h" 3
template <class _A1>
__attribute__ ((__always_inline__))
int
__libcpp_fpclassify(_A1 __lcpp_x) noexcept
{
    return (sizeof (__lcpp_x) == sizeof (float) ? __fpclassifyf (__lcpp_x) : sizeof (__lcpp_x) == sizeof (double) ? __fpclassify (__lcpp_x) : __fpclassifyl (__lcpp_x));
}



template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{ return __lcpp_x == 0 ? 2 : 4; }
# 424 "../../buildtools/third_party/libc++/trunk/include/math.h" 3
template <class _A1>
__attribute__ ((__always_inline__))
bool
__libcpp_isfinite(_A1 __lcpp_x) noexcept
{
    return (sizeof (__lcpp_x) == sizeof (float) ? __finitef (__lcpp_x) : sizeof (__lcpp_x) == sizeof (double) ? __finite (__lcpp_x) : __finitel (__lcpp_x));
}



template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1 __lcpp_x) noexcept
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1) noexcept
{ return true; }







template <class _A1>
__attribute__ ((__always_inline__))
bool
__libcpp_isinf(_A1 __lcpp_x) noexcept
{
    return (sizeof (__lcpp_x) == sizeof (float) ? __isinff (__lcpp_x) : sizeof (__lcpp_x) == sizeof (double) ? __isinf (__lcpp_x) : __isinfl (__lcpp_x));
}



template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1 __lcpp_x) noexcept
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1) noexcept
{ return false; }







template <class _A1>
__attribute__ ((__always_inline__))
bool
__libcpp_isnan(_A1 __lcpp_x) noexcept
{
    return (sizeof (__lcpp_x) == sizeof (float) ? __isnanf (__lcpp_x) : sizeof (__lcpp_x) == sizeof (double) ? __isnan (__lcpp_x) : __isnanl (__lcpp_x));
}



template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnan(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnan(_A1) noexcept
{ return false; }







template <class _A1>
__attribute__ ((__always_inline__))
bool
__libcpp_isnormal(_A1 __lcpp_x) noexcept
{
    return (fpclassify (__lcpp_x) == 4);
}



template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{ return __lcpp_x != 0; }







template <class _A1, class _A2>
__attribute__ ((__always_inline__))
bool
__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreater(__lcpp_x, __lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__always_inline__))
bool
__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreaterequal(__lcpp_x, __lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__always_inline__))
bool
__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isless(__lcpp_x, __lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__always_inline__))
bool
__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessequal(__lcpp_x, __lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__always_inline__))
bool
__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessgreater(__lcpp_x, __lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__always_inline__))
bool
__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isunordered(__lcpp_x, __lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}






inline __attribute__ ((__always_inline__))
float
abs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}

inline __attribute__ ((__always_inline__))
double
abs(double __lcpp_x) noexcept {return ::fabs(__lcpp_x);}

inline __attribute__ ((__always_inline__))
long double
abs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}





inline __attribute__ ((__always_inline__)) float acos(float __lcpp_x) noexcept {return ::acosf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double acos(long double __lcpp_x) noexcept {return ::acosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) noexcept {return ::acos((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float asin(float __lcpp_x) noexcept {return ::asinf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double asin(long double __lcpp_x) noexcept {return ::asinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) noexcept {return ::asin((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float atan(float __lcpp_x) noexcept {return ::atanf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double atan(long double __lcpp_x) noexcept {return ::atanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) noexcept {return ::atan((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float atan2(float __lcpp_y, float __lcpp_x) noexcept {return ::atan2f(__lcpp_y, __lcpp_x);}
inline __attribute__ ((__always_inline__)) long double atan2(long double __lcpp_y, long double __lcpp_x) noexcept {return ::atan2l(__lcpp_y, __lcpp_x);}


template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}




inline __attribute__ ((__always_inline__)) float ceil(float __lcpp_x) noexcept {return ::ceilf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double ceil(long double __lcpp_x) noexcept {return ::ceill(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) noexcept {return ::ceil((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float cos(float __lcpp_x) noexcept {return ::cosf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double cos(long double __lcpp_x) noexcept {return ::cosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) noexcept {return ::cos((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float cosh(float __lcpp_x) noexcept {return ::coshf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double cosh(long double __lcpp_x) noexcept {return ::coshl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) noexcept {return ::cosh((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float exp(float __lcpp_x) noexcept {return ::expf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double exp(long double __lcpp_x) noexcept {return ::expl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) noexcept {return ::exp((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float fabs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double fabs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) noexcept {return ::fabs((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float floor(float __lcpp_x) noexcept {return ::floorf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double floor(long double __lcpp_x) noexcept {return ::floorl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) noexcept {return ::floor((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float fmod(float __lcpp_x, float __lcpp_y) noexcept {return ::fmodf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double fmod(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmodl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__always_inline__)) float frexp(float __lcpp_x, int* __lcpp_e) noexcept {return ::frexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__always_inline__)) long double frexp(long double __lcpp_x, int* __lcpp_e) noexcept {return ::frexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int* __lcpp_e) noexcept {return ::frexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__always_inline__)) float ldexp(float __lcpp_x, int __lcpp_e) noexcept {return ::ldexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__always_inline__)) long double ldexp(long double __lcpp_x, int __lcpp_e) noexcept {return ::ldexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {return ::ldexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__always_inline__)) float log(float __lcpp_x) noexcept {return ::logf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double log(long double __lcpp_x) noexcept {return ::logl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) noexcept {return ::log((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float log10(float __lcpp_x) noexcept {return ::log10f(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double log10(long double __lcpp_x) noexcept {return ::log10l(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) noexcept {return ::log10((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float modf(float __lcpp_x, float* __lcpp_y) noexcept {return ::modff(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double modf(long double __lcpp_x, long double* __lcpp_y) noexcept {return ::modfl(__lcpp_x, __lcpp_y);}





inline __attribute__ ((__always_inline__)) float pow(float __lcpp_x, float __lcpp_y) noexcept {return ::powf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double pow(long double __lcpp_x, long double __lcpp_y) noexcept {return ::powl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__always_inline__)) float sin(float __lcpp_x) noexcept {return ::sinf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double sin(long double __lcpp_x) noexcept {return ::sinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) noexcept {return ::sin((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float sinh(float __lcpp_x) noexcept {return ::sinhf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double sinh(long double __lcpp_x) noexcept {return ::sinhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) noexcept {return ::sinh((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float sqrt(float __lcpp_x) noexcept {return ::sqrtf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double sqrt(long double __lcpp_x) noexcept {return ::sqrtl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) noexcept {return ::sqrt((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float tan(float __lcpp_x) noexcept {return ::tanf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double tan(long double __lcpp_x) noexcept {return ::tanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) noexcept {return ::tan((double)__lcpp_x);}




inline __attribute__ ((__always_inline__)) float tanh(float __lcpp_x) noexcept {return ::tanhf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double tanh(long double __lcpp_x) noexcept {return ::tanhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) noexcept {return ::tanh((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float acosh(float __lcpp_x) noexcept {return ::acoshf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double acosh(long double __lcpp_x) noexcept {return ::acoshl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) noexcept {return ::acosh((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float asinh(float __lcpp_x) noexcept {return ::asinhf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double asinh(long double __lcpp_x) noexcept {return ::asinhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) noexcept {return ::asinh((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float atanh(float __lcpp_x) noexcept {return ::atanhf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double atanh(long double __lcpp_x) noexcept {return ::atanhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) noexcept {return ::atanh((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float cbrt(float __lcpp_x) noexcept {return ::cbrtf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double cbrt(long double __lcpp_x) noexcept {return ::cbrtl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) noexcept {return ::cbrt((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float copysign(float __lcpp_x,
                                                float __lcpp_y) noexcept {
  return ::copysignf(__lcpp_x, __lcpp_y);
}
inline __attribute__ ((__always_inline__)) long double
copysign(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::copysignl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__always_inline__)) float erf(float __lcpp_x) noexcept {return ::erff(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double erf(long double __lcpp_x) noexcept {return ::erfl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) noexcept {return ::erf((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float erfc(float __lcpp_x) noexcept {return ::erfcf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double erfc(long double __lcpp_x) noexcept {return ::erfcl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) noexcept {return ::erfc((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float exp2(float __lcpp_x) noexcept {return ::exp2f(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double exp2(long double __lcpp_x) noexcept {return ::exp2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) noexcept {return ::exp2((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float expm1(float __lcpp_x) noexcept {return ::expm1f(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double expm1(long double __lcpp_x) noexcept {return ::expm1l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) noexcept {return ::expm1((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float fdim(float __lcpp_x, float __lcpp_y) noexcept {return ::fdimf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double fdim(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fdiml(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__always_inline__)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__always_inline__)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value &&
    std::is_arithmetic<_A3>::value,
    std::__promote<_A1, _A2, _A3>
>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value &&
                     std::is_same<_A3, __result_type>::value)), "");
    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}



inline __attribute__ ((__always_inline__)) float fmax(float __lcpp_x, float __lcpp_y) noexcept {return ::fmaxf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double fmax(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmaxl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__always_inline__)) float fmin(float __lcpp_x, float __lcpp_y) noexcept {return ::fminf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double fmin(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fminl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__always_inline__)) float hypot(float __lcpp_x, float __lcpp_y) noexcept {return ::hypotf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double hypot(long double __lcpp_x, long double __lcpp_y) noexcept {return ::hypotl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__always_inline__)) int ilogb(float __lcpp_x) noexcept {return ::ilogbf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) int ilogb(long double __lcpp_x) noexcept {return ::ilogbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) noexcept {return ::ilogb((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float lgamma(float __lcpp_x) noexcept {return ::lgammaf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double lgamma(long double __lcpp_x) noexcept {return ::lgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) noexcept {return ::lgamma((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) long long llrint(float __lcpp_x) noexcept {return ::llrintf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long long llrint(long double __lcpp_x) noexcept {return ::llrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) noexcept {return ::llrint((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) long long llround(float __lcpp_x) noexcept {return ::llroundf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long long llround(long double __lcpp_x) noexcept {return ::llroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) noexcept {return ::llround((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float log1p(float __lcpp_x) noexcept {return ::log1pf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double log1p(long double __lcpp_x) noexcept {return ::log1pl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) noexcept {return ::log1p((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float log2(float __lcpp_x) noexcept {return ::log2f(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double log2(long double __lcpp_x) noexcept {return ::log2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) noexcept {return ::log2((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float logb(float __lcpp_x) noexcept {return ::logbf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double logb(long double __lcpp_x) noexcept {return ::logbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) noexcept {return ::logb((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) long lrint(float __lcpp_x) noexcept {return ::lrintf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long lrint(long double __lcpp_x) noexcept {return ::lrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) noexcept {return ::lrint((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) long lround(float __lcpp_x) noexcept {return ::lroundf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long lround(long double __lcpp_x) noexcept {return ::lroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) noexcept {return ::lround((double)__lcpp_x);}





inline __attribute__ ((__always_inline__)) float nearbyint(float __lcpp_x) noexcept {return ::nearbyintf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double nearbyint(long double __lcpp_x) noexcept {return ::nearbyintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) noexcept {return ::nearbyint((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float nextafter(float __lcpp_x, float __lcpp_y) noexcept {return ::nextafterf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nextafterl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__always_inline__)) float nexttoward(float __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {return ::nexttoward((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__always_inline__)) float remainder(float __lcpp_x, float __lcpp_y) noexcept {return ::remainderf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double remainder(long double __lcpp_x, long double __lcpp_y) noexcept {return ::remainderl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__always_inline__)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) noexcept {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__always_inline__)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) noexcept {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2>
inline __attribute__ ((__always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}



inline __attribute__ ((__always_inline__)) float rint(float __lcpp_x) noexcept {return ::rintf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double rint(long double __lcpp_x) noexcept {return ::rintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) noexcept {return ::rint((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float round(float __lcpp_x) noexcept {return ::roundf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double round(long double __lcpp_x) noexcept {return ::roundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) noexcept {return ::round((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float scalbln(float __lcpp_x, long __lcpp_y) noexcept {return ::scalblnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double scalbln(long double __lcpp_x, long __lcpp_y) noexcept {return ::scalblnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {return ::scalbln((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__always_inline__)) float scalbn(float __lcpp_x, int __lcpp_y) noexcept {return ::scalbnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__always_inline__)) long double scalbn(long double __lcpp_x, int __lcpp_y) noexcept {return ::scalbnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {return ::scalbn((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__always_inline__)) float tgamma(float __lcpp_x) noexcept {return ::tgammaf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double tgamma(long double __lcpp_x) noexcept {return ::tgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) noexcept {return ::tgamma((double)__lcpp_x);}



inline __attribute__ ((__always_inline__)) float trunc(float __lcpp_x) noexcept {return ::truncf(__lcpp_x);}
inline __attribute__ ((__always_inline__)) long double trunc(long double __lcpp_x) noexcept {return ::truncl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) noexcept {return ::trunc((double)__lcpp_x);}

}
# 306 "../../buildtools/third_party/libc++/trunk/include/cmath" 2 3
# 309 "../../buildtools/third_party/libc++/trunk/include/cmath" 3


namespace std {inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;


using ::abs;


using ::acos;
using ::acosf;
using ::asin;
using ::asinf;
using ::atan;
using ::atanf;
using ::atan2;
using ::atan2f;
using ::ceil;
using ::ceilf;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;

using ::exp;
using ::expf;

using ::fabs;
using ::fabsf;
using ::floor;
using ::floorf;

using ::fmod;
using ::fmodf;

using ::frexp;
using ::frexpf;
using ::ldexp;
using ::ldexpf;

using ::log;
using ::logf;

using ::log10;
using ::log10f;
using ::modf;
using ::modff;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;

using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;
using ::cbrt;
using ::cbrtf;

using ::copysign;
using ::copysignf;

using ::erf;
using ::erff;
using ::erfc;
using ::erfcf;
using ::exp2;
using ::exp2f;
using ::expm1;
using ::expm1f;
using ::fdim;
using ::fdimf;
using ::fmaf;
using ::fma;
using ::fmax;
using ::fmaxf;
using ::fmin;
using ::fminf;
using ::hypot;
using ::hypotf;
using ::ilogb;
using ::ilogbf;
using ::lgamma;
using ::lgammaf;
using ::llrint;
using ::llrintf;
using ::llround;
using ::llroundf;
using ::log1p;
using ::log1pf;
using ::log2;
using ::log2f;
using ::logb;
using ::logbf;
using ::lrint;
using ::lrintf;
using ::lround;
using ::lroundf;

using ::nan;
using ::nanf;

using ::nearbyint;
using ::nearbyintf;
using ::nextafter;
using ::nextafterf;
using ::nexttoward;
using ::nexttowardf;
using ::remainder;
using ::remainderf;
using ::remquo;
using ::remquof;
using ::rint;
using ::rintf;
using ::round;
using ::roundf;
using ::scalbln;
using ::scalblnf;
using ::scalbn;
using ::scalbnf;
using ::tgamma;
using ::tgammaf;
using ::trunc;
using ::truncf;

using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;
# 549 "../../buildtools/third_party/libc++/trunk/include/cmath" 3
template <class _A1>
__attribute__ ((__always_inline__))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isnan(__lcpp_x);



}

template <class _A1>
__attribute__ ((__always_inline__))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
{
    return isnan(__lcpp_x);
}

template <class _A1>
__attribute__ ((__always_inline__))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isinf(__lcpp_x);



}

template <class _A1>
__attribute__ ((__always_inline__))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
{
    return isinf(__lcpp_x);
}

template <class _A1>
__attribute__ ((__always_inline__))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isfinite(__lcpp_x);



}

template <class _A1>
__attribute__ ((__always_inline__))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
{
    return isfinite(__lcpp_x);
}

} }
# 13 "../../base/numerics/checked_math_impl.h" 2




# 1 "../../base/numerics/safe_conversions.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/numerics/safe_conversions.h" 2





# 1 "../../base/numerics/safe_conversions_impl.h" 1
# 21 "../../base/numerics/safe_conversions_impl.h"
namespace base {
namespace internal {



template <typename NumericType>
struct MaxExponent {
  static const int value = std::is_floating_point<NumericType>::value
                               ? std::numeric_limits<NumericType>::max_exponent
                               : std::numeric_limits<NumericType>::digits + 1;
};



template <typename NumericType>
struct IntegerBitsPlusSign {
  static const int value = std::numeric_limits<NumericType>::digits +
                           std::is_signed<NumericType>::value;
};



template <typename Integer>
struct PositionOfSignBit {
  static const size_t value = IntegerBitsPlusSign<Integer>::value - 1;
};



template <typename T,
          typename std::enable_if<std::is_signed<T>::value>::type* = nullptr>
constexpr bool IsValueNegative(T value) {
  static_assert(std::is_arithmetic<T>::value, "Argument must be numeric.");
  return value < 0;
}

template <typename T,
          typename std::enable_if<!std::is_signed<T>::value>::type* = nullptr>
constexpr bool IsValueNegative(T) {
  static_assert(std::is_arithmetic<T>::value, "Argument must be numeric.");
  return false;
}




template <typename T>
constexpr typename std::make_signed<T>::type ConditionalNegate(
    T x,
    bool is_negative) {
  static_assert(std::is_integral<T>::value, "Type must be integral");
  using SignedT = typename std::make_signed<T>::type;
  using UnsignedT = typename std::make_unsigned<T>::type;
  return static_cast<SignedT>(
      (static_cast<UnsignedT>(x) ^ -SignedT(is_negative)) + is_negative);
}


template <typename T>
constexpr typename std::make_unsigned<T>::type SafeUnsignedAbs(T value) {
  static_assert(std::is_integral<T>::value, "Type must be integral");
  using UnsignedT = typename std::make_unsigned<T>::type;
  return IsValueNegative(value) ? 0 - static_cast<UnsignedT>(value)
                                : static_cast<UnsignedT>(value);
}



constexpr bool CanDetectCompileTimeConstant() {
  return true;
}
template <typename T>
constexpr bool IsCompileTimeConstant(const T v) {
  return __builtin_constant_p(v);
}
# 105 "../../base/numerics/safe_conversions_impl.h"
template <typename T>
constexpr bool MustTreatAsConstexpr(const T v) {


  return !CanDetectCompileTimeConstant() || IsCompileTimeConstant(v);
}




struct CheckOnFailure {
  template <typename T>
  static T HandleFailure() {



    __builtin_trap();



    return T();
  }
};

enum IntegerRepresentation {
  INTEGER_REPRESENTATION_UNSIGNED,
  INTEGER_REPRESENTATION_SIGNED
};






enum NumericRangeRepresentation {
  NUMERIC_RANGE_NOT_CONTAINED,
  NUMERIC_RANGE_CONTAINED
};




template <typename Dst,
          typename Src,
          IntegerRepresentation DstSign = std::is_signed<Dst>::value
                                              ? INTEGER_REPRESENTATION_SIGNED
                                              : INTEGER_REPRESENTATION_UNSIGNED,
          IntegerRepresentation SrcSign = std::is_signed<Src>::value
                                              ? INTEGER_REPRESENTATION_SIGNED
                                              : INTEGER_REPRESENTATION_UNSIGNED>
struct StaticDstRangeRelationToSrcRange;



template <typename Dst, typename Src, IntegerRepresentation Sign>
struct StaticDstRangeRelationToSrcRange<Dst, Src, Sign, Sign> {
  static const NumericRangeRepresentation value =
      MaxExponent<Dst>::value >= MaxExponent<Src>::value
          ? NUMERIC_RANGE_CONTAINED
          : NUMERIC_RANGE_NOT_CONTAINED;
};



template <typename Dst, typename Src>
struct StaticDstRangeRelationToSrcRange<Dst,
                                        Src,
                                        INTEGER_REPRESENTATION_SIGNED,
                                        INTEGER_REPRESENTATION_UNSIGNED> {
  static const NumericRangeRepresentation value =
      MaxExponent<Dst>::value > MaxExponent<Src>::value
          ? NUMERIC_RANGE_CONTAINED
          : NUMERIC_RANGE_NOT_CONTAINED;
};


template <typename Dst, typename Src>
struct StaticDstRangeRelationToSrcRange<Dst,
                                        Src,
                                        INTEGER_REPRESENTATION_UNSIGNED,
                                        INTEGER_REPRESENTATION_SIGNED> {
  static const NumericRangeRepresentation value = NUMERIC_RANGE_NOT_CONTAINED;
};



class RangeCheck {
 public:
  constexpr RangeCheck(bool is_in_lower_bound, bool is_in_upper_bound)
      : is_underflow_(!is_in_lower_bound), is_overflow_(!is_in_upper_bound) {}
  constexpr RangeCheck() : is_underflow_(0), is_overflow_(0) {}
  constexpr bool IsValid() const { return !is_overflow_ && !is_underflow_; }
  constexpr bool IsInvalid() const { return is_overflow_ && is_underflow_; }
  constexpr bool IsOverflow() const { return is_overflow_ && !is_underflow_; }
  constexpr bool IsUnderflow() const { return !is_overflow_ && is_underflow_; }
  constexpr bool IsOverflowFlagSet() const { return is_overflow_; }
  constexpr bool IsUnderflowFlagSet() const { return is_underflow_; }
  constexpr bool operator==(const RangeCheck rhs) const {
    return is_underflow_ == rhs.is_underflow_ &&
           is_overflow_ == rhs.is_overflow_;
  }
  constexpr bool operator!=(const RangeCheck rhs) const {
    return !(*this == rhs);
  }

 private:


  const bool is_underflow_;
  const bool is_overflow_;
};
# 238 "../../base/numerics/safe_conversions_impl.h"
template <typename Dst, typename Src, template <typename> class Bounds>
struct NarrowingRange {
  using SrcLimits = std::numeric_limits<Src>;
  using DstLimits = typename std::numeric_limits<Dst>;


  static const int kShift =
      (MaxExponent<Src>::value > MaxExponent<Dst>::value &&
       SrcLimits::digits < DstLimits::digits)
          ? (DstLimits::digits - SrcLimits::digits)
          : 0;
  template <
      typename T,
      typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>



  static constexpr T Adjust(T value) {
    static_assert(std::is_same<T, Dst>::value, "");
    static_assert(kShift < DstLimits::digits, "");
    return static_cast<T>(
        ConditionalNegate(SafeUnsignedAbs(value) & ~((T(1) << kShift) - T(1)),
                          IsValueNegative(value)));
  }

  template <typename T,
            typename std::enable_if<std::is_floating_point<T>::value>::type* =
                nullptr>
  static constexpr T Adjust(T value) {
    static_assert(std::is_same<T, Dst>::value, "");
    static_assert(kShift == 0, "");
    return value;
  }

  static constexpr Dst max() { return Adjust(Bounds<Dst>::max()); }
  static constexpr Dst lowest() { return Adjust(Bounds<Dst>::lowest()); }
};

template <typename Dst,
          typename Src,
          template <typename> class Bounds,
          IntegerRepresentation DstSign = std::is_signed<Dst>::value
                                              ? INTEGER_REPRESENTATION_SIGNED
                                              : INTEGER_REPRESENTATION_UNSIGNED,
          IntegerRepresentation SrcSign = std::is_signed<Src>::value
                                              ? INTEGER_REPRESENTATION_SIGNED
                                              : INTEGER_REPRESENTATION_UNSIGNED,
          NumericRangeRepresentation DstRange =
              StaticDstRangeRelationToSrcRange<Dst, Src>::value>
struct DstRangeRelationToSrcRangeImpl;






template <typename Dst,
          typename Src,
          template <typename> class Bounds,
          IntegerRepresentation DstSign,
          IntegerRepresentation SrcSign>
struct DstRangeRelationToSrcRangeImpl<Dst,
                                      Src,
                                      Bounds,
                                      DstSign,
                                      SrcSign,
                                      NUMERIC_RANGE_CONTAINED> {
  static constexpr RangeCheck Check(Src value) {
    using SrcLimits = std::numeric_limits<Src>;
    using DstLimits = NarrowingRange<Dst, Src, Bounds>;
    return RangeCheck(
        static_cast<Dst>(SrcLimits::lowest()) >= DstLimits::lowest() ||
            static_cast<Dst>(value) >= DstLimits::lowest(),
        static_cast<Dst>(SrcLimits::max()) <= DstLimits::max() ||
            static_cast<Dst>(value) <= DstLimits::max());
  }
};



template <typename Dst, typename Src, template <typename> class Bounds>
struct DstRangeRelationToSrcRangeImpl<Dst,
                                      Src,
                                      Bounds,
                                      INTEGER_REPRESENTATION_SIGNED,
                                      INTEGER_REPRESENTATION_SIGNED,
                                      NUMERIC_RANGE_NOT_CONTAINED> {
  static constexpr RangeCheck Check(Src value) {
    using DstLimits = NarrowingRange<Dst, Src, Bounds>;
    return RangeCheck(value >= DstLimits::lowest(), value <= DstLimits::max());
  }
};



template <typename Dst, typename Src, template <typename> class Bounds>
struct DstRangeRelationToSrcRangeImpl<Dst,
                                      Src,
                                      Bounds,
                                      INTEGER_REPRESENTATION_UNSIGNED,
                                      INTEGER_REPRESENTATION_UNSIGNED,
                                      NUMERIC_RANGE_NOT_CONTAINED> {
  static constexpr RangeCheck Check(Src value) {
    using DstLimits = NarrowingRange<Dst, Src, Bounds>;
    return RangeCheck(
        DstLimits::lowest() == Dst(0) || value >= DstLimits::lowest(),
        value <= DstLimits::max());
  }
};


template <typename Dst, typename Src, template <typename> class Bounds>
struct DstRangeRelationToSrcRangeImpl<Dst,
                                      Src,
                                      Bounds,
                                      INTEGER_REPRESENTATION_SIGNED,
                                      INTEGER_REPRESENTATION_UNSIGNED,
                                      NUMERIC_RANGE_NOT_CONTAINED> {
  static constexpr RangeCheck Check(Src value) {
    using DstLimits = NarrowingRange<Dst, Src, Bounds>;
    using Promotion = decltype(Src() + Dst());
    return RangeCheck(DstLimits::lowest() <= Dst(0) ||
                          static_cast<Promotion>(value) >=
                              static_cast<Promotion>(DstLimits::lowest()),
                      static_cast<Promotion>(value) <=
                          static_cast<Promotion>(DstLimits::max()));
  }
};



template <typename Dst, typename Src, template <typename> class Bounds>
struct DstRangeRelationToSrcRangeImpl<Dst,
                                      Src,
                                      Bounds,
                                      INTEGER_REPRESENTATION_UNSIGNED,
                                      INTEGER_REPRESENTATION_SIGNED,
                                      NUMERIC_RANGE_NOT_CONTAINED> {
  static constexpr RangeCheck Check(Src value) {
    using SrcLimits = std::numeric_limits<Src>;
    using DstLimits = NarrowingRange<Dst, Src, Bounds>;
    using Promotion = decltype(Src() + Dst());
    return RangeCheck(
        value >= Src(0) && (DstLimits::lowest() == 0 ||
                            static_cast<Dst>(value) >= DstLimits::lowest()),
        static_cast<Promotion>(SrcLimits::max()) <=
                static_cast<Promotion>(DstLimits::max()) ||
            static_cast<Promotion>(value) <=
                static_cast<Promotion>(DstLimits::max()));
  }
};


template <typename Dst, typename Src>
struct IsTypeInRangeForNumericType {
  static const bool value = StaticDstRangeRelationToSrcRange<Dst, Src>::value ==
                            NUMERIC_RANGE_CONTAINED;
};

template <typename Dst,
          template <typename> class Bounds = std::numeric_limits,
          typename Src>
constexpr RangeCheck DstRangeRelationToSrcRange(Src value) {
  static_assert(std::is_arithmetic<Src>::value, "Argument must be numeric.");
  static_assert(std::is_arithmetic<Dst>::value, "Result must be numeric.");
  static_assert(Bounds<Dst>::lowest() < Bounds<Dst>::max(), "");
  return DstRangeRelationToSrcRangeImpl<Dst, Src, Bounds>::Check(value);
}


template <size_t Size, bool IsSigned>
struct IntegerForDigitsAndSign;
# 418 "../../base/numerics/safe_conversions_impl.h"
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<int8_t>::value, std::is_signed<int8_t>::value> { using type = int8_t; };
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<uint8_t>::value, std::is_signed<uint8_t>::value> { using type = uint8_t; };
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<int16_t>::value, std::is_signed<int16_t>::value> { using type = int16_t; };
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<uint16_t>::value, std::is_signed<uint16_t>::value> { using type = uint16_t; };
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<int32_t>::value, std::is_signed<int32_t>::value> { using type = int32_t; };
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<uint32_t>::value, std::is_signed<uint32_t>::value> { using type = uint32_t; };
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<int64_t>::value, std::is_signed<int64_t>::value> { using type = int64_t; };
template <> struct IntegerForDigitsAndSign<IntegerBitsPlusSign<uint64_t>::value, std::is_signed<uint64_t>::value> { using type = uint64_t; };





static_assert(IntegerBitsPlusSign<intmax_t>::value == 64,
              "Max integer size not supported for this toolchain.");

template <typename Integer, bool IsSigned = std::is_signed<Integer>::value>
struct TwiceWiderInteger {
  using type =
      typename IntegerForDigitsAndSign<IntegerBitsPlusSign<Integer>::value * 2,
                                       IsSigned>::type;
};

enum ArithmeticPromotionCategory {
  LEFT_PROMOTION,
  RIGHT_PROMOTION
};


template <typename Lhs,
          typename Rhs,
          ArithmeticPromotionCategory Promotion =
              (MaxExponent<Lhs>::value > MaxExponent<Rhs>::value)
                  ? LEFT_PROMOTION
                  : RIGHT_PROMOTION>
struct MaxExponentPromotion;

template <typename Lhs, typename Rhs>
struct MaxExponentPromotion<Lhs, Rhs, LEFT_PROMOTION> {
  using type = Lhs;
};

template <typename Lhs, typename Rhs>
struct MaxExponentPromotion<Lhs, Rhs, RIGHT_PROMOTION> {
  using type = Rhs;
};


template <typename Lhs,
          typename Rhs,
          ArithmeticPromotionCategory Promotion =
              std::is_signed<Lhs>::value
                  ? (std::is_signed<Rhs>::value
                         ? (MaxExponent<Lhs>::value > MaxExponent<Rhs>::value
                                ? LEFT_PROMOTION
                                : RIGHT_PROMOTION)
                         : LEFT_PROMOTION)
                  : (std::is_signed<Rhs>::value
                         ? RIGHT_PROMOTION
                         : (MaxExponent<Lhs>::value < MaxExponent<Rhs>::value
                                ? LEFT_PROMOTION
                                : RIGHT_PROMOTION))>
struct LowestValuePromotion;

template <typename Lhs, typename Rhs>
struct LowestValuePromotion<Lhs, Rhs, LEFT_PROMOTION> {
  using type = Lhs;
};

template <typename Lhs, typename Rhs>
struct LowestValuePromotion<Lhs, Rhs, RIGHT_PROMOTION> {
  using type = Rhs;
};


template <
    typename Lhs,
    typename Rhs = Lhs,
    bool is_intmax_type =
        std::is_integral<typename MaxExponentPromotion<Lhs, Rhs>::type>::value&&
            IntegerBitsPlusSign<typename MaxExponentPromotion<Lhs, Rhs>::type>::
                value == IntegerBitsPlusSign<intmax_t>::value,
    bool is_max_exponent =
        StaticDstRangeRelationToSrcRange<
            typename MaxExponentPromotion<Lhs, Rhs>::type,
            Lhs>::value ==
        NUMERIC_RANGE_CONTAINED&& StaticDstRangeRelationToSrcRange<
            typename MaxExponentPromotion<Lhs, Rhs>::type,
            Rhs>::value == NUMERIC_RANGE_CONTAINED>
struct BigEnoughPromotion;


template <typename Lhs, typename Rhs, bool is_intmax_type>
struct BigEnoughPromotion<Lhs, Rhs, is_intmax_type, true> {
  using type = typename MaxExponentPromotion<Lhs, Rhs>::type;
  static const bool is_contained = true;
};


template <typename Lhs, typename Rhs>
struct BigEnoughPromotion<Lhs, Rhs, false, false> {
  using type =
      typename TwiceWiderInteger<typename MaxExponentPromotion<Lhs, Rhs>::type,
                                 std::is_signed<Lhs>::value ||
                                     std::is_signed<Rhs>::value>::type;
  static const bool is_contained = true;
};


template <typename Lhs, typename Rhs>
struct BigEnoughPromotion<Lhs, Rhs, true, false> {
  using type = typename MaxExponentPromotion<Lhs, Rhs>::type;
  static const bool is_contained = false;
};





template <typename T, typename Lhs, typename Rhs = Lhs>
struct IsIntegerArithmeticSafe {
  static const bool value =
      !std::is_floating_point<T>::value &&
      !std::is_floating_point<Lhs>::value &&
      !std::is_floating_point<Rhs>::value &&
      std::is_signed<T>::value >= std::is_signed<Lhs>::value &&
      IntegerBitsPlusSign<T>::value >= (2 * IntegerBitsPlusSign<Lhs>::value) &&
      std::is_signed<T>::value >= std::is_signed<Rhs>::value &&
      IntegerBitsPlusSign<T>::value >= (2 * IntegerBitsPlusSign<Rhs>::value);
};



template <typename Lhs,
          typename Rhs,
          bool is_promotion_possible = IsIntegerArithmeticSafe<
              typename std::conditional<std::is_signed<Lhs>::value ||
                                            std::is_signed<Rhs>::value,
                                        intmax_t,
                                        uintmax_t>::type,
              typename MaxExponentPromotion<Lhs, Rhs>::type>::value>
struct FastIntegerArithmeticPromotion;

template <typename Lhs, typename Rhs>
struct FastIntegerArithmeticPromotion<Lhs, Rhs, true> {
  using type =
      typename TwiceWiderInteger<typename MaxExponentPromotion<Lhs, Rhs>::type,
                                 std::is_signed<Lhs>::value ||
                                     std::is_signed<Rhs>::value>::type;
  static_assert(IsIntegerArithmeticSafe<type, Lhs, Rhs>::value, "");
  static const bool is_contained = true;
};

template <typename Lhs, typename Rhs>
struct FastIntegerArithmeticPromotion<Lhs, Rhs, false> {
  using type = typename BigEnoughPromotion<Lhs, Rhs>::type;
  static const bool is_contained = false;
};


template <typename T, bool is_enum = std::is_enum<T>::value>
struct ArithmeticOrUnderlyingEnum;

template <typename T>
struct ArithmeticOrUnderlyingEnum<T, true> {
  using type = typename std::underlying_type<T>::type;
  static const bool value = std::is_arithmetic<type>::value;
};

template <typename T>
struct ArithmeticOrUnderlyingEnum<T, false> {
  using type = T;
  static const bool value = std::is_arithmetic<type>::value;
};


template <typename T>
class CheckedNumeric;

template <typename T>
class ClampedNumeric;

template <typename T>
class StrictNumeric;


template <typename T>
struct UnderlyingType {
  using type = typename ArithmeticOrUnderlyingEnum<T>::type;
  static const bool is_numeric = std::is_arithmetic<type>::value;
  static const bool is_checked = false;
  static const bool is_clamped = false;
  static const bool is_strict = false;
};

template <typename T>
struct UnderlyingType<CheckedNumeric<T>> {
  using type = T;
  static const bool is_numeric = true;
  static const bool is_checked = true;
  static const bool is_clamped = false;
  static const bool is_strict = false;
};

template <typename T>
struct UnderlyingType<ClampedNumeric<T>> {
  using type = T;
  static const bool is_numeric = true;
  static const bool is_checked = false;
  static const bool is_clamped = true;
  static const bool is_strict = false;
};

template <typename T>
struct UnderlyingType<StrictNumeric<T>> {
  using type = T;
  static const bool is_numeric = true;
  static const bool is_checked = false;
  static const bool is_clamped = false;
  static const bool is_strict = true;
};

template <typename L, typename R>
struct IsCheckedOp {
  static const bool value =
      UnderlyingType<L>::is_numeric && UnderlyingType<R>::is_numeric &&
      (UnderlyingType<L>::is_checked || UnderlyingType<R>::is_checked);
};

template <typename L, typename R>
struct IsClampedOp {
  static const bool value =
      UnderlyingType<L>::is_numeric && UnderlyingType<R>::is_numeric &&
      (UnderlyingType<L>::is_clamped || UnderlyingType<R>::is_clamped) &&
      !(UnderlyingType<L>::is_checked || UnderlyingType<R>::is_checked);
};

template <typename L, typename R>
struct IsStrictOp {
  static const bool value =
      UnderlyingType<L>::is_numeric && UnderlyingType<R>::is_numeric &&
      (UnderlyingType<L>::is_strict || UnderlyingType<R>::is_strict) &&
      !(UnderlyingType<L>::is_checked || UnderlyingType<R>::is_checked) &&
      !(UnderlyingType<L>::is_clamped || UnderlyingType<R>::is_clamped);
};




template <typename Src>
constexpr typename std::make_signed<
    typename base::internal::UnderlyingType<Src>::type>::type
as_signed(const Src value) {
  static_assert(std::is_integral<decltype(as_signed(value))>::value,
                "Argument must be a signed or unsigned integer type.");
  return static_cast<decltype(as_signed(value))>(value);
}




template <typename Src>
constexpr typename std::make_unsigned<
    typename base::internal::UnderlyingType<Src>::type>::type
as_unsigned(const Src value) {
  static_assert(std::is_integral<decltype(as_unsigned(value))>::value,
                "Argument must be a signed or unsigned integer type.");
  return static_cast<decltype(as_unsigned(value))>(value);
}

template <typename L, typename R>
constexpr bool IsLessImpl(const L lhs,
                          const R rhs,
                          const RangeCheck l_range,
                          const RangeCheck r_range) {
  return l_range.IsUnderflow() || r_range.IsOverflow() ||
         (l_range == r_range &&
          static_cast<decltype(lhs + rhs)>(lhs) <
              static_cast<decltype(lhs + rhs)>(rhs));
}

template <typename L, typename R>
struct IsLess {
  static_assert(std::is_arithmetic<L>::value && std::is_arithmetic<R>::value,
                "Types must be numeric.");
  static constexpr bool Test(const L lhs, const R rhs) {
    return IsLessImpl(lhs, rhs, DstRangeRelationToSrcRange<R>(lhs),
                      DstRangeRelationToSrcRange<L>(rhs));
  }
};

template <typename L, typename R>
constexpr bool IsLessOrEqualImpl(const L lhs,
                                 const R rhs,
                                 const RangeCheck l_range,
                                 const RangeCheck r_range) {
  return l_range.IsUnderflow() || r_range.IsOverflow() ||
         (l_range == r_range &&
          static_cast<decltype(lhs + rhs)>(lhs) <=
              static_cast<decltype(lhs + rhs)>(rhs));
}

template <typename L, typename R>
struct IsLessOrEqual {
  static_assert(std::is_arithmetic<L>::value && std::is_arithmetic<R>::value,
                "Types must be numeric.");
  static constexpr bool Test(const L lhs, const R rhs) {
    return IsLessOrEqualImpl(lhs, rhs, DstRangeRelationToSrcRange<R>(lhs),
                             DstRangeRelationToSrcRange<L>(rhs));
  }
};

template <typename L, typename R>
constexpr bool IsGreaterImpl(const L lhs,
                             const R rhs,
                             const RangeCheck l_range,
                             const RangeCheck r_range) {
  return l_range.IsOverflow() || r_range.IsUnderflow() ||
         (l_range == r_range &&
          static_cast<decltype(lhs + rhs)>(lhs) >
              static_cast<decltype(lhs + rhs)>(rhs));
}

template <typename L, typename R>
struct IsGreater {
  static_assert(std::is_arithmetic<L>::value && std::is_arithmetic<R>::value,
                "Types must be numeric.");
  static constexpr bool Test(const L lhs, const R rhs) {
    return IsGreaterImpl(lhs, rhs, DstRangeRelationToSrcRange<R>(lhs),
                         DstRangeRelationToSrcRange<L>(rhs));
  }
};

template <typename L, typename R>
constexpr bool IsGreaterOrEqualImpl(const L lhs,
                                    const R rhs,
                                    const RangeCheck l_range,
                                    const RangeCheck r_range) {
  return l_range.IsOverflow() || r_range.IsUnderflow() ||
         (l_range == r_range &&
          static_cast<decltype(lhs + rhs)>(lhs) >=
              static_cast<decltype(lhs + rhs)>(rhs));
}

template <typename L, typename R>
struct IsGreaterOrEqual {
  static_assert(std::is_arithmetic<L>::value && std::is_arithmetic<R>::value,
                "Types must be numeric.");
  static constexpr bool Test(const L lhs, const R rhs) {
    return IsGreaterOrEqualImpl(lhs, rhs, DstRangeRelationToSrcRange<R>(lhs),
                                DstRangeRelationToSrcRange<L>(rhs));
  }
};

template <typename L, typename R>
struct IsEqual {
  static_assert(std::is_arithmetic<L>::value && std::is_arithmetic<R>::value,
                "Types must be numeric.");
  static constexpr bool Test(const L lhs, const R rhs) {
    return DstRangeRelationToSrcRange<R>(lhs) ==
               DstRangeRelationToSrcRange<L>(rhs) &&
           static_cast<decltype(lhs + rhs)>(lhs) ==
               static_cast<decltype(lhs + rhs)>(rhs);
  }
};

template <typename L, typename R>
struct IsNotEqual {
  static_assert(std::is_arithmetic<L>::value && std::is_arithmetic<R>::value,
                "Types must be numeric.");
  static constexpr bool Test(const L lhs, const R rhs) {
    return DstRangeRelationToSrcRange<R>(lhs) !=
               DstRangeRelationToSrcRange<L>(rhs) ||
           static_cast<decltype(lhs + rhs)>(lhs) !=
               static_cast<decltype(lhs + rhs)>(rhs);
  }
};



template <template <typename, typename> class C, typename L, typename R>
constexpr bool SafeCompare(const L lhs, const R rhs) {
  static_assert(std::is_arithmetic<L>::value && std::is_arithmetic<R>::value,
                "Types must be numeric.");
  using Promotion = BigEnoughPromotion<L, R>;
  using BigType = typename Promotion::type;
  return Promotion::is_contained

             ? C<BigType, BigType>::Test(
                   static_cast<BigType>(static_cast<L>(lhs)),
                   static_cast<BigType>(static_cast<R>(rhs)))

             : C<L, R>::Test(lhs, rhs);
}

template <typename Dst, typename Src>
constexpr bool IsMaxInRangeForNumericType() {
  return IsGreaterOrEqual<Dst, Src>::Test(std::numeric_limits<Dst>::max(),
                                          std::numeric_limits<Src>::max());
}

template <typename Dst, typename Src>
constexpr bool IsMinInRangeForNumericType() {
  return IsLessOrEqual<Dst, Src>::Test(std::numeric_limits<Dst>::lowest(),
                                       std::numeric_limits<Src>::lowest());
}

template <typename Dst, typename Src>
constexpr Dst CommonMax() {
  return !IsMaxInRangeForNumericType<Dst, Src>()
             ? Dst(std::numeric_limits<Dst>::max())
             : Dst(std::numeric_limits<Src>::max());
}

template <typename Dst, typename Src>
constexpr Dst CommonMin() {
  return !IsMinInRangeForNumericType<Dst, Src>()
             ? Dst(std::numeric_limits<Dst>::lowest())
             : Dst(std::numeric_limits<Src>::lowest());
}




template <typename Dst, typename Src = Dst>
constexpr Dst CommonMaxOrMin(bool is_min) {
  return is_min ? CommonMin<Dst, Src>() : CommonMax<Dst, Src>();
}

}
}
# 15 "../../base/numerics/safe_conversions.h" 2








namespace base {
namespace internal {


template <typename Dst, typename Src>
struct SaturateFastAsmOp {
  static const bool is_supported = false;
  static constexpr Dst Do(Src) {

    return CheckOnFailure::template HandleFailure<Dst>();
  }
};





template <typename Dst, typename Src, typename Enable = void>
struct IsValueInRangeFastOp {
  static const bool is_supported = false;
  static constexpr bool Do(Src value) {

    return CheckOnFailure::template HandleFailure<bool>();
  }
};


template <typename Dst, typename Src>
struct IsValueInRangeFastOp<
    Dst,
    Src,
    typename std::enable_if<
        std::is_integral<Dst>::value && std::is_integral<Src>::value &&
        std::is_signed<Dst>::value && std::is_signed<Src>::value &&
        !IsTypeInRangeForNumericType<Dst, Src>::value>::type> {
  static const bool is_supported = true;

  static constexpr bool Do(Src value) {


    return value == static_cast<Dst>(value);
  }
};


template <typename Dst, typename Src>
struct IsValueInRangeFastOp<
    Dst,
    Src,
    typename std::enable_if<
        std::is_integral<Dst>::value && std::is_integral<Src>::value &&
        !std::is_signed<Dst>::value && std::is_signed<Src>::value &&
        !IsTypeInRangeForNumericType<Dst, Src>::value>::type> {
  static const bool is_supported = true;

  static constexpr bool Do(Src value) {


    return as_unsigned(value) <= as_unsigned(CommonMax<Src, Dst>());
  }
};



template <typename Dst, typename Src>
constexpr bool IsValueInRangeForNumericType(Src value) {
  using SrcType = typename internal::UnderlyingType<Src>::type;
  return internal::IsValueInRangeFastOp<Dst, SrcType>::is_supported
             ? internal::IsValueInRangeFastOp<Dst, SrcType>::Do(
                   static_cast<SrcType>(value))
             : internal::DstRangeRelationToSrcRange<Dst>(
                   static_cast<SrcType>(value))
                   .IsValid();
}




template <typename Dst,
          class CheckHandler = internal::CheckOnFailure,
          typename Src>
constexpr Dst checked_cast(Src value) {


  using SrcType = typename internal::UnderlyingType<Src>::type;
  return __builtin_expect(!!((IsValueInRangeForNumericType<Dst>(value))), 1)
             ? static_cast<Dst>(static_cast<SrcType>(value))
             : CheckHandler::template HandleFailure<Dst>();
}




template <typename T>
struct SaturationDefaultLimits : public std::numeric_limits<T> {
  static constexpr T NaN() {
    return std::numeric_limits<T>::has_quiet_NaN
               ? std::numeric_limits<T>::quiet_NaN()
               : T();
  }
  using std::numeric_limits<T>::max;
  static constexpr T Overflow() {
    return std::numeric_limits<T>::has_infinity
               ? std::numeric_limits<T>::infinity()
               : std::numeric_limits<T>::max();
  }
  using std::numeric_limits<T>::lowest;
  static constexpr T Underflow() {
    return std::numeric_limits<T>::has_infinity
               ? std::numeric_limits<T>::infinity() * -1
               : std::numeric_limits<T>::lowest();
  }
};

template <typename Dst, template <typename> class S, typename Src>
constexpr Dst saturated_cast_impl(Src value, RangeCheck constraint) {


  return !constraint.IsOverflowFlagSet()
             ? (!constraint.IsUnderflowFlagSet() ? static_cast<Dst>(value)
                                                 : S<Dst>::Underflow())

             : (std::is_integral<Src>::value || !constraint.IsUnderflowFlagSet()
                    ? S<Dst>::Overflow()
                    : S<Dst>::NaN());
}




template <typename Dst, typename Src, typename Enable = void>
struct SaturateFastOp {
  static const bool is_supported = false;
  static constexpr Dst Do(Src value) {

    return CheckOnFailure::template HandleFailure<Dst>();
  }
};

template <typename Dst, typename Src>
struct SaturateFastOp<
    Dst,
    Src,
    typename std::enable_if<std::is_integral<Src>::value &&
                            std::is_integral<Dst>::value>::type> {
  static const bool is_supported = true;
  static Dst Do(Src value) {
    if (SaturateFastAsmOp<Dst, Src>::is_supported)
      return SaturateFastAsmOp<Dst, Src>::Do(value);




    Dst saturated = CommonMaxOrMin<Dst, Src>(
        IsMaxInRangeForNumericType<Dst, Src>() ||
        (!IsMinInRangeForNumericType<Dst, Src>() && IsValueNegative(value)));
    return __builtin_expect(!!(IsValueInRangeForNumericType<Dst>(value)), 1)
               ? static_cast<Dst>(value)
               : saturated;
  }
};





template <typename Dst,
          template <typename> class SaturationHandler = SaturationDefaultLimits,
          typename Src>
constexpr Dst saturated_cast(Src value) {
  using SrcType = typename UnderlyingType<Src>::type;
  return !IsCompileTimeConstant(value) &&
                 SaturateFastOp<Dst, SrcType>::is_supported &&
                 std::is_same<SaturationHandler<Dst>,
                              SaturationDefaultLimits<Dst>>::value
             ? SaturateFastOp<Dst, SrcType>::Do(static_cast<SrcType>(value))
             : saturated_cast_impl<Dst, SaturationHandler, SrcType>(
                   static_cast<SrcType>(value),
                   DstRangeRelationToSrcRange<Dst, SaturationHandler, SrcType>(
                       static_cast<SrcType>(value)));
}




template <typename Dst, typename Src>
constexpr Dst strict_cast(Src value) {
  using SrcType = typename UnderlyingType<Src>::type;
  static_assert(UnderlyingType<Src>::is_numeric, "Argument must be numeric.");
  static_assert(std::is_arithmetic<Dst>::value, "Result must be numeric.");







  static_assert(StaticDstRangeRelationToSrcRange<Dst, SrcType>::value ==
                    NUMERIC_RANGE_CONTAINED,
                "The source type is out of range for the destination type. "
                "Please see strict_cast<> comments for more information.");

  return static_cast<Dst>(static_cast<SrcType>(value));
}


template <typename Dst, typename Src, class Enable = void>
struct IsNumericRangeContained {
  static const bool value = false;
};

template <typename Dst, typename Src>
struct IsNumericRangeContained<
    Dst,
    Src,
    typename std::enable_if<ArithmeticOrUnderlyingEnum<Dst>::value &&
                            ArithmeticOrUnderlyingEnum<Src>::value>::type> {
  static const bool value = StaticDstRangeRelationToSrcRange<Dst, Src>::value ==
                            NUMERIC_RANGE_CONTAINED;
};
# 254 "../../base/numerics/safe_conversions.h"
template <typename T>
class StrictNumeric {
 public:
  using type = T;

  constexpr StrictNumeric() : value_(0) {}


  template <typename Src>
  constexpr StrictNumeric(const StrictNumeric<Src>& rhs)
      : value_(strict_cast<T>(rhs.value_)) {}



  template <typename Src>
  constexpr StrictNumeric(Src value)
      : value_(strict_cast<T>(value)) {}
# 284 "../../base/numerics/safe_conversions.h"
  template <typename Dst,
            typename std::enable_if<
                IsNumericRangeContained<Dst, T>::value>::type* = nullptr>
  constexpr operator Dst() const {
    return static_cast<typename ArithmeticOrUnderlyingEnum<Dst>::type>(value_);
  }

 private:
  const T value_;
};


template <typename T>
constexpr StrictNumeric<typename UnderlyingType<T>::type> MakeStrictNum(
    const T value) {
  return value;
}


template <typename T>
std::ostream& operator<<(std::ostream& os, const StrictNumeric<T>& value) {
  os << static_cast<T>(value);
  return os;
}
# 318 "../../base/numerics/safe_conversions.h"
template <typename L, typename R, typename std::enable_if< internal::IsStrictOp<L, R>::value>::type* = nullptr> constexpr bool operator <(const L lhs, const R rhs) { return SafeCompare<IsLess, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsStrictOp<L, R>::value>::type* = nullptr> constexpr bool operator <=(const L lhs, const R rhs) { return SafeCompare<IsLessOrEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsStrictOp<L, R>::value>::type* = nullptr> constexpr bool operator >(const L lhs, const R rhs) { return SafeCompare<IsGreater, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsStrictOp<L, R>::value>::type* = nullptr> constexpr bool operator >=(const L lhs, const R rhs) { return SafeCompare<IsGreaterOrEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsStrictOp<L, R>::value>::type* = nullptr> constexpr bool operator ==(const L lhs, const R rhs) { return SafeCompare<IsEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsStrictOp<L, R>::value>::type* = nullptr> constexpr bool operator !=(const L lhs, const R rhs) { return SafeCompare<IsNotEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };

};

using internal::as_signed;
using internal::as_unsigned;
using internal::checked_cast;
using internal::strict_cast;
using internal::saturated_cast;
using internal::SafeUnsignedAbs;
using internal::StrictNumeric;
using internal::MakeStrictNum;
using internal::IsValueInRangeForNumericType;
using internal::IsTypeInRangeForNumericType;
using internal::IsValueNegative;


using SizeT = StrictNumeric<size_t>;

}
# 18 "../../base/numerics/checked_math_impl.h" 2
# 1 "../../base/numerics/safe_math_shared_impl.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/numerics/safe_math_shared_impl.h" 2


# 1 "../../buildtools/third_party/libc++/trunk/include/cassert" 1 3
# 21 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/assert.h" 1 3 4
# 22 "../../buildtools/third_party/libc++/trunk/include/cassert" 2 3
# 25 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 12 "../../base/numerics/safe_math_shared_impl.h" 2
# 26 "../../base/numerics/safe_math_shared_impl.h"
# 1 "../../base/numerics/safe_math_clang_gcc_impl.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/cassert" 1 3
# 21 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/assert.h" 1 3 4
# 22 "../../buildtools/third_party/libc++/trunk/include/cassert" 2 3
# 25 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 9 "../../base/numerics/safe_math_clang_gcc_impl.h" 2
# 21 "../../base/numerics/safe_math_clang_gcc_impl.h"
namespace base {
namespace internal {




template <typename T, typename U>
struct CheckedMulFastAsmOp {
  static const bool is_supported = false;
  template <typename V>
  static constexpr bool Do(T, U, V*) {

    return CheckOnFailure::template HandleFailure<bool>();
  }
};

template <typename T, typename U>
struct ClampedAddFastAsmOp {
  static const bool is_supported = false;
  template <typename V>
  static constexpr V Do(T, U) {

    return CheckOnFailure::template HandleFailure<V>();
  }
};

template <typename T, typename U>
struct ClampedSubFastAsmOp {
  static const bool is_supported = false;
  template <typename V>
  static constexpr V Do(T, U) {

    return CheckOnFailure::template HandleFailure<V>();
  }
};

template <typename T, typename U>
struct ClampedMulFastAsmOp {
  static const bool is_supported = false;
  template <typename V>
  static constexpr V Do(T, U) {

    return CheckOnFailure::template HandleFailure<V>();
  }
};



template <typename T, typename U>
struct CheckedAddFastOp {
  static const bool is_supported = true;
  template <typename V>
  __attribute__((always_inline)) static constexpr bool Do(T x, U y, V* result) {
    return !__builtin_add_overflow(x, y, result);
  }
};

template <typename T, typename U>
struct CheckedSubFastOp {
  static const bool is_supported = true;
  template <typename V>
  __attribute__((always_inline)) static constexpr bool Do(T x, U y, V* result) {
    return !__builtin_sub_overflow(x, y, result);
  }
};

template <typename T, typename U>
struct CheckedMulFastOp {





  static const bool is_supported =
      (IsTypeInRangeForNumericType<intptr_t, T>::value &&
       IsTypeInRangeForNumericType<intptr_t, U>::value) ||
      (IsTypeInRangeForNumericType<uintptr_t, T>::value &&
       IsTypeInRangeForNumericType<uintptr_t, U>::value);



  template <typename V>
  __attribute__((always_inline)) static constexpr bool Do(T x, U y, V* result) {
    return CheckedMulFastAsmOp<T, U>::is_supported
               ? CheckedMulFastAsmOp<T, U>::Do(x, y, result)
               : !__builtin_mul_overflow(x, y, result);
  }
};

template <typename T, typename U>
struct ClampedAddFastOp {
  static const bool is_supported = ClampedAddFastAsmOp<T, U>::is_supported;
  template <typename V>
  __attribute__((always_inline)) static V Do(T x, U y) {
    return ClampedAddFastAsmOp<T, U>::template Do<V>(x, y);
  }
};

template <typename T, typename U>
struct ClampedSubFastOp {
  static const bool is_supported = ClampedSubFastAsmOp<T, U>::is_supported;
  template <typename V>
  __attribute__((always_inline)) static V Do(T x, U y) {
    return ClampedSubFastAsmOp<T, U>::template Do<V>(x, y);
  }
};

template <typename T, typename U>
struct ClampedMulFastOp {
  static const bool is_supported = ClampedMulFastAsmOp<T, U>::is_supported;
  template <typename V>
  __attribute__((always_inline)) static V Do(T x, U y) {
    return ClampedMulFastAsmOp<T, U>::template Do<V>(x, y);
  }
};

template <typename T>
struct ClampedNegFastOp {
  static const bool is_supported = std::is_signed<T>::value;
  __attribute__((always_inline)) static T Do(T value) {

    if (!ClampedSubFastAsmOp<T, T>::is_supported) {
      T result;
      return !__builtin_sub_overflow(T(0), value, &result)
                 ? result
                 : std::numeric_limits<T>::max();
    }


    return ClampedSubFastOp<T, T>::template Do<T>(T(0), value);
  }
};

}
}
# 27 "../../base/numerics/safe_math_shared_impl.h" 2





namespace base {
namespace internal {
# 113 "../../base/numerics/safe_math_shared_impl.h"
template <typename Numeric,
          bool IsInteger = std::is_integral<Numeric>::value,
          bool IsFloat = std::is_floating_point<Numeric>::value>
struct UnsignedOrFloatForSize;

template <typename Numeric>
struct UnsignedOrFloatForSize<Numeric, true, false> {
  using type = typename std::make_unsigned<Numeric>::type;
};

template <typename Numeric>
struct UnsignedOrFloatForSize<Numeric, false, true> {
  using type = Numeric;
};






template <typename T,
          typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
constexpr T NegateWrapper(T value) {
  using UnsignedT = typename std::make_unsigned<T>::type;

  return static_cast<T>(UnsignedT(0) - static_cast<UnsignedT>(value));
}

template <
    typename T,
    typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
constexpr T NegateWrapper(T value) {
  return -value;
}

template <typename T,
          typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
constexpr typename std::make_unsigned<T>::type InvertWrapper(T value) {
  return ~value;
}

template <typename T,
          typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
constexpr T AbsWrapper(T value) {
  return static_cast<T>(SafeUnsignedAbs(value));
}

template <
    typename T,
    typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
constexpr T AbsWrapper(T value) {
  return value < 0 ? -value : value;
}

template <template <typename, typename, typename> class M,
          typename L,
          typename R>
struct MathWrapper {
  using math = M<typename UnderlyingType<L>::type,
                 typename UnderlyingType<R>::type,
                 void>;
  using type = typename math::result_type;
};



template <template <typename, typename, typename> class M,
          typename L,
          typename R,
          typename... Args>
struct ResultType;

template <template <typename, typename, typename> class M,
          typename L,
          typename R>
struct ResultType<M, L, R> {
  using type = typename MathWrapper<M, L, R>::type;
};

template <template <typename, typename, typename> class M,
          typename L,
          typename R,
          typename... Args>
struct ResultType {
  using type =
      typename ResultType<M, typename ResultType<M, L, R>::type, Args...>::type;
};
# 234 "../../base/numerics/safe_math_shared_impl.h"
}
}
# 19 "../../base/numerics/checked_math_impl.h" 2

namespace base {
namespace internal {

template <typename T>
constexpr bool CheckedAddImpl(T x, T y, T* result) {
  static_assert(std::is_integral<T>::value, "Type must be integral");


  using UnsignedDst = typename std::make_unsigned<T>::type;
  using SignedDst = typename std::make_signed<T>::type;
  UnsignedDst ux = static_cast<UnsignedDst>(x);
  UnsignedDst uy = static_cast<UnsignedDst>(y);
  UnsignedDst uresult = static_cast<UnsignedDst>(ux + uy);
  *result = static_cast<T>(uresult);


  return (std::is_signed<T>::value)
             ? static_cast<SignedDst>((uresult ^ ux) & (uresult ^ uy)) >= 0
             : uresult >= uy;
}

template <typename T, typename U, class Enable = void>
struct CheckedAddOp {};

template <typename T, typename U>
struct CheckedAddOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {

    if (CheckedAddFastOp<T, U>::is_supported)
      return CheckedAddFastOp<T, U>::Do(x, y, result);


    using FastPromotion = typename FastIntegerArithmeticPromotion<T, U>::type;
    using Promotion =
        typename std::conditional<(IntegerBitsPlusSign<FastPromotion>::value >
                                   IntegerBitsPlusSign<intptr_t>::value),
                                  typename BigEnoughPromotion<T, U>::type,
                                  FastPromotion>::type;


    if (__builtin_expect(!!(!IsValueInRangeForNumericType<Promotion>(x) || !IsValueInRangeForNumericType<Promotion>(y)), 0)) {

      return false;
    }

    Promotion presult = {};
    bool is_valid = true;
    if (IsIntegerArithmeticSafe<Promotion, T, U>::value) {
      presult = static_cast<Promotion>(x) + static_cast<Promotion>(y);
    } else {
      is_valid = CheckedAddImpl(static_cast<Promotion>(x),
                                static_cast<Promotion>(y), &presult);
    }
    *result = static_cast<V>(presult);
    return is_valid && IsValueInRangeForNumericType<V>(presult);
  }
};

template <typename T>
constexpr bool CheckedSubImpl(T x, T y, T* result) {
  static_assert(std::is_integral<T>::value, "Type must be integral");


  using UnsignedDst = typename std::make_unsigned<T>::type;
  using SignedDst = typename std::make_signed<T>::type;
  UnsignedDst ux = static_cast<UnsignedDst>(x);
  UnsignedDst uy = static_cast<UnsignedDst>(y);
  UnsignedDst uresult = static_cast<UnsignedDst>(ux - uy);
  *result = static_cast<T>(uresult);


  return (std::is_signed<T>::value)
             ? static_cast<SignedDst>((uresult ^ ux) & (ux ^ uy)) >= 0
             : x >= y;
}

template <typename T, typename U, class Enable = void>
struct CheckedSubOp {};

template <typename T, typename U>
struct CheckedSubOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {

    if (CheckedSubFastOp<T, U>::is_supported)
      return CheckedSubFastOp<T, U>::Do(x, y, result);


    using FastPromotion = typename FastIntegerArithmeticPromotion<T, U>::type;
    using Promotion =
        typename std::conditional<(IntegerBitsPlusSign<FastPromotion>::value >
                                   IntegerBitsPlusSign<intptr_t>::value),
                                  typename BigEnoughPromotion<T, U>::type,
                                  FastPromotion>::type;


    if (__builtin_expect(!!(!IsValueInRangeForNumericType<Promotion>(x) || !IsValueInRangeForNumericType<Promotion>(y)), 0)) {

      return false;
    }

    Promotion presult = {};
    bool is_valid = true;
    if (IsIntegerArithmeticSafe<Promotion, T, U>::value) {
      presult = static_cast<Promotion>(x) - static_cast<Promotion>(y);
    } else {
      is_valid = CheckedSubImpl(static_cast<Promotion>(x),
                                static_cast<Promotion>(y), &presult);
    }
    *result = static_cast<V>(presult);
    return is_valid && IsValueInRangeForNumericType<V>(presult);
  }
};

template <typename T>
constexpr bool CheckedMulImpl(T x, T y, T* result) {
  static_assert(std::is_integral<T>::value, "Type must be integral");


  using UnsignedDst = typename std::make_unsigned<T>::type;
  using SignedDst = typename std::make_signed<T>::type;
  const UnsignedDst ux = SafeUnsignedAbs(x);
  const UnsignedDst uy = SafeUnsignedAbs(y);
  UnsignedDst uresult = static_cast<UnsignedDst>(ux * uy);
  const bool is_negative =
      std::is_signed<T>::value && static_cast<SignedDst>(x ^ y) < 0;
  *result = is_negative ? 0 - uresult : uresult;



  return uy <= UnsignedDst(!std::is_signed<T>::value || is_negative) ||
         ux <= (std::numeric_limits<T>::max() + UnsignedDst(is_negative)) / uy;
}

template <typename T, typename U, class Enable = void>
struct CheckedMulOp {};

template <typename T, typename U>
struct CheckedMulOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {

    if (CheckedMulFastOp<T, U>::is_supported)
      return CheckedMulFastOp<T, U>::Do(x, y, result);

    using Promotion = typename FastIntegerArithmeticPromotion<T, U>::type;

    if (__builtin_expect(!!((!IsValueInRangeForNumericType<Promotion>(x) || !IsValueInRangeForNumericType<Promotion>(y)) && x && y), 0)) {


      return false;
    }

    Promotion presult = {};
    bool is_valid = true;
    if (CheckedMulFastOp<Promotion, Promotion>::is_supported) {

      is_valid = CheckedMulFastOp<Promotion, Promotion>::Do(x, y, &presult);
    } else if (IsIntegerArithmeticSafe<Promotion, T, U>::value) {
      presult = static_cast<Promotion>(x) * static_cast<Promotion>(y);
    } else {
      is_valid = CheckedMulImpl(static_cast<Promotion>(x),
                                static_cast<Promotion>(y), &presult);
    }
    *result = static_cast<V>(presult);
    return is_valid && IsValueInRangeForNumericType<V>(presult);
  }
};



template <typename T, typename U, class Enable = void>
struct CheckedDivOp {};

template <typename T, typename U>
struct CheckedDivOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {
    if (__builtin_expect(!!(!y), 0))
      return false;



    using Promotion = typename BigEnoughPromotion<T, U>::type;
    if (__builtin_expect(!!((std::is_signed<T>::value && std::is_signed<U>::value && IsTypeInRangeForNumericType<T, Promotion>::value && static_cast<Promotion>(x) == std::numeric_limits<Promotion>::lowest() && y == static_cast<U>(-1))), 0)) {





      return false;
    }


    if (__builtin_expect(!!((!IsValueInRangeForNumericType<Promotion>(x) || !IsValueInRangeForNumericType<Promotion>(y)) && x), 0)) {


      return false;
    }

    Promotion presult = Promotion(x) / Promotion(y);
    *result = static_cast<V>(presult);
    return IsValueInRangeForNumericType<V>(presult);
  }
};

template <typename T, typename U, class Enable = void>
struct CheckedModOp {};

template <typename T, typename U>
struct CheckedModOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {
    using Promotion = typename BigEnoughPromotion<T, U>::type;
    if (__builtin_expect(!!(y), 1)) {
      Promotion presult = static_cast<Promotion>(x) % static_cast<Promotion>(y);
      *result = static_cast<Promotion>(presult);
      return IsValueInRangeForNumericType<V>(presult);
    }
    return false;
  }
};

template <typename T, typename U, class Enable = void>
struct CheckedLshOp {};




template <typename T, typename U>
struct CheckedLshOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = T;
  template <typename V>
  static constexpr bool Do(T x, U shift, V* result) {

    if (__builtin_expect(!!(!IsValueNegative(x) && as_unsigned(shift) < as_unsigned(std::numeric_limits<T>::digits)), 1)) {



      *result = static_cast<V>(as_unsigned(x) << shift);

      return *result >> shift == x;
    }


    return std::is_signed<T>::value && !x &&
           as_unsigned(shift) == as_unsigned(std::numeric_limits<T>::digits);
  }
};

template <typename T, typename U, class Enable = void>
struct CheckedRshOp {};




template <typename T, typename U>
struct CheckedRshOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = T;
  template <typename V>
  static bool Do(T x, U shift, V* result) {

    if (__builtin_expect(!!(as_unsigned(shift) < IntegerBitsPlusSign<T>::value), 1)) {

      T tmp = x >> shift;
      *result = static_cast<V>(tmp);
      return IsValueInRangeForNumericType<V>(tmp);
    }
    return false;
  }
};

template <typename T, typename U, class Enable = void>
struct CheckedAndOp {};


template <typename T, typename U>
struct CheckedAndOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename std::make_unsigned<
      typename MaxExponentPromotion<T, U>::type>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {
    result_type tmp = static_cast<result_type>(x) & static_cast<result_type>(y);
    *result = static_cast<V>(tmp);
    return IsValueInRangeForNumericType<V>(tmp);
  }
};

template <typename T, typename U, class Enable = void>
struct CheckedOrOp {};


template <typename T, typename U>
struct CheckedOrOp<T,
                   U,
                   typename std::enable_if<std::is_integral<T>::value &&
                                           std::is_integral<U>::value>::type> {
  using result_type = typename std::make_unsigned<
      typename MaxExponentPromotion<T, U>::type>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {
    result_type tmp = static_cast<result_type>(x) | static_cast<result_type>(y);
    *result = static_cast<V>(tmp);
    return IsValueInRangeForNumericType<V>(tmp);
  }
};

template <typename T, typename U, class Enable = void>
struct CheckedXorOp {};


template <typename T, typename U>
struct CheckedXorOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename std::make_unsigned<
      typename MaxExponentPromotion<T, U>::type>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {
    result_type tmp = static_cast<result_type>(x) ^ static_cast<result_type>(y);
    *result = static_cast<V>(tmp);
    return IsValueInRangeForNumericType<V>(tmp);
  }
};



template <typename T, typename U, class Enable = void>
struct CheckedMaxOp {};

template <typename T, typename U>
struct CheckedMaxOp<
    T,
    U,
    typename std::enable_if<std::is_arithmetic<T>::value &&
                            std::is_arithmetic<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {
    result_type tmp = IsGreater<T, U>::Test(x, y) ? static_cast<result_type>(x)
                                                  : static_cast<result_type>(y);
    *result = static_cast<V>(tmp);
    return IsValueInRangeForNumericType<V>(tmp);
  }
};



template <typename T, typename U, class Enable = void>
struct CheckedMinOp {};

template <typename T, typename U>
struct CheckedMinOp<
    T,
    U,
    typename std::enable_if<std::is_arithmetic<T>::value &&
                            std::is_arithmetic<U>::value>::type> {
  using result_type = typename LowestValuePromotion<T, U>::type;
  template <typename V>
  static constexpr bool Do(T x, U y, V* result) {
    result_type tmp = IsLess<T, U>::Test(x, y) ? static_cast<result_type>(x)
                                               : static_cast<result_type>(y);
    *result = static_cast<V>(tmp);
    return IsValueInRangeForNumericType<V>(tmp);
  }
};
# 436 "../../base/numerics/checked_math_impl.h"
template <typename T, typename U> struct CheckedAddOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V> static constexpr bool Do(T x, U y, V* result) { using Promotion = typename MaxExponentPromotion<T, U>::type; Promotion presult = x + y; *result = static_cast<V>(presult); return IsValueInRangeForNumericType<V>(presult); } };
template <typename T, typename U> struct CheckedSubOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V> static constexpr bool Do(T x, U y, V* result) { using Promotion = typename MaxExponentPromotion<T, U>::type; Promotion presult = x - y; *result = static_cast<V>(presult); return IsValueInRangeForNumericType<V>(presult); } };
template <typename T, typename U> struct CheckedMulOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V> static constexpr bool Do(T x, U y, V* result) { using Promotion = typename MaxExponentPromotion<T, U>::type; Promotion presult = x * y; *result = static_cast<V>(presult); return IsValueInRangeForNumericType<V>(presult); } };
template <typename T, typename U> struct CheckedDivOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V> static constexpr bool Do(T x, U y, V* result) { using Promotion = typename MaxExponentPromotion<T, U>::type; Promotion presult = x / y; *result = static_cast<V>(presult); return IsValueInRangeForNumericType<V>(presult); } };






enum NumericRepresentation {
  NUMERIC_INTEGER,
  NUMERIC_FLOATING,
  NUMERIC_UNKNOWN
};

template <typename NumericType>
struct GetNumericRepresentation {
  static const NumericRepresentation value =
      std::is_integral<NumericType>::value
          ? NUMERIC_INTEGER
          : (std::is_floating_point<NumericType>::value ? NUMERIC_FLOATING
                                                        : NUMERIC_UNKNOWN);
};

template <typename T,
          NumericRepresentation type = GetNumericRepresentation<T>::value>
class CheckedNumericState {};


template <typename T>
class CheckedNumericState<T, NUMERIC_INTEGER> {
 private:



  bool is_valid_;
  T value_;


  template <typename Src>
  static constexpr T WellDefinedConversionOrZero(const Src value,
                                                 const bool is_valid) {
    using SrcType = typename internal::UnderlyingType<Src>::type;
    return (std::is_integral<SrcType>::value || is_valid)
               ? static_cast<T>(value)
               : static_cast<T>(0);
  }

 public:
  template <typename Src, NumericRepresentation type>
  friend class CheckedNumericState;

  constexpr CheckedNumericState() : is_valid_(true), value_(0) {}

  template <typename Src>
  constexpr CheckedNumericState(Src value, bool is_valid)
      : is_valid_(is_valid && IsValueInRangeForNumericType<T>(value)),
        value_(WellDefinedConversionOrZero(value, is_valid_)) {
    static_assert(std::is_arithmetic<Src>::value, "Argument must be numeric.");
  }


  template <typename Src>
  constexpr CheckedNumericState(const CheckedNumericState<Src>& rhs)
      : is_valid_(rhs.IsValid()),
        value_(WellDefinedConversionOrZero(rhs.value(), is_valid_)) {}

  template <typename Src>
  constexpr explicit CheckedNumericState(Src value)
      : is_valid_(IsValueInRangeForNumericType<T>(value)),
        value_(WellDefinedConversionOrZero(value, is_valid_)) {}

  constexpr bool is_valid() const { return is_valid_; }
  constexpr T value() const { return value_; }
};


template <typename T>
class CheckedNumericState<T, NUMERIC_FLOATING> {
 private:
  T value_;


  template <typename Src>
  static constexpr T WellDefinedConversionOrNaN(const Src value,
                                                const bool is_valid) {
    using SrcType = typename internal::UnderlyingType<Src>::type;
    return (StaticDstRangeRelationToSrcRange<T, SrcType>::value ==
                NUMERIC_RANGE_CONTAINED ||
            is_valid)
               ? static_cast<T>(value)
               : std::numeric_limits<T>::quiet_NaN();
  }

 public:
  template <typename Src, NumericRepresentation type>
  friend class CheckedNumericState;

  constexpr CheckedNumericState() : value_(0.0) {}

  template <typename Src>
  constexpr CheckedNumericState(Src value, bool is_valid)
      : value_(WellDefinedConversionOrNaN(value, is_valid)) {}

  template <typename Src>
  constexpr explicit CheckedNumericState(Src value)
      : value_(WellDefinedConversionOrNaN(
            value,
            IsValueInRangeForNumericType<T>(value))) {}


  template <typename Src>
  constexpr CheckedNumericState(const CheckedNumericState<Src>& rhs)
      : value_(WellDefinedConversionOrNaN(
            rhs.value(),
            rhs.is_valid() && IsValueInRangeForNumericType<T>(rhs.value()))) {}

  constexpr bool is_valid() const {

    return MustTreatAsConstexpr(value_)
               ? value_ <= std::numeric_limits<T>::max() &&
                     value_ >= std::numeric_limits<T>::lowest()
               : std::isfinite(value_);
  }
  constexpr T value() const { return value_; }
};

}
}
# 14 "../../base/numerics/checked_math.h" 2

namespace base {
namespace internal {

template <typename T>
class CheckedNumeric {
  static_assert(std::is_arithmetic<T>::value,
                "CheckedNumeric<T>: T must be a numeric type.");

 public:
  using type = T;

  constexpr CheckedNumeric() {}


  template <typename Src>
  constexpr CheckedNumeric(const CheckedNumeric<Src>& rhs)
      : state_(rhs.state_.value(), rhs.IsValid()) {}

  template <typename Src>
  friend class CheckedNumeric;



  template <typename Src>
  constexpr CheckedNumeric(Src value)
      : state_(value) {
    static_assert(std::is_arithmetic<Src>::value, "Argument must be numeric.");
  }



  template <typename Src>
  constexpr CheckedNumeric(
      StrictNumeric<Src> value)
      : state_(static_cast<Src>(value)) {}




  template <typename Dst = T>
  constexpr bool IsValid() const {
    return state_.is_valid() &&
           IsValueInRangeForNumericType<Dst>(state_.value());
  }




  template <typename Dst>

  __attribute__((warn_unused_result))



  constexpr bool
  AssignIfValid(Dst* result) const {
    return __builtin_expect(!!(IsValid<Dst>()), 1)
               ? ((*result = static_cast<Dst>(state_.value())), true)
               : false;
  }
# 84 "../../base/numerics/checked_math.h"
  template <typename Dst = T, class CheckHandler = CheckOnFailure>
  constexpr StrictNumeric<Dst> ValueOrDie() const {
    return __builtin_expect(!!(IsValid<Dst>()), 1)
               ? static_cast<Dst>(state_.value())
               : CheckHandler::template HandleFailure<Dst>();
  }







  template <typename Dst = T, typename Src>
  constexpr StrictNumeric<Dst> ValueOrDefault(const Src default_value) const {
    return __builtin_expect(!!(IsValid<Dst>()), 1)
               ? static_cast<Dst>(state_.value())
               : checked_cast<Dst>(default_value);
  }




  template <typename Dst>
  constexpr CheckedNumeric<typename UnderlyingType<Dst>::type> Cast() const {
    return *this;
  }




  template <typename U>
  friend U GetNumericValueForTest(const CheckedNumeric<U>& src);


  template <typename Src>
  constexpr CheckedNumeric& operator+=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator-=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator*=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator/=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator%=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator<<=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator>>=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator&=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator|=(const Src rhs);
  template <typename Src>
  constexpr CheckedNumeric& operator^=(const Src rhs);

  constexpr CheckedNumeric operator-() const {



    return MustTreatAsConstexpr(state_.value()) || !std::is_signed<T>::value ||
                   std::is_floating_point<T>::value
               ? CheckedNumeric<T>(
                     NegateWrapper(state_.value()),
                     IsValid() && (!std::is_signed<T>::value ||
                                   std::is_floating_point<T>::value ||
                                   NegateWrapper(state_.value()) !=
                                       std::numeric_limits<T>::lowest()))
               : FastRuntimeNegate();
  }

  constexpr CheckedNumeric operator~() const {
    return CheckedNumeric<decltype(InvertWrapper(T()))>(
        InvertWrapper(state_.value()), IsValid());
  }

  constexpr CheckedNumeric Abs() const {
    return !IsValueNegative(state_.value()) ? *this : -*this;
  }

  template <typename U>
  constexpr CheckedNumeric<typename MathWrapper<CheckedMaxOp, T, U>::type> Max(
      const U rhs) const {
    using R = typename UnderlyingType<U>::type;
    using result_type = typename MathWrapper<CheckedMaxOp, T, U>::type;


    return CheckedNumeric<result_type>(
        static_cast<result_type>(
            IsGreater<T, R>::Test(state_.value(), Wrapper<U>::value(rhs))
                ? state_.value()
                : Wrapper<U>::value(rhs)),
        state_.is_valid() && Wrapper<U>::is_valid(rhs));
  }

  template <typename U>
  constexpr CheckedNumeric<typename MathWrapper<CheckedMinOp, T, U>::type> Min(
      const U rhs) const {
    using R = typename UnderlyingType<U>::type;
    using result_type = typename MathWrapper<CheckedMinOp, T, U>::type;


    return CheckedNumeric<result_type>(
        static_cast<result_type>(
            IsLess<T, R>::Test(state_.value(), Wrapper<U>::value(rhs))
                ? state_.value()
                : Wrapper<U>::value(rhs)),
        state_.is_valid() && Wrapper<U>::is_valid(rhs));
  }




  constexpr CheckedNumeric<typename UnsignedOrFloatForSize<T>::type>
  UnsignedAbs() const {
    return CheckedNumeric<typename UnsignedOrFloatForSize<T>::type>(
        SafeUnsignedAbs(state_.value()), state_.is_valid());
  }

  constexpr CheckedNumeric& operator++() {
    *this += 1;
    return *this;
  }

  constexpr CheckedNumeric operator++(int) {
    CheckedNumeric value = *this;
    *this += 1;
    return value;
  }

  constexpr CheckedNumeric& operator--() {
    *this -= 1;
    return *this;
  }

  constexpr CheckedNumeric operator--(int) {
    CheckedNumeric value = *this;
    *this -= 1;
    return value;
  }



  template <template <typename, typename, typename> class M,
            typename L,
            typename R>
  static constexpr CheckedNumeric MathOp(const L lhs, const R rhs) {
    using Math = typename MathWrapper<M, L, R>::math;
    T result = 0;
    bool is_valid =
        Wrapper<L>::is_valid(lhs) && Wrapper<R>::is_valid(rhs) &&
        Math::Do(Wrapper<L>::value(lhs), Wrapper<R>::value(rhs), &result);
    return CheckedNumeric<T>(result, is_valid);
  }


  template <template <typename, typename, typename> class M, typename R>
  constexpr CheckedNumeric& MathOp(const R rhs) {
    using Math = typename MathWrapper<M, T, R>::math;
    T result = 0;
    bool is_valid = state_.is_valid() && Wrapper<R>::is_valid(rhs) &&
                    Math::Do(state_.value(), Wrapper<R>::value(rhs), &result);
    *this = CheckedNumeric<T>(result, is_valid);
    return *this;
  }

 private:
  CheckedNumericState<T> state_;

  CheckedNumeric FastRuntimeNegate() const {
    T result;
    bool success = CheckedSubOp<T, T>::Do(T(0), state_.value(), &result);
    return CheckedNumeric<T>(result, IsValid() && success);
  }

  template <typename Src>
  constexpr CheckedNumeric(Src value, bool is_valid)
      : state_(value, is_valid) {}



  template <typename Src>
  struct Wrapper {
    static constexpr bool is_valid(Src) { return true; }
    static constexpr Src value(Src value) { return value; }
  };

  template <typename Src>
  struct Wrapper<CheckedNumeric<Src>> {
    static constexpr bool is_valid(const CheckedNumeric<Src> v) {
      return v.IsValid();
    }
    static constexpr Src value(const CheckedNumeric<Src> v) {
      return v.state_.value();
    }
  };

  template <typename Src>
  struct Wrapper<StrictNumeric<Src>> {
    static constexpr bool is_valid(const StrictNumeric<Src>) { return true; }
    static constexpr Src value(const StrictNumeric<Src> v) {
      return static_cast<Src>(v);
    }
  };
};


template <typename Dst, typename Src>
constexpr bool IsValidForType(const CheckedNumeric<Src> value) {
  return value.template IsValid<Dst>();
}

template <typename Dst, typename Src>
constexpr StrictNumeric<Dst> ValueOrDieForType(
    const CheckedNumeric<Src> value) {
  return value.template ValueOrDie<Dst>();
}

template <typename Dst, typename Src, typename Default>
constexpr StrictNumeric<Dst> ValueOrDefaultForType(
    const CheckedNumeric<Src> value,
    const Default default_value) {
  return value.template ValueOrDefault<Dst>(default_value);
}



template <typename T>
constexpr CheckedNumeric<typename UnderlyingType<T>::type> MakeCheckedNum(
    const T value) {
  return value;
}


template <template <typename, typename, typename> class M,
          typename L,
          typename R>
constexpr CheckedNumeric<typename MathWrapper<M, L, R>::type> CheckMathOp(
    const L lhs,
    const R rhs) {
  using Math = typename MathWrapper<M, L, R>::math;
  return CheckedNumeric<typename Math::result_type>::template MathOp<M>(lhs,
                                                                        rhs);
}


template <template <typename, typename, typename> class M,
          typename L,
          typename R,
          typename... Args>
constexpr CheckedNumeric<typename ResultType<M, L, R, Args...>::type>
CheckMathOp(const L lhs, const R rhs, const Args... args) {
  return CheckMathOp<M>(CheckMathOp<M>(lhs, rhs), args...);
}

template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedAddOp, L, R>::type> operator +(const L lhs, const R rhs) { return decltype(lhs + rhs)::template MathOp<CheckedAddOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator +=( const R rhs) { return MathOp<CheckedAddOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedAddOp, L, R, Args...>::type> CheckAdd(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedAddOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedSubOp, L, R>::type> operator -(const L lhs, const R rhs) { return decltype(lhs - rhs)::template MathOp<CheckedSubOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator -=( const R rhs) { return MathOp<CheckedSubOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedSubOp, L, R, Args...>::type> CheckSub(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedSubOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedMulOp, L, R>::type> operator *(const L lhs, const R rhs) { return decltype(lhs * rhs)::template MathOp<CheckedMulOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator *=( const R rhs) { return MathOp<CheckedMulOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedMulOp, L, R, Args...>::type> CheckMul(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedMulOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedDivOp, L, R>::type> operator /(const L lhs, const R rhs) { return decltype(lhs / rhs)::template MathOp<CheckedDivOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator /=( const R rhs) { return MathOp<CheckedDivOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedDivOp, L, R, Args...>::type> CheckDiv(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedDivOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedModOp, L, R>::type> operator %(const L lhs, const R rhs) { return decltype(lhs % rhs)::template MathOp<CheckedModOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator %=( const R rhs) { return MathOp<CheckedModOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedModOp, L, R, Args...>::type> CheckMod(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedModOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedLshOp, L, R>::type> operator <<(const L lhs, const R rhs) { return decltype(lhs << rhs)::template MathOp<CheckedLshOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator <<=( const R rhs) { return MathOp<CheckedLshOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedLshOp, L, R, Args...>::type> CheckLsh(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedLshOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedRshOp, L, R>::type> operator >>(const L lhs, const R rhs) { return decltype(lhs >> rhs)::template MathOp<CheckedRshOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator >>=( const R rhs) { return MathOp<CheckedRshOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedRshOp, L, R, Args...>::type> CheckRsh(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedRshOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedAndOp, L, R>::type> operator &(const L lhs, const R rhs) { return decltype(lhs & rhs)::template MathOp<CheckedAndOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator &=( const R rhs) { return MathOp<CheckedAndOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedAndOp, L, R, Args...>::type> CheckAnd(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedAndOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedOrOp, L, R>::type> operator |(const L lhs, const R rhs) { return decltype(lhs | rhs)::template MathOp<CheckedOrOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator |=( const R rhs) { return MathOp<CheckedOrOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedOrOp, L, R, Args...>::type> CheckOr(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedOrOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsCheckedOp<L, R>::value>::type* = nullptr> constexpr CheckedNumeric< typename MathWrapper<CheckedXorOp, L, R>::type> operator ^(const L lhs, const R rhs) { return decltype(lhs ^ rhs)::template MathOp<CheckedXorOp>(lhs, rhs); } template <typename L> template <typename R> constexpr CheckedNumeric<L>& CheckedNumeric<L>::operator ^=( const R rhs) { return MathOp<CheckedXorOp>(rhs); } template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedXorOp, L, R, Args...>::type> CheckXor(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedXorOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedMaxOp, L, R, Args...>::type> CheckMax(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedMaxOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename... Args> constexpr CheckedNumeric< typename ResultType<CheckedMinOp, L, R, Args...>::type> CheckMin(const L lhs, const R rhs, const Args... args) { return CheckMathOp<CheckedMinOp, L, R, Args...>(lhs, rhs, args...); }




template <typename L, typename R>
L* operator+(L* lhs, const StrictNumeric<R> rhs) {
  uintptr_t result = CheckAdd(reinterpret_cast<uintptr_t>(lhs),
                              CheckMul(sizeof(L), static_cast<R>(rhs)))
                         .template ValueOrDie<uintptr_t>();
  return reinterpret_cast<L*>(result);
}

template <typename L, typename R>
L* operator-(L* lhs, const StrictNumeric<R> rhs) {
  uintptr_t result = CheckSub(reinterpret_cast<uintptr_t>(lhs),
                              CheckMul(sizeof(L), static_cast<R>(rhs)))
                         .template ValueOrDie<uintptr_t>();
  return reinterpret_cast<L*>(result);
}

}

using internal::CheckedNumeric;
using internal::IsValidForType;
using internal::ValueOrDieForType;
using internal::ValueOrDefaultForType;
using internal::MakeCheckedNum;
using internal::CheckMax;
using internal::CheckMin;
using internal::CheckAdd;
using internal::CheckSub;
using internal::CheckMul;
using internal::CheckDiv;
using internal::CheckMod;
using internal::CheckLsh;
using internal::CheckRsh;
using internal::CheckAnd;
using internal::CheckOr;
using internal::CheckXor;

}
# 9 "../../base/numerics/safe_math.h" 2
# 1 "../../base/numerics/clamped_math.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/numerics/clamped_math.h" 2




# 1 "../../base/numerics/clamped_math_impl.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/numerics/clamped_math_impl.h" 2
# 21 "../../base/numerics/clamped_math_impl.h"
namespace base {
namespace internal {

template <typename T,
          typename std::enable_if<std::is_integral<T>::value &&
                                  std::is_signed<T>::value>::type* = nullptr>
constexpr T SaturatedNegWrapper(T value) {
  return MustTreatAsConstexpr(value) || !ClampedNegFastOp<T>::is_supported
             ? (NegateWrapper(value) != std::numeric_limits<T>::lowest()
                    ? NegateWrapper(value)
                    : std::numeric_limits<T>::max())
             : ClampedNegFastOp<T>::Do(value);
}

template <typename T,
          typename std::enable_if<std::is_integral<T>::value &&
                                  !std::is_signed<T>::value>::type* = nullptr>
constexpr T SaturatedNegWrapper(T value) {
  return T(0);
}

template <
    typename T,
    typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
constexpr T SaturatedNegWrapper(T value) {
  return -value;
}

template <typename T,
          typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
constexpr T SaturatedAbsWrapper(T value) {
# 60 "../../base/numerics/clamped_math_impl.h"
  return static_cast<T>(SafeUnsignedAbs(value) -
                        IsValueNegative<T>(SafeUnsignedAbs(value)));
}

template <
    typename T,
    typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
constexpr T SaturatedAbsWrapper(T value) {
  return value < 0 ? -value : value;
}

template <typename T, typename U, class Enable = void>
struct ClampedAddOp {};

template <typename T, typename U>
struct ClampedAddOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V = result_type>
  static constexpr V Do(T x, U y) {
    if (ClampedAddFastOp<T, U>::is_supported)
      return ClampedAddFastOp<T, U>::template Do<V>(x, y);

    static_assert(std::is_same<V, result_type>::value ||
                      IsTypeInRangeForNumericType<U, V>::value,
                  "The saturation result cannot be determined from the "
                  "provided types.");
    const V saturated = CommonMaxOrMin<V>(IsValueNegative(y));
    V result = {};
    return __builtin_expect(!!((CheckedAddOp<T, U>::Do(x, y, &result))), 1)
               ? result
               : saturated;
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedSubOp {};

template <typename T, typename U>
struct ClampedSubOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V = result_type>
  static constexpr V Do(T x, U y) {

    if (ClampedSubFastOp<T, U>::is_supported)
      return ClampedSubFastOp<T, U>::template Do<V>(x, y);

    static_assert(std::is_same<V, result_type>::value ||
                      IsTypeInRangeForNumericType<U, V>::value,
                  "The saturation result cannot be determined from the "
                  "provided types.");
    const V saturated = CommonMaxOrMin<V>(!IsValueNegative(y));
    V result = {};
    return __builtin_expect(!!((CheckedSubOp<T, U>::Do(x, y, &result))), 1)
               ? result
               : saturated;
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedMulOp {};

template <typename T, typename U>
struct ClampedMulOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V = result_type>
  static constexpr V Do(T x, U y) {

    if (ClampedMulFastOp<T, U>::is_supported)
      return ClampedMulFastOp<T, U>::template Do<V>(x, y);

    V result = {};
    const V saturated =
        CommonMaxOrMin<V>(IsValueNegative(x) ^ IsValueNegative(y));
    return __builtin_expect(!!((CheckedMulOp<T, U>::Do(x, y, &result))), 1)
               ? result
               : saturated;
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedDivOp {};

template <typename T, typename U>
struct ClampedDivOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V = result_type>
  static constexpr V Do(T x, U y) {
    V result = {};
    if (__builtin_expect(!!((CheckedDivOp<T, U>::Do(x, y, &result))), 1))
      return result;

    return x ? CommonMaxOrMin<V>(IsValueNegative(x) ^ IsValueNegative(y))
             : SaturationDefaultLimits<V>::NaN();
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedModOp {};

template <typename T, typename U>
struct ClampedModOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V = result_type>
  static constexpr V Do(T x, U y) {
    V result = {};
    return __builtin_expect(!!((CheckedModOp<T, U>::Do(x, y, &result))), 1)
               ? result
               : x;
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedLshOp {};



template <typename T, typename U>
struct ClampedLshOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = T;
  template <typename V = result_type>
  static constexpr V Do(T x, U shift) {
    static_assert(!std::is_signed<U>::value, "Shift value must be unsigned.");
    if (__builtin_expect(!!(shift < std::numeric_limits<T>::digits), 1)) {

      V result = static_cast<V>(as_unsigned(x) << shift);

      if (__builtin_expect(!!(result >> shift == x), 1))
        return result;
    }
    return x ? CommonMaxOrMin<V>(IsValueNegative(x)) : 0;
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedRshOp {};


template <typename T, typename U>
struct ClampedRshOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = T;
  template <typename V = result_type>
  static constexpr V Do(T x, U shift) {
    static_assert(!std::is_signed<U>::value, "Shift value must be unsigned.");

    const V saturated = as_unsigned(V(0)) - IsValueNegative(x);
    return __builtin_expect(!!(shift < IntegerBitsPlusSign<T>::value), 1)
               ? saturated_cast<V>(x >> shift)
               : saturated;
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedAndOp {};

template <typename T, typename U>
struct ClampedAndOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename std::make_unsigned<
      typename MaxExponentPromotion<T, U>::type>::type;
  template <typename V>
  static constexpr V Do(T x, U y) {
    return static_cast<result_type>(x) & static_cast<result_type>(y);
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedOrOp {};


template <typename T, typename U>
struct ClampedOrOp<T,
                   U,
                   typename std::enable_if<std::is_integral<T>::value &&
                                           std::is_integral<U>::value>::type> {
  using result_type = typename std::make_unsigned<
      typename MaxExponentPromotion<T, U>::type>::type;
  template <typename V>
  static constexpr V Do(T x, U y) {
    return static_cast<result_type>(x) | static_cast<result_type>(y);
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedXorOp {};


template <typename T, typename U>
struct ClampedXorOp<T,
                    U,
                    typename std::enable_if<std::is_integral<T>::value &&
                                            std::is_integral<U>::value>::type> {
  using result_type = typename std::make_unsigned<
      typename MaxExponentPromotion<T, U>::type>::type;
  template <typename V>
  static constexpr V Do(T x, U y) {
    return static_cast<result_type>(x) ^ static_cast<result_type>(y);
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedMaxOp {};

template <typename T, typename U>
struct ClampedMaxOp<
    T,
    U,
    typename std::enable_if<std::is_arithmetic<T>::value &&
                            std::is_arithmetic<U>::value>::type> {
  using result_type = typename MaxExponentPromotion<T, U>::type;
  template <typename V = result_type>
  static constexpr V Do(T x, U y) {
    return IsGreater<T, U>::Test(x, y) ? saturated_cast<V>(x)
                                       : saturated_cast<V>(y);
  }
};

template <typename T, typename U, class Enable = void>
struct ClampedMinOp {};

template <typename T, typename U>
struct ClampedMinOp<
    T,
    U,
    typename std::enable_if<std::is_arithmetic<T>::value &&
                            std::is_arithmetic<U>::value>::type> {
  using result_type = typename LowestValuePromotion<T, U>::type;
  template <typename V = result_type>
  static constexpr V Do(T x, U y) {
    return IsLess<T, U>::Test(x, y) ? saturated_cast<V>(x)
                                    : saturated_cast<V>(y);
  }
};
# 331 "../../base/numerics/clamped_math_impl.h"
template <typename T, typename U> struct ClampedAddOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V = result_type> static constexpr V Do(T x, U y) { return saturated_cast<V>(x + y); } };
template <typename T, typename U> struct ClampedSubOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V = result_type> static constexpr V Do(T x, U y) { return saturated_cast<V>(x - y); } };
template <typename T, typename U> struct ClampedMulOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V = result_type> static constexpr V Do(T x, U y) { return saturated_cast<V>(x * y); } };
template <typename T, typename U> struct ClampedDivOp< T, U, typename std::enable_if<std::is_floating_point<T>::value || std::is_floating_point<U>::value>::type> { using result_type = typename MaxExponentPromotion<T, U>::type; template <typename V = result_type> static constexpr V Do(T x, U y) { return saturated_cast<V>(x / y); } };



}
}
# 14 "../../base/numerics/clamped_math.h" 2

namespace base {
namespace internal {

template <typename T>
class ClampedNumeric {
  static_assert(std::is_arithmetic<T>::value,
                "ClampedNumeric<T>: T must be a numeric type.");

 public:
  using type = T;

  constexpr ClampedNumeric() : value_(0) {}


  template <typename Src>
  constexpr ClampedNumeric(const ClampedNumeric<Src>& rhs)
      : value_(saturated_cast<T>(rhs.value_)) {}

  template <typename Src>
  friend class ClampedNumeric;



  template <typename Src>
  constexpr ClampedNumeric(Src value)
      : value_(saturated_cast<T>(value)) {
    static_assert(std::is_arithmetic<Src>::value, "Argument must be numeric.");
  }



  template <typename Src>
  constexpr ClampedNumeric(
      StrictNumeric<Src> value)
      : value_(saturated_cast<T>(static_cast<Src>(value))) {}



  template <typename Dst>
  constexpr ClampedNumeric<typename UnderlyingType<Dst>::type> Cast() const {
    return *this;
  }


  template <typename Src>
  constexpr ClampedNumeric& operator+=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator-=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator*=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator/=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator%=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator<<=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator>>=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator&=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator|=(const Src rhs);
  template <typename Src>
  constexpr ClampedNumeric& operator^=(const Src rhs);

  constexpr ClampedNumeric operator-() const {


    return ClampedNumeric<T>(SaturatedNegWrapper(value_));
  }

  constexpr ClampedNumeric operator~() const {
    return ClampedNumeric<decltype(InvertWrapper(T()))>(InvertWrapper(value_));
  }

  constexpr ClampedNumeric Abs() const {


    return ClampedNumeric<T>(SaturatedAbsWrapper(value_));
  }

  template <typename U>
  constexpr ClampedNumeric<typename MathWrapper<ClampedMaxOp, T, U>::type> Max(
      const U rhs) const {
    using result_type = typename MathWrapper<ClampedMaxOp, T, U>::type;
    return ClampedNumeric<result_type>(
        ClampedMaxOp<T, U>::Do(value_, Wrapper<U>::value(rhs)));
  }

  template <typename U>
  constexpr ClampedNumeric<typename MathWrapper<ClampedMinOp, T, U>::type> Min(
      const U rhs) const {
    using result_type = typename MathWrapper<ClampedMinOp, T, U>::type;
    return ClampedNumeric<result_type>(
        ClampedMinOp<T, U>::Do(value_, Wrapper<U>::value(rhs)));
  }




  constexpr ClampedNumeric<typename UnsignedOrFloatForSize<T>::type>
  UnsignedAbs() const {
    return ClampedNumeric<typename UnsignedOrFloatForSize<T>::type>(
        SafeUnsignedAbs(value_));
  }

  constexpr ClampedNumeric& operator++() {
    *this += 1;
    return *this;
  }

  constexpr ClampedNumeric operator++(int) {
    ClampedNumeric value = *this;
    *this += 1;
    return value;
  }

  constexpr ClampedNumeric& operator--() {
    *this -= 1;
    return *this;
  }

  constexpr ClampedNumeric operator--(int) {
    ClampedNumeric value = *this;
    *this -= 1;
    return value;
  }



  template <template <typename, typename, typename> class M,
            typename L,
            typename R>
  static constexpr ClampedNumeric MathOp(const L lhs, const R rhs) {
    using Math = typename MathWrapper<M, L, R>::math;
    return ClampedNumeric<T>(
        Math::template Do<T>(Wrapper<L>::value(lhs), Wrapper<R>::value(rhs)));
  }


  template <template <typename, typename, typename> class M, typename R>
  constexpr ClampedNumeric& MathOp(const R rhs) {
    using Math = typename MathWrapper<M, T, R>::math;
    *this =
        ClampedNumeric<T>(Math::template Do<T>(value_, Wrapper<R>::value(rhs)));
    return *this;
  }

  template <typename Dst>
  constexpr operator Dst() const {
    return saturated_cast<typename ArithmeticOrUnderlyingEnum<Dst>::type>(
        value_);
  }




  constexpr T RawValue() const { return value_; }

 private:
  T value_;



  template <typename Src>
  struct Wrapper {
    static constexpr Src value(Src value) {
      return static_cast<typename UnderlyingType<Src>::type>(value);
    }
  };
};



template <typename T>
constexpr ClampedNumeric<typename UnderlyingType<T>::type> MakeClampedNum(
    const T value) {
  return value;
}


template <typename T>
std::ostream& operator<<(std::ostream& os, const ClampedNumeric<T>& value) {
  os << static_cast<T>(value);
  return os;
}


template <template <typename, typename, typename> class M,
          typename L,
          typename R>
constexpr ClampedNumeric<typename MathWrapper<M, L, R>::type> ClampMathOp(
    const L lhs,
    const R rhs) {
  using Math = typename MathWrapper<M, L, R>::math;
  return ClampedNumeric<typename Math::result_type>::template MathOp<M>(lhs,
                                                                        rhs);
}


template <template <typename, typename, typename> class M,
          typename L,
          typename R,
          typename... Args>
constexpr ClampedNumeric<typename ResultType<M, L, R, Args...>::type>
ClampMathOp(const L lhs, const R rhs, const Args... args) {
  return ClampMathOp<M>(ClampMathOp<M>(lhs, rhs), args...);
}

template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedAddOp, L, R>::type> operator +(const L lhs, const R rhs) { return decltype(lhs + rhs)::template MathOp<ClampedAddOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator +=( const R rhs) { return MathOp<ClampedAddOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedAddOp, L, R, Args...>::type> ClampAdd(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedAddOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedSubOp, L, R>::type> operator -(const L lhs, const R rhs) { return decltype(lhs - rhs)::template MathOp<ClampedSubOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator -=( const R rhs) { return MathOp<ClampedSubOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedSubOp, L, R, Args...>::type> ClampSub(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedSubOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedMulOp, L, R>::type> operator *(const L lhs, const R rhs) { return decltype(lhs * rhs)::template MathOp<ClampedMulOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator *=( const R rhs) { return MathOp<ClampedMulOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedMulOp, L, R, Args...>::type> ClampMul(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedMulOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedDivOp, L, R>::type> operator /(const L lhs, const R rhs) { return decltype(lhs / rhs)::template MathOp<ClampedDivOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator /=( const R rhs) { return MathOp<ClampedDivOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedDivOp, L, R, Args...>::type> ClampDiv(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedDivOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedModOp, L, R>::type> operator %(const L lhs, const R rhs) { return decltype(lhs % rhs)::template MathOp<ClampedModOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator %=( const R rhs) { return MathOp<ClampedModOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedModOp, L, R, Args...>::type> ClampMod(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedModOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedLshOp, L, R>::type> operator <<(const L lhs, const R rhs) { return decltype(lhs << rhs)::template MathOp<ClampedLshOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator <<=( const R rhs) { return MathOp<ClampedLshOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedLshOp, L, R, Args...>::type> ClampLsh(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedLshOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedRshOp, L, R>::type> operator >>(const L lhs, const R rhs) { return decltype(lhs >> rhs)::template MathOp<ClampedRshOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator >>=( const R rhs) { return MathOp<ClampedRshOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedRshOp, L, R, Args...>::type> ClampRsh(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedRshOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedAndOp, L, R>::type> operator &(const L lhs, const R rhs) { return decltype(lhs & rhs)::template MathOp<ClampedAndOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator &=( const R rhs) { return MathOp<ClampedAndOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedAndOp, L, R, Args...>::type> ClampAnd(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedAndOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedOrOp, L, R>::type> operator |(const L lhs, const R rhs) { return decltype(lhs | rhs)::template MathOp<ClampedOrOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator |=( const R rhs) { return MathOp<ClampedOrOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedOrOp, L, R, Args...>::type> ClampOr(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedOrOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if<IsClampedOp<L, R>::value>::type* = nullptr> constexpr ClampedNumeric< typename MathWrapper<ClampedXorOp, L, R>::type> operator ^(const L lhs, const R rhs) { return decltype(lhs ^ rhs)::template MathOp<ClampedXorOp>(lhs, rhs); } template <typename L> template <typename R> constexpr ClampedNumeric<L>& ClampedNumeric<L>::operator ^=( const R rhs) { return MathOp<ClampedXorOp>(rhs); } template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedXorOp, L, R, Args...>::type> ClampXor(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedXorOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedMaxOp, L, R, Args...>::type> ClampMax(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedMaxOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename... Args> constexpr ClampedNumeric< typename ResultType<ClampedMinOp, L, R, Args...>::type> ClampMin(const L lhs, const R rhs, const Args... args) { return ClampMathOp<ClampedMinOp, L, R, Args...>(lhs, rhs, args...); }
template <typename L, typename R, typename std::enable_if< internal::IsClampedOp<L, R>::value>::type* = nullptr> constexpr bool operator <(const L lhs, const R rhs) { return SafeCompare<IsLess, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsClampedOp<L, R>::value>::type* = nullptr> constexpr bool operator <=(const L lhs, const R rhs) { return SafeCompare<IsLessOrEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsClampedOp<L, R>::value>::type* = nullptr> constexpr bool operator >(const L lhs, const R rhs) { return SafeCompare<IsGreater, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsClampedOp<L, R>::value>::type* = nullptr> constexpr bool operator >=(const L lhs, const R rhs) { return SafeCompare<IsGreaterOrEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsClampedOp<L, R>::value>::type* = nullptr> constexpr bool operator ==(const L lhs, const R rhs) { return SafeCompare<IsEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };
template <typename L, typename R, typename std::enable_if< internal::IsClampedOp<L, R>::value>::type* = nullptr> constexpr bool operator !=(const L lhs, const R rhs) { return SafeCompare<IsNotEqual, typename UnderlyingType<L>::type, typename UnderlyingType<R>::type>(lhs, rhs); };

}

using internal::ClampedNumeric;
using internal::MakeClampedNum;
using internal::ClampMax;
using internal::ClampMin;
using internal::ClampAdd;
using internal::ClampSub;
using internal::ClampMul;
using internal::ClampDiv;
using internal::ClampMod;
using internal::ClampLsh;
using internal::ClampRsh;
using internal::ClampAnd;
using internal::ClampOr;
using internal::ClampXor;

}
# 10 "../../base/numerics/safe_math.h" 2
# 64 "../../base/time/time.h" 2
# 78 "../../base/time/time.h"
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 27 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 28 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 37 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 55 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 189 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 79 "../../base/time/time.h" 2
# 88 "../../base/time/time.h"
namespace base {

class PlatformThreadHandle;
class TimeDelta;




namespace time_internal {



            int64_t SaturatedAdd(TimeDelta delta, int64_t value);
            int64_t SaturatedSub(TimeDelta delta, int64_t value);

}



class TimeDelta {
 public:
  constexpr TimeDelta() : delta_(0) {}


  static constexpr TimeDelta FromDays(int days);
  static constexpr TimeDelta FromHours(int hours);
  static constexpr TimeDelta FromMinutes(int minutes);
  static constexpr TimeDelta FromSeconds(int64_t secs);
  static constexpr TimeDelta FromMilliseconds(int64_t ms);
  static constexpr TimeDelta FromSecondsD(double secs);
  static constexpr TimeDelta FromMillisecondsD(double ms);
  static constexpr TimeDelta FromMicroseconds(int64_t us);

  static TimeDelta FromTimeSpec(const timespec& ts);
# 133 "../../base/time/time.h"
  static TimeDelta FromInternalValue(int64_t delta) { return TimeDelta(delta); }




  static constexpr TimeDelta Max();




  static constexpr TimeDelta Min();







  int64_t ToInternalValue() const { return delta_; }


  TimeDelta magnitude() const {



    const int64_t mask = delta_ >> (sizeof(delta_) * 8 - 1);
    return TimeDelta((delta_ + mask) ^ mask);
  }


  bool is_zero() const {
    return delta_ == 0;
  }


  bool is_max() const { return delta_ == std::numeric_limits<int64_t>::max(); }
  bool is_min() const { return delta_ == std::numeric_limits<int64_t>::min(); }


  struct timespec ToTimeSpec() const;







  int InDays() const;
  int InHours() const;
  int InMinutes() const;
  double InSecondsF() const;
  int64_t InSeconds() const;
  double InMillisecondsF() const;
  int64_t InMilliseconds() const;
  int64_t InMillisecondsRoundedUp() const;
  int64_t InMicroseconds() const;
  int64_t InNanoseconds() const;

  TimeDelta& operator=(TimeDelta other) {
    delta_ = other.delta_;
    return *this;
  }


  TimeDelta operator+(TimeDelta other) const {
    return TimeDelta(time_internal::SaturatedAdd(*this, other.delta_));
  }
  TimeDelta operator-(TimeDelta other) const {
    return TimeDelta(time_internal::SaturatedSub(*this, other.delta_));
  }

  TimeDelta& operator+=(TimeDelta other) {
    return *this = (*this + other);
  }
  TimeDelta& operator-=(TimeDelta other) {
    return *this = (*this - other);
  }
  TimeDelta operator-() const {
    return TimeDelta(-delta_);
  }


  template<typename T>
  TimeDelta operator*(T a) const {
    CheckedNumeric<int64_t> rv(delta_);
    rv *= a;
    if (rv.IsValid())
      return TimeDelta(rv.ValueOrDie());

    if ((delta_ < 0) ^ (a < 0))
      return TimeDelta(std::numeric_limits<int64_t>::min());
    return TimeDelta(std::numeric_limits<int64_t>::max());
  }
  template<typename T>
  TimeDelta operator/(T a) const {
    CheckedNumeric<int64_t> rv(delta_);
    rv /= a;
    if (rv.IsValid())
      return TimeDelta(rv.ValueOrDie());


    if ((delta_ < 0) ^ (a <= 0))
      return TimeDelta(std::numeric_limits<int64_t>::min());
    return TimeDelta(std::numeric_limits<int64_t>::max());
  }
  template<typename T>
  TimeDelta& operator*=(T a) {
    return *this = (*this * a);
  }
  template<typename T>
  TimeDelta& operator/=(T a) {
    return *this = (*this / a);
  }

  int64_t operator/(TimeDelta a) const { return delta_ / a.delta_; }
  TimeDelta operator%(TimeDelta a) const {
    return TimeDelta(delta_ % a.delta_);
  }


  constexpr bool operator==(TimeDelta other) const {
    return delta_ == other.delta_;
  }
  constexpr bool operator!=(TimeDelta other) const {
    return delta_ != other.delta_;
  }
  constexpr bool operator<(TimeDelta other) const {
    return delta_ < other.delta_;
  }
  constexpr bool operator<=(TimeDelta other) const {
    return delta_ <= other.delta_;
  }
  constexpr bool operator>(TimeDelta other) const {
    return delta_ > other.delta_;
  }
  constexpr bool operator>=(TimeDelta other) const {
    return delta_ >= other.delta_;
  }






 private:
  friend int64_t time_internal::SaturatedAdd(TimeDelta delta, int64_t value);
  friend int64_t time_internal::SaturatedSub(TimeDelta delta, int64_t value);




  constexpr explicit TimeDelta(int64_t delta_us) : delta_(delta_us) {}


  static constexpr TimeDelta FromDouble(double value);



  static constexpr TimeDelta FromProduct(int64_t value, int64_t positive_value);


  int64_t delta_;
};

template<typename T>
inline TimeDelta operator*(T a, TimeDelta td) {
  return td * a;
}


            std::ostream& operator<<(std::ostream& os, TimeDelta time_delta);




namespace time_internal {







template<class TimeClass>
class TimeBase {
 public:
  static const int64_t kHoursPerDay = 24;
  static const int64_t kMillisecondsPerSecond = 1000;
  static const int64_t kMillisecondsPerDay =
      kMillisecondsPerSecond * 60 * 60 * kHoursPerDay;
  static const int64_t kMicrosecondsPerMillisecond = 1000;
  static const int64_t kMicrosecondsPerSecond =
      kMicrosecondsPerMillisecond * kMillisecondsPerSecond;
  static const int64_t kMicrosecondsPerMinute = kMicrosecondsPerSecond * 60;
  static const int64_t kMicrosecondsPerHour = kMicrosecondsPerMinute * 60;
  static const int64_t kMicrosecondsPerDay =
      kMicrosecondsPerHour * kHoursPerDay;
  static const int64_t kMicrosecondsPerWeek = kMicrosecondsPerDay * 7;
  static const int64_t kNanosecondsPerMicrosecond = 1000;
  static const int64_t kNanosecondsPerSecond =
      kNanosecondsPerMicrosecond * kMicrosecondsPerSecond;






  bool is_null() const {
    return us_ == 0;
  }


  bool is_max() const { return us_ == std::numeric_limits<int64_t>::max(); }
  bool is_min() const { return us_ == std::numeric_limits<int64_t>::min(); }



  static TimeClass Max() {
    return TimeClass(std::numeric_limits<int64_t>::max());
  }

  static TimeClass Min() {
    return TimeClass(std::numeric_limits<int64_t>::min());
  }






  int64_t ToInternalValue() const { return us_; }







  TimeDelta since_origin() const { return TimeDelta::FromMicroseconds(us_); }

  TimeClass& operator=(TimeClass other) {
    us_ = other.us_;
    return *(static_cast<TimeClass*>(this));
  }


  TimeDelta operator-(TimeClass other) const {
    return TimeDelta::FromMicroseconds(us_ - other.us_);
  }


  TimeClass operator+(TimeDelta delta) const {
    return TimeClass(time_internal::SaturatedAdd(delta, us_));
  }
  TimeClass operator-(TimeDelta delta) const {
    return TimeClass(-time_internal::SaturatedSub(delta, us_));
  }


  TimeClass& operator+=(TimeDelta delta) {
    return static_cast<TimeClass&>(*this = (*this + delta));
  }
  TimeClass& operator-=(TimeDelta delta) {
    return static_cast<TimeClass&>(*this = (*this - delta));
  }


  bool operator==(TimeClass other) const {
    return us_ == other.us_;
  }
  bool operator!=(TimeClass other) const {
    return us_ != other.us_;
  }
  bool operator<(TimeClass other) const {
    return us_ < other.us_;
  }
  bool operator<=(TimeClass other) const {
    return us_ <= other.us_;
  }
  bool operator>(TimeClass other) const {
    return us_ > other.us_;
  }
  bool operator>=(TimeClass other) const {
    return us_ >= other.us_;
  }







  static TimeClass FromInternalValue(int64_t us) { return TimeClass(us); }

 protected:
  constexpr explicit TimeBase(int64_t us) : us_(us) {}


  int64_t us_;
};

}

template<class TimeClass>
inline TimeClass operator+(TimeDelta delta, TimeClass t) {
  return t + delta;
}





class Time : public time_internal::TimeBase<Time> {
 public:





  static constexpr int64_t kTimeTToMicrosecondsOffset =
      11644473600000000L;
# 483 "../../base/time/time.h"
  static constexpr int kExplodedMinYear =
      (sizeof(time_t) == 4 ? 1902 : std::numeric_limits<int>::min());
  static constexpr int kExplodedMaxYear =
      (sizeof(time_t) == 4 ? 2037 : std::numeric_limits<int>::max());





  struct Exploded {
    int year;
    int month;
    int day_of_week;
    int day_of_month;
    int hour;
    int minute;
    int second;

    int millisecond;




    bool HasValidValues() const;
  };


  Time() : TimeBase(0) {
  }


  static Time UnixEpoch();




  static Time Now();





  static Time NowFromSystemTime();


  static Time FromTimeT(time_t tt);
  time_t ToTimeT() const;






  static Time FromDoubleT(double dt);
  double ToDoubleT() const;






  static Time FromTimeSpec(const timespec& ts);





  static Time FromJsTime(double ms_since_epoch);
  double ToJsTime() const;




  static Time FromJavaTime(int64_t ms_since_epoch);
  int64_t ToJavaTime() const;


  static Time FromTimeVal(struct timeval t);
  struct timeval ToTimeVal() const;
# 611 "../../base/time/time.h"
  static bool FromUTCExploded(const Exploded& exploded,
                              Time* time) __attribute__((warn_unused_result)) {
    return FromExploded(false, exploded, time);
  }
  static bool FromLocalExploded(const Exploded& exploded,
                                Time* time) __attribute__((warn_unused_result)) {
    return FromExploded(true, exploded, time);
  }
# 628 "../../base/time/time.h"
  static bool FromString(const char* time_string,
                         Time* parsed_time) __attribute__((warn_unused_result)) {
    return FromStringInternal(time_string, true, parsed_time);
  }
  static bool FromUTCString(const char* time_string,
                            Time* parsed_time) __attribute__((warn_unused_result)) {
    return FromStringInternal(time_string, false, parsed_time);
  }



  void UTCExplode(Exploded* exploded) const {
    return Explode(false, exploded);
  }
  void LocalExplode(Exploded* exploded) const {
    return Explode(true, exploded);
  }



  Time LocalMidnight() const;

 private:
  friend class time_internal::TimeBase<Time>;

  explicit Time(int64_t us) : TimeBase(us) {}



  void Explode(bool is_local, Exploded* exploded) const;





  static bool FromExploded(bool is_local,
                           const Exploded& exploded,
                           Time* time) __attribute__((warn_unused_result));
# 674 "../../base/time/time.h"
  static bool FromStringInternal(const char* time_string,
                                 bool is_local,
                                 Time* parsed_time) __attribute__((warn_unused_result));


  static bool ExplodedMostlyEquals(const Exploded& lhs,
                                   const Exploded& rhs) __attribute__((warn_unused_result));
};


constexpr TimeDelta TimeDelta::FromDays(int days) {
  return days == std::numeric_limits<int>::max()
             ? Max()
             : TimeDelta(days * Time::kMicrosecondsPerDay);
}


constexpr TimeDelta TimeDelta::FromHours(int hours) {
  return hours == std::numeric_limits<int>::max()
             ? Max()
             : TimeDelta(hours * Time::kMicrosecondsPerHour);
}


constexpr TimeDelta TimeDelta::FromMinutes(int minutes) {
  return minutes == std::numeric_limits<int>::max()
             ? Max()
             : TimeDelta(minutes * Time::kMicrosecondsPerMinute);
}


constexpr TimeDelta TimeDelta::FromSeconds(int64_t secs) {
  return FromProduct(secs, Time::kMicrosecondsPerSecond);
}


constexpr TimeDelta TimeDelta::FromMilliseconds(int64_t ms) {
  return FromProduct(ms, Time::kMicrosecondsPerMillisecond);
}


constexpr TimeDelta TimeDelta::FromSecondsD(double secs) {
  return FromDouble(secs * Time::kMicrosecondsPerSecond);
}


constexpr TimeDelta TimeDelta::FromMillisecondsD(double ms) {
  return FromDouble(ms * Time::kMicrosecondsPerMillisecond);
}


constexpr TimeDelta TimeDelta::FromMicroseconds(int64_t us) {
  return TimeDelta(us);
}


constexpr TimeDelta TimeDelta::Max() {
  return TimeDelta(std::numeric_limits<int64_t>::max());
}


constexpr TimeDelta TimeDelta::Min() {
  return TimeDelta(std::numeric_limits<int64_t>::min());
}


constexpr TimeDelta TimeDelta::FromDouble(double value) {


  return value > std::numeric_limits<int64_t>::max()
             ? Max()
             : value < std::numeric_limits<int64_t>::min()
                   ? Min()
                   : TimeDelta(static_cast<int64_t>(value));
}


constexpr TimeDelta TimeDelta::FromProduct(int64_t value,
                                           int64_t positive_value) {
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(positive_value > 0);
  return value > std::numeric_limits<int64_t>::max() / positive_value
             ? Max()
             : value < std::numeric_limits<int64_t>::min() / positive_value
                   ? Min()
                   : TimeDelta(value * positive_value);
}


            std::ostream& operator<<(std::ostream& os, Time time);




class TimeTicks : public time_internal::TimeBase<TimeTicks> {
 public:

  enum class Clock {
    FUCHSIA_ZX_CLOCK_MONOTONIC,
    LINUX_CLOCK_MONOTONIC,
    IOS_CF_ABSOLUTE_TIME_MINUS_KERN_BOOTTIME,
    MAC_MACH_ABSOLUTE_TIME,
    WIN_QPC,
    WIN_ROLLOVER_PROTECTED_TIME_GET_TIME
  };

  constexpr TimeTicks() : TimeBase(0) {}





  static TimeTicks Now();





  static bool IsHighResolution() __attribute__((warn_unused_result));






  static bool IsConsistentAcrossProcesses() __attribute__((warn_unused_result));
# 825 "../../base/time/time.h"
  static TimeTicks UnixEpoch();




  TimeTicks SnappedToNextTick(TimeTicks tick_phase,
                              TimeDelta tick_interval) const;




  static Clock GetClock();







 private:
  friend class time_internal::TimeBase<TimeTicks>;



  explicit TimeTicks(int64_t us) : TimeBase(us) {}
};


            std::ostream& operator<<(std::ostream& os, TimeTicks time_ticks);





class ThreadTicks : public time_internal::TimeBase<ThreadTicks> {
 public:
  ThreadTicks() : TimeBase(0) {
  }


  static bool IsSupported() __attribute__((warn_unused_result)) {



    return true;





  }



  static void WaitUntilInitialized() {



  }
# 892 "../../base/time/time.h"
  static ThreadTicks Now();
# 901 "../../base/time/time.h"
 private:
  friend class time_internal::TimeBase<ThreadTicks>;



  explicit ThreadTicks(int64_t us) : TimeBase(us) {}
# 920 "../../base/time/time.h"
};


            std::ostream& operator<<(std::ostream& os, ThreadTicks time_ticks);

}
# 21 "../../base/trace_event/trace_event.h" 2
# 1 "../../base/trace_event/common/trace_event_common.h" 1
# 22 "../../base/trace_event/trace_event.h" 2
# 1 "../../base/trace_event/heap_profiler.h" 1








# 1 "../../base/trace_event/heap_profiler_allocation_context_tracker.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/vector" 1 3
# 275 "../../buildtools/third_party/libc++/trunk/include/vector" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__split_buffer" 1 3
# 11 "../../buildtools/third_party/libc++/trunk/include/__split_buffer" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 15 "../../buildtools/third_party/libc++/trunk/include/__split_buffer" 2 3


namespace std {inline namespace __1 {

template <bool>
class __split_buffer_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
    : private __split_buffer_common<true>
{
private:
    __split_buffer(const __split_buffer&);
    __split_buffer& operator=(const __split_buffer&);
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename remove_reference<allocator_type>::type __alloc_rr;
    typedef allocator_traits<__alloc_rr> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __first_;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

    __attribute__ ((__always_inline__)) __alloc_rr& __alloc() noexcept {return __end_cap_.second();}
    __attribute__ ((__always_inline__)) const __alloc_rr& __alloc() const noexcept {return __end_cap_.second();}
    __attribute__ ((__always_inline__)) pointer& __end_cap() noexcept {return __end_cap_.first();}
    __attribute__ ((__always_inline__)) const pointer& __end_cap() const noexcept {return __end_cap_.first();}

    __attribute__ ((__always_inline__))
    __split_buffer()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__always_inline__))
    explicit __split_buffer(__alloc_rr& __a);
    __attribute__ ((__always_inline__))
    explicit __split_buffer(const __alloc_rr& __a);
    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);
    ~__split_buffer();


    __split_buffer(__split_buffer&& __c)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);
    __split_buffer& operator=(__split_buffer&& __c)
        noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value);




    __attribute__ ((__always_inline__)) iterator begin() noexcept {return __begin_;}
    __attribute__ ((__always_inline__)) const_iterator begin() const noexcept {return __begin_;}
    __attribute__ ((__always_inline__)) iterator end() noexcept {return __end_;}
    __attribute__ ((__always_inline__)) const_iterator end() const noexcept {return __end_;}

    __attribute__ ((__always_inline__))
    void clear() noexcept
        {__destruct_at_end(__begin_);}
    __attribute__ ((__always_inline__)) size_type size() const {return static_cast<size_type>(__end_ - __begin_);}
    __attribute__ ((__always_inline__)) bool empty() const {return __end_ == __begin_;}
    __attribute__ ((__always_inline__)) size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}
    __attribute__ ((__always_inline__)) size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}
    __attribute__ ((__always_inline__)) size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}

    __attribute__ ((__always_inline__)) reference front() {return *__begin_;}
    __attribute__ ((__always_inline__)) const_reference front() const {return *__begin_;}
    __attribute__ ((__always_inline__)) reference back() {return *(__end_ - 1);}
    __attribute__ ((__always_inline__)) const_reference back() const {return *(__end_ - 1);}

    void reserve(size_type __n);
    void shrink_to_fit() noexcept;
    void push_front(const_reference __x);
    __attribute__ ((__always_inline__)) void push_back(const_reference __x);

    void push_front(value_type&& __x);
    void push_back(value_type&& __x);
    template <class... _Args>
        void emplace_back(_Args&&... __args);


    __attribute__ ((__always_inline__)) void pop_front() {__destruct_at_begin(__begin_+1);}
    __attribute__ ((__always_inline__)) void pop_back() {__destruct_at_end(__end_-1);}

    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _InputIter>
        typename enable_if
        <
            __is_input_iterator<_InputIter>::value &&
           !__is_forward_iterator<_InputIter>::value,
            void
        >::type
        __construct_at_end(_InputIter __first, _InputIter __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__always_inline__)) void __destruct_at_begin(pointer __new_begin)
        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}
        __attribute__ ((__always_inline__))
        void __destruct_at_begin(pointer __new_begin, false_type);
        __attribute__ ((__always_inline__))
        void __destruct_at_begin(pointer __new_begin, true_type);

    __attribute__ ((__always_inline__))
    void __destruct_at_end(pointer __new_last) noexcept
        {__destruct_at_end(__new_last, false_type());}
    __attribute__ ((__always_inline__))
        void __destruct_at_end(pointer __new_last, false_type) noexcept;
    __attribute__ ((__always_inline__))
        void __destruct_at_end(pointer __new_last, true_type) noexcept;

    void swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value);


    bool __invariants() const;

private:
    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__split_buffer& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__split_buffer&, false_type) noexcept
        {}
};

template <class _Tp, class _Allocator>
bool
__split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == nullptr)
    {
        if (__begin_ != nullptr)
            return false;
        if (__end_ != nullptr)
            return false;
        if (__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (__begin_ < __first_)
            return false;
        if (__end_ < __begin_)
            return false;
        if (__end_cap() < __end_)
            return false;
    }
    return true;
}






template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    __alloc_rr& __a = this->__alloc();
    do
    {
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_));
        ++this->__end_;
        --__n;
    } while (__n > 0);
}







template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    __alloc_rr& __a = this->__alloc();
    do
    {
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), __x);
        ++this->__end_;
        --__n;
    } while (__n > 0);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if
<
     __is_input_iterator<_InputIter>::value &&
    !__is_forward_iterator<_InputIter>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        if (__end_ == __end_cap())
        {
            size_type __old_cap = __end_cap() - __first_;
            size_type __new_cap = std::__1::max<size_type>(2 * __old_cap, 8);
            __split_buffer __buf(__new_cap, 0, __a);
            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
                __alloc_traits::construct(__buf.__alloc(),
                        std::__1::__to_raw_pointer(__buf.__end_), std::__1::move(*__p));
            swap(__buf);
        }
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) noexcept
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) noexcept
{
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
        __alloc_traits::deallocate(__alloc(), __first_, capacity());
}



template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::__1::move(__c.__first_)),
      __begin_(std::__1::move(__c.__begin_)),
      __end_(std::__1::move(__c.__end_)),
      __end_cap_(std::__1::move(__c.__end_cap_))
{
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)
    : __end_cap_(__second_tag(), __a)
{
    if (__a == __c.__alloc())
    {
        __first_ = __c.__first_;
        __begin_ = __c.__begin_;
        __end_ = __c.__end_;
        __end_cap() = __c.__end_cap();
        __c.__first_ = nullptr;
        __c.__begin_ = nullptr;
        __c.__end_ = nullptr;
        __c.__end_cap() = nullptr;
    }
    else
    {
        size_type __cap = __c.size();
        __first_ = __alloc_traits::allocate(__alloc(), __cap);
        __begin_ = __end_ = __first_;
        __end_cap() = __first_ + __cap;
        typedef move_iterator<iterator> _Ip;
        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>&
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)
    noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value)


{
    clear();
    shrink_to_fit();
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __move_assign_alloc(__c,
        integral_constant<bool,
                          __alloc_traits::propagate_on_container_move_assignment::value>());
    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
    return *this;
}



template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value)

{
    std::__1::swap(__first_, __x.__first_);
    std::__1::swap(__begin_, __x.__begin_);
    std::__1::swap(__end_, __x.__end_);
    std::__1::swap(__end_cap(), __x.__end_cap());
    __swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::__1::swap(__first_, __t.__first_);
        std::__1::swap(__begin_, __t.__begin_);
        std::__1::swap(__end_, __t.__end_);
        std::__1::swap(__end_cap(), __t.__end_cap());
    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {




            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            __t.__end_ = __t.__begin_ + (__end_ - __begin_);
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());






    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__begin_-1), __x);
    --__begin_;
}



template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__begin_-1),
            std::__1::move(__x));
    --__begin_;
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__end_), __x);
    ++__end_;
}



template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__end_),
            std::__1::move(__x));
    ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__end_),
                              std::__1::forward<_Args>(__args)...);
    ++__end_;
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)
        noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 276 "../../buildtools/third_party/libc++/trunk/include/vector" 2 3
# 282 "../../buildtools/third_party/libc++/trunk/include/vector" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 286 "../../buildtools/third_party/libc++/trunk/include/vector" 2 3


namespace std {inline namespace __1 {

template <bool>
class __vector_base_common
{
protected:
    __attribute__ ((__always_inline__)) __vector_base_common() {}
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__vector_base_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("vector");
}

template <bool __b>
void
__vector_base_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("vector");
}

extern template class __vector_base_common<true>;

template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
protected:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    __attribute__ ((__always_inline__))
    allocator_type& __alloc() noexcept
        {return __end_cap_.second();}
    __attribute__ ((__always_inline__))
    const allocator_type& __alloc() const noexcept
        {return __end_cap_.second();}
    __attribute__ ((__always_inline__))
    pointer& __end_cap() noexcept
        {return __end_cap_.first();}
    __attribute__ ((__always_inline__))
    const pointer& __end_cap() const noexcept
        {return __end_cap_.first();}

    __attribute__ ((__always_inline__))
    __vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__always_inline__)) __vector_base(const allocator_type& __a);
    ~__vector_base();

    __attribute__ ((__always_inline__))
    void clear() noexcept {__destruct_at_end(__begin_);}
    __attribute__ ((__always_inline__))
    size_type capacity() const noexcept
        {return static_cast<size_type>(__end_cap() - __begin_);}

    __attribute__ ((__always_inline__))
    void __destruct_at_end(pointer __new_last) noexcept;

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __vector_base& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__vector_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}
private:
    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                clear();
                __alloc_traits::deallocate(__alloc(), __begin_, capacity());
                __begin_ = __end_ = __end_cap() = nullptr;
            }
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __vector_base&, false_type)
        {}

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__vector_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__vector_base&, false_type)
        noexcept
        {}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) noexcept
{
    pointer __soon_to_be_end = __end_;
    while (__new_last != __soon_to_be_end)
        __alloc_traits::destroy(__alloc(), std::__1::__to_raw_pointer(--__soon_to_be_end));
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr)
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base()
{
    if (__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(__alloc(), __begin_, capacity());
    }
}

template <class _Tp, class _Allocator >
class vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator> __base;
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    __attribute__ ((__always_inline__))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value)
        {



        }
    __attribute__ ((__always_inline__)) explicit vector(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value)



        : __base(__a)
    {



    }
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const_reference __x);
    vector(size_type __n, const_reference __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value,
                                 _InputIterator>::type __last);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value,
                                 _ForwardIterator>::type __last);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);
# 534 "../../buildtools/third_party/libc++/trunk/include/vector" 3
    vector(const vector& __x);
    vector(const vector& __x, const allocator_type& __a);
    __attribute__ ((__always_inline__))
    vector& operator=(const vector& __x);


    __attribute__ ((__always_inline__))
    vector(initializer_list<value_type> __il);

    __attribute__ ((__always_inline__))
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    vector(vector&& __x)



        noexcept(is_nothrow_move_constructible<allocator_type>::value);


    __attribute__ ((__always_inline__))
    vector(vector&& __x, const allocator_type& __a);
    __attribute__ ((__always_inline__))
    vector& operator=(vector&& __x)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__always_inline__))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const_reference __u);


    __attribute__ ((__always_inline__))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept
        {return this->__alloc();}

    __attribute__ ((__always_inline__)) iterator begin() noexcept;
    __attribute__ ((__always_inline__)) const_iterator begin() const noexcept;
    __attribute__ ((__always_inline__)) iterator end() noexcept;
    __attribute__ ((__always_inline__)) const_iterator end() const noexcept;

    __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__always_inline__))
    size_type size() const noexcept
        {return static_cast<size_type>(this->__end_ - this->__begin_);}
    __attribute__ ((__always_inline__))
    size_type capacity() const noexcept
        {return __base::capacity();}
    __attribute__ ((__always_inline__))
    bool empty() const noexcept
        {return this->__begin_ == this->__end_;}
    size_type max_size() const noexcept;
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__always_inline__)) reference operator[](size_type __n);
    __attribute__ ((__always_inline__)) const_reference operator[](size_type __n) const;
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__always_inline__)) reference front()
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__always_inline__)) const_reference front() const
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__always_inline__)) reference back()
    {
        ((void)0);
        return *(this->__end_ - 1);
    }
    __attribute__ ((__always_inline__)) const_reference back() const
    {
        ((void)0);
        return *(this->__end_ - 1);
    }

    __attribute__ ((__always_inline__))
    value_type* data() noexcept
        {return std::__1::__to_raw_pointer(this->__begin_);}
    __attribute__ ((__always_inline__))
    const value_type* data() const noexcept
        {return std::__1::__to_raw_pointer(this->__begin_);}





    template <class _Arg>
    __attribute__ ((__always_inline__))
    void __emplace_back(_Arg&& __arg) {
      emplace_back(std::__1::forward<_Arg>(__arg));
    }


    __attribute__ ((__always_inline__)) void push_back(const_reference __x);


    __attribute__ ((__always_inline__)) void push_back(value_type&& __x);

    template <class... _Args>
        __attribute__ ((__always_inline__))



        void emplace_back(_Args&&... __args);



    __attribute__ ((__always_inline__))
    void pop_back();

    iterator insert(const_iterator __position, const_reference __x);


    iterator insert(const_iterator __position, value_type&& __x);
    template <class... _Args>
        iterator emplace(const_iterator __position, _Args&&... __args);


    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__always_inline__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__always_inline__))
    void clear() noexcept
    {
        size_type __old_size = size();
        __base::clear();
        __annotate_shrink(__old_size);
        __invalidate_all_iterators();
    }

    void resize(size_type __sz);
    void resize(size_type __sz, const_reference __x);

    void swap(vector&)

        noexcept;





    bool __invariants() const;
# 776 "../../buildtools/third_party/libc++/trunk/include/vector" 3
private:
    __attribute__ ((__always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__always_inline__)) void __invalidate_iterators_past(pointer __new_last);
    void allocate(size_type __n);
    void deallocate() noexcept;
    __attribute__ ((__always_inline__)) size_type __recommend(size_type __new_size) const;
    void __construct_at_end(size_type __n);
    __attribute__ ((__always_inline__))
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);
    void __append(size_type __n);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__always_inline__))
    iterator __make_iter(pointer __p) noexcept;
    __attribute__ ((__always_inline__))
    const_iterator __make_iter(const_pointer __p) const noexcept;
    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(vector& __c, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__always_inline__))
    void __destruct_at_end(pointer __new_last) noexcept
    {
        __invalidate_iterators_past(__new_last);
        size_type __old_size = size();
        __base::__destruct_at_end(__new_last);
        __annotate_shrink(__old_size);
    }


    template <class _Up> void __push_back_slow_path(_Up&& __x);

    template <class... _Args>
    void __emplace_back_slow_path(_Args&&... __args);
# 837 "../../buildtools/third_party/libc++/trunk/include/vector" 3
    __attribute__ ((__always_inline__))
    void __annotate_contiguous_container(const void*, const void*, const void*,
                                         const void*) const {}

    __attribute__ ((__always_inline__))
    void __annotate_new(size_type __current_size) const {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + capacity(), data() + __current_size);
    }

    __attribute__ ((__always_inline__))
    void __annotate_delete() const {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + capacity());
    }

    __attribute__ ((__always_inline__))
    void __annotate_increase(size_type __n) const
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + size() + __n);
    }

    __attribute__ ((__always_inline__))
    void __annotate_shrink(size_type __old_size) const
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + __old_size, data() + size());
    }
# 884 "../../buildtools/third_party/libc++/trunk/include/vector" 3
    struct __RAII_IncreaseAnnotator {
      __attribute__ ((__always_inline__))
      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}
      __attribute__ ((__always_inline__)) void __done() {}
    };


};

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{
    __annotate_delete();
    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    __annotate_delete();
    pointer __r = __v.__begin_;
    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);
    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
    return __r;
}
# 931 "../../buildtools/third_party/libc++/trunk/include/vector" 3
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::allocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
    this->__end_cap() = this->__begin_ + __n;
    __annotate_new(0);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::deallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
    }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept
{
    return std::__1::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                 numeric_limits<difference_type>::max());
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max<size_type>(2*__cap, __new_size);
}






template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    allocator_type& __a = this->__alloc();
    do
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_));
        ++this->__end_;
        --__n;
        __annotator.__done();
    } while (__n > 0);
}







template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    allocator_type& __a = this->__alloc();
    do
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), __x);
        ++this->__end_;
        --__n;
        __annotator.__done();
    } while (__n > 0);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)
{
    allocator_type& __a = this->__alloc();
    __RAII_IncreaseAnnotator __annotator(*this, __n);
    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);
    __annotator.__done();
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{



    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)
{



    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value,
                          _InputIterator>::type __last)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value>::type*)
    : __base(__a)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value,
                                                   _ForwardIterator>::type __last)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)
    : __base(__a)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)
    : __base(__a)
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(vector&& __x)



        noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __base(std::__1::move(__x.__alloc()))
{




    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)
    : __base(__a)
{



    if (__a == __x.__alloc())
    {
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;



    }
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)
{



    if (__il.size() > 0)
    {
        allocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{



    if (__il.size() > 0)
    {
        allocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__x, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    deallocate();
    __base::__move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__end_ = __c.__end_;
    this->__end_cap() = __c.__end_cap();
    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;



}



template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != &__x)
    {
        __base::__copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __new_size = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__new_size <= capacity())
    {
        _ForwardIterator __mid = __last;
        bool __growing = false;
        if (__new_size > size())
        {
            __growing = true;
            __mid = __first;
            std::__1::advance(__mid, size());
        }
        pointer __m = std::__1::copy(__first, __mid, this->__begin_);
        if (__growing)
            __construct_at_end(__mid, __last, __new_size - size());
        else
            this->__destruct_at_end(__m);
    }
    else
    {
        deallocate();
        allocate(__recommend(__new_size));
        __construct_at_end(__first, __last, __new_size);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        deallocate();
        allocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) noexcept
{



    return iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const noexcept
{



    return const_iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n)
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {




            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
            __swap_out_circular_buffer(__v);






    }
}

template <class _Tp, class _Allocator>
template <class _Up>
void

vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)



{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(__v.__end_), std::__1::forward<_Up>(__x));
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ != this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(this->__alloc(),
                                  std::__1::__to_raw_pointer(this->__end_), __x);
        __annotator.__done();
        ++this->__end_;
    }
    else
        __push_back_slow_path(__x);
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(this->__alloc(),
                                  std::__1::__to_raw_pointer(this->__end_),
                                  std::__1::move(__x));
        __annotator.__done();
        ++this->__end_;
    }
    else
        __push_back_slow_path(std::__1::move(__x));
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)
{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(__v.__end_), std::__1::forward<_Args>(__args)...);
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
inline



void

vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (this->__end_ < this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(this->__alloc(),
                                  std::__1::__to_raw_pointer(this->__end_),
                                  std::__1::forward<_Args>(__args)...);
        __annotator.__done();
        ++this->__end_;
    }
    else
        __emplace_back_slow_path(std::__1::forward<_Args>(__args)...);



}



template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{





    ((void)0);

    difference_type __ps = __position - cbegin();
    pointer __p = this->__begin_ + __ps;
    this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
    this->__invalidate_iterators_past(__p-1);
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
# 1704 "../../buildtools/third_party/libc++/trunk/include/vector" 3
    ((void)0);
    pointer __p = this->__begin_ + (__first - begin());
    if (__first != __last) {
        this->__destruct_at_end(std::__1::move(__p + (__last - __first), this->__end_, __p));
        this->__invalidate_iterators_past(__p - 1);
    }
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)
        __alloc_traits::construct(this->__alloc(),
                                  std::__1::__to_raw_pointer(this->__end_),
                                  std::__1::move(*__i));
    std::__1::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        if (__p == this->__end_)
        {
            __alloc_traits::construct(this->__alloc(),
                                      std::__1::__to_raw_pointer(this->__end_), __x);
            ++this->__end_;
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
        __annotator.__done();
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        if (__p == this->__end_)
        {
            __alloc_traits::construct(this->__alloc(),
                                      std::__1::__to_raw_pointer(this->__end_),
                                      std::__1::move(__x));
            ++this->__end_;
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__x);
        }
        __annotator.__done();
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(std::__1::move(__x));
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        if (__p == this->__end_)
        {
            __alloc_traits::construct(this->__alloc(),
                                      std::__1::__to_raw_pointer(this->__end_),
                                      std::__1::forward<_Args>(__args)...);
            ++this->__end_;
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__tmp.get());
        }
        __annotator.__done();
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.emplace_back(std::__1::forward<_Args>(__args)...);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __RAII_IncreaseAnnotator __annotator(*this, __n);
                __move_range(__p, __old_last, __p + __old_n);
                __annotator.__done();
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                std::__1::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{





    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_),
                                  *__first);
        ++this->__end_;
        __annotator.__done();
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {




            __v.__construct_at_end(__first, __last);
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;
# 1941 "../../buildtools/third_party/libc++/trunk/include/vector" 3
    }
    __p = std::__1::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), make_move_iterator(__v.begin()),
                                    make_move_iterator(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{





    pointer __p = this->__begin_ + (__position - begin());
    difference_type __n = std::__1::distance(__first, __last);
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _ForwardIterator __m = __last;
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                difference_type __diff = this->__end_ - __p;
                std::__1::advance(__m, __diff);
                __construct_at_end(__m, __last, __n - __diff);
                __n = __dx;
            }
            if (__n > 0)
            {
                __RAII_IncreaseAnnotator __annotator(*this, __n);
                __move_range(__p, __old_last, __p + __old_n);
                __annotator.__done();
                std::__1::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__first, __last);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::swap(vector& __x)

    noexcept




{
    ((void)0);



    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__end_, __x.__end_);
    std::__1::swap(this->__end_cap(), __x.__end_cap());
    __swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());



}

template <class _Tp, class _Allocator>
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__end_ != nullptr || this->__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}
# 2103 "../../buildtools/third_party/libc++/trunk/include/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::__invalidate_all_iterators()
{



}


template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {
# 2131 "../../buildtools/third_party/libc++/trunk/include/vector" 3
  ((void)__new_last);

}



template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};

template <class _Allocator>
class vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;
    typedef __bit_const_reference<vector> const_reference;
private:
    __attribute__ ((__always_inline__))
    size_type& __cap() noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__always_inline__))
    const size_type& __cap() const noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__always_inline__))
    __storage_allocator& __alloc() noexcept
        {return __cap_alloc_.second();}
    __attribute__ ((__always_inline__))
    const __storage_allocator& __alloc() const noexcept
        {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    __attribute__ ((__always_inline__))
    static size_type __internal_cap_to_external(size_type __n) noexcept
        {return __n * __bits_per_word;}
    __attribute__ ((__always_inline__))
    static size_type __external_cap_to_internal(size_type __n) noexcept
        {return (__n - 1) / __bits_per_word + 1;}

public:
    __attribute__ ((__always_inline__))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__always_inline__)) explicit vector(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value);



    ~vector();
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const value_type& __v);
    vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);

    vector(const vector& __v);
    vector(const vector& __v, const allocator_type& __a);
    vector& operator=(const vector& __v);


    vector(initializer_list<value_type> __il);
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    vector(vector&& __v)



        noexcept(is_nothrow_move_constructible<allocator_type>::value);

    vector(vector&& __v, const allocator_type& __a);
    __attribute__ ((__always_inline__))
    vector& operator=(vector&& __v)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__always_inline__))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value &&
           !__is_forward_iterator<_InputIterator>::value,
           void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
           void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const value_type& __x);


    __attribute__ ((__always_inline__))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__always_inline__)) allocator_type get_allocator() const noexcept
        {return allocator_type(this->__alloc());}

    size_type max_size() const noexcept;
    __attribute__ ((__always_inline__))
    size_type capacity() const noexcept
        {return __internal_cap_to_external(__cap());}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept
        {return __size_;}
    __attribute__ ((__always_inline__))
    bool empty() const noexcept
        {return __size_ == 0;}
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__always_inline__))
    iterator begin() noexcept
        {return __make_iter(0);}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__always_inline__))
    iterator end() noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept
        {return __make_iter(__size_);}

    __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__always_inline__)) reference operator[](size_type __n) {return __make_ref(__n);}
    __attribute__ ((__always_inline__)) const_reference operator[](size_type __n) const {return __make_ref(__n);}
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__always_inline__)) reference front() {return __make_ref(0);}
    __attribute__ ((__always_inline__)) const_reference front() const {return __make_ref(0);}
    __attribute__ ((__always_inline__)) reference back() {return __make_ref(__size_ - 1);}
    __attribute__ ((__always_inline__)) const_reference back() const {return __make_ref(__size_ - 1);}

    void push_back(const value_type& __x);

    template <class... _Args>



    __attribute__ ((__always_inline__)) void emplace_back(_Args&&... __args)

    {
        push_back ( value_type ( std::__1::forward<_Args>(__args)... ));



    }


    __attribute__ ((__always_inline__)) void pop_back() {--__size_;}


    template <class... _Args>
   __attribute__ ((__always_inline__)) iterator emplace(const_iterator position, _Args&&... __args)
        { return insert ( position, value_type ( std::__1::forward<_Args>(__args)... )); }


    iterator insert(const_iterator __position, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__always_inline__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__always_inline__))
    void clear() noexcept {__size_ = 0;}

    void swap(vector&)

        noexcept;




    static void swap(reference __x, reference __y) noexcept { std::__1::swap(__x, __y); }

    void resize(size_type __sz, value_type __x = false);
    void flip() noexcept;

    bool __invariants() const;

private:
    __attribute__ ((__always_inline__)) void __invalidate_all_iterators();
    void allocate(size_type __n);
    void deallocate() noexcept;
    __attribute__ ((__always_inline__))
    static size_type __align_it(size_type __new_size) noexcept
        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};
    __attribute__ ((__always_inline__)) size_type __recommend(size_type __new_size) const;
    __attribute__ ((__always_inline__)) void __construct_at_end(size_type __n, bool __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__always_inline__))
    reference __make_ref(size_type __pos) noexcept
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__always_inline__))
    const_reference __make_ref(size_type __pos) const noexcept
        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__always_inline__))
    iterator __make_iter(size_type __pos) noexcept
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__always_inline__))
    const_iterator __make_iter(size_type __pos) const noexcept
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__always_inline__))
    iterator __const_iterator_cast(const_iterator __p) noexcept
        {return begin() + (__p - cbegin());}

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                deallocate();
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const vector&, false_type)
        {}

    void __move_assign(vector& __c, false_type);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    __attribute__ ((__always_inline__))
    void __move_assign_alloc(vector& __c)
        noexcept(!__storage_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__always_inline__))
    void __move_assign_alloc(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(vector&, false_type)
        noexcept
        {}

    size_t __hash_code() const noexcept;

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct hash<vector>;
};

template <class _Allocator>
inline __attribute__ ((__always_inline__))
void
vector<bool, _Allocator>::__invalidate_all_iterators()
{
}
# 2512 "../../buildtools/third_party/libc++/trunk/include/vector" 3
template <class _Allocator>
void
vector<bool, _Allocator>::allocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    __n = __external_cap_to_internal(__n);
    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
    this->__size_ = 0;
    this->__cap() = __n;
}

template <class _Allocator>
void
vector<bool, _Allocator>::deallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        __invalidate_all_iterators();
        this->__begin_ = nullptr;
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max(2*__cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__ ((__always_inline__))
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    std::__1::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += std::__1::distance(__first, __last);
    std::__1::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__ ((__always_inline__))
vector<bool, _Allocator>::vector()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0)
{
}

template <class _Allocator>
inline __attribute__ ((__always_inline__))
vector<bool, _Allocator>::vector(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value)



    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0)
{




        for (; __first != __last; ++__first)
            push_back(*__first);
# 2694 "../../buildtools/third_party/libc++/trunk/include/vector" 3
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{




        for (; __first != __last; ++__first)
            push_back(*__first);
# 2721 "../../buildtools/third_party/libc++/trunk/include/vector" 3
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}



template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0)
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}



template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != &__v)
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                deallocate();
                allocate(__v.__size_);
            }
            std::__1::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}



template <class _Allocator>
inline __attribute__ ((__always_inline__))
vector<bool, _Allocator>::vector(vector&& __v)



        noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(__v.__cap_alloc_)
{
    __v.__begin_ = nullptr;
    __v.__size_ = 0;
    __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
        this->__begin_ = __v.__begin_;
        this->__size_ = __v.__size_;
        this->__cap() = __v.__cap();
        __v.__begin_ = nullptr;
        __v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
inline __attribute__ ((__always_inline__))
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__v, integral_constant<bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__alloc() != __c.__alloc())
        assign(__c.begin(), __c.end());
    else
        __move_assign(__c, true_type());
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    deallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __c.__begin_ = nullptr;
    __c.__cap() = __c.__size_ = 0;
}



template <class _Allocator>
void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        std::__1::fill_n(begin(), __n, __x);
    }
  __invalidate_all_iterators();
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_forward_iterator<_InputIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __ns = std::__1::distance(__first, __last);
    ((void)0);
    const size_t __n = static_cast<size_type>(__ns);
    if (__n)
    {
        if (__n > capacity())
        {
            deallocate();
            allocate(__n);
        }
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        vector __v(this->__alloc());
        __v.allocate(__n);
        __v.__construct_at_end(this->begin(), this->end());
        swap(__v);
        __invalidate_all_iterators();
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::shrink_to_fit() noexcept
{
    if (__external_cap_to_internal(size()) > __cap())
    {




            vector(*this, allocator_type(__alloc())).swap(*this);






    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(__alloc());
    if (__first != __last)
    {




            __v.assign(__first, __last);
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;
# 3132 "../../buildtools/third_party/libc++/trunk/include/vector" 3
    }
    __p = std::__1::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    const difference_type __n_signed = std::__1::distance(__first, __last);
    ((void)0);
    const size_type __n = static_cast<size_type>(__n_signed);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::copy(__first, __last, __r);
    return __r;
}

template <class _Allocator>
inline __attribute__ ((__always_inline__))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::__1::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::__1::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
void
vector<bool, _Allocator>::swap(vector& __x)

    noexcept




{
    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__size_, __x.__size_);
    std::__1::swap(this->__cap(), __x.__cap());
    __swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = std::__1::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        std::__1::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
void
vector<bool, _Allocator>::flip() noexcept
{

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const noexcept
{
    size_t __h = 0;

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;

    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
    __attribute__ ((__always_inline__))
    size_t operator()(const vector<bool, _Allocator>& __vec) const noexcept
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 9 "../../base/trace_event/heap_profiler_allocation_context_tracker.h" 2




# 1 "../../base/trace_event/heap_profiler_allocation_context.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/trace_event/heap_profiler_allocation_context.h" 2






namespace base {
namespace trace_event {
# 44 "../../base/trace_event/heap_profiler_allocation_context.h"
struct StackFrame {
  enum class Type {
    TRACE_EVENT_NAME,
    THREAD_NAME,
    PROGRAM_COUNTER,
  };

  static StackFrame FromTraceEventName(const char* name) {
    return {Type::TRACE_EVENT_NAME, name};
  }
  static StackFrame FromThreadName(const char* name) {
    return {Type::THREAD_NAME, name};
  }
  static StackFrame FromProgramCounter(const void* pc) {
    return {Type::PROGRAM_COUNTER, pc};
  }

  Type type;
  const void* value;
};

bool operator < (const StackFrame& lhs, const StackFrame& rhs);
bool operator == (const StackFrame& lhs, const StackFrame& rhs);
bool operator != (const StackFrame& lhs, const StackFrame& rhs);

struct Backtrace {
  Backtrace();




  enum { kMaxFrameCount = 48 };
  StackFrame frames[kMaxFrameCount];
  size_t frame_count = 0;
};

bool operator==(const Backtrace& lhs, const Backtrace& rhs);
bool operator!=(const Backtrace& lhs, const Backtrace& rhs);




struct AllocationContext {
  AllocationContext();
  AllocationContext(const Backtrace& backtrace, const char* type_name);

  Backtrace backtrace;





  const char* type_name;
};

bool operator==(const AllocationContext& lhs,
                            const AllocationContext& rhs);
bool operator!=(const AllocationContext& lhs,
                            const AllocationContext& rhs);


struct AllocationMetrics {
  size_t size;
  size_t count;
};

}
}

namespace std {

template <>
struct hash<base::trace_event::StackFrame> {
  size_t operator()(const base::trace_event::StackFrame& frame) const;
};

template <>
struct hash<base::trace_event::Backtrace> {
  size_t operator()(const base::trace_event::Backtrace& backtrace) const;
};

template <>
struct hash<base::trace_event::AllocationContext> {
  size_t operator()(const base::trace_event::AllocationContext& context) const;
};

}
# 14 "../../base/trace_event/heap_profiler_allocation_context_tracker.h" 2

namespace base {
namespace trace_event {






class AllocationContextTracker {
 public:
  enum class CaptureMode : int32_t {
    DISABLED,
    PSEUDO_STACK,
    MIXED_STACK,

    NATIVE_STACK,
  };


  struct PseudoStackFrame {
    const char* trace_event_category;
    const char* trace_event_name;

    bool operator==(const PseudoStackFrame& other) const {
      return trace_event_category == other.trace_event_category &&
             trace_event_name == other.trace_event_name;
    }
  };



  static void SetCaptureMode(CaptureMode mode);


  inline static CaptureMode capture_mode() {



    if (subtle::NoBarrier_Load(&capture_mode_) ==
            static_cast<int32_t>(CaptureMode::DISABLED))
      return CaptureMode::DISABLED;





    return static_cast<CaptureMode>(subtle::Acquire_Load(&capture_mode_));
  }




  static AllocationContextTracker* GetInstanceForCurrentThread();



  static void SetCurrentThreadName(const char* name);




  void begin_ignore_scope() { ignore_scope_depth_++; }
  void end_ignore_scope() {
    if (ignore_scope_depth_)
      ignore_scope_depth_--;
  }




  void PushPseudoStackFrame(PseudoStackFrame stack_frame);
  void PopPseudoStackFrame(PseudoStackFrame stack_frame);


  void PushNativeStackFrame(const void* pc);
  void PopNativeStackFrame(const void* pc);



  void PushCurrentTaskContext(const char* context);
  void PopCurrentTaskContext(const char* context);



  bool GetContextSnapshot(AllocationContext* snapshot);

  ~AllocationContextTracker();

 private:
  AllocationContextTracker();

  static subtle::Atomic32 capture_mode_;


  std::vector<StackFrame> tracked_stack_;


  const char* thread_name_;



  std::vector<const char*> task_contexts_;

  uint32_t ignore_scope_depth_;

  AllocationContextTracker(const AllocationContextTracker&) = delete; AllocationContextTracker& operator=(const AllocationContextTracker&) = delete;
};

}
}
# 10 "../../base/trace_event/heap_profiler.h" 2
# 40 "../../base/trace_event/heap_profiler.h"
namespace trace_event_internal {



class HeapProfilerScopedTaskExecutionTracker {
 public:
  inline explicit HeapProfilerScopedTaskExecutionTracker(
      const char* task_context)
      : context_(task_context) {
    using base::trace_event::AllocationContextTracker;
    if (__builtin_expect(!!(AllocationContextTracker::capture_mode() != AllocationContextTracker::CaptureMode::DISABLED), 0)) {

      AllocationContextTracker::GetInstanceForCurrentThread()
          ->PushCurrentTaskContext(context_);
    }
  }

  inline ~HeapProfilerScopedTaskExecutionTracker() {
    using base::trace_event::AllocationContextTracker;
    if (__builtin_expect(!!(AllocationContextTracker::capture_mode() != AllocationContextTracker::CaptureMode::DISABLED), 0)) {

      AllocationContextTracker::GetInstanceForCurrentThread()
          ->PopCurrentTaskContext(context_);
    }
  }

 private:
  const char* context_;
};

class HeapProfilerScopedStackFrame {
 public:
  inline explicit HeapProfilerScopedStackFrame(const void* program_counter)
      : program_counter_(program_counter) {
    using base::trace_event::AllocationContextTracker;
    if (__builtin_expect(!!(AllocationContextTracker::capture_mode() == AllocationContextTracker::CaptureMode::MIXED_STACK), 0)) {

      AllocationContextTracker::GetInstanceForCurrentThread()
          ->PushNativeStackFrame(program_counter_);
    }
  }

  inline ~HeapProfilerScopedStackFrame() {
    using base::trace_event::AllocationContextTracker;
    if (__builtin_expect(!!(AllocationContextTracker::capture_mode() == AllocationContextTracker::CaptureMode::MIXED_STACK), 0)) {

      AllocationContextTracker::GetInstanceForCurrentThread()
          ->PopNativeStackFrame(program_counter_);
    }
  }

 private:
  const void* const program_counter_;
};

class HeapProfilerScopedIgnore {
 public:
  inline HeapProfilerScopedIgnore() {
    using base::trace_event::AllocationContextTracker;
    if (__builtin_expect(!!(AllocationContextTracker::capture_mode() != AllocationContextTracker::CaptureMode::DISABLED), 0)) {


      AllocationContextTracker::GetInstanceForCurrentThread()
          ->begin_ignore_scope();
    }
  }
  inline ~HeapProfilerScopedIgnore() {
    using base::trace_event::AllocationContextTracker;
    if (__builtin_expect(!!(AllocationContextTracker::capture_mode() != AllocationContextTracker::CaptureMode::DISABLED), 0)) {


      AllocationContextTracker::GetInstanceForCurrentThread()
          ->end_ignore_scope();
    }
  }
};

}
# 23 "../../base/trace_event/trace_event.h" 2
# 1 "../../base/trace_event/trace_category.h" 1
# 10 "../../base/trace_event/trace_category.h"
namespace base {
namespace trace_event {



struct TraceCategory {





  enum StateFlags : uint8_t {
    ENABLED_FOR_RECORDING = 1 << 0,


    DEPRECATED_ENABLED_FOR_MONITORING = 1 << 1,
    DEPRECATED_ENABLED_FOR_EVENT_CALLBACK = 1 << 2,

    ENABLED_FOR_ETW_EXPORT = 1 << 3,
    ENABLED_FOR_FILTERING = 1 << 4
  };

  static const TraceCategory* FromStatePtr(const uint8_t* state_ptr) {
    static_assert(
        __builtin_offsetof(TraceCategory, state_) == 0,
        "|state_| must be the first field of the TraceCategory class.");
    return reinterpret_cast<const TraceCategory*>(state_ptr);
  }

  bool is_valid() const { return name_ != nullptr; }
  void set_name(const char* name) { name_ = name; }
  const char* name() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(is_valid());
    return name_;
  }





  const uint8_t* state_ptr() const {
    return const_cast<const uint8_t*>(&state_);
  }

  uint8_t state() const {
    return *const_cast<volatile const uint8_t*>(&state_);
  }

  bool is_enabled() const { return state() != 0; }

  void set_state(uint8_t state) {
    *const_cast<volatile uint8_t*>(&state_) = state;
  }

  void clear_state_flag(StateFlags flag) { set_state(state() & (~flag)); }
  void set_state_flag(StateFlags flag) { set_state(state() | flag); }

  uint32_t enabled_filters() const {
    return *const_cast<volatile const uint32_t*>(&enabled_filters_);
  }

  bool is_filter_enabled(size_t index) const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(index < sizeof(enabled_filters_) * 8);
    return (enabled_filters() & (1 << index)) != 0;
  }

  void set_enabled_filters(uint32_t enabled_filters) {
    *const_cast<volatile uint32_t*>(&enabled_filters_) = enabled_filters;
  }

  void reset_for_testing() {
    set_state(0);
    set_enabled_filters(0);
  }
# 96 "../../base/trace_event/trace_category.h"
  uint8_t state_;



  uint32_t enabled_filters_;


  const char* name_;
};

}
}
# 24 "../../base/trace_event/trace_event.h" 2
# 1 "../../base/trace_event/trace_event_system_stats_monitor.h" 1








# 1 "../../base/gtest_prod_util.h" 1







# 1 "../../testing/gtest/include/gtest/gtest_prod.h" 1
# 10 "../../testing/gtest/include/gtest/gtest_prod.h"
# 1 "../../third_party/googletest/src/googletest/include/gtest/gtest_prod.h" 1
# 11 "../../testing/gtest/include/gtest/gtest_prod.h" 2
# 9 "../../base/gtest_prod_util.h" 2
# 10 "../../base/trace_event/trace_event_system_stats_monitor.h" 2

# 1 "../../base/memory/ref_counted.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/memory/ref_counted.h" 2



# 1 "../../base/atomic_ref_count.h" 1
# 13 "../../base/atomic_ref_count.h"
namespace base {

class AtomicRefCount {
 public:
  constexpr AtomicRefCount() : ref_count_(0) {}
  explicit constexpr AtomicRefCount(int initial_value)
      : ref_count_(initial_value) {}


  void Increment() { Increment(1); }


  void Increment(int increment) {
    ref_count_.fetch_add(increment, std::memory_order_relaxed);
  }




  bool Decrement() {




    return ref_count_.fetch_sub(1, std::memory_order_acq_rel) != 1;
  }







  bool IsOne() const { return ref_count_.load(std::memory_order_acquire) == 1; }




  bool IsZero() const {
    return ref_count_.load(std::memory_order_acquire) == 0;
  }



  int SubtleRefCountForDebug() const {
    return ref_count_.load(std::memory_order_relaxed);
  }

 private:
  std::atomic_int ref_count_;
};

}
# 13 "../../base/memory/ref_counted.h" 2




# 1 "../../base/memory/scoped_refptr.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/memory/scoped_refptr.h" 2








template <class T>
class scoped_refptr;

namespace base {

template <class, typename>
class RefCounted;
template <class, typename>
class RefCountedThreadSafe;

template <typename T>
scoped_refptr<T> AdoptRef(T* t);

namespace subtle {

enum AdoptRefTag { kAdoptRefTag };
enum StartRefCountFromZeroTag { kStartRefCountFromZeroTag };
enum StartRefCountFromOneTag { kStartRefCountFromOneTag };

template <typename T, typename U, typename V>
constexpr bool IsRefCountPreferenceOverridden(const T*,
                                              const RefCounted<U, V>*) {
  return !std::is_same<std::decay_t<decltype(T::kRefCountPreference)>,
                       std::decay_t<decltype(U::kRefCountPreference)>>::value;
}

template <typename T, typename U, typename V>
constexpr bool IsRefCountPreferenceOverridden(
    const T*,
    const RefCountedThreadSafe<U, V>*) {
  return !std::is_same<std::decay_t<decltype(T::kRefCountPreference)>,
                       std::decay_t<decltype(U::kRefCountPreference)>>::value;
}

constexpr bool IsRefCountPreferenceOverridden(...) {
  return false;
}

}




template <typename T>
scoped_refptr<T> AdoptRef(T* obj) {
  using Tag = std::decay_t<decltype(T::kRefCountPreference)>;
  static_assert(std::is_same<subtle::StartRefCountFromOneTag, Tag>::value,
                "Use AdoptRef only for the reference count starts from one.");

  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(obj);
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(obj->HasOneRef());
  obj->Adopted();
  return scoped_refptr<T>(obj, subtle::kAdoptRefTag);
}

namespace subtle {

template <typename T>
scoped_refptr<T> AdoptRefIfNeeded(T* obj, StartRefCountFromZeroTag) {
  return scoped_refptr<T>(obj);
}

template <typename T>
scoped_refptr<T> AdoptRefIfNeeded(T* obj, StartRefCountFromOneTag) {
  return AdoptRef(obj);
}

}



template <typename T, typename... Args>
scoped_refptr<T> MakeRefCounted(Args&&... args) {
  T* obj = new T(std::forward<Args>(args)...);
  return subtle::AdoptRefIfNeeded(obj, T::kRefCountPreference);
}



template <typename T>
scoped_refptr<T> WrapRefCounted(T* t) {
  return scoped_refptr<T>(t);
}

}
# 154 "../../base/memory/scoped_refptr.h"
template <class T>
class scoped_refptr {
 public:
  typedef T element_type;

  scoped_refptr() {}

  scoped_refptr(T* p) : ptr_(p) {
    if (ptr_)
      AddRef(ptr_);
  }


  scoped_refptr(const scoped_refptr<T>& r) : ptr_(r.ptr_) {
    if (ptr_)
      AddRef(ptr_);
  }


  template <typename U,
            typename = typename std::enable_if<
                std::is_convertible<U*, T*>::value>::type>
  scoped_refptr(const scoped_refptr<U>& r) : ptr_(r.get()) {
    if (ptr_)
      AddRef(ptr_);
  }



  scoped_refptr(scoped_refptr&& r) : ptr_(r.get()) { r.ptr_ = nullptr; }


  template <typename U,
            typename = typename std::enable_if<
                std::is_convertible<U*, T*>::value>::type>
  scoped_refptr(scoped_refptr<U>&& r) : ptr_(r.get()) {
    r.ptr_ = nullptr;
  }

  ~scoped_refptr() {
    static_assert(!base::subtle::IsRefCountPreferenceOverridden(
                      static_cast<T*>(nullptr), static_cast<T*>(nullptr)),
                  "It's unsafe to override the ref count preference."
                  " Please remove REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE"
                  " from subclasses.");
    if (ptr_)
      Release(ptr_);
  }

  T* get() const { return ptr_; }

  T& operator*() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(ptr_);
    return *ptr_;
  }

  T* operator->() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(ptr_);
    return ptr_;
  }

  scoped_refptr<T>& operator=(T* p) {

    if (p)
      AddRef(p);
    T* old_ptr = ptr_;
    ptr_ = p;
    if (old_ptr)
      Release(old_ptr);
    return *this;
  }

  scoped_refptr<T>& operator=(const scoped_refptr<T>& r) {
    return *this = r.ptr_;
  }

  template <typename U>
  scoped_refptr<T>& operator=(const scoped_refptr<U>& r) {
    return *this = r.get();
  }

  scoped_refptr<T>& operator=(scoped_refptr<T>&& r) {
    scoped_refptr<T> tmp(std::move(r));
    tmp.swap(*this);
    return *this;
  }

  template <typename U>
  scoped_refptr<T>& operator=(scoped_refptr<U>&& r) {




    scoped_refptr<T> tmp(std::move(r));
    tmp.swap(*this);
    return *this;
  }

  void swap(scoped_refptr<T>& r) {
    T* tmp = ptr_;
    ptr_ = r.ptr_;
    r.ptr_ = tmp;
  }

  explicit operator bool() const { return ptr_ != nullptr; }

  template <typename U>
  bool operator==(const scoped_refptr<U>& rhs) const {
    return ptr_ == rhs.get();
  }

  template <typename U>
  bool operator!=(const scoped_refptr<U>& rhs) const {
    return !operator==(rhs);
  }

  template <typename U>
  bool operator<(const scoped_refptr<U>& rhs) const {
    return ptr_ < rhs.get();
  }

 protected:
  T* ptr_ = nullptr;

 private:
  template <typename U>
  friend scoped_refptr<U> base::AdoptRef(U*);

  scoped_refptr(T* p, base::subtle::AdoptRefTag) : ptr_(p) {}


  template <typename U>
  friend class scoped_refptr;





  static void AddRef(T* ptr);
  static void Release(T* ptr);
};


template <typename T>
void scoped_refptr<T>::AddRef(T* ptr) {
  ptr->AddRef();
}


template <typename T>
void scoped_refptr<T>::Release(T* ptr) {
  ptr->Release();
}

template <typename T, typename U>
bool operator==(const scoped_refptr<T>& lhs, const U* rhs) {
  return lhs.get() == rhs;
}

template <typename T, typename U>
bool operator==(const T* lhs, const scoped_refptr<U>& rhs) {
  return lhs == rhs.get();
}

template <typename T>
bool operator==(const scoped_refptr<T>& lhs, std::nullptr_t null) {
  return !static_cast<bool>(lhs);
}

template <typename T>
bool operator==(std::nullptr_t null, const scoped_refptr<T>& rhs) {
  return !static_cast<bool>(rhs);
}

template <typename T, typename U>
bool operator!=(const scoped_refptr<T>& lhs, const U* rhs) {
  return !operator==(lhs, rhs);
}

template <typename T, typename U>
bool operator!=(const T* lhs, const scoped_refptr<U>& rhs) {
  return !operator==(lhs, rhs);
}

template <typename T>
bool operator!=(const scoped_refptr<T>& lhs, std::nullptr_t null) {
  return !operator==(lhs, null);
}

template <typename T>
bool operator!=(std::nullptr_t null, const scoped_refptr<T>& rhs) {
  return !operator==(null, rhs);
}

template <typename T>
std::ostream& operator<<(std::ostream& out, const scoped_refptr<T>& p) {
  return out << p.get();
}

template <typename T>
void swap(scoped_refptr<T>& lhs, scoped_refptr<T>& rhs) {
  lhs.swap(rhs);
}
# 18 "../../base/memory/ref_counted.h" 2
# 1 "../../base/sequence_checker.h" 1
# 10 "../../base/sequence_checker.h"
# 1 "../../base/sequence_checker_impl.h" 1
# 13 "../../base/sequence_checker_impl.h"
# 1 "../../base/synchronization/lock.h" 1
# 11 "../../base/synchronization/lock.h"
# 1 "../../base/synchronization/lock_impl.h" 1
# 20 "../../base/synchronization/lock_impl.h"
namespace base {
namespace internal {




class LockImpl {
 public:



  using NativeHandle = pthread_mutex_t;


  LockImpl();
  ~LockImpl();



  bool Try();


  void Lock();



  inline void Unlock();




  NativeHandle* native_handle() { return &native_handle_; }



  static bool PriorityInheritanceAvailable();


 private:
  NativeHandle native_handle_;

  LockImpl(const LockImpl&) = delete; LockImpl& operator=(const LockImpl&) = delete;
};






void LockImpl::Unlock() {
  int rv = pthread_mutex_unlock(&native_handle_);
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << (::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, rv), ::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, 0), (rv)==(0)) << ". " << strerror(rv);
}


}
}
# 12 "../../base/synchronization/lock.h" 2
# 1 "../../base/threading/platform_thread.h" 1
# 12 "../../base/threading/platform_thread.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 13 "../../base/threading/platform_thread.h" 2
# 30 "../../base/threading/platform_thread.h"
namespace base {
# 40 "../../base/threading/platform_thread.h"
typedef pid_t PlatformThreadId;
# 51 "../../base/threading/platform_thread.h"
class PlatformThreadRef {
 public:



  typedef pthread_t RefType;

  PlatformThreadRef()
      : id_(0) {
  }

  explicit PlatformThreadRef(RefType id)
      : id_(id) {
  }

  bool operator==(PlatformThreadRef other) const {
    return id_ == other.id_;
  }

  bool operator!=(PlatformThreadRef other) const { return id_ != other.id_; }

  bool is_null() const {
    return id_ == 0;
  }
 private:
  RefType id_;
};


class PlatformThreadHandle {
 public:



  typedef pthread_t Handle;


  PlatformThreadHandle() : handle_(0) {}

  explicit PlatformThreadHandle(Handle handle) : handle_(handle) {}

  bool is_equal(const PlatformThreadHandle& other) const {
    return handle_ == other.handle_;
  }

  bool is_null() const {
    return !handle_;
  }

  Handle platform_handle() const {
    return handle_;
  }

 private:
  Handle handle_;
};

const PlatformThreadId kInvalidThreadId(0);



enum class ThreadPriority : int {

  BACKGROUND,

  NORMAL,

  DISPLAY,

  REALTIME_AUDIO,
};


class PlatformThread {
 public:


  class Delegate {
   public:
    virtual void ThreadMain() = 0;

   protected:
    virtual ~Delegate() {}
  };


  static PlatformThreadId CurrentId();



  static PlatformThreadRef CurrentRef();





  static PlatformThreadHandle CurrentHandle();


  static void YieldCurrentThread();


  static void Sleep(base::TimeDelta duration);



  static void SetName(const std::string& name);


  static const char* GetName();
# 170 "../../base/threading/platform_thread.h"
  static bool Create(size_t stack_size,
                     Delegate* delegate,
                     PlatformThreadHandle* thread_handle) {
    return CreateWithPriority(stack_size, delegate, thread_handle,
                              ThreadPriority::NORMAL);
  }



  static bool CreateWithPriority(size_t stack_size, Delegate* delegate,
                                 PlatformThreadHandle* thread_handle,
                                 ThreadPriority priority);




  static bool CreateNonJoinable(size_t stack_size, Delegate* delegate);



  static bool CreateNonJoinableWithPriority(size_t stack_size,
                                            Delegate* delegate,
                                            ThreadPriority priority);




  static void Join(PlatformThreadHandle thread_handle);



  static void Detach(PlatformThreadHandle thread_handle);



  static bool CanIncreaseCurrentThreadPriority();
# 220 "../../base/threading/platform_thread.h"
  static void SetCurrentThreadPriority(ThreadPriority priority);

  static ThreadPriority GetCurrentThreadPriority();
# 234 "../../base/threading/platform_thread.h"
  static void SetThreadPriority(PlatformThreadId thread_id,
                                ThreadPriority priority);


 private:
  PlatformThread() = delete; PlatformThread(const PlatformThread&) = delete; PlatformThread& operator=(const PlatformThread&) = delete;
};

}
# 13 "../../base/synchronization/lock.h" 2


namespace base {




class Lock {
 public:


  Lock() : lock_() {}
  ~Lock() {}
  void Acquire() { lock_.Lock(); }
  void Release() { lock_.Unlock(); }





  bool Try() { return lock_.Try(); }


  void AssertAcquired() const {}
# 66 "../../base/synchronization/lock.h"
  static bool HandlesMultipleThreadPriorities() {



    return internal::LockImpl::PriorityInheritanceAvailable();
# 79 "../../base/synchronization/lock.h"
  }





  friend class ConditionVariable;


 private:
# 104 "../../base/synchronization/lock.h"
  internal::LockImpl lock_;

  Lock(const Lock&) = delete; Lock& operator=(const Lock&) = delete;
};


class AutoLock {
 public:
  struct AlreadyAcquired {};

  explicit AutoLock(Lock& lock) : lock_(lock) {
    lock_.Acquire();
  }

  AutoLock(Lock& lock, const AlreadyAcquired&) : lock_(lock) {
    lock_.AssertAcquired();
  }

  ~AutoLock() {
    lock_.AssertAcquired();
    lock_.Release();
  }

 private:
  Lock& lock_;
  AutoLock(const AutoLock&) = delete; AutoLock& operator=(const AutoLock&) = delete;
};



class AutoUnlock {
 public:
  explicit AutoUnlock(Lock& lock) : lock_(lock) {

    lock_.AssertAcquired();
    lock_.Release();
  }

  ~AutoUnlock() {
    lock_.Acquire();
  }

 private:
  Lock& lock_;
  AutoUnlock(const AutoUnlock&) = delete; AutoUnlock& operator=(const AutoUnlock&) = delete;
};

}
# 14 "../../base/sequence_checker_impl.h" 2

namespace base {







class SequenceCheckerImpl {
 public:
  SequenceCheckerImpl();
  ~SequenceCheckerImpl();



  bool CalledOnValidSequence() const __attribute__((warn_unused_result));



  void DetachFromSequence();

 private:
  class Core;


  mutable Lock lock_;
  mutable std::unique_ptr<Core> core_;

  SequenceCheckerImpl(const SequenceCheckerImpl&) = delete; SequenceCheckerImpl& operator=(const SequenceCheckerImpl&) = delete;
};

}
# 11 "../../base/sequence_checker.h" 2
# 62 "../../base/sequence_checker.h"
namespace base {





class SequenceCheckerDoNothing {
 public:
  SequenceCheckerDoNothing() = default;
  bool CalledOnValidSequence() const __attribute__((warn_unused_result)) { return true; }
  void DetachFromSequence() {}

 private:
  SequenceCheckerDoNothing(const SequenceCheckerDoNothing&) = delete; SequenceCheckerDoNothing& operator=(const SequenceCheckerDoNothing&) = delete;
};





class SequenceChecker : public SequenceCheckerDoNothing {
};


}
# 19 "../../base/memory/ref_counted.h" 2
# 1 "../../base/threading/thread_collision_warner.h" 1
# 129 "../../base/threading/thread_collision_warner.h"
namespace base {





struct AsserterBase {
  virtual ~AsserterBase() {}
  virtual void warn() = 0;
};

struct DCheckAsserter : public AsserterBase {
  ~DCheckAsserter() override {}
  void warn() override;
};

class ThreadCollisionWarner {
 public:

  explicit ThreadCollisionWarner(AsserterBase* asserter = new DCheckAsserter())
      : valid_thread_id_(0),
        counter_(0),
        asserter_(asserter) {}

  ~ThreadCollisionWarner() {
    delete asserter_;
  }






  class Check {
   public:
    explicit Check(ThreadCollisionWarner* warner)
        : warner_(warner) {
      warner_->EnterSelf();
    }

    ~Check() {}

   private:
    ThreadCollisionWarner* warner_;

    Check(const Check&) = delete; Check& operator=(const Check&) = delete;
  };



  class ScopedCheck {
   public:
    explicit ScopedCheck(ThreadCollisionWarner* warner)
        : warner_(warner) {
      warner_->Enter();
    }

    ~ScopedCheck() {
      warner_->Leave();
    }

   private:
    ThreadCollisionWarner* warner_;

    ScopedCheck(const ScopedCheck&) = delete; ScopedCheck& operator=(const ScopedCheck&) = delete;
  };



  class ScopedRecursiveCheck {
   public:
    explicit ScopedRecursiveCheck(ThreadCollisionWarner* warner)
        : warner_(warner) {
      warner_->EnterSelf();
    }

    ~ScopedRecursiveCheck() {
      warner_->Leave();
    }

   private:
    ThreadCollisionWarner* warner_;

    ScopedRecursiveCheck(const ScopedRecursiveCheck&) = delete; ScopedRecursiveCheck& operator=(const ScopedRecursiveCheck&) = delete;
  };

 private:



  void EnterSelf();


  void Enter();



  void Leave();



  volatile subtle::Atomic32 valid_thread_id_;



  volatile subtle::Atomic32 counter_;



  AsserterBase* asserter_;

  ThreadCollisionWarner(const ThreadCollisionWarner&) = delete; ThreadCollisionWarner& operator=(const ThreadCollisionWarner&) = delete;
};

}
# 20 "../../base/memory/ref_counted.h" 2


namespace base {
namespace subtle {

class RefCountedBase {
 public:
  bool HasOneRef() const { return ref_count_ == 1; }

 protected:
  explicit RefCountedBase(StartRefCountFromZeroTag) {



  }

  explicit RefCountedBase(StartRefCountFromOneTag) : ref_count_(1) {




  }

  ~RefCountedBase() {



  }

  void AddRef() const {
# 65 "../../base/memory/ref_counted.h"
    AddRefImpl();
  }


  bool Release() const {
    --ref_count_;
# 88 "../../base/memory/ref_counted.h"
    return ref_count_ == 0;
  }
# 104 "../../base/memory/ref_counted.h"
  bool IsOnValidSequence() const {



    return true;

  }

 private:
  template <typename U>
  friend scoped_refptr<U> base::AdoptRef(U*);

  void Adopted() const {




  }




  void AddRefImpl() const { ++ref_count_; }






  mutable uint32_t ref_count_ = 0;







  typedef void InternalFakeMutexTypeadd_release_;

  RefCountedBase(const RefCountedBase&) = delete; RefCountedBase& operator=(const RefCountedBase&) = delete;
};

class RefCountedThreadSafeBase {
 public:
  bool HasOneRef() const;

 protected:
  explicit RefCountedThreadSafeBase(StartRefCountFromZeroTag) {}
  explicit RefCountedThreadSafeBase(StartRefCountFromOneTag) : ref_count_(1) {



  }




  ~RefCountedThreadSafeBase() = default;







  bool Release() const { return ReleaseImpl(); }
  void AddRef() const { AddRefImpl(); }






 private:
  template <typename U>
  friend scoped_refptr<U> base::AdoptRef(U*);

  void Adopted() const {




  }

  inline __attribute__((__always_inline__)) void AddRefImpl() const {







    ref_count_.Increment();
  }

  inline __attribute__((__always_inline__)) bool ReleaseImpl() const {




    if (!ref_count_.Decrement()) {



      return true;
    }
    return false;
  }

  mutable AtomicRefCount ref_count_{0};





  RefCountedThreadSafeBase(const RefCountedThreadSafeBase&) = delete; RefCountedThreadSafeBase& operator=(const RefCountedThreadSafeBase&) = delete;
};

}
# 234 "../../base/memory/ref_counted.h"
class ScopedAllowCrossThreadRefCountAccess final {
 public:




  ScopedAllowCrossThreadRefCountAccess() {}
  ~ScopedAllowCrossThreadRefCountAccess() {}

};
# 293 "../../base/memory/ref_counted.h"
template <class T, typename Traits>
class RefCounted;

template <typename T>
struct DefaultRefCountedTraits {
  static void Destruct(const T* x) {
    RefCounted<T, DefaultRefCountedTraits>::DeleteInternal(x);
  }
};

template <class T, typename Traits = DefaultRefCountedTraits<T>>
class RefCounted : public subtle::RefCountedBase {
 public:
  static constexpr subtle::StartRefCountFromZeroTag kRefCountPreference =
      subtle::kStartRefCountFromZeroTag;

  RefCounted() : subtle::RefCountedBase(T::kRefCountPreference) {}

  void AddRef() const {
    subtle::RefCountedBase::AddRef();
  }

  void Release() const {
    if (subtle::RefCountedBase::Release()) {



                               ;

      Traits::Destruct(static_cast<const T*>(this));
    }
  }

 protected:
  ~RefCounted() = default;

 private:
  friend struct DefaultRefCountedTraits<T>;
  template <typename U>
  static void DeleteInternal(const U* x) {
    delete x;
  }

  RefCounted(const RefCounted&) = delete; RefCounted& operator=(const RefCounted&) = delete;
};


template <class T, typename Traits> class RefCountedThreadSafe;



template<typename T>
struct DefaultRefCountedThreadSafeTraits {
  static void Destruct(const T* x) {



    RefCountedThreadSafe<T,
                         DefaultRefCountedThreadSafeTraits>::DeleteInternal(x);
  }
};
# 370 "../../base/memory/ref_counted.h"
template <class T, typename Traits = DefaultRefCountedThreadSafeTraits<T> >
class RefCountedThreadSafe : public subtle::RefCountedThreadSafeBase {
 public:
  static constexpr subtle::StartRefCountFromZeroTag kRefCountPreference =
      subtle::kStartRefCountFromZeroTag;

  explicit RefCountedThreadSafe()
      : subtle::RefCountedThreadSafeBase(T::kRefCountPreference) {}

  void AddRef() const {
    subtle::RefCountedThreadSafeBase::AddRef();
  }

  void Release() const {
    if (subtle::RefCountedThreadSafeBase::Release()) {
                               ;
      Traits::Destruct(static_cast<const T*>(this));
    }
  }

 protected:
  ~RefCountedThreadSafe() = default;

 private:
  friend struct DefaultRefCountedThreadSafeTraits<T>;
  template <typename U>
  static void DeleteInternal(const U* x) {
    delete x;
  }

  RefCountedThreadSafe(const RefCountedThreadSafe&) = delete; RefCountedThreadSafe& operator=(const RefCountedThreadSafe&) = delete;
};





template<typename T>
class RefCountedData
    : public base::RefCountedThreadSafe< base::RefCountedData<T> > {
 public:
  RefCountedData() : data() {}
  RefCountedData(const T& in_value) : data(in_value) {}
  RefCountedData(T&& in_value) : data(std::move(in_value)) {}

  T data;

 private:
  friend class base::RefCountedThreadSafe<base::RefCountedData<T> >;
  ~RefCountedData() = default;
};

}
# 12 "../../base/trace_event/trace_event_system_stats_monitor.h" 2
# 1 "../../base/memory/weak_ptr.h" 1
# 82 "../../base/memory/weak_ptr.h"
namespace base {

template <typename T> class SupportsWeakPtr;
template <typename T> class WeakPtr;

namespace internal {



class WeakReference {
 public:


  class Flag : public RefCountedThreadSafe<Flag> {
   public:
    Flag();

    void Invalidate();
    bool IsValid() const;

   private:
    friend class base::RefCountedThreadSafe<Flag>;

    ~Flag();

    SequenceChecker sequence_checker_;
    bool is_valid_;
  };

  WeakReference();
  explicit WeakReference(const Flag* flag);
  ~WeakReference();

  WeakReference(WeakReference&& other);
  WeakReference(const WeakReference& other);
  WeakReference& operator=(WeakReference&& other) = default;
  WeakReference& operator=(const WeakReference& other) = default;

  bool is_valid() const;

 private:
  scoped_refptr<const Flag> flag_;
};

class WeakReferenceOwner {
 public:
  WeakReferenceOwner();
  ~WeakReferenceOwner();

  WeakReference GetRef() const;

  bool HasRefs() const {
    return flag_.get() && !flag_->HasOneRef();
  }

  void Invalidate();

 private:
  mutable scoped_refptr<WeakReference::Flag> flag_;
};





class WeakPtrBase {
 public:
  WeakPtrBase();
  ~WeakPtrBase();

  WeakPtrBase(const WeakPtrBase& other) = default;
  WeakPtrBase(WeakPtrBase&& other) = default;
  WeakPtrBase& operator=(const WeakPtrBase& other) = default;
  WeakPtrBase& operator=(WeakPtrBase&& other) = default;

 protected:
  WeakPtrBase(const WeakReference& ref, uintptr_t ptr);

  WeakReference ref_;



  uintptr_t ptr_;
};




class SupportsWeakPtrBase {
 public:






  template<typename Derived>
  static WeakPtr<Derived> StaticAsWeakPtr(Derived* t) {
    static_assert(
        std::is_base_of<internal::SupportsWeakPtrBase, Derived>::value,
        "AsWeakPtr argument must inherit from SupportsWeakPtr");
    return AsWeakPtrImpl<Derived>(t);
  }

 private:



  template <typename Derived, typename Base>
  static WeakPtr<Derived> AsWeakPtrImpl(SupportsWeakPtr<Base>* t) {
    WeakPtr<Base> ptr = t->AsWeakPtr();
    return WeakPtr<Derived>(
        ptr.ref_, static_cast<Derived*>(reinterpret_cast<Base*>(ptr.ptr_)));
  }
};

}

template <typename T> class WeakPtrFactory;
# 215 "../../base/memory/weak_ptr.h"
template <typename T>
class WeakPtr : public internal::WeakPtrBase {
 public:
  WeakPtr() {}

  WeakPtr(std::nullptr_t) {}



  template <typename U>
  WeakPtr(const WeakPtr<U>& other) : WeakPtrBase(other) {


    T* t = reinterpret_cast<U*>(other.ptr_);
    ptr_ = reinterpret_cast<uintptr_t>(t);
  }
  template <typename U>
  WeakPtr(WeakPtr<U>&& other) : WeakPtrBase(std::move(other)) {


    T* t = reinterpret_cast<U*>(other.ptr_);
    ptr_ = reinterpret_cast<uintptr_t>(t);
  }

  T* get() const {
    return ref_.is_valid() ? reinterpret_cast<T*>(ptr_) : nullptr;
  }

  T& operator*() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(get() != nullptr);
    return *get();
  }
  T* operator->() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(get() != nullptr);
    return get();
  }

  void reset() {
    ref_ = internal::WeakReference();
    ptr_ = 0;
  }


  explicit operator bool() const { return get() != nullptr; }

 private:
  friend class internal::SupportsWeakPtrBase;
  template <typename U> friend class WeakPtr;
  friend class SupportsWeakPtr<T>;
  friend class WeakPtrFactory<T>;

  WeakPtr(const internal::WeakReference& ref, T* ptr)
      : WeakPtrBase(ref, reinterpret_cast<uintptr_t>(ptr)) {}
};


template <class T>
bool operator!=(const WeakPtr<T>& weak_ptr, std::nullptr_t) {
  return !(weak_ptr == nullptr);
}
template <class T>
bool operator!=(std::nullptr_t, const WeakPtr<T>& weak_ptr) {
  return weak_ptr != nullptr;
}
template <class T>
bool operator==(const WeakPtr<T>& weak_ptr, std::nullptr_t) {
  return weak_ptr.get() == nullptr;
}
template <class T>
bool operator==(std::nullptr_t, const WeakPtr<T>& weak_ptr) {
  return weak_ptr == nullptr;
}

namespace internal {
class WeakPtrFactoryBase {
 protected:
  WeakPtrFactoryBase(uintptr_t ptr);
  ~WeakPtrFactoryBase();
  internal::WeakReferenceOwner weak_reference_owner_;
  uintptr_t ptr_;
};
}






template <class T>
class WeakPtrFactory : public internal::WeakPtrFactoryBase {
 public:
  explicit WeakPtrFactory(T* ptr)
      : WeakPtrFactoryBase(reinterpret_cast<uintptr_t>(ptr)) {}

  ~WeakPtrFactory() {}

  WeakPtr<T> GetWeakPtr() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(ptr_);
    return WeakPtr<T>(weak_reference_owner_.GetRef(),
                      reinterpret_cast<T*>(ptr_));
  }


  void InvalidateWeakPtrs() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(ptr_);
    weak_reference_owner_.Invalidate();
  }


  bool HasWeakPtrs() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(ptr_);
    return weak_reference_owner_.HasRefs();
  }

 private:
  WeakPtrFactory() = delete; WeakPtrFactory(const WeakPtrFactory&) = delete; WeakPtrFactory& operator=(const WeakPtrFactory&) = delete;
};






template <class T>
class SupportsWeakPtr : public internal::SupportsWeakPtrBase {
 public:
  SupportsWeakPtr() {}

  WeakPtr<T> AsWeakPtr() {
    return WeakPtr<T>(weak_reference_owner_.GetRef(), static_cast<T*>(this));
  }

 protected:
  ~SupportsWeakPtr() {}

 private:
  internal::WeakReferenceOwner weak_reference_owner_;
  SupportsWeakPtr(const SupportsWeakPtr&) = delete; SupportsWeakPtr& operator=(const SupportsWeakPtr&) = delete;
};
# 373 "../../base/memory/weak_ptr.h"
template <typename Derived>
WeakPtr<Derived> AsWeakPtr(Derived* t) {
  return internal::SupportsWeakPtrBase::StaticAsWeakPtr<Derived>(t);
}

}
# 13 "../../base/trace_event/trace_event_system_stats_monitor.h" 2
# 1 "../../base/process/process_metrics.h" 1
# 11 "../../base/process/process_metrics.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 12 "../../base/process/process_metrics.h" 2








# 1 "../../base/process/process_handle.h" 1
# 12 "../../base/process/process_handle.h"
# 1 "../../base/files/file_path.h" 1
# 105 "../../base/files/file_path.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 106 "../../base/files/file_path.h" 2
# 115 "../../base/files/file_path.h"
# 1 "../../base/strings/string_piece.h" 1
# 25 "../../base/strings/string_piece.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 26 "../../base/strings/string_piece.h" 2
# 35 "../../base/strings/string_piece.h"
namespace base {
# 46 "../../base/strings/string_piece.h"
namespace internal {

            void CopyToString(const StringPiece& self, std::string* target);
            void CopyToString(const StringPiece16& self, string16* target);

            void AppendToString(const StringPiece& self, std::string* target);
            void AppendToString(const StringPiece16& self, string16* target);

            size_t copy(const StringPiece& self,
                        char* buf,
                        size_t n,
                        size_t pos);
            size_t copy(const StringPiece16& self,
                        char16* buf,
                        size_t n,
                        size_t pos);

            size_t find(const StringPiece& self,
                        const StringPiece& s,
                        size_t pos);
            size_t find(const StringPiece16& self,
                        const StringPiece16& s,
                        size_t pos);
            size_t find(const StringPiece& self,
                        char c,
                        size_t pos);
            size_t find(const StringPiece16& self,
                        char16 c,
                        size_t pos);

            size_t rfind(const StringPiece& self,
                         const StringPiece& s,
                         size_t pos);
            size_t rfind(const StringPiece16& self,
                         const StringPiece16& s,
                         size_t pos);
            size_t rfind(const StringPiece& self,
                         char c,
                         size_t pos);
            size_t rfind(const StringPiece16& self,
                         char16 c,
                         size_t pos);

            size_t find_first_of(const StringPiece& self,
                                 const StringPiece& s,
                                 size_t pos);
            size_t find_first_of(const StringPiece16& self,
                                 const StringPiece16& s,
                                 size_t pos);

            size_t find_first_not_of(const StringPiece& self,
                                     const StringPiece& s,
                                     size_t pos);
            size_t find_first_not_of(const StringPiece16& self,
                                     const StringPiece16& s,
                                     size_t pos);
            size_t find_first_not_of(const StringPiece& self,
                                     char c,
                                     size_t pos);
            size_t find_first_not_of(const StringPiece16& self,
                                     char16 c,
                                     size_t pos);

            size_t find_last_of(const StringPiece& self,
                                const StringPiece& s,
                                size_t pos);
            size_t find_last_of(const StringPiece16& self,
                                const StringPiece16& s,
                                size_t pos);
            size_t find_last_of(const StringPiece& self,
                                char c,
                                size_t pos);
            size_t find_last_of(const StringPiece16& self,
                                char16 c,
                                size_t pos);

            size_t find_last_not_of(const StringPiece& self,
                                    const StringPiece& s,
                                    size_t pos);
            size_t find_last_not_of(const StringPiece16& self,
                                    const StringPiece16& s,
                                    size_t pos);
            size_t find_last_not_of(const StringPiece16& self,
                                    char16 c,
                                    size_t pos);
            size_t find_last_not_of(const StringPiece& self,
                                    char c,
                                    size_t pos);

            StringPiece substr(const StringPiece& self,
                               size_t pos,
                               size_t n);
            StringPiece16 substr(const StringPiece16& self,
                                 size_t pos,
                                 size_t n);
# 150 "../../base/strings/string_piece.h"
}
# 160 "../../base/strings/string_piece.h"
template <typename STRING_TYPE> class BasicStringPiece {
 public:

  typedef size_t size_type;
  typedef typename STRING_TYPE::value_type value_type;
  typedef const value_type* pointer;
  typedef const value_type& reference;
  typedef const value_type& const_reference;
  typedef ptrdiff_t difference_type;
  typedef const value_type* const_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  static const size_type npos;

 public:



  constexpr BasicStringPiece() : ptr_(__null), length_(0) {}
  BasicStringPiece(const value_type* str)
      : ptr_(str),
        length_((str == __null) ? 0 : STRING_TYPE::traits_type::length(str)) {}
  BasicStringPiece(const STRING_TYPE& str)
      : ptr_(str.data()), length_(str.size()) {}
  constexpr BasicStringPiece(const value_type* offset, size_type len)
      : ptr_(offset), length_(len) {}
  BasicStringPiece(const typename STRING_TYPE::const_iterator& begin,
                   const typename STRING_TYPE::const_iterator& end) {





    length_ = static_cast<size_t>(std::distance(begin, end));



    ptr_ = length_ > 0 ? &*begin : nullptr;
  }





  constexpr const value_type* data() const { return ptr_; }
  constexpr size_type size() const { return length_; }
  constexpr size_type length() const { return length_; }
  bool empty() const { return length_ == 0; }

  void clear() {
    ptr_ = __null;
    length_ = 0;
  }
  void set(const value_type* data, size_type len) {
    ptr_ = data;
    length_ = len;
  }
  void set(const value_type* str) {
    ptr_ = str;
    length_ = str ? STRING_TYPE::traits_type::length(str) : 0;
  }

  constexpr value_type operator[](size_type i) const { return ptr_[i]; }
  value_type front() const { return ptr_[0]; }
  value_type back() const { return ptr_[length_ - 1]; }

  constexpr void remove_prefix(size_type n) {
    ptr_ += n;
    length_ -= n;
  }

  constexpr void remove_suffix(size_type n) { length_ -= n; }

  int compare(const BasicStringPiece<STRING_TYPE>& x) const {
    int r = wordmemcmp(
        ptr_, x.ptr_, (length_ < x.length_ ? length_ : x.length_));
    if (r == 0) {
      if (length_ < x.length_) r = -1;
      else if (length_ > x.length_) r = +1;
    }
    return r;
  }


  explicit operator STRING_TYPE() const { return as_string(); }

  STRING_TYPE as_string() const {

    return empty() ? STRING_TYPE() : STRING_TYPE(data(), size());
  }

  const_iterator begin() const { return ptr_; }
  const_iterator end() const { return ptr_ + length_; }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(ptr_ + length_);
  }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(ptr_);
  }

  size_type max_size() const { return length_; }
  size_type capacity() const { return length_; }

  static int wordmemcmp(const value_type* p,
                        const value_type* p2,
                        size_type N) {
    return STRING_TYPE::traits_type::compare(p, p2, N);
  }



  void CopyToString(STRING_TYPE* target) const {
    internal::CopyToString(*this, target);
  }

  void AppendToString(STRING_TYPE* target) const {
    internal::AppendToString(*this, target);
  }

  size_type copy(value_type* buf, size_type n, size_type pos = 0) const {
    return internal::copy(*this, buf, n, pos);
  }


  bool starts_with(const BasicStringPiece& x) const {
    return ((this->length_ >= x.length_) &&
            (wordmemcmp(this->ptr_, x.ptr_, x.length_) == 0));
  }


  bool ends_with(const BasicStringPiece& x) const {
    return ((this->length_ >= x.length_) &&
            (wordmemcmp(this->ptr_ + (this->length_-x.length_),
                        x.ptr_, x.length_) == 0));
  }


  size_type find(const BasicStringPiece<STRING_TYPE>& s,
                 size_type pos = 0) const {
    return internal::find(*this, s, pos);
  }
  size_type find(value_type c, size_type pos = 0) const {
    return internal::find(*this, c, pos);
  }


  size_type rfind(const BasicStringPiece& s,
                  size_type pos = BasicStringPiece::npos) const {
    return internal::rfind(*this, s, pos);
  }
  size_type rfind(value_type c, size_type pos = BasicStringPiece::npos) const {
    return internal::rfind(*this, c, pos);
  }


  size_type find_first_of(const BasicStringPiece& s,
                          size_type pos = 0) const {
    return internal::find_first_of(*this, s, pos);
  }
  size_type find_first_of(value_type c, size_type pos = 0) const {
    return find(c, pos);
  }


  size_type find_first_not_of(const BasicStringPiece& s,
                              size_type pos = 0) const {
    return internal::find_first_not_of(*this, s, pos);
  }
  size_type find_first_not_of(value_type c, size_type pos = 0) const {
    return internal::find_first_not_of(*this, c, pos);
  }


  size_type find_last_of(const BasicStringPiece& s,
                         size_type pos = BasicStringPiece::npos) const {
    return internal::find_last_of(*this, s, pos);
  }
  size_type find_last_of(value_type c,
                         size_type pos = BasicStringPiece::npos) const {
    return rfind(c, pos);
  }


  size_type find_last_not_of(const BasicStringPiece& s,
                             size_type pos = BasicStringPiece::npos) const {
    return internal::find_last_not_of(*this, s, pos);
  }
  size_type find_last_not_of(value_type c,
                             size_type pos = BasicStringPiece::npos) const {
    return internal::find_last_not_of(*this, c, pos);
  }


  BasicStringPiece substr(size_type pos,
                          size_type n = BasicStringPiece::npos) const {
    return internal::substr(*this, pos, n);
  }

 protected:
  const value_type* ptr_;
  size_type length_;
};

template <typename STRING_TYPE>
const typename BasicStringPiece<STRING_TYPE>::size_type
BasicStringPiece<STRING_TYPE>::npos =
    typename BasicStringPiece<STRING_TYPE>::size_type(-1);



extern template class BasicStringPiece<std::string>;
extern template class BasicStringPiece<string16>;




            bool operator==(const StringPiece& x, const StringPiece& y);

inline bool operator!=(const StringPiece& x, const StringPiece& y) {
  return !(x == y);
}

inline bool operator<(const StringPiece& x, const StringPiece& y) {
  const int r = StringPiece::wordmemcmp(
      x.data(), y.data(), (x.size() < y.size() ? x.size() : y.size()));
  return ((r < 0) || ((r == 0) && (x.size() < y.size())));
}

inline bool operator>(const StringPiece& x, const StringPiece& y) {
  return y < x;
}

inline bool operator<=(const StringPiece& x, const StringPiece& y) {
  return !(x > y);
}

inline bool operator>=(const StringPiece& x, const StringPiece& y) {
  return !(x < y);
}



inline bool operator==(const StringPiece16& x, const StringPiece16& y) {
  if (x.size() != y.size())
    return false;

  return StringPiece16::wordmemcmp(x.data(), y.data(), x.size()) == 0;
}

inline bool operator!=(const StringPiece16& x, const StringPiece16& y) {
  return !(x == y);
}

inline bool operator<(const StringPiece16& x, const StringPiece16& y) {
  const int r = StringPiece16::wordmemcmp(
      x.data(), y.data(), (x.size() < y.size() ? x.size() : y.size()));
  return ((r < 0) || ((r == 0) && (x.size() < y.size())));
}

inline bool operator>(const StringPiece16& x, const StringPiece16& y) {
  return y < x;
}

inline bool operator<=(const StringPiece16& x, const StringPiece16& y) {
  return !(x > y);
}

inline bool operator>=(const StringPiece16& x, const StringPiece16& y) {
  return !(x < y);
}

            std::ostream& operator<<(std::ostream& o,
                                     const StringPiece& piece);
# 449 "../../base/strings/string_piece.h"
struct StringPieceHash {
  std::size_t operator()(const StringPiece& sp) const {
    std::size_t result = 0; for (StringPiece::const_iterator i = sp.begin(); i != sp.end(); ++i) result = (result * 131) + *i; return result;;
  }
};
struct StringPiece16Hash {
  std::size_t operator()(const StringPiece16& sp16) const {
    std::size_t result = 0; for (StringPiece16::const_iterator i = sp16.begin(); i != sp16.end(); ++i) result = (result * 131) + *i; return result;;
  }
};

}
# 116 "../../base/files/file_path.h" 2
# 136 "../../base/files/file_path.h"
namespace base {

class Pickle;
class PickleIterator;



class FilePath {
 public:




  typedef std::string StringType;






  typedef BasicStringPiece<StringType> StringPieceType;
  typedef StringType::value_type CharType;





  static const CharType kSeparators[];


  static const size_t kSeparatorsLength;


  static const CharType kCurrentDirectory[];


  static const CharType kParentDirectory[];


  static const CharType kExtensionSeparator;

  FilePath();
  FilePath(const FilePath& that);
  explicit FilePath(StringPieceType path);
  ~FilePath();
  FilePath& operator=(const FilePath& that);



  FilePath(FilePath&& that) noexcept;


  FilePath& operator=(FilePath&& that);

  bool operator==(const FilePath& that) const;

  bool operator!=(const FilePath& that) const;


  bool operator<(const FilePath& that) const {
    return path_ < that.path_;
  }

  const StringType& value() const { return path_; }

  bool empty() const { return path_.empty(); }

  void clear() { path_.clear(); }


  static bool IsSeparator(CharType character);
# 218 "../../base/files/file_path.h"
  void GetComponents(std::vector<FilePath::StringType>* components) const;






  bool IsParent(const FilePath& child) const;
# 235 "../../base/files/file_path.h"
  bool AppendRelativePath(const FilePath& child, FilePath* path) const;







  FilePath DirName() const __attribute__((warn_unused_result));





  FilePath BaseName() const __attribute__((warn_unused_result));
# 261 "../../base/files/file_path.h"
  StringType Extension() const __attribute__((warn_unused_result));
# 270 "../../base/files/file_path.h"
  StringType FinalExtension() const __attribute__((warn_unused_result));




  FilePath RemoveExtension() const __attribute__((warn_unused_result));



  FilePath RemoveFinalExtension() const __attribute__((warn_unused_result));
# 288 "../../base/files/file_path.h"
  FilePath InsertBeforeExtension(
      StringPieceType suffix) const __attribute__((warn_unused_result));
  FilePath InsertBeforeExtensionASCII(
      StringPiece suffix) const __attribute__((warn_unused_result));



  FilePath AddExtension(StringPieceType extension) const __attribute__((warn_unused_result));





  FilePath ReplaceExtension(StringPieceType extension) const __attribute__((warn_unused_result));



  bool MatchesExtension(StringPieceType extension) const;







  FilePath Append(StringPieceType component) const __attribute__((warn_unused_result));
  FilePath Append(const FilePath& component) const __attribute__((warn_unused_result));







  FilePath AppendASCII(StringPiece component) const __attribute__((warn_unused_result));





  bool IsAbsolute() const;


  bool EndsWithSeparator() const __attribute__((warn_unused_result));



  FilePath AsEndingWithSeparator() const __attribute__((warn_unused_result));



  FilePath StripTrailingSeparators() const __attribute__((warn_unused_result));



  bool ReferencesParent() const;





  string16 LossyDisplayName() const;




  std::string MaybeAsASCII() const;
# 369 "../../base/files/file_path.h"
  std::string AsUTF8Unsafe() const;


  string16 AsUTF16Unsafe() const;
# 382 "../../base/files/file_path.h"
  static FilePath FromUTF8Unsafe(StringPiece utf8);


  static FilePath FromUTF16Unsafe(StringPiece16 utf16);

  void WriteToPickle(Pickle* pickle) const;
  bool ReadFromPickle(PickleIterator* iter);



  FilePath NormalizePathSeparators() const;



  FilePath NormalizePathSeparatorsTo(CharType separator) const;
# 406 "../../base/files/file_path.h"
  static int CompareIgnoreCase(StringPieceType string1,
                               StringPieceType string2);
  static bool CompareEqualIgnoreCase(StringPieceType string1,
                                     StringPieceType string2) {
    return CompareIgnoreCase(string1, string2) == 0;
  }
  static bool CompareLessIgnoreCase(StringPieceType string1,
                                    StringPieceType string2) {
    return CompareIgnoreCase(string1, string2) < 0;
  }
# 442 "../../base/files/file_path.h"
 private:





  void StripTrailingSeparatorsInternal();

  StringType path_;
};

            std::ostream& operator<<(std::ostream& out,
                                     const FilePath& file_path);

}
# 468 "../../base/files/file_path.h"
namespace std {

template <>
struct hash<base::FilePath> {
  typedef base::FilePath argument_type;
  typedef std::size_t result_type;
  result_type operator()(argument_type const& f) const {
    return hash<base::FilePath::StringType>()(f.value());
  }
};

}
# 13 "../../base/process/process_handle.h" 2
# 23 "../../base/process/process_handle.h"
namespace base {
# 41 "../../base/process/process_handle.h"
typedef pid_t ProcessHandle;
typedef pid_t ProcessId;
const ProcessHandle kNullProcessHandle = 0;
const ProcessId kNullProcessId = 0;
# 59 "../../base/process/process_handle.h"
            ProcessId GetCurrentProcId();





            uint32_t GetUniqueIdForProcess();
# 74 "../../base/process/process_handle.h"
            void InitUniqueIdForProcessInPidNamespace(
    ProcessId pid_outside_of_namespace);



            ProcessHandle GetCurrentProcessHandle();







            ProcessId GetProcId(ProcessHandle process);





            ProcessId GetParentProcessId(ProcessHandle process);




            FilePath GetProcessExecutablePath(ProcessHandle process);


}
# 21 "../../base/process/process_metrics.h" 2

# 1 "../../base/values.h" 1
# 24 "../../base/values.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 25 "../../base/values.h" 2



# 1 "../../buildtools/third_party/libc++/trunk/include/map" 1 3
# 442 "../../buildtools/third_party/libc++/trunk/include/map" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__tree" 1 3
# 22 "../../buildtools/third_party/libc++/trunk/include/__tree" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 26 "../../buildtools/third_party/libc++/trunk/include/__tree" 2 3


namespace std {inline namespace __1 {

template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
    class __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
    class __tree_const_iterator;

template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;


template <class _Key, class _Value>
union __value_type;





template <class _Key, class _CP, class _Compare,
    bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare;

template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator> class __map_iterator;
template <class _TreeIterator> class __map_const_iterator;
# 79 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
template <class _NodePtr>
inline __attribute__ ((__always_inline__))
bool
__tree_is_left_child(_NodePtr __x) noexcept
{
    return __x == __x->__parent_->__left_;
}




template <class _NodePtr>
unsigned
__tree_sub_invariant(_NodePtr __x)
{
    if (__x == nullptr)
        return 1;


    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
        return 0;

    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
        return 0;

    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
        return 0;

    if (!__x->__is_black_)
    {
        if (__x->__left_ && !__x->__left_->__is_black_)
            return 0;
        if (__x->__right_ && !__x->__right_->__is_black_)
            return 0;
    }
    unsigned __h = __tree_sub_invariant(__x->__left_);
    if (__h == 0)
        return 0;
    if (__h != __tree_sub_invariant(__x->__right_))
        return 0;
    return __h + __x->__is_black_;
}




template <class _NodePtr>
bool
__tree_invariant(_NodePtr __root)
{
    if (__root == nullptr)
        return true;

    if (__root->__parent_ == nullptr)
        return false;
    if (!__tree_is_left_child(__root))
        return false;

    if (!__root->__is_black_)
        return false;

    return __tree_sub_invariant(__root) != 0;
}



template <class _NodePtr>
inline __attribute__ ((__always_inline__))
_NodePtr
__tree_min(_NodePtr __x) noexcept
{
    while (__x->__left_ != nullptr)
        __x = __x->__left_;
    return __x;
}



template <class _NodePtr>
inline __attribute__ ((__always_inline__))
_NodePtr
__tree_max(_NodePtr __x) noexcept
{
    while (__x->__right_ != nullptr)
        __x = __x->__right_;
    return __x;
}



template <class _NodePtr>
_NodePtr
__tree_next(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return __tree_min(__x->__right_);
    while (!__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__ ((__always_inline__))
_EndNodePtr
__tree_next_iter(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return static_cast<_EndNodePtr>(__tree_min(__x->__right_));
    while (!__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return static_cast<_EndNodePtr>(__x->__parent_);
}




template <class _NodePtr, class _EndNodePtr>
inline __attribute__ ((__always_inline__))
_NodePtr
__tree_prev_iter(_EndNodePtr __x) noexcept
{
    if (__x->__left_ != nullptr)
        return __tree_max(__x->__left_);
    _NodePtr __xx = static_cast<_NodePtr>(__x);
    while (__tree_is_left_child(__xx))
        __xx = __xx->__parent_unsafe();
    return __xx->__parent_unsafe();
}



template <class _NodePtr>
_NodePtr
__tree_leaf(_NodePtr __x) noexcept
{
    while (true)
    {
        if (__x->__left_ != nullptr)
        {
            __x = __x->__left_;
            continue;
        }
        if (__x->__right_ != nullptr)
        {
            __x = __x->__right_;
            continue;
        }
        break;
    }
    return __x;
}




template <class _NodePtr>
void
__tree_left_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__right_;
    __x->__right_ = __y->__left_;
    if (__x->__right_ != nullptr)
        __x->__right_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __x;
    __x->__set_parent(__y);
}




template <class _NodePtr>
void
__tree_right_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__left_;
    __x->__left_ = __y->__right_;
    if (__x->__left_ != nullptr)
        __x->__left_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__right_ = __x;
    __x->__set_parent(__y);
}
# 279 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
template <class _NodePtr>
void
__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept
{
    __x->__is_black_ = __x == __root;
    while (__x != __root && !__x->__parent_unsafe()->__is_black_)
    {

        if (__tree_is_left_child(__x->__parent_unsafe()))
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (!__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    __tree_left_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                __tree_right_rotate(__x);
                break;
            }
        }
        else
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    __tree_right_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                __tree_left_rotate(__x);
                break;
            }
        }
    }
}
# 349 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
template <class _NodePtr>
void
__tree_remove(_NodePtr __root, _NodePtr __z) noexcept
{




    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?
                    __z : __tree_next(__z);

    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;

    _NodePtr __w = nullptr;

    if (__x != nullptr)
        __x->__parent_ = __y->__parent_;
    if (__tree_is_left_child(__y))
    {
        __y->__parent_->__left_ = __x;
        if (__y != __root)
            __w = __y->__parent_unsafe()->__right_;
        else
            __root = __x;
    }
    else
    {
        __y->__parent_unsafe()->__right_ = __x;

        __w = __y->__parent_->__left_;
    }
    bool __removed_black = __y->__is_black_;


    if (__y != __z)
    {

        __y->__parent_ = __z->__parent_;
        if (__tree_is_left_child(__z))
            __y->__parent_->__left_ = __y;
        else
            __y->__parent_unsafe()->__right_ = __y;
        __y->__left_ = __z->__left_;
        __y->__left_->__set_parent(__y);
        __y->__right_ = __z->__right_;
        if (__y->__right_ != nullptr)
            __y->__right_->__set_parent(__y);
        __y->__is_black_ = __z->__is_black_;
        if (__root == __z)
            __root = __y;
    }


    if (__removed_black && __root != nullptr)
    {
# 416 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
        if (__x != nullptr)
            __x->__is_black_ = true;
        else
        {





            while (true)
            {
                if (!__tree_is_left_child(__w))
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        __tree_left_rotate(__w->__parent_unsafe());


                        if (__root == __w->__left_)
                            __root = __w;

                        __w = __w->__left_->__right_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (__x == __root || !__x->__is_black_)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = __tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)
                        {

                            __w->__left_->__is_black_ = true;
                            __w->__is_black_ = false;
                            __tree_right_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__right_->__is_black_ = true;
                        __tree_left_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
                else
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        __tree_right_rotate(__w->__parent_unsafe());


                        if (__root == __w->__right_)
                            __root = __w;

                        __w = __w->__right_->__left_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (!__x->__is_black_ || __x == __root)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = __tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)
                        {

                            __w->__right_->__is_black_ = true;
                            __w->__is_black_ = false;
                            __tree_left_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__left_->__is_black_ = true;
                        __tree_right_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
            }
        }
    }
}





template <class _Tp>
struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};

template <class ..._Args>
struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};


template <class _Tp>
struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__always_inline__))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__always_inline__))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__always_inline__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n);
  }


  __attribute__ ((__always_inline__))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v);
  }

};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef pair<_Key, _Tp> __nc_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__always_inline__))
  static key_type const&
  __get_key(__node_value_type const& __t) {
    return __t.__cc.first;
  }

  template <class _Up>
  __attribute__ ((__always_inline__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      key_type const&>::type
  __get_key(_Up& __t) {
    return __t.first;
  }

  __attribute__ ((__always_inline__))
  static __container_value_type const&
  __get_value(__node_value_type const& __t) {
    return __t.__cc;
  }

  template <class _Up>
  __attribute__ ((__always_inline__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__always_inline__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n.__cc);
  }


  __attribute__ ((__always_inline__))
  static __nc_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v.__nc);
  }

};

template <class _VoidPtr>
struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
                                                             __end_node_pointer;



  typedef typename conditional<
      is_pointer<__end_node_pointer>::value,
        __end_node_pointer,
        __node_base_pointer>::type __parent_pointer;


private:
  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,
         bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >
    : public __tree_node_base_types<_VoidPtr>,
             __tree_key_value_types<_Tp>,
             __tree_map_pointer_types<_Tp, _VoidPtr>
{
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
public:

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;



  typedef typename conditional<
      is_pointer<__node_pointer>::value,
        typename __base::__end_node_pointer,
        __node_pointer>::type __iter_pointer;

private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types {
  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type
                                                                        _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};



template <class _Pointer>
class __tree_end_node
{
public:
    typedef _Pointer pointer;
    pointer __left_;

    __attribute__ ((__always_inline__))
    __tree_end_node() noexcept : __left_() {}
};

template <class _VoidPtr>
class __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type
{
    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
    typedef typename _NodeBaseTypes::__node_base_pointer pointer;
    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

    pointer __right_;
    __parent_pointer __parent_;
    bool __is_black_;

    __attribute__ ((__always_inline__))
    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}

    __attribute__ ((__always_inline__))
    void __set_parent(pointer __p) {
        __parent_ = static_cast<__parent_pointer>(__p);
    }

private:
  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const&) = delete;
  __tree_node_base& operator=(__tree_node_base const&) = delete;
};

template <class _Tp, class _VoidPtr>
class __tree_node
    : public __tree_node_base<_VoidPtr>
{
public:
    typedef _Tp __node_value_type;

    __node_value_type __value_;

private:
  ~__tree_node() = delete;
  __tree_node(__tree_node const&) = delete;
  __tree_node& operator=(__tree_node const&) = delete;
};


template <class _Allocator>
class __tree_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __tree_node_types<pointer> _NodeTypes;
    allocator_type& __na_;

    __tree_node_destructor& operator=(const __tree_node_destructor&);

public:
    bool __value_constructed;

    __attribute__ ((__always_inline__))
    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) noexcept
        : __na_(__na),
          __value_constructed(__val)
        {}

    __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __map_node_destructor;
};


template <class _Tp, class _NodePtr, class _DiffType>
class __tree_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__always_inline__)) __tree_iterator() noexcept

    : __ptr_(nullptr)

    {}

    __attribute__ ((__always_inline__)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__always_inline__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__always_inline__))
    __tree_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__always_inline__))
    __tree_iterator operator++(int)
        {__tree_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__always_inline__))
    __tree_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__always_inline__))
    __tree_iterator operator--(int)
        {__tree_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__always_inline__))
        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__always_inline__))
        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__always_inline__))
    explicit __tree_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__always_inline__))
    explicit __tree_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__always_inline__))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
    template <class, class, class> friend class __tree;
    template <class, class, class> friend class __tree_const_iterator;
    template <class> friend class __map_iterator;
    template <class, class, class, class> friend class map;
    template <class, class, class, class> friend class multimap;
    template <class, class, class> friend class set;
    template <class, class, class> friend class multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __tree_const_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

    __attribute__ ((__always_inline__)) __tree_const_iterator() noexcept

    : __ptr_(nullptr)

    {}

private:
    typedef __tree_iterator<value_type, __node_pointer, difference_type>
                                                           __non_const_iterator;
public:
    __attribute__ ((__always_inline__))
    __tree_const_iterator(__non_const_iterator __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__always_inline__)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__always_inline__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__always_inline__))
    __tree_const_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__always_inline__))
    __tree_const_iterator operator++(int)
        {__tree_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__always_inline__))
    __tree_const_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__always_inline__))
    __tree_const_iterator operator--(int)
        {__tree_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__always_inline__))
        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__always_inline__))
        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__always_inline__))
    explicit __tree_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__always_inline__))
    explicit __tree_const_iterator(__end_node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__always_inline__))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }

    template <class, class, class> friend class __tree;
    template <class, class, class, class> friend class map;
    template <class, class, class, class> friend class multimap;
    template <class, class, class> friend class set;
    template <class, class, class> friend class multiset;
    template <class> friend class __map_const_iterator;

};


template <class _Tp, class _Compare, class _Allocator>
struct __diagnose_tree_helper {
  static constexpr bool __trigger_diagnostics()
      __attribute__((diagnose_if(!__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a const call operator", "warning")))

  { return true; }
};

template <class _Key, class _Value, class _KeyComp, class _Alloc>
struct __diagnose_tree_helper<
    __value_type<_Key, _Value>,
    __map_value_compare<_Key, __value_type<_Key, _Value>, _KeyComp>,
    _Alloc
> : __diagnose_tree_helper<_Key, _KeyComp, _Alloc>
{
};


template <class _Tp, class _Compare, class _Allocator>
class __tree
{
public:
    typedef _Tp value_type;
    typedef _Compare value_compare;
    typedef _Allocator allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __make_tree_node_types<value_type,
        typename __alloc_traits::void_pointer>::type
                                                    _NodeTypes;
    typedef typename _NodeTypes::key_type key_type;
public:
    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;

    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

public:
    typedef typename _NodeTypes::__void_pointer __void_pointer;

    typedef typename _NodeTypes::__node_type __node;
    typedef typename _NodeTypes::__node_pointer __node_pointer;

    typedef typename _NodeTypes::__node_base_type __node_base;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

    typedef typename _NodeTypes::__end_node_type __end_node_t;
    typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

    typedef typename _NodeTypes::__parent_pointer __parent_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;

private:



    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:
    __iter_pointer __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator> __pair1_;
    __compressed_pair<size_type, value_compare> __pair3_;

public:
    __attribute__ ((__always_inline__))
    __iter_pointer __end_node() noexcept
    {
        return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())
        );
    }
    __attribute__ ((__always_inline__))
    __iter_pointer __end_node() const noexcept
    {
        return static_cast<__iter_pointer>(
            pointer_traits<__end_node_ptr>::pointer_to(
                const_cast<__end_node_t&>(__pair1_.first())
            )
        );
    }
    __attribute__ ((__always_inline__))
          __node_allocator& __node_alloc() noexcept {return __pair1_.second();}
private:
    __attribute__ ((__always_inline__))
    const __node_allocator& __node_alloc() const noexcept
        {return __pair1_.second();}
    __attribute__ ((__always_inline__))
          __iter_pointer& __begin_node() noexcept {return __begin_node_;}
    __attribute__ ((__always_inline__))
    const __iter_pointer& __begin_node() const noexcept {return __begin_node_;}
public:
    __attribute__ ((__always_inline__))
    allocator_type __alloc() const noexcept
        {return allocator_type(__node_alloc());}
private:
    __attribute__ ((__always_inline__))
          size_type& size() noexcept {return __pair3_.first();}
public:
    __attribute__ ((__always_inline__))
    const size_type& size() const noexcept {return __pair3_.first();}
    __attribute__ ((__always_inline__))
          value_compare& value_comp() noexcept {return __pair3_.second();}
    __attribute__ ((__always_inline__))
    const value_compare& value_comp() const noexcept
        {return __pair3_.second();}
public:

    __attribute__ ((__always_inline__))
    __node_pointer __root() const noexcept
        {return static_cast<__node_pointer>(__end_node()->__left_);}

    __node_base_pointer* __root_ptr() const noexcept {
        return std::__1::addressof(__end_node()->__left_);
    }

    typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;

    explicit __tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value);


    explicit __tree(const allocator_type& __a);
    __tree(const value_compare& __comp, const allocator_type& __a);
    __tree(const __tree& __t);
    __tree& operator=(const __tree& __t);
    template <class _InputIterator>
        void __assign_unique(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);

    __tree(__tree&& __t)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value);


    __tree(__tree&& __t, const allocator_type& __a);
    __tree& operator=(__tree&& __t)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);





    ~__tree();

    __attribute__ ((__always_inline__))
          iterator begin() noexcept {return iterator(__begin_node());}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return const_iterator(__begin_node());}
    __attribute__ ((__always_inline__))
          iterator end() noexcept {return iterator(__end_node());}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return const_iterator(__end_node());}

    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept
        {return std::min<size_type>(
                __node_traits::max_size(__node_alloc()),
                numeric_limits<difference_type >::max());}

    void clear() noexcept;

    void swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value);



    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_unique_key_args(_Key const&, _Args&&... __args);
    template <class _Key, class ..._Args>
    iterator
    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);

    template <class... _Args>
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);

    template <class... _Args>
    iterator __emplace_multi(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
        return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__always_inline__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
        return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_unique_extract_key(__p, std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__always_inline__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        iterator
    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {
        return __emplace_hint_unique_key_args(__p, __f,
                                              std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__always_inline__))
    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {
        return __emplace_hint_unique_impl(__p, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {
      return __emplace_hint_unique_impl(__p, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {
      return __emplace_hint_unique_key_args(__p, __x, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
      return __emplace_hint_unique_key_args(__p, __x.first, std::__1::forward<_Pp>(__x));
    }
# 1271 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
    }

    __attribute__ ((__always_inline__))
    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);
    }







    __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), std::__1::move(__v));
    }

    __attribute__ ((__always_inline__))
    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), std::__1::move(__v));
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(_Vp&& __v) {
        return __emplace_unique(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__always_inline__))
    iterator __insert_unique(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_unique(__p, std::__1::forward<_Vp>(__v));
    }

    __attribute__ ((__always_inline__))
    iterator __insert_multi(__container_value_type&& __v) {
        return __emplace_multi(std::__1::move(__v));
    }

    __attribute__ ((__always_inline__))
    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_multi(__p, std::__1::move(__v));
    }

    template <class _Vp>
    __attribute__ ((__always_inline__))
    iterator __insert_multi(_Vp&& __v) {
        return __emplace_multi(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp>
    __attribute__ ((__always_inline__))
    iterator __insert_multi(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_multi(__p, std::__1::forward<_Vp>(__v));
    }



    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
    iterator __node_insert_unique(const_iterator __p,
                                              __node_pointer __nd);

    iterator __node_insert_multi(__node_pointer __nd);
    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);

    void __insert_node_at(__parent_pointer __parent,
                          __node_base_pointer& __child,
                          __node_base_pointer __new_node);

    template <class _Key>
        iterator find(const _Key& __v);
    template <class _Key>
        const_iterator find(const _Key& __v) const;

    template <class _Key>
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        __attribute__ ((__always_inline__))
        iterator lower_bound(const _Key& __v)
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __lower_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__always_inline__))
        const_iterator lower_bound(const _Key& __v) const
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __lower_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        __attribute__ ((__always_inline__))
        iterator upper_bound(const _Key& __v)
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __upper_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__always_inline__))
        const_iterator upper_bound(const _Key& __v) const
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __upper_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    typedef __tree_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    __node_holder remove(const_iterator __p) noexcept;
private:
    __node_base_pointer&
        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf(const_iterator __hint,
                    __parent_pointer& __parent, const key_type& __v);


    template <class _Key>
    __node_base_pointer&
        __find_equal(__parent_pointer& __parent, const _Key& __v);
    template <class _Key>
    __attribute__ ((__always_inline__)) __node_base_pointer&
    __find_equal(__parent_pointer& __parent, const _Key& __v) const {
      return const_cast<__tree*>(this)->__find_equal(__parent, __v);
    }
    template <class _Key>
    __node_base_pointer&
        __find_equal(const_iterator __hint, __parent_pointer& __parent,
                     __node_base_pointer& __dummy,
                     const _Key& __v);


    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);




    void destroy(__node_pointer __nd) noexcept;

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __tree& __t)
        {__copy_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __tree& __t, true_type)
        {
        if (__node_alloc() != __t.__node_alloc())
         clear();
        __node_alloc() = __t.__node_alloc();
        }
    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __tree&, false_type) {}

    void __move_assign(__tree& __t, false_type);
    void __move_assign(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);


    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__tree& __t)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__node_alloc() = std::__1::move(__t.__node_alloc());}
    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__tree&, false_type) noexcept {}

    __node_pointer __detach();
    static __node_pointer __detach(__node_pointer);

    template <class, class, class, class> friend class map;
    template <class, class, class, class> friend class multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value)


    : __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__second_tag(), __node_allocator(__a)),
      __pair3_(0)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,
                                           const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__second_tag(), __node_allocator(__a)),
      __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::__detach()
{
    __node_pointer __cache = static_cast<__node_pointer>(__begin_node());
    __begin_node() = __end_node();
    __end_node()->__left_->__parent_ = nullptr;
    __end_node()->__left_ = nullptr;
    size() = 0;

    if (__cache->__right_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__right_);


    return __cache;
}





template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)
{
    if (__cache->__parent_ == nullptr)
        return nullptr;
    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))
    {
        __cache->__parent_->__left_ = nullptr;
        __cache = static_cast<__node_pointer>(__cache->__parent_);
        if (__cache->__right_ == nullptr)
            return __cache;
        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));
    }

    __cache->__parent_unsafe()->__right_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__left_ == nullptr)
        return __cache;
    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)
{
    if (this != &__t)
    {
        value_comp() = __t.value_comp();
        __copy_assign_alloc(__t);
        __assign_multi(__t.begin(), __t.end());
    }
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");

    if (size() != 0)
    {
        __node_pointer __cache = __detach();




            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__value_ = *__first;
                __node_pointer __next = __detach(__cache);
                __node_insert_unique(__cache);
                __cache = __next;
            }
# 1614 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
        if (__cache != nullptr)
        {
            while (__cache->__parent_ != nullptr)
                __cache = static_cast<__node_pointer>(__cache->__parent_);
            destroy(__cache);
        }
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (size() != 0)
    {
        __node_pointer __cache = __detach();




            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__value_ = *__first;
                __node_pointer __next = __detach(__cache);
                __node_insert_multi(__cache);
                __cache = __next;
            }
# 1660 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
        if (__cache != nullptr)
        {
            while (__cache->__parent_ != nullptr)
                __cache = static_cast<__node_pointer>(__cache->__parent_);
            destroy(__cache);
        }
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__second_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp())
{
    __begin_node() = __end_node();
}



template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value)


    : __begin_node_(std::__1::move(__t.__begin_node_)),
      __pair1_(std::__1::move(__t.__pair1_)),
      __pair3_(std::__1::move(__t.__pair3_))
{
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)
    : __pair1_(__second_tag(), __node_allocator(__a)),
      __pair3_(0, std::__1::move(__t.value_comp()))
{
    if (__a == __t.__alloc())
    {
        if (__t.size() == 0)
            __begin_node() = __end_node();
        else
        {
            __begin_node() = __t.__begin_node();
            __end_node()->__left_ = __t.__end_node()->__left_;
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
            size() = __t.size();
            __t.__begin_node() = __t.__end_node();
            __t.__end_node()->__left_ = nullptr;
            __t.size() = 0;
        }
    }
    else
    {
        __begin_node() = __end_node();
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)
    noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)

{
    destroy(static_cast<__node_pointer>(__end_node()->__left_));
    __begin_node_ = __t.__begin_node_;
    __pair1_.first() = __t.__pair1_.first();
    __move_assign_alloc(__t);
    __pair3_ = std::__1::move(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)
{
    if (__node_alloc() == __t.__node_alloc())
        __move_assign(__t, true_type());
    else
    {
        value_comp() = std::__1::move(__t.value_comp());
        const_iterator __e = end();
        if (size() != 0)
        {
            __node_pointer __cache = __detach();




                while (__cache != nullptr && __t.size() != 0)
                {
                    __cache->__value_ = std::__1::move(__t.remove(__t.begin())->__value_);
                    __node_pointer __next = __detach(__cache);
                    __node_insert_multi(__cache);
                    __cache = __next;
                }
# 1784 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
            if (__cache != nullptr)
            {
                while (__cache->__parent_ != nullptr)
                    __cache = static_cast<__node_pointer>(__cache->__parent_);
                destroy(__cache);
            }
        }
        while (__t.size() != 0)
            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)




{
    __move_assign(__t, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree()
{
    static_assert((is_copy_constructible<value_compare>::value),
                 "Comparator must be copy-constructible.");

    static_assert((__diagnose_tree_helper<_Tp, _Compare, _Allocator>::
                     __trigger_diagnostics()), "");

  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept
{
    if (__nd != nullptr)
    {
        destroy(static_cast<__node_pointer>(__nd->__left_));
        destroy(static_cast<__node_pointer>(__nd->__right_));
        __node_allocator& __na = __node_alloc();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
        __node_traits::deallocate(__na, __nd, 1);
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value)

{
    using std::__1::swap;
    swap(__begin_node_, __t.__begin_node_);
    swap(__pair1_.first(), __t.__pair1_.first());
    __swap_allocator(__node_alloc(), __t.__node_alloc());
    __pair3_.swap(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
    if (__t.size() == 0)
        __t.__begin_node() = __t.__end_node();
    else
        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::clear() noexcept
{
    destroy(__root());
    size() = 0;
    __begin_node() = __end_node();
    __end_node()->__left_ = nullptr;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,
                                                   const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,
                                                    const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}







template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer& __parent,
                                               const key_type& __v)
{
    if (__hint == end() || !value_comp()(*__hint, __v))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || !value_comp()(__v, *--__prior))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_leaf_high(__parent, __v);
    }

    return __find_leaf_low(__parent, __v);
}





template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,
                                                const _Key& __v)
{
    __node_pointer __nd = __root();
    __node_base_pointer* __nd_ptr = __root_ptr();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__left_);
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__right_);
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__nd);
                return *__nd_ptr;
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}
# 2045 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer& __parent,
                                                __node_base_pointer& __dummy,
                                                const _Key& __v)
{
    if (__hint == end() || value_comp()(__v, *__hint))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || value_comp()(*--__prior, __v))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_equal(__parent, __v);
    }
    else if (value_comp()(*__hint, __v))
    {

        const_iterator __next = std::__1::next(__hint);
        if (__next == end() || value_comp()(__v, *__next))
        {

            if (__hint.__get_np()->__right_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__next.__ptr_);
                return __parent->__left_;
            }
        }

        return __find_equal(__parent, __v);
    }

    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
    return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__parent_pointer __parent,
                                                    __node_base_pointer& __child,
                                                    __node_base_pointer __new_node)
{
    __new_node->__left_ = nullptr;
    __new_node->__right_ = nullptr;
    __new_node->__parent_ = __parent;

    __child = __new_node;
    if (__begin_node()->__left_ != nullptr)
        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
    __tree_balance_after_insert(__end_node()->__left_, __child);
    ++size();
}


template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)






{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {

        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);



        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}



template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const& __k, _Args&&... __args)







{
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {

        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);



        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return iterator(__r);
}




template <class _Tp, class _Compare, class _Allocator>
template <class ..._Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_tree_value_type<_Args...>::value,
                  "Cannot construct from __value_type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    return __h;
}


template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}
# 2300 "../../buildtools/third_party/libc++/trunk/include/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,
                                                        __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    iterator __r(__p.__ptr_);
    ++__r;
    if (__begin_node() == __p.__ptr_)
        __begin_node() = __r.__ptr_;
    --size();
    __node_allocator& __na = __node_alloc();
    __tree_remove(__end_node()->__left_,
                  static_cast<__node_base_pointer>(__np));
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(
        const_cast<__node_value_type&>(*__p)));
    __node_traits::deallocate(__na, __np, 1);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    while (__f != __l)
        __f = erase(__f);
    return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)
{
    pair<iterator, iterator> __p = __equal_range_multi(__k);
    size_type __r = 0;
    for (; __p.first != __p.second; ++__r)
        __p.first = erase(__p.first);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)
{
    iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const
{
    const_iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const
{
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return 1;
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const
{
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return std::__1::distance(
                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)
            );
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(iterator(__rt),
                      iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(const_iterator(__rt),
                      const_iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept
{
    __node_pointer __np = __p.__get_np();
    if (__begin_node() == __p.__ptr_)
    {
        if (__np->__right_ != nullptr)
            __begin_node() = static_cast<__iter_pointer>(__np->__right_);
        else
            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
    }
    --size();
    __tree_remove(__end_node()->__left_,
                  static_cast<__node_base_pointer>(__np));
    return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(__tree<_Tp, _Compare, _Allocator>& __x,
     __tree<_Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 443 "../../buildtools/third_party/libc++/trunk/include/map" 2 3
# 452 "../../buildtools/third_party/libc++/trunk/include/map" 3


namespace std {inline namespace __1 {

template <class _Key, class _CP, class _Compare, bool _IsSmall>
class __map_value_compare
    : private _Compare
{
public:
    __attribute__ ((__always_inline__))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : _Compare() {}
    __attribute__ ((__always_inline__))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : _Compare(c) {}
    __attribute__ ((__always_inline__))
    const _Compare& key_comp() const noexcept {return *this;}
    __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}
    __attribute__ ((__always_inline__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      using std::__1::swap;
      swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));
    }


    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}

};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
    _Compare comp;

public:
    __attribute__ ((__always_inline__))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : comp() {}
    __attribute__ ((__always_inline__))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : comp(c) {}
    __attribute__ ((__always_inline__))
    const _Compare& key_comp() const noexcept {return comp;}

    __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return comp(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return comp(__x.__cc.first, __y);}
    __attribute__ ((__always_inline__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return comp(__x, __y.__cc.first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
        using std::__1::swap;
        swap(comp, __y.comp);
    }


    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return comp (__x, __y.__cc.first);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return comp (__x.__cc.first, __y);}

};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__ ((__always_inline__))
void
swap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,
     __map_value_compare<_Key, _CP, _Compare, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;

private:
    allocator_type& __na_;

    __map_node_destructor& operator=(const __map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__always_inline__))
    explicit __map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__always_inline__))
    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }


    __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__cc.second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__cc.first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class _Key, class _Tp, class _Compare, class _Allocator>
    class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class multimap;
template <class _TreeIterator> class __map_const_iterator;



template <class _Key, class _Tp>
union __value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;

    value_type __cc;
    __nc_value_type __nc;

    __attribute__ ((__always_inline__))
    __value_type& operator=(const __value_type& __v)
        {__nc = __v.__cc; return *this;}

    __attribute__ ((__always_inline__))
    __value_type& operator=(__value_type&& __v)
        {__nc = std::__1::move(__v.__nc); return *this;}

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__always_inline__))
    __value_type& operator=(_ValueTp&& __v) {
        __nc = std::__1::forward<_ValueTp>(__v); return *this;
    }

private:
    __value_type() = delete;
    ~__value_type() = delete;
    __value_type(const __value_type& __v) = delete;
    __value_type(__value_type&& __v) = delete;
};
# 672 "../../buildtools/third_party/libc++/trunk/include/map" 3
template <class _Tp>
struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp> >
{
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator>
class __map_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__always_inline__))
    __map_iterator() noexcept {}

    __attribute__ ((__always_inline__))
    __map_iterator(_TreeIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__always_inline__))
    __map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__always_inline__))
    __map_iterator operator++(int)
    {
        __map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__always_inline__))
    __map_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__always_inline__))
    __map_iterator operator--(int)
    {
        __map_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend
    __attribute__ ((__always_inline__))
    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class map;
    template <class, class, class, class> friend class multimap;
    template <class> friend class __map_const_iterator;
};

template <class _TreeIterator>
class __map_const_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__always_inline__))
    __map_const_iterator() noexcept {}

    __attribute__ ((__always_inline__))
    __map_const_iterator(_TreeIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__always_inline__))
    __map_const_iterator(__map_iterator<
        typename _TreeIterator::__non_const_iterator> __i) noexcept
        : __i_(__i.__i_) {}

    __attribute__ ((__always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__always_inline__))
    __map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__always_inline__))
    __map_const_iterator operator++(int)
    {
        __map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__always_inline__))
    __map_const_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__always_inline__))
    __map_const_iterator operator--(int)
    {
        __map_const_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class map;
    template <class, class, class, class> friend class multimap;
    template <class, class, class> friend class __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef _Compare key_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    class value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;

        __attribute__ ((__always_inline__)) value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__always_inline__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    __attribute__ ((__always_inline__))
    map()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__always_inline__))
    explicit map(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__always_inline__))
    explicit map(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
    __attribute__ ((__always_inline__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
    __attribute__ ((__always_inline__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__always_inline__))
    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : map(__f, __l, key_compare(), __a) {}


    __attribute__ ((__always_inline__))
    map(const map& __m)
        : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__always_inline__))
    map& operator=(const map& __m)
        {

            __tree_ = __m.__tree_;
# 921 "../../buildtools/third_party/libc++/trunk/include/map" 3
            return *this;
        }



    __attribute__ ((__always_inline__))
    map(map&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    map(map&& __m, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    map& operator=(map&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__always_inline__))
    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__always_inline__))
    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__always_inline__))
    map(initializer_list<value_type> __il, const allocator_type& __a)
        : map(__il, key_compare(), __a) {}


    __attribute__ ((__always_inline__))
    map& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__always_inline__))
    explicit map(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__always_inline__))
    map(const map& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}

    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


          mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__always_inline__))
    value_compare value_comp() const {return value_compare(__tree_.value_comp().key_comp());}


    template <class ..._Args>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> emplace(_Args&& ...__args) {
        return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__always_inline__))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_unique(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__always_inline__))
        pair<iterator, bool> insert(_Pp&& __p)
            {return __tree_.__insert_unique(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__always_inline__))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_unique(__pos.__i_, std::__1::forward<_Pp>(__p));}



    __attribute__ ((__always_inline__))
    pair<iterator, bool>
        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}

    __attribute__ ((__always_inline__))
    iterator
        insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_unique(__p.__i_, __v);}


    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    insert(value_type&& __v) {return __tree_.__insert_unique(std::__1::move(__v));}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
    {return __tree_.__insert_unique(__p.__i_, std::__1::move(__v));}

    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }
# 1191 "../../buildtools/third_party/libc++/trunk/include/map" 3
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {__tree_.clear();}

    __attribute__ ((__always_inline__))
    void swap(map& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_unique(__k);}

    __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_unique(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_base_pointer __node_base_pointer;
    typedef typename __base::__parent_pointer __parent_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;




};



template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_unique(__e.__i_,
                    std::__1::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));
    }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(__k),
        std::__1::forward_as_tuple()).first->__cc.second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(std::__1::move(__k)),
        std::__1::forward_as_tuple()).first->__cc.second;
}
# 1368 "../../buildtools/third_party/libc++/trunk/include/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);




    return static_cast<__node_pointer>(__child)->__value_.__cc.second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const
{
    __parent_pointer __parent;
    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);




    return static_cast<__node_pointer>(__child)->__value_.__cc.second;
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x,
     map<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef _Compare key_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    class value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class multimap;
    protected:
        key_compare comp;

        __attribute__ ((__always_inline__))
        value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__always_inline__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    __attribute__ ((__always_inline__))
    multimap()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__always_inline__))
    explicit multimap(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__always_inline__))
    explicit multimap(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__always_inline__))
    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : multimap(__f, __l, key_compare(), __a) {}


    __attribute__ ((__always_inline__))
    multimap(const multimap& __m)
        : __tree_(__m.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__always_inline__))
    multimap& operator=(const multimap& __m)
        {

            __tree_ = __m.__tree_;
# 1579 "../../buildtools/third_party/libc++/trunk/include/map" 3
            return *this;
        }



    __attribute__ ((__always_inline__))
    multimap(multimap&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    multimap(multimap&& __m, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    multimap& operator=(multimap&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__always_inline__))
    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__always_inline__))
    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__always_inline__))
    multimap(initializer_list<value_type> __il, const allocator_type& __a)
        : multimap(__il, key_compare(), __a) {}


    __attribute__ ((__always_inline__))
    multimap& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__always_inline__))
    explicit multimap(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__always_inline__))
    multimap(const multimap& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}

    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__always_inline__))
    value_compare value_comp() const
        {return value_compare(__tree_.value_comp().key_comp());}



    template <class ..._Args>
    __attribute__ ((__always_inline__))
    iterator emplace(_Args&& ...__args) {
        return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__always_inline__))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_multi(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__always_inline__))
        iterator insert(_Pp&& __p)
            {return __tree_.__insert_multi(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__always_inline__))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_multi(__pos.__i_, std::__1::forward<_Pp>(__p));}

    __attribute__ ((__always_inline__))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__1::move(__v));}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p.__i_, std::__1::move(__v));}


    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}



    __attribute__ ((__always_inline__))
    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_multi(__p.__i_, __v);}

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }

    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__always_inline__))
    void clear() {__tree_.clear();}

    __attribute__ ((__always_inline__))
    void swap(multimap& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}

    __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
};


template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_multi(__e.__i_,
                    std::__1::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));
    }
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,
     multimap<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 29 "../../base/values.h" 2






# 1 "../../base/containers/flat_map.h" 1
# 12 "../../base/containers/flat_map.h"
# 1 "../../base/containers/flat_tree.h" 1
# 15 "../../base/containers/flat_tree.h"
namespace base {

enum FlatContainerDupes {
  KEEP_FIRST_OF_DUPES,
  KEEP_LAST_OF_DUPES,
};

namespace internal {



template <class Iterator>
constexpr bool is_multipass() {
  return std::is_base_of<
      std::forward_iterator_tag,
      typename std::iterator_traits<Iterator>::iterator_category>::value;
}



template <class Iterator, class BinaryPredicate>
Iterator LastUnique(Iterator first, Iterator last, BinaryPredicate compare) {
  Iterator replacable = std::adjacent_find(first, last, compare);


  if (replacable == last)
    return last;

  first = std::next(replacable);


  if (first == last)
    return replacable;



  for (Iterator next = std::next(first); next != last; ++next, ++first) {
    if (!compare(*first, *next))
      *replacable++ = std::move(*first);
  }


  *replacable++ = std::move(*first);
  return replacable;
}


template <typename T, typename = void>
struct IsTransparentCompare : std::false_type {};
template <typename T>
struct IsTransparentCompare<T, void_t<typename T::is_transparent>>
    : std::true_type {};
# 81 "../../base/containers/flat_tree.h"
template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
class flat_tree {
 private:
  using underlying_type = std::vector<Value>;

 public:



  using key_type = Key;
  using key_compare = KeyCompare;
  using value_type = Value;


  class value_compare : public key_compare {
   public:
    value_compare() = default;

    template <class Cmp>
    explicit value_compare(Cmp&& compare_arg)
        : KeyCompare(std::forward<Cmp>(compare_arg)) {}

    bool operator()(const value_type& left, const value_type& right) const {
      GetKeyFromValue extractor;
      return key_compare::operator()(extractor(left), extractor(right));
    }
  };

  using pointer = typename underlying_type::pointer;
  using const_pointer = typename underlying_type::const_pointer;
  using reference = typename underlying_type::reference;
  using const_reference = typename underlying_type::const_reference;
  using size_type = typename underlying_type::size_type;
  using difference_type = typename underlying_type::difference_type;
  using iterator = typename underlying_type::iterator;
  using const_iterator = typename underlying_type::const_iterator;
  using reverse_iterator = typename underlying_type::reverse_iterator;
  using const_reverse_iterator =
      typename underlying_type::const_reverse_iterator;
# 133 "../../base/containers/flat_tree.h"
  flat_tree();
  explicit flat_tree(const key_compare& comp);

  template <class InputIterator>
  flat_tree(InputIterator first,
            InputIterator last,
            FlatContainerDupes dupe_handling = KEEP_FIRST_OF_DUPES,
            const key_compare& comp = key_compare());

  flat_tree(const flat_tree&);
  flat_tree(flat_tree&&);

  flat_tree(std::vector<value_type> items,
            FlatContainerDupes dupe_handling = KEEP_FIRST_OF_DUPES,
            const key_compare& comp = key_compare());

  flat_tree(std::initializer_list<value_type> ilist,
            FlatContainerDupes dupe_handling = KEEP_FIRST_OF_DUPES,
            const key_compare& comp = key_compare());

  ~flat_tree();






  flat_tree& operator=(const flat_tree&);
  flat_tree& operator=(flat_tree&&);

  flat_tree& operator=(std::initializer_list<value_type> ilist);
# 174 "../../base/containers/flat_tree.h"
  void reserve(size_type new_capacity);
  size_type capacity() const;
  void shrink_to_fit();






  void clear();

  size_type size() const;
  size_type max_size() const;
  bool empty() const;




  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;

  iterator end();
  const_iterator end() const;
  const_iterator cend() const;

  reverse_iterator rbegin();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator crbegin() const;

  reverse_iterator rend();
  const_reverse_iterator rend() const;
  const_reverse_iterator crend() const;
# 218 "../../base/containers/flat_tree.h"
  std::pair<iterator, bool> insert(const value_type& val);
  std::pair<iterator, bool> insert(value_type&& val);

  iterator insert(const_iterator position_hint, const value_type& x);
  iterator insert(const_iterator position_hint, value_type&& x);




  template <class InputIterator>
  void insert(InputIterator first,
              InputIterator last,
              FlatContainerDupes dupes = KEEP_FIRST_OF_DUPES);

  template <class... Args>
  std::pair<iterator, bool> emplace(Args&&... args);

  template <class... Args>
  iterator emplace_hint(const_iterator position_hint, Args&&... args);
# 249 "../../base/containers/flat_tree.h"
  iterator erase(iterator position);
  iterator erase(const_iterator position);
  iterator erase(const_iterator first, const_iterator last);
  template <typename K>
  size_type erase(const K& key);




  key_compare key_comp() const;
  value_compare value_comp() const;






  template <typename K>
  size_type count(const K& key) const;

  template <typename K>
  iterator find(const K& key);

  template <typename K>
  const_iterator find(const K& key) const;

  template <typename K>
  std::pair<iterator, iterator> equal_range(const K& key);

  template <typename K>
  std::pair<const_iterator, const_iterator> equal_range(const K& key) const;

  template <typename K>
  iterator lower_bound(const K& key);

  template <typename K>
  const_iterator lower_bound(const K& key) const;

  template <typename K>
  iterator upper_bound(const K& key);

  template <typename K>
  const_iterator upper_bound(const K& key) const;
# 304 "../../base/containers/flat_tree.h"
  void swap(flat_tree& other);

  friend bool operator==(const flat_tree& lhs, const flat_tree& rhs) {
    return lhs.impl_.body_ == rhs.impl_.body_;
  }

  friend bool operator!=(const flat_tree& lhs, const flat_tree& rhs) {
    return !(lhs == rhs);
  }

  friend bool operator<(const flat_tree& lhs, const flat_tree& rhs) {
    return lhs.impl_.body_ < rhs.impl_.body_;
  }

  friend bool operator>(const flat_tree& lhs, const flat_tree& rhs) {
    return rhs < lhs;
  }

  friend bool operator>=(const flat_tree& lhs, const flat_tree& rhs) {
    return !(lhs < rhs);
  }

  friend bool operator<=(const flat_tree& lhs, const flat_tree& rhs) {
    return !(lhs > rhs);
  }

  friend void swap(flat_tree& lhs, flat_tree& rhs) { lhs.swap(rhs); }

 protected:


  template <class... Args>
  iterator unsafe_emplace(const_iterator position, Args&&... args);





  template <class K, class... Args>
  std::pair<iterator, bool> emplace_key_args(const K& key, Args&&... args);



  template <class K, class... Args>
  std::pair<iterator, bool> emplace_hint_key_args(const_iterator hint,
                                                  const K& key,
                                                  Args&&... args);

 private:


  struct KeyValueCompare {

    explicit KeyValueCompare(const key_compare& key_comp)
        : key_comp_(key_comp) {}

    template <typename T, typename U>
    bool operator()(const T& lhs, const U& rhs) const {
      return key_comp_(extract_if_value_type(lhs), extract_if_value_type(rhs));
    }

   private:
    const key_type& extract_if_value_type(const value_type& v) const {
      GetKeyFromValue extractor;
      return extractor(v);
    }

    template <typename K>
    const K& extract_if_value_type(const K& k) const {
      return k;
    }

    const key_compare& key_comp_;
  };

  const flat_tree& as_const() { return *this; }

  iterator const_cast_it(const_iterator c_it) {
    auto distance = std::distance(cbegin(), c_it);
    return std::next(begin(), distance);
  }






  template <class V>
  std::pair<iterator, bool> insert_or_assign(V&& val) {
    auto position = lower_bound(GetKeyFromValue()(val));

    if (position == end() || value_comp()(val, *position))
      return {impl_.body_.emplace(position, std::forward<V>(val)), true};

    *position = std::forward<V>(val);
    return {position, false};
  }






  template <class V>
  std::pair<iterator, bool> append_or_assign(iterator first,
                                             iterator last,
                                             V&& val) {
    auto position = std::lower_bound(first, last, val, value_comp());

    if (position == last || value_comp()(val, *position)) {


      const difference_type distance = std::distance(begin(), position);
      impl_.body_.emplace_back(std::forward<V>(val));
      return {std::next(begin(), distance), true};
    }

    *position = std::forward<V>(val);
    return {position, false};
  }






  template <class V>
  std::pair<iterator, bool> append_unique(iterator first,
                                          iterator last,
                                          V&& val) {
    auto position = std::lower_bound(first, last, val, value_comp());

    if (position == last || value_comp()(val, *position)) {


      const difference_type distance = std::distance(begin(), position);
      impl_.body_.emplace_back(std::forward<V>(val));
      return {std::next(begin(), distance), true};
    }

    return {position, false};
  }

  void sort_and_unique(iterator first,
                       iterator last,
                       FlatContainerDupes dupes) {

    std::stable_sort(first, last, impl_.get_value_comp());

    auto comparator = [this](const value_type& lhs, const value_type& rhs) {


      return !impl_.get_value_comp()(lhs, rhs);
    };

    iterator erase_after;
    switch (dupes) {
      case KEEP_FIRST_OF_DUPES:
        erase_after = std::unique(first, last, comparator);
        break;
      case KEEP_LAST_OF_DUPES:
        erase_after = LastUnique(first, last, comparator);
        break;
    }
    erase(erase_after, last);
  }






  struct Impl : private value_compare {
    Impl() = default;

    template <class Cmp, class... Body>
    explicit Impl(Cmp&& compare_arg, Body&&... underlying_type_args)
        : value_compare(std::forward<Cmp>(compare_arg)),
          body_(std::forward<Body>(underlying_type_args)...) {}

    const value_compare& get_value_comp() const { return *this; }
    const key_compare& get_key_comp() const { return *this; }

    underlying_type body_;
  } impl_;


  template <typename K>
  using KeyTypeOrK = typename std::
      conditional<IsTransparentCompare<key_compare>::value, K, key_type>::type;
};




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::flat_tree() = default;

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::flat_tree(
    const KeyCompare& comp)
    : impl_(comp) {}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <class InputIterator>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::flat_tree(
    InputIterator first,
    InputIterator last,
    FlatContainerDupes dupe_handling,
    const KeyCompare& comp)
    : impl_(comp, first, last) {
  sort_and_unique(begin(), end(), dupe_handling);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::flat_tree(
    const flat_tree&) = default;

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::flat_tree(flat_tree&&) =
    default;

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::flat_tree(
    std::vector<value_type> items,
    FlatContainerDupes dupe_handling,
    const KeyCompare& comp)
    : impl_(comp, std::move(items)) {
  sort_and_unique(begin(), end(), dupe_handling);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::flat_tree(
    std::initializer_list<value_type> ilist,
    FlatContainerDupes dupe_handling,
    const KeyCompare& comp)
    : flat_tree(std::begin(ilist), std::end(ilist), dupe_handling, comp) {}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::~flat_tree() = default;




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::operator=(
    const flat_tree&) -> flat_tree& = default;

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::operator=(flat_tree &&)
    -> flat_tree& = default;

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::operator=(
    std::initializer_list<value_type> ilist) -> flat_tree& {
  impl_.body_ = ilist;
  sort_and_unique(begin(), end(), KEEP_FIRST_OF_DUPES);
  return *this;
}




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
void flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::reserve(
    size_type new_capacity) {
  impl_.body_.reserve(new_capacity);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::capacity() const
    -> size_type {
  return impl_.body_.capacity();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
void flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::shrink_to_fit() {
  impl_.body_.shrink_to_fit();
}




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
void flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::clear() {
  impl_.body_.clear();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::size() const
    -> size_type {
  return impl_.body_.size();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::max_size() const
    -> size_type {
  return impl_.body_.max_size();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
bool flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::empty() const {
  return impl_.body_.empty();
}




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::begin() -> iterator {
  return impl_.body_.begin();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::begin() const
    -> const_iterator {
  return impl_.body_.begin();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::cbegin() const
    -> const_iterator {
  return impl_.body_.cbegin();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::end() -> iterator {
  return impl_.body_.end();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::end() const
    -> const_iterator {
  return impl_.body_.end();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::cend() const
    -> const_iterator {
  return impl_.body_.cend();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::rbegin()
    -> reverse_iterator {
  return impl_.body_.rbegin();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::rbegin() const
    -> const_reverse_iterator {
  return impl_.body_.rbegin();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::crbegin() const
    -> const_reverse_iterator {
  return impl_.body_.crbegin();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::rend()
    -> reverse_iterator {
  return impl_.body_.rend();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::rend() const
    -> const_reverse_iterator {
  return impl_.body_.rend();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::crend() const
    -> const_reverse_iterator {
  return impl_.body_.crend();
}







template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::insert(
    const value_type& val) -> std::pair<iterator, bool> {
  return emplace_key_args(GetKeyFromValue()(val), val);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::insert(
    value_type&& val) -> std::pair<iterator, bool> {
  return emplace_key_args(GetKeyFromValue()(val), std::move(val));
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::insert(
    const_iterator position_hint,
    const value_type& val) -> iterator {
  return emplace_hint_key_args(position_hint, GetKeyFromValue()(val), val)
      .first;
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::insert(
    const_iterator position_hint,
    value_type&& val) -> iterator {
  return emplace_hint_key_args(position_hint, GetKeyFromValue()(val),
                               std::move(val))
      .first;
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <class InputIterator>
void flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::insert(
    InputIterator first,
    InputIterator last,
    FlatContainerDupes dupes) {
  if (first == last)
    return;



  const bool overwrite_existing = dupes == KEEP_LAST_OF_DUPES;
  const bool insert_inplace =
      is_multipass<InputIterator>() && std::next(first) == last;

  if (insert_inplace) {
    if (overwrite_existing) {
      for (; first != last; ++first)
        insert_or_assign(*first);
    } else
      std::copy(first, last, std::inserter(*this, end()));
    return;
  }



  const size_type original_size = size();
  auto middle = [this, original_size]() {
    return std::next(begin(), original_size);
  };


  difference_type pos_first_new = original_size;



  if (overwrite_existing) {
    for (; first != last; ++first) {
      std::pair<iterator, bool> result =
          append_or_assign(begin(), middle(), *first);
      if (result.second) {
        pos_first_new =
            std::min(pos_first_new, std::distance(begin(), result.first));
      }
    }
  } else {
    for (; first != last; ++first) {
      std::pair<iterator, bool> result =
          append_unique(begin(), middle(), *first);
      if (result.second) {
        pos_first_new =
            std::min(pos_first_new, std::distance(begin(), result.first));
      }
    }
  }




  sort_and_unique(middle(), end(), dupes);
  std::inplace_merge(std::next(begin(), pos_first_new), middle(), end(),
                     value_comp());
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <class... Args>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::emplace(Args&&... args)
    -> std::pair<iterator, bool> {
  return insert(value_type(std::forward<Args>(args)...));
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <class... Args>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::emplace_hint(
    const_iterator position_hint,
    Args&&... args) -> iterator {
  return insert(position_hint, value_type(std::forward<Args>(args)...));
}




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::erase(
    iterator position) -> iterator {
  return impl_.body_.erase(position);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::erase(
    const_iterator position) -> iterator {

  return erase(const_cast_it(position));
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::erase(const K& val)
    -> size_type {
  auto eq_range = equal_range(val);
  auto res = std::distance(eq_range.first, eq_range.second);

  erase(const_cast_it(eq_range.first), const_cast_it(eq_range.second));
  return res;
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::erase(
    const_iterator first,
    const_iterator last) -> iterator {

  return impl_.body_.erase(const_cast_it(first), const_cast_it(last));
}




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::key_comp() const
    -> key_compare {
  return impl_.get_key_comp();
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::value_comp() const
    -> value_compare {
  return impl_.get_value_comp();
}




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::count(
    const K& key) const -> size_type {
  auto eq_range = equal_range(key);
  return std::distance(eq_range.first, eq_range.second);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::find(const K& key)
    -> iterator {
  return const_cast_it(as_const().find(key));
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::find(
    const K& key) const -> const_iterator {
  auto eq_range = equal_range(key);
  return (eq_range.first == eq_range.second) ? end() : eq_range.first;
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::equal_range(
    const K& key) -> std::pair<iterator, iterator> {
  auto res = as_const().equal_range(key);
  return {const_cast_it(res.first), const_cast_it(res.second)};
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::equal_range(
    const K& key) const -> std::pair<const_iterator, const_iterator> {
  auto lower = lower_bound(key);

  GetKeyFromValue extractor;
  if (lower == end() || impl_.get_key_comp()(key, extractor(*lower)))
    return {lower, lower};

  return {lower, std::next(lower)};
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::lower_bound(
    const K& key) -> iterator {
  return const_cast_it(as_const().lower_bound(key));
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::lower_bound(
    const K& key) const -> const_iterator {
  static_assert(std::is_convertible<const KeyTypeOrK<K>&, const K&>::value,
                "Requested type cannot be bound to the container's key_type "
                "which is required for a non-transparent compare.");

  const KeyTypeOrK<K>& key_ref = key;

  KeyValueCompare key_value(impl_.get_key_comp());
  return std::lower_bound(begin(), end(), key_ref, key_value);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::upper_bound(
    const K& key) -> iterator {
  return const_cast_it(as_const().upper_bound(key));
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <typename K>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::upper_bound(
    const K& key) const -> const_iterator {
  static_assert(std::is_convertible<const KeyTypeOrK<K>&, const K&>::value,
                "Requested type cannot be bound to the container's key_type "
                "which is required for a non-transparent compare.");

  const KeyTypeOrK<K>& key_ref = key;

  KeyValueCompare key_value(impl_.get_key_comp());
  return std::upper_bound(begin(), end(), key_ref, key_value);
}




template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
void flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::swap(
    flat_tree& other) {
  std::swap(impl_, other.impl_);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <class... Args>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::unsafe_emplace(
    const_iterator position,
    Args&&... args) -> iterator {
  return impl_.body_.emplace(position, std::forward<Args>(args)...);
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <class K, class... Args>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::emplace_key_args(
    const K& key,
    Args&&... args) -> std::pair<iterator, bool> {
  auto lower = lower_bound(key);
  if (lower == end() || key_comp()(key, GetKeyFromValue()(*lower)))
    return {unsafe_emplace(lower, std::forward<Args>(args)...), true};
  return {lower, false};
}

template <class Key, class Value, class GetKeyFromValue, class KeyCompare>
template <class K, class... Args>
auto flat_tree<Key, Value, GetKeyFromValue, KeyCompare>::emplace_hint_key_args(
    const_iterator hint,
    const K& key,
    Args&&... args) -> std::pair<iterator, bool> {
  GetKeyFromValue extractor;
  if ((hint == begin() || key_comp()(extractor(*std::prev(hint)), key))) {
    if (hint == end() || key_comp()(key, extractor(*hint))) {

      return {unsafe_emplace(hint, std::forward<Args>(args)...), true};
    }
    if (!key_comp()(extractor(*hint), key)) {

      return {const_cast_it(hint), false};
    }
  }

  return emplace_key_args(key, std::forward<Args>(args)...);
}



template <class Key>
struct GetKeyFromValueIdentity {
  const Key& operator()(const Key& k) const { return k; }
};

}





template <class Key,
          class Value,
          class GetKeyFromValue,
          class KeyCompare,
          typename Predicate>
void EraseIf(base::internal::flat_tree<Key, Value, GetKeyFromValue, KeyCompare>&
                 container,
             Predicate pred) {
  container.erase(std::remove_if(container.begin(), container.end(), pred),
                  container.end());
}

}
# 13 "../../base/containers/flat_map.h" 2



namespace base {

namespace internal {



template <class Key, class Mapped>
struct GetKeyFromValuePairFirst {
  const Key& operator()(const std::pair<Key, Mapped>& p) const {
    return p.first;
  }
};

}
# 151 "../../base/containers/flat_map.h"
template <class Key, class Mapped, class Compare = std::less<>>
class flat_map : public ::base::internal::flat_tree<
                     Key,
                     std::pair<Key, Mapped>,
                     ::base::internal::GetKeyFromValuePairFirst<Key, Mapped>,
                     Compare> {
 private:
  using tree = typename ::base::internal::flat_tree<
      Key,
      std::pair<Key, Mapped>,
      ::base::internal::GetKeyFromValuePairFirst<Key, Mapped>,
      Compare>;

 public:
  using key_type = typename tree::key_type;
  using mapped_type = Mapped;
  using value_type = typename tree::value_type;
  using iterator = typename tree::iterator;
  using const_iterator = typename tree::const_iterator;
# 180 "../../base/containers/flat_map.h"
  using tree::tree;
  using tree::operator=;
# 191 "../../base/containers/flat_map.h"
  mapped_type& operator[](const key_type& key);
  mapped_type& operator[](key_type&& key);

  template <class K, class M>
  std::pair<iterator, bool> insert_or_assign(K&& key, M&& obj);
  template <class K, class M>
  iterator insert_or_assign(const_iterator hint, K&& key, M&& obj);

  template <class K, class... Args>
  std::enable_if_t<std::is_constructible<key_type, K&&>::value,
                   std::pair<iterator, bool>>
  try_emplace(K&& key, Args&&... args);

  template <class K, class... Args>
  std::enable_if_t<std::is_constructible<key_type, K&&>::value, iterator>
  try_emplace(const_iterator hint, K&& key, Args&&... args);






  void swap(flat_map& other);

  friend void swap(flat_map& lhs, flat_map& rhs) { lhs.swap(rhs); }
};




template <class Key, class Mapped, class Compare>
auto flat_map<Key, Mapped, Compare>::operator[](const key_type& key)
    -> mapped_type& {
  iterator found = tree::lower_bound(key);
  if (found == tree::end() || tree::key_comp()(key, found->first))
    found = tree::unsafe_emplace(found, key, mapped_type());
  return found->second;
}

template <class Key, class Mapped, class Compare>
auto flat_map<Key, Mapped, Compare>::operator[](key_type&& key)
    -> mapped_type& {
  iterator found = tree::lower_bound(key);
  if (found == tree::end() || tree::key_comp()(key, found->first))
    found = tree::unsafe_emplace(found, std::move(key), mapped_type());
  return found->second;
}

template <class Key, class Mapped, class Compare>
template <class K, class M>
auto flat_map<Key, Mapped, Compare>::insert_or_assign(K&& key, M&& obj)
    -> std::pair<iterator, bool> {
  auto result =
      tree::emplace_key_args(key, std::forward<K>(key), std::forward<M>(obj));
  if (!result.second)
    result.first->second = std::forward<M>(obj);
  return result;
}

template <class Key, class Mapped, class Compare>
template <class K, class M>
auto flat_map<Key, Mapped, Compare>::insert_or_assign(const_iterator hint,
                                                      K&& key,
                                                      M&& obj) -> iterator {
  auto result = tree::emplace_hint_key_args(hint, key, std::forward<K>(key),
                                            std::forward<M>(obj));
  if (!result.second)
    result.first->second = std::forward<M>(obj);
  return result.first;
}

template <class Key, class Mapped, class Compare>
template <class K, class... Args>
auto flat_map<Key, Mapped, Compare>::try_emplace(K&& key, Args&&... args)
    -> std::enable_if_t<std::is_constructible<key_type, K&&>::value,
                        std::pair<iterator, bool>> {
  return tree::emplace_key_args(
      key, std::piecewise_construct,
      std::forward_as_tuple(std::forward<K>(key)),
      std::forward_as_tuple(std::forward<Args>(args)...));
}

template <class Key, class Mapped, class Compare>
template <class K, class... Args>
auto flat_map<Key, Mapped, Compare>::try_emplace(const_iterator hint,
                                                 K&& key,
                                                 Args&&... args)
    -> std::enable_if_t<std::is_constructible<key_type, K&&>::value, iterator> {
  return tree::emplace_hint_key_args(
             hint, key, std::piecewise_construct,
             std::forward_as_tuple(std::forward<K>(key)),
             std::forward_as_tuple(std::forward<Args>(args)...))
      .first;
}




template <class Key, class Mapped, class Compare>
void flat_map<Key, Mapped, Compare>::swap(flat_map& other) {
  tree::swap(other);
}

}
# 36 "../../base/values.h" 2
# 1 "../../base/containers/span.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/containers/span.h" 2


# 1 "../../buildtools/third_party/libc++/trunk/include/array" 1 3
# 114 "../../buildtools/third_party/libc++/trunk/include/array" 3




namespace std {inline namespace __1 {

template <class _Tp, size_t _Size>
struct array
{

    typedef array __self;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    value_type __elems_[_Size > 0 ? _Size : 1];


    __attribute__ ((__always_inline__)) void fill(const value_type& __u)
        {std::__1::fill_n(__elems_, _Size, __u);}
    __attribute__ ((__always_inline__))
    void swap(array& __a) noexcept(_Size == 0 || __is_nothrow_swappable<_Tp>::value)
        { __swap_dispatch((std::integral_constant<bool, _Size == 0>()), __a); }

    __attribute__ ((__always_inline__))
    void __swap_dispatch(std::true_type, array&) {}

    __attribute__ ((__always_inline__))
    void __swap_dispatch(std::false_type, array& __a)
        { std::__1::swap_ranges(__elems_, __elems_ + _Size, __a.__elems_);}


    __attribute__ ((__always_inline__))
    iterator begin() noexcept {return iterator(__elems_);}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return const_iterator(__elems_);}
    __attribute__ ((__always_inline__))
    iterator end() noexcept {return iterator(__elems_ + _Size);}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return const_iterator(__elems_ + _Size);}

    __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}


    __attribute__ ((__always_inline__))
    constexpr size_type size() const noexcept {return _Size;}
    __attribute__ ((__always_inline__))
    constexpr size_type max_size() const noexcept {return _Size;}
    __attribute__ ((__always_inline__))
    constexpr bool empty() const noexcept {return _Size == 0;}


    __attribute__ ((__always_inline__))
    reference operator[](size_type __n) {return __elems_[__n];}
    __attribute__ ((__always_inline__)) constexpr
    const_reference operator[](size_type __n) const {return __elems_[__n];}

                                        reference at(size_type __n);
    constexpr const_reference at(size_type __n) const;

    __attribute__ ((__always_inline__)) reference front() {return __elems_[0];}
    __attribute__ ((__always_inline__)) constexpr const_reference front() const {return __elems_[0];}
    __attribute__ ((__always_inline__)) reference back() {return __elems_[_Size > 0 ? _Size-1 : 0];}
    __attribute__ ((__always_inline__)) constexpr const_reference back() const {return __elems_[_Size > 0 ? _Size-1 : 0];}

    __attribute__ ((__always_inline__))
    value_type* data() noexcept {return __elems_;}
    __attribute__ ((__always_inline__))
    const value_type* data() const noexcept {return __elems_;}
};

template <class _Tp, size_t _Size>

typename array<_Tp, _Size>::reference
array<_Tp, _Size>::at(size_type __n)
{
    if (__n >= _Size)
        __throw_out_of_range("array::at");

    return __elems_[__n];
}

template <class _Tp, size_t _Size>
constexpr
typename array<_Tp, _Size>::const_reference
array<_Tp, _Size>::at(size_type __n) const
{
    if (__n >= _Size)
        __throw_out_of_range("array::at");
    return __elems_[__n];
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__))
bool
operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return std::__1::equal(__x.__elems_, __x.__elems_ + _Size, __y.__elems_);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__))
bool
operator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__x == __y);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__))
bool
operator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return std::__1::lexicographical_compare(__x.__elems_, __x.__elems_ + _Size, __y.__elems_, __y.__elems_ + _Size);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__))
bool
operator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return __y < __x;
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__))
bool
operator<=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__y < __x);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__))
bool
operator>=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__x < __y);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__))
typename enable_if
<
    _Size == 0 ||
    __is_swappable<_Tp>::value,
    void
>::type
swap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)
                                  noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, size_t _Size>
class tuple_size<array<_Tp, _Size> >
    : public integral_constant<size_t, _Size> {};

template <size_t _Ip, class _Tp, size_t _Size>
class tuple_element<_Ip, array<_Tp, _Size> >
{
    static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
public:
    typedef _Tp type;
};

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__)) constexpr
_Tp&
get(array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
    return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__)) constexpr
const _Tp&
get(const array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
    return __a.__elems_[_Ip];
}



template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__)) constexpr
_Tp&&
get(array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
    return std::__1::move(__a.__elems_[_Ip]);
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__always_inline__)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
    return std::__1::move(__a.__elems_[_Ip]);
}



} }
# 12 "../../base/containers/span.h" 2




namespace base {

template <typename T>
class span;

namespace internal {

template <typename T>
struct IsSpanImpl : std::false_type {};

template <typename T>
struct IsSpanImpl<span<T>> : std::true_type {};

template <typename T>
using IsSpan = IsSpanImpl<std::decay_t<T>>;

template <typename T>
struct IsStdArrayImpl : std::false_type {};

template <typename T, size_t N>
struct IsStdArrayImpl<std::array<T, N>> : std::true_type {};

template <typename T>
using IsStdArray = IsStdArrayImpl<std::decay_t<T>>;

template <typename From, typename To>
using IsLegalSpanConversion = std::is_convertible<From*, To*>;

template <typename Container, typename T>
using ContainerHasConvertibleData = IsLegalSpanConversion<
    std::remove_pointer_t<decltype(std::declval<Container>().data())>,
    T>;
template <typename Container>
using ContainerHasIntegralSize =
    std::is_integral<decltype(std::declval<Container>().size())>;

template <typename From, typename To>
using EnableIfLegalSpanConversion =
    std::enable_if_t<IsLegalSpanConversion<From, To>::value>;
# 68 "../../base/containers/span.h"
template <typename Container, typename T>
using EnableIfSpanCompatibleContainer =
    std::enable_if_t<!internal::IsSpan<Container>::value &&
                     !internal::IsStdArray<Container>::value &&
                     ContainerHasConvertibleData<Container, T>::value &&
                     ContainerHasIntegralSize<Container>::value>;

template <typename Container, typename T>
using EnableIfConstSpanCompatibleContainer =
    std::enable_if_t<std::is_const<T>::value &&
                     !internal::IsSpan<Container>::value &&
                     !internal::IsStdArray<Container>::value &&
                     ContainerHasConvertibleData<Container, T>::value &&
                     ContainerHasIntegralSize<Container>::value>;

}
# 180 "../../base/containers/span.h"
template <typename T>
class span {
 public:
  using value_type = std::remove_cv_t<T>;
  using pointer = T*;
  using reference = T&;
  using iterator = T*;
  using const_iterator = const T*;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;


  constexpr span() noexcept : data_(nullptr), size_(0) {}
  constexpr span(std::nullptr_t) noexcept : span() {}
  constexpr span(T* data, size_t size) noexcept : data_(data), size_(size) {}

  template <size_t N>
  constexpr span(T (&array)[N]) noexcept : span(array, N) {}



  template <typename Container,
            typename = internal::EnableIfSpanCompatibleContainer<Container, T>>
  constexpr span(Container& container)
      : span(container.data(), container.size()) {}
  template <
      typename Container,
      typename = internal::EnableIfConstSpanCompatibleContainer<Container, T>>
  span(const Container& container) : span(container.data(), container.size()) {}
  ~span() noexcept = default;


  template <typename U, typename = internal::EnableIfLegalSpanConversion<U, T>>
  constexpr span(const span<U>& other) : span(other.data(), other.size()) {}
  template <typename U, typename = internal::EnableIfLegalSpanConversion<U, T>>
  constexpr span(span<U>&& other) : span(other.data(), other.size()) {}




  constexpr span first(size_t count) const { return span(data_, count); }

  constexpr span last(size_t count) const {
    return span(data_ + (size_ - count), count);
  }

  constexpr span subspan(size_t pos, size_t count = -1) const {
    return span(data_ + pos, std::min(size_ - pos, count));
  }


  constexpr size_t length() const noexcept { return size_; }
  constexpr size_t size() const noexcept { return size_; }
  constexpr bool empty() const noexcept { return size_ == 0; }


  constexpr T& operator[](size_t index) const noexcept { return data_[index]; }
  constexpr T* data() const noexcept { return data_; }


  iterator begin() const noexcept { return data_; }
  iterator end() const noexcept { return data_ + size_; }

  const_iterator cbegin() const noexcept { return begin(); }
  const_iterator cend() const noexcept { return end(); }

  reverse_iterator rbegin() const noexcept { return reverse_iterator(end()); }
  reverse_iterator rend() const noexcept { return reverse_iterator(begin()); }

  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(cend());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(cbegin());
  }

 private:
  T* data_;
  size_t size_;
};


template <typename T>
constexpr bool operator==(const span<T>& lhs, const span<T>& rhs) noexcept {
  return std::equal(lhs.cbegin(), lhs.cend(), rhs.cbegin(), rhs.cend());
}

template <typename T>
constexpr bool operator!=(const span<T>& lhs, const span<T>& rhs) noexcept {
  return !(lhs == rhs);
}

template <typename T>
constexpr bool operator<(const span<T>& lhs, const span<T>& rhs) noexcept {
  return std::lexicographical_compare(lhs.cbegin(), lhs.cend(), rhs.cbegin(),
                                      rhs.cend());
}

template <typename T>
constexpr bool operator<=(const span<T>& lhs, const span<T>& rhs) noexcept {
  return !(rhs < lhs);
}

template <typename T>
constexpr bool operator>(const span<T>& lhs, const span<T>& rhs) noexcept {
  return rhs < lhs;
}

template <typename T>
constexpr bool operator>=(const span<T>& lhs, const span<T>& rhs) noexcept {
  return !(lhs < rhs);
}


template <typename T>
constexpr span<T> make_span(T* data, size_t size) noexcept {
  return span<T>(data, size);
}

template <typename T, size_t N>
constexpr span<T> make_span(T (&array)[N]) noexcept {
  return span<T>(array);
}

template <typename Container,
          typename T = typename Container::value_type,
          typename = internal::EnableIfSpanCompatibleContainer<Container, T>>
constexpr span<T> make_span(Container& container) {
  return span<T>(container);
}

template <
    typename Container,
    typename T = std::add_const_t<typename Container::value_type>,
    typename = internal::EnableIfConstSpanCompatibleContainer<Container, T>>
constexpr span<T> make_span(const Container& container) {
  return span<T>(container);
}

}
# 37 "../../base/values.h" 2



# 1 "../../base/value_iterators.h" 1
# 16 "../../base/value_iterators.h"
namespace base {

class Value;

namespace detail {

using DictStorage = base::flat_map<std::string, std::unique_ptr<Value>>;






class dict_iterator {
 public:
  using difference_type = DictStorage::iterator::difference_type;
  using value_type = std::pair<const std::string, Value>;
  using reference = std::pair<const std::string&, Value&>;
  using iterator_category = std::bidirectional_iterator_tag;

  class pointer {
   public:
    explicit pointer(const reference& ref);
    pointer(const pointer& ptr);
    pointer& operator=(const pointer& ptr) = delete;

    reference* operator->() { return &ref_; }

   private:
    reference ref_;
  };

  explicit dict_iterator(DictStorage::iterator dict_iter);
  dict_iterator(const dict_iterator& dict_iter);
  dict_iterator& operator=(const dict_iterator& dict_iter);
  ~dict_iterator();

  reference operator*();
  pointer operator->();

  dict_iterator& operator++();
  dict_iterator operator++(int);
  dict_iterator& operator--();
  dict_iterator operator--(int);

              friend bool operator==(const dict_iterator& lhs,
                                     const dict_iterator& rhs);
              friend bool operator!=(const dict_iterator& lhs,
                                     const dict_iterator& rhs);

 private:
  DictStorage::iterator dict_iter_;
};






class const_dict_iterator {
 public:
  using difference_type = DictStorage::const_iterator::difference_type;
  using value_type = std::pair<const std::string, Value>;
  using reference = std::pair<const std::string&, const Value&>;
  using iterator_category = std::bidirectional_iterator_tag;

  class pointer {
   public:
    explicit pointer(const reference& ref);
    pointer(const pointer& ptr);
    pointer& operator=(const pointer& ptr) = delete;

    const reference* operator->() const { return &ref_; }

   private:
    const reference ref_;
  };

  explicit const_dict_iterator(DictStorage::const_iterator dict_iter);
  const_dict_iterator(const const_dict_iterator& dict_iter);
  const_dict_iterator& operator=(const const_dict_iterator& dict_iter);
  ~const_dict_iterator();

  reference operator*() const;
  pointer operator->() const;

  const_dict_iterator& operator++();
  const_dict_iterator operator++(int);
  const_dict_iterator& operator--();
  const_dict_iterator operator--(int);

              friend bool operator==(const const_dict_iterator& lhs,
                                     const const_dict_iterator& rhs);
              friend bool operator!=(const const_dict_iterator& lhs,
                                     const const_dict_iterator& rhs);

 private:
  DictStorage::const_iterator dict_iter_;
};






class dict_iterator_proxy {
 public:
  using key_type = DictStorage::key_type;
  using mapped_type = DictStorage::mapped_type::element_type;
  using value_type = std::pair<key_type, mapped_type>;
  using key_compare = DictStorage::key_compare;
  using size_type = DictStorage::size_type;
  using difference_type = DictStorage::difference_type;

  using iterator = dict_iterator;
  using const_iterator = const_dict_iterator;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  explicit dict_iterator_proxy(DictStorage* storage);

  iterator begin();
  const_iterator begin() const;
  iterator end();
  const_iterator end() const;

  reverse_iterator rbegin();
  const_reverse_iterator rbegin() const;
  reverse_iterator rend();
  const_reverse_iterator rend() const;

  const_dict_iterator cbegin() const;
  const_dict_iterator cend() const;
  const_reverse_iterator crbegin() const;
  const_reverse_iterator crend() const;

 private:
  DictStorage* storage_;
};





class const_dict_iterator_proxy {
 public:
  using key_type = const DictStorage::key_type;
  using mapped_type = const DictStorage::mapped_type::element_type;
  using value_type = std::pair<key_type, mapped_type>;
  using key_compare = DictStorage::key_compare;
  using size_type = DictStorage::size_type;
  using difference_type = DictStorage::difference_type;

  using iterator = const_dict_iterator;
  using const_iterator = const_dict_iterator;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  explicit const_dict_iterator_proxy(const DictStorage* storage);

  const_iterator begin() const;
  const_iterator end() const;

  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;

  const_iterator cbegin() const;
  const_iterator cend() const;
  const_reverse_iterator crbegin() const;
  const_reverse_iterator crend() const;

 private:
  const DictStorage* storage_;
};
}

}
# 41 "../../base/values.h" 2

namespace base {

class DictionaryValue;
class ListValue;
class Value;
# 81 "../../base/values.h"
class Value {
 public:
  using BlobStorage = std::vector<char>;
  using DictStorage = flat_map<std::string, std::unique_ptr<Value>>;
  using ListStorage = std::vector<Value>;

  enum class Type {
    NONE = 0,
    BOOLEAN,
    INTEGER,
    DOUBLE,
    STRING,
    BINARY,
    DICTIONARY,
    LIST

  };






  static std::unique_ptr<Value> CreateWithCopiedBuffer(const char* buffer,
                                                       size_t size);


  static Value FromUniquePtrValue(std::unique_ptr<Value> val);
  static std::unique_ptr<Value> ToUniquePtrValue(Value val);

  Value(Value&& that) noexcept;
  Value() noexcept;



  Value Clone() const;

  explicit Value(Type type);
  explicit Value(bool in_bool);
  explicit Value(int in_int);
  explicit Value(double in_double);





  explicit Value(const char* in_string);
  explicit Value(StringPiece in_string);
  explicit Value(std::string&& in_string) noexcept;
  explicit Value(const char16* in_string16);
  explicit Value(StringPiece16 in_string16);

  explicit Value(const BlobStorage& in_blob);
  explicit Value(BlobStorage&& in_blob) noexcept;

  explicit Value(const DictStorage& in_dict);
  explicit Value(DictStorage&& in_dict) noexcept;

  explicit Value(const ListStorage& in_list);
  explicit Value(ListStorage&& in_list) noexcept;

  Value& operator=(Value&& that) noexcept;

  ~Value();


  static const char* GetTypeName(Type type);


  Type type() const { return type_; }


  bool IsType(Type type) const { return type == type_; }
  bool is_none() const { return type() == Type::NONE; }
  bool is_bool() const { return type() == Type::BOOLEAN; }
  bool is_int() const { return type() == Type::INTEGER; }
  bool is_double() const { return type() == Type::DOUBLE; }
  bool is_string() const { return type() == Type::STRING; }
  bool is_blob() const { return type() == Type::BINARY; }
  bool is_dict() const { return type() == Type::DICTIONARY; }
  bool is_list() const { return type() == Type::LIST; }


  bool GetBool() const;
  int GetInt() const;
  double GetDouble() const;
  const std::string& GetString() const;
  const BlobStorage& GetBlob() const;

  ListStorage& GetList();
  const ListStorage& GetList() const;
# 181 "../../base/values.h"
  Value* FindKey(StringPiece key);
  const Value* FindKey(StringPiece key) const;
# 193 "../../base/values.h"
  Value* FindKeyOfType(StringPiece key, Type type);
  const Value* FindKeyOfType(StringPiece key, Type type) const;
# 203 "../../base/values.h"
  Value* SetKey(StringPiece key, Value value);

  Value* SetKey(std::string&& key, Value value);

  Value* SetKey(const char* key, Value value);
# 217 "../../base/values.h"
  bool RemoveKey(StringPiece key);
# 237 "../../base/values.h"
  Value* FindPath(std::initializer_list<StringPiece> path);
  Value* FindPath(span<const StringPiece> path);
  const Value* FindPath(std::initializer_list<StringPiece> path) const;
  const Value* FindPath(span<const StringPiece> path) const;






  Value* FindPathOfType(std::initializer_list<StringPiece> path, Type type);
  Value* FindPathOfType(span<const StringPiece> path, Type type);
  const Value* FindPathOfType(std::initializer_list<StringPiece> path,
                              Type type) const;
  const Value* FindPathOfType(span<const StringPiece> path, Type type) const;
# 269 "../../base/values.h"
  Value* SetPath(std::initializer_list<StringPiece> path, Value value);
  Value* SetPath(span<const StringPiece> path, Value value);
# 286 "../../base/values.h"
  bool RemovePath(std::initializer_list<StringPiece> path);
  bool RemovePath(span<const StringPiece> path);

  using dict_iterator_proxy = detail::dict_iterator_proxy;
  using const_dict_iterator_proxy = detail::const_dict_iterator_proxy;






  dict_iterator_proxy DictItems();
  const_dict_iterator_proxy DictItems() const;






  bool GetAsBoolean(bool* out_value) const;

  bool GetAsInteger(int* out_value) const;

  bool GetAsDouble(double* out_value) const;

  bool GetAsString(std::string* out_value) const;
  bool GetAsString(string16* out_value) const;
  bool GetAsString(const Value** out_value) const;
  bool GetAsString(StringPiece* out_value) const;


  bool GetAsList(ListValue** out_value);
  bool GetAsList(const ListValue** out_value) const;

  bool GetAsDictionary(DictionaryValue** out_value);
  bool GetAsDictionary(const DictionaryValue** out_value) const;
# 330 "../../base/values.h"
  Value* DeepCopy() const;


  std::unique_ptr<Value> CreateDeepCopy() const;



              friend bool operator==(const Value& lhs, const Value& rhs);
              friend bool operator!=(const Value& lhs, const Value& rhs);
              friend bool operator<(const Value& lhs, const Value& rhs);
              friend bool operator>(const Value& lhs, const Value& rhs);
              friend bool operator<=(const Value& lhs, const Value& rhs);
              friend bool operator>=(const Value& lhs, const Value& rhs);




  bool Equals(const Value* other) const;



  size_t EstimateMemoryUsage() const;

 protected:


  Type type_;

  union {
    bool bool_value_;
    int int_value_;
    double double_value_;
    std::string string_value_;
    BlobStorage binary_value_;
    DictStorage dict_;
    ListStorage list_;
  };

 private:
  void InternalMoveConstructFrom(Value&& that);
  void InternalCleanup();

  Value(const Value&) = delete; Value& operator=(const Value&) = delete;
};




class DictionaryValue : public Value {
 public:
  using const_iterator = DictStorage::const_iterator;
  using iterator = DictStorage::iterator;


  static std::unique_ptr<DictionaryValue> From(std::unique_ptr<Value> value);

  DictionaryValue();
  explicit DictionaryValue(const DictStorage& in_dict);
  explicit DictionaryValue(DictStorage&& in_dict) noexcept;



  bool HasKey(StringPiece key) const;


  size_t size() const { return dict_.size(); }


  bool empty() const { return dict_.empty(); }


  void Clear();
# 412 "../../base/values.h"
  Value* Set(StringPiece path, std::unique_ptr<Value> in_value);




  Value* SetBoolean(StringPiece path, bool in_value);

  Value* SetInteger(StringPiece path, int in_value);

  Value* SetDouble(StringPiece path, double in_value);

  Value* SetString(StringPiece path, StringPiece in_value);

  Value* SetString(StringPiece path, const string16& in_value);

  DictionaryValue* SetDictionary(StringPiece path,
                                 std::unique_ptr<DictionaryValue> in_value);

  ListValue* SetList(StringPiece path, std::unique_ptr<ListValue> in_value);




  Value* SetWithoutPathExpansion(StringPiece key,
                                 std::unique_ptr<Value> in_value);
# 447 "../../base/values.h"
  bool Get(StringPiece path, const Value** out_value) const;

  bool Get(StringPiece path, Value** out_value);






  bool GetBoolean(StringPiece path, bool* out_value) const;

  bool GetInteger(StringPiece path, int* out_value) const;



  bool GetDouble(StringPiece path, double* out_value) const;

  bool GetString(StringPiece path, std::string* out_value) const;

  bool GetString(StringPiece path, string16* out_value) const;

  bool GetStringASCII(StringPiece path, std::string* out_value) const;

  bool GetBinary(StringPiece path, const Value** out_value) const;

  bool GetBinary(StringPiece path, Value** out_value);

  bool GetDictionary(StringPiece path,
                     const DictionaryValue** out_value) const;

  bool GetDictionary(StringPiece path, DictionaryValue** out_value);

  bool GetList(StringPiece path, const ListValue** out_value) const;

  bool GetList(StringPiece path, ListValue** out_value);




  bool GetWithoutPathExpansion(StringPiece key, const Value** out_value) const;

  bool GetWithoutPathExpansion(StringPiece key, Value** out_value);

  bool GetBooleanWithoutPathExpansion(StringPiece key, bool* out_value) const;

  bool GetIntegerWithoutPathExpansion(StringPiece key, int* out_value) const;

  bool GetDoubleWithoutPathExpansion(StringPiece key, double* out_value) const;

  bool GetStringWithoutPathExpansion(StringPiece key,
                                     std::string* out_value) const;

  bool GetStringWithoutPathExpansion(StringPiece key,
                                     string16* out_value) const;

  bool GetDictionaryWithoutPathExpansion(
      StringPiece key,
      const DictionaryValue** out_value) const;

  bool GetDictionaryWithoutPathExpansion(StringPiece key,
                                         DictionaryValue** out_value);

  bool GetListWithoutPathExpansion(StringPiece key,
                                   const ListValue** out_value) const;

  bool GetListWithoutPathExpansion(StringPiece key, ListValue** out_value);
# 521 "../../base/values.h"
  bool Remove(StringPiece path, std::unique_ptr<Value>* out_value);




  bool RemoveWithoutPathExpansion(StringPiece key,
                                  std::unique_ptr<Value>* out_value);




  bool RemovePath(StringPiece path, std::unique_ptr<Value>* out_value);

  using Value::RemovePath;



  std::unique_ptr<DictionaryValue> DeepCopyWithoutEmptyChildren() const;






  void MergeDictionary(const DictionaryValue* dictionary);


  void Swap(DictionaryValue* other);




  class Iterator {
   public:
    explicit Iterator(const DictionaryValue& target);
    Iterator(const Iterator& other);
    ~Iterator();

    bool IsAtEnd() const { return it_ == target_.dict_.end(); }
    void Advance() { ++it_; }

    const std::string& key() const { return it_->first; }
    const Value& value() const { return *it_->second; }

   private:
    const DictionaryValue& target_;
    DictStorage::const_iterator it_;
  };



  iterator begin() { return dict_.begin(); }
  iterator end() { return dict_.end(); }


  const_iterator begin() const { return dict_.begin(); }
  const_iterator end() const { return dict_.end(); }



  DictionaryValue* DeepCopy() const;


  std::unique_ptr<DictionaryValue> CreateDeepCopy() const;
};


class ListValue : public Value {
 public:
  using const_iterator = ListStorage::const_iterator;
  using iterator = ListStorage::iterator;


  static std::unique_ptr<ListValue> From(std::unique_ptr<Value> value);

  ListValue();
  explicit ListValue(const ListStorage& in_list);
  explicit ListValue(ListStorage&& in_list) noexcept;



  void Clear();



  size_t GetSize() const { return list_.size(); }



  bool empty() const { return list_.empty(); }



  void Reserve(size_t n);







  bool Set(size_t index, std::unique_ptr<Value> in_value);






  bool Get(size_t index, const Value** out_value) const;
  bool Get(size_t index, Value** out_value);






  bool GetBoolean(size_t index, bool* out_value) const;

  bool GetInteger(size_t index, int* out_value) const;



  bool GetDouble(size_t index, double* out_value) const;

  bool GetString(size_t index, std::string* out_value) const;
  bool GetString(size_t index, string16* out_value) const;

  bool GetDictionary(size_t index, const DictionaryValue** out_value) const;
  bool GetDictionary(size_t index, DictionaryValue** out_value);

  using Value::GetList;

  bool GetList(size_t index, const ListValue** out_value) const;
  bool GetList(size_t index, ListValue** out_value);







  bool Remove(size_t index, std::unique_ptr<Value>* out_value);





  bool Remove(const Value& value, size_t* index);






  iterator Erase(iterator iter, std::unique_ptr<Value>* out_value);



  void Append(std::unique_ptr<Value> in_value);



  void AppendBoolean(bool in_value);
  void AppendInteger(int in_value);
  void AppendDouble(double in_value);
  void AppendString(StringPiece in_value);
  void AppendString(const string16& in_value);

  void AppendStrings(const std::vector<std::string>& in_values);
  void AppendStrings(const std::vector<string16>& in_values);




  bool AppendIfNotPresent(std::unique_ptr<Value> in_value);




  bool Insert(size_t index, std::unique_ptr<Value> in_value);





  const_iterator Find(const Value& value) const;



  void Swap(ListValue* other);



  iterator begin() { return list_.begin(); }

  iterator end() { return list_.end(); }


  const_iterator begin() const { return list_.begin(); }

  const_iterator end() const { return list_.end(); }



  ListValue* DeepCopy() const;


  std::unique_ptr<ListValue> CreateDeepCopy() const;
};



class ValueSerializer {
 public:
  virtual ~ValueSerializer();

  virtual bool Serialize(const Value& root) = 0;
};



class ValueDeserializer {
 public:
  virtual ~ValueDeserializer();







  virtual std::unique_ptr<Value> Deserialize(int* error_code,
                                             std::string* error_str) = 0;
};





            std::ostream& operator<<(std::ostream& out, const Value& value);

            inline std::ostream& operator<<(std::ostream& out,
                                            const DictionaryValue& value) {
  return out << static_cast<const Value&>(value);
}

            inline std::ostream& operator<<(std::ostream& out,
                                            const ListValue& value) {
  return out << static_cast<const Value&>(value);
}


            std::ostream& operator<<(std::ostream& out,
                                     const Value::Type& type);

}
# 23 "../../base/process/process_metrics.h" 2
# 38 "../../base/process/process_metrics.h"
namespace base {





struct IoCounters {
  uint64_t ReadOperationCount;
  uint64_t WriteOperationCount;
  uint64_t OtherOperationCount;
  uint64_t ReadTransferCount;
  uint64_t WriteTransferCount;
  uint64_t OtherTransferCount;
};
# 83 "../../base/process/process_metrics.h"
struct WorkingSetKBytes {
  WorkingSetKBytes() : priv(0), shareable(0), shared(0) {}
  size_t priv;
  size_t shareable;
  size_t shared;



};







struct CommittedKBytes {
  CommittedKBytes() : priv(0), mapped(0), image(0) {}
  size_t priv;
  size_t mapped;
  size_t image;
};







struct PageFaultCounts {
  int64_t minor;
  int64_t major;
};



            int64_t TimeValToMicroseconds(const struct timeval& tv);






class ProcessMetrics {
 public:
  ~ProcessMetrics();



  static std::unique_ptr<ProcessMetrics> CreateProcessMetrics(
      ProcessHandle process);
# 146 "../../base/process/process_metrics.h"
  static std::unique_ptr<ProcessMetrics> CreateCurrentProcessMetrics();




  size_t GetPagefileUsage() const;

  size_t GetPeakPagefileUsage() const;


  size_t GetWorkingSetSize() const;

  size_t GetPeakWorkingSetSize() const;




  bool GetMemoryBytes(size_t* private_bytes, size_t* shared_bytes) const;


  void GetCommittedKBytes(CommittedKBytes* usage) const;



  bool GetWorkingSetKBytes(WorkingSetKBytes* ws_usage) const;


  bool GetProportionalSetSizeBytes(uint64_t* pss_bytes) const;
# 218 "../../base/process/process_metrics.h"
  double GetPlatformIndependentCPUUsage();



  int GetIdleWakeupsPerSecond();
# 246 "../../base/process/process_metrics.h"
  bool GetIOCounters(IoCounters* io_counters) const;




  int GetOpenFdCount() const;



  int GetOpenFdSoftLimit() const;




  uint64_t GetVmSwapBytes() const;



  bool GetPageFaultCounts(PageFaultCounts* counts) const;



  size_t GetMallocUsage();

 private:

  explicit ProcessMetrics(ProcessHandle process);





  bool GetWorkingSetKBytesStatm(WorkingSetKBytes* ws_usage) const;







  int CalculateIdleWakeupsPerSecond(uint64_t absolute_idle_wakeups);
# 298 "../../base/process/process_metrics.h"
  ProcessHandle process_;




  TimeTicks last_cpu_time_;
  int64_t last_system_time_;



  TimeTicks last_idle_wakeups_time_;
  uint64_t last_absolute_idle_wakeups_;
# 326 "../../base/process/process_metrics.h"
  int last_cpu_;



  ProcessMetrics(const ProcessMetrics&) = delete; ProcessMetrics& operator=(const ProcessMetrics&) = delete;
};



            size_t GetSystemCommitCharge();





            size_t GetPageSize();



            size_t GetMaxFds();




            void SetFdLimit(unsigned int max_descriptors);
# 365 "../../base/process/process_metrics.h"
struct SystemMemoryInfoKB {
  SystemMemoryInfoKB();
  SystemMemoryInfoKB(const SystemMemoryInfoKB& other);


  std::unique_ptr<DictionaryValue> ToValue() const;

  int total = 0;


  int free = 0;
# 393 "../../base/process/process_metrics.h"
  int available = 0;



  int swap_total = 0;
  int swap_free = 0;




  int buffers = 0;
  int cached = 0;
  int active_anon = 0;
  int inactive_anon = 0;
  int active_file = 0;
  int inactive_file = 0;
  int dirty = 0;
  int reclaimable = 0;
# 427 "../../base/process/process_metrics.h"
};







            bool GetSystemMemoryInfo(SystemMemoryInfoKB* meminfo);
# 444 "../../base/process/process_metrics.h"
            int ParseProcStatCPU(StringPiece input);





            int GetNumberOfThreads(ProcessHandle process);


            extern const char kProcSelfExe[];




            bool ParseProcMeminfo(StringPiece input,
                                  SystemMemoryInfoKB* meminfo);


struct VmStatInfo {

  std::unique_ptr<DictionaryValue> ToValue() const;

  unsigned long pswpin = 0;
  unsigned long pswpout = 0;
  unsigned long pgmajfault = 0;
};



            bool GetVmStatInfo(VmStatInfo* vmstat);




            bool ParseProcVmstat(StringPiece input, VmStatInfo* vmstat);


struct SystemDiskInfo {
  SystemDiskInfo();
  SystemDiskInfo(const SystemDiskInfo& other);


  std::unique_ptr<Value> ToValue() const;

  uint64_t reads = 0;
  uint64_t reads_merged = 0;
  uint64_t sectors_read = 0;
  uint64_t read_time = 0;
  uint64_t writes = 0;
  uint64_t writes_merged = 0;
  uint64_t sectors_written = 0;
  uint64_t write_time = 0;
  uint64_t io = 0;
  uint64_t io_time = 0;
  uint64_t weighted_io_time = 0;
};




            bool IsValidDiskName(StringPiece candidate);



            bool GetSystemDiskInfo(SystemDiskInfo* diskinfo);


            TimeDelta GetUserCpuTimeSinceBoot();
# 557 "../../base/process/process_metrics.h"
class SystemMetrics {
 public:
  SystemMetrics();

  static SystemMetrics Sample();


  std::unique_ptr<Value> ToValue() const;

 private:
  friend class SystemMetricsTest_SystemMetrics_Test; friend class SystemMetricsTest_DISABLED_SystemMetrics_Test; friend class SystemMetricsTest_FLAKY_SystemMetrics_Test;

  size_t committed_memory_;

  SystemMemoryInfoKB memory_info_;
  VmStatInfo vmstat_info_;
  SystemDiskInfo disk_info_;




};
# 616 "../../base/process/process_metrics.h"
}
# 14 "../../base/trace_event/trace_event_system_stats_monitor.h" 2
# 1 "../../base/timer/timer.h" 1
# 67 "../../base/timer/timer.h"
# 1 "../../base/bind.h" 1
# 10 "../../base/bind.h"
# 1 "../../base/bind_internal.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/bind_internal.h" 2




# 1 "../../base/bind_helpers.h" 1
# 163 "../../base/bind_helpers.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 164 "../../base/bind_helpers.h" 2




# 1 "../../base/callback.h" 1








# 1 "../../base/callback_internal.h" 1
# 16 "../../base/callback_internal.h"
namespace base {

struct FakeBindState;

namespace internal {

class CallbackBase;
class CallbackBaseCopyable;

class BindStateBase;

template <typename Functor, typename... BoundArgs>
struct BindState;

struct BindStateBaseRefCountTraits {
  static void Destruct(const BindStateBase*);
};

template <typename T, bool IsScalar = std::is_scalar<T>::value>
struct PassingTraits;

template <typename T>
struct PassingTraits<T, false> {
  using Type = T&&;
};

template <typename T>
struct PassingTraits<T, true> {
  using Type = T;
};

template <typename T>
using PassingTraitsType = typename PassingTraits<T>::Type;
# 61 "../../base/callback_internal.h"
class BindStateBase
    : public RefCountedThreadSafe<BindStateBase, BindStateBaseRefCountTraits> {
 public:
  static constexpr ::base::subtle::StartRefCountFromOneTag kRefCountPreference = ::base::subtle::kStartRefCountFromOneTag;

  using InvokeFuncStorage = void(*)();

 private:
  BindStateBase(InvokeFuncStorage polymorphic_invoke,
                void (*destructor)(const BindStateBase*));
  BindStateBase(InvokeFuncStorage polymorphic_invoke,
                void (*destructor)(const BindStateBase*),
                bool (*is_cancelled)(const BindStateBase*));

  ~BindStateBase() = default;

  friend struct BindStateBaseRefCountTraits;
  friend class RefCountedThreadSafe<BindStateBase, BindStateBaseRefCountTraits>;

  friend class CallbackBase;
  friend class CallbackBaseCopyable;


  template <typename Functor, typename... BoundArgs>
  friend struct BindState;
  friend struct ::base::FakeBindState;

  bool IsCancelled() const {
    return is_cancelled_(this);
  }





  InvokeFuncStorage polymorphic_invoke_;


  void (*destructor_)(const BindStateBase*);
  bool (*is_cancelled_)(const BindStateBase*);

  BindStateBase(const BindStateBase&) = delete; BindStateBase& operator=(const BindStateBase&) = delete;
};





class CallbackBase {
 public:
  CallbackBase(CallbackBase&& c);
  CallbackBase& operator=(CallbackBase&& c);

  explicit CallbackBase(const CallbackBaseCopyable& c);
  CallbackBase& operator=(const CallbackBaseCopyable& c);

  explicit CallbackBase(CallbackBaseCopyable&& c);
  CallbackBase& operator=(CallbackBaseCopyable&& c);


  bool is_null() const { return !bind_state_; }
  explicit operator bool() const { return !is_null(); }



  bool IsCancelled() const;


  void Reset();

 protected:
  using InvokeFuncStorage = BindStateBase::InvokeFuncStorage;


  bool EqualsInternal(const CallbackBase& other) const;



  explicit CallbackBase(BindStateBase* bind_state);

  InvokeFuncStorage polymorphic_invoke() const {
    return bind_state_->polymorphic_invoke_;
  }




  ~CallbackBase();

  scoped_refptr<BindStateBase> bind_state_;
};


class CallbackBaseCopyable : public CallbackBase {
 public:
  CallbackBaseCopyable(const CallbackBaseCopyable& c);
  CallbackBaseCopyable(CallbackBaseCopyable&& c);
  CallbackBaseCopyable& operator=(const CallbackBaseCopyable& c);
  CallbackBaseCopyable& operator=(CallbackBaseCopyable&& c);

 protected:
  explicit CallbackBaseCopyable(BindStateBase* bind_state)
      : CallbackBase(bind_state) {}
  ~CallbackBaseCopyable() {}
};

}
}
# 10 "../../base/callback.h" 2
# 20 "../../base/callback.h"
namespace base {

template <typename R, typename... Args>
class OnceCallback<R(Args...)> : public internal::CallbackBase {
 public:
  using RunType = R(Args...);
  using PolymorphicInvoke = R (*)(internal::BindStateBase*,
                                  internal::PassingTraitsType<Args>...);

  OnceCallback() : internal::CallbackBase(nullptr) {}

  explicit OnceCallback(internal::BindStateBase* bind_state)
      : internal::CallbackBase(bind_state) {}

  OnceCallback(const OnceCallback&) = delete;
  OnceCallback& operator=(const OnceCallback&) = delete;

  OnceCallback(OnceCallback&&) = default;
  OnceCallback& operator=(OnceCallback&&) = default;

  OnceCallback(RepeatingCallback<RunType> other)
      : internal::CallbackBase(std::move(other)) {}

  OnceCallback& operator=(RepeatingCallback<RunType> other) {
    static_cast<internal::CallbackBase&>(*this) = std::move(other);
    return *this;
  }

  bool Equals(const OnceCallback& other) const { return EqualsInternal(other); }

  R Run(Args... args) const & {
    static_assert(!sizeof(*this),
                  "OnceCallback::Run() may only be invoked on a non-const "
                  "rvalue, i.e. std::move(callback).Run().");
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(false);
  }

  R Run(Args... args) && {




    OnceCallback cb = std::move(*this);
    PolymorphicInvoke f =
        reinterpret_cast<PolymorphicInvoke>(cb.polymorphic_invoke());
    return f(cb.bind_state_.get(), std::forward<Args>(args)...);
  }
};

template <typename R, typename... Args>
class RepeatingCallback<R(Args...)> : public internal::CallbackBaseCopyable {
 public:
  using RunType = R(Args...);
  using PolymorphicInvoke = R (*)(internal::BindStateBase*,
                                  internal::PassingTraitsType<Args>...);

  RepeatingCallback() : internal::CallbackBaseCopyable(nullptr) {}

  explicit RepeatingCallback(internal::BindStateBase* bind_state)
      : internal::CallbackBaseCopyable(bind_state) {}


  RepeatingCallback(const RepeatingCallback&) = default;
  RepeatingCallback& operator=(const RepeatingCallback&) = default;
  RepeatingCallback(RepeatingCallback&&) = default;
  RepeatingCallback& operator=(RepeatingCallback&&) = default;

  bool Equals(const RepeatingCallback& other) const {
    return EqualsInternal(other);
  }

  R Run(Args... args) const & {
    PolymorphicInvoke f =
        reinterpret_cast<PolymorphicInvoke>(this->polymorphic_invoke());
    return f(this->bind_state_.get(), std::forward<Args>(args)...);
  }

  R Run(Args... args) && {




    RepeatingCallback cb = std::move(*this);
    PolymorphicInvoke f =
        reinterpret_cast<PolymorphicInvoke>(cb.polymorphic_invoke());
    return f(cb.bind_state_.get(), std::forward<Args>(args)...);
  }
};

}
# 169 "../../base/bind_helpers.h" 2



namespace base {

template <typename T>
struct IsWeakReceiver;

template <typename>
struct BindUnwrapTraits;

namespace internal {

template <typename Functor, typename SFINAE = void>
struct FunctorTraits;

template <typename T>
class UnretainedWrapper {
 public:
  explicit UnretainedWrapper(T* o) : ptr_(o) {}
  T* get() const { return ptr_; }
 private:
  T* ptr_;
};

template <typename T>
class ConstRefWrapper {
 public:
  explicit ConstRefWrapper(const T& o) : ptr_(&o) {}
  const T& get() const { return *ptr_; }
 private:
  const T* ptr_;
};

template <typename T>
class RetainedRefWrapper {
 public:
  explicit RetainedRefWrapper(T* o) : ptr_(o) {}
  explicit RetainedRefWrapper(scoped_refptr<T> o) : ptr_(std::move(o)) {}
  T* get() const { return ptr_.get(); }
 private:
  scoped_refptr<T> ptr_;
};

template <typename T>
struct IgnoreResultHelper {
  explicit IgnoreResultHelper(T functor) : functor_(std::move(functor)) {}
  explicit operator bool() const { return !!functor_; }

  T functor_;
};
# 228 "../../base/bind_helpers.h"
template <typename T>
class OwnedWrapper {
 public:
  explicit OwnedWrapper(T* o) : ptr_(o) {}
  ~OwnedWrapper() { delete ptr_; }
  T* get() const { return ptr_; }
  OwnedWrapper(OwnedWrapper&& other) {
    ptr_ = other.ptr_;
    other.ptr_ = __null;
  }

 private:
  mutable T* ptr_;
};
# 266 "../../base/bind_helpers.h"
template <typename T>
class PassedWrapper {
 public:
  explicit PassedWrapper(T&& scoper)
      : is_valid_(true), scoper_(std::move(scoper)) {}
  PassedWrapper(PassedWrapper&& other)
      : is_valid_(other.is_valid_), scoper_(std::move(other.scoper_)) {}
  T Take() const {
    !(!(is_valid_)) ? (void) 0 : ::logging::LogMessageVoidify() & (::logging::LogMessage("../../base/bind_helpers.h", 274, "is_valid_").stream());
    is_valid_ = false;
    return std::move(scoper_);
  }

 private:
  mutable bool is_valid_;
  mutable T scoper_;
};

template <typename T>
using Unwrapper = BindUnwrapTraits<std::decay_t<T>>;

template <typename T>
auto Unwrap(T&& o) -> decltype(Unwrapper<T>::Unwrap(std::forward<T>(o))) {
  return Unwrapper<T>::Unwrap(std::forward<T>(o));
}
# 299 "../../base/bind_helpers.h"
template <bool is_method, typename... Args>
struct IsWeakMethod : std::false_type {};

template <typename T, typename... Args>
struct IsWeakMethod<true, T, Args...> : IsWeakReceiver<T> {};


template <typename... Types>
struct TypeList {};


template <size_t n, typename List>
struct DropTypeListItemImpl;


template <size_t n, typename T, typename... List>
struct DropTypeListItemImpl<n, TypeList<T, List...>>
    : DropTypeListItemImpl<n - 1, TypeList<List...>> {};

template <typename T, typename... List>
struct DropTypeListItemImpl<0, TypeList<T, List...>> {
  using Type = TypeList<T, List...>;
};

template <>
struct DropTypeListItemImpl<0, TypeList<>> {
  using Type = TypeList<>;
};


template <size_t n, typename List>
using DropTypeListItem = typename DropTypeListItemImpl<n, List>::Type;


template <size_t n, typename List, typename... Accum>
struct TakeTypeListItemImpl;


template <size_t n, typename T, typename... List, typename... Accum>
struct TakeTypeListItemImpl<n, TypeList<T, List...>, Accum...>
    : TakeTypeListItemImpl<n - 1, TypeList<List...>, Accum..., T> {};

template <typename T, typename... List, typename... Accum>
struct TakeTypeListItemImpl<0, TypeList<T, List...>, Accum...> {
  using Type = TypeList<Accum...>;
};

template <typename... Accum>
struct TakeTypeListItemImpl<0, TypeList<>, Accum...> {
  using Type = TypeList<Accum...>;
};




template <size_t n, typename List>
using TakeTypeListItem = typename TakeTypeListItemImpl<n, List>::Type;


template <typename List1, typename List2>
struct ConcatTypeListsImpl;

template <typename... Types1, typename... Types2>
struct ConcatTypeListsImpl<TypeList<Types1...>, TypeList<Types2...>> {
  using Type = TypeList<Types1..., Types2...>;
};


template <typename List1, typename List2>
using ConcatTypeLists = typename ConcatTypeListsImpl<List1, List2>::Type;


template <typename R, typename ArgList>
struct MakeFunctionTypeImpl;

template <typename R, typename... Args>
struct MakeFunctionTypeImpl<R, TypeList<Args...>> {


  typedef R Type(Args...);
};



template <typename R, typename ArgList>
using MakeFunctionType = typename MakeFunctionTypeImpl<R, ArgList>::Type;


template <typename Signature>
struct ExtractArgsImpl;

template <typename R, typename... Args>
struct ExtractArgsImpl<R(Args...)> {
  using ReturnType = R;
  using ArgsList = TypeList<Args...>;
};



template <typename Signature>
using ExtractArgs = typename ExtractArgsImpl<Signature>::ArgsList;



template <typename Signature>
using ExtractReturnType = typename ExtractArgsImpl<Signature>::ReturnType;

}

template <typename T>
static inline internal::UnretainedWrapper<T> Unretained(T* o) {
  return internal::UnretainedWrapper<T>(o);
}

template <typename T>
static inline internal::RetainedRefWrapper<T> RetainedRef(T* o) {
  return internal::RetainedRefWrapper<T>(o);
}

template <typename T>
static inline internal::RetainedRefWrapper<T> RetainedRef(scoped_refptr<T> o) {
  return internal::RetainedRefWrapper<T>(std::move(o));
}

template <typename T>
static inline internal::ConstRefWrapper<T> ConstRef(const T& o) {
  return internal::ConstRefWrapper<T>(o);
}

template <typename T>
static inline internal::OwnedWrapper<T> Owned(T* o) {
  return internal::OwnedWrapper<T>(o);
}
# 440 "../../base/bind_helpers.h"
template <typename T,
          std::enable_if_t<!std::is_lvalue_reference<T>::value>* = nullptr>
static inline internal::PassedWrapper<T> Passed(T&& scoper) {
  return internal::PassedWrapper<T>(std::move(scoper));
}
template <typename T>
static inline internal::PassedWrapper<T> Passed(T* scoper) {
  return internal::PassedWrapper<T>(std::move(*scoper));
}

template <typename T>
static inline internal::IgnoreResultHelper<T> IgnoreResult(T data) {
  return internal::IgnoreResultHelper<T>(std::move(data));
}

            void DoNothing();

template<typename T>
void DeletePointer(T* obj) {
  delete obj;
}
# 473 "../../base/bind_helpers.h"
template <typename T>
struct IsWeakReceiver : std::false_type {};

template <typename T>
struct IsWeakReceiver<internal::ConstRefWrapper<T>> : IsWeakReceiver<T> {};

template <typename T>
struct IsWeakReceiver<WeakPtr<T>> : std::true_type {};




template <typename>
struct BindUnwrapTraits {
  template <typename T>
  static T&& Unwrap(T&& o) { return std::forward<T>(o); }
};

template <typename T>
struct BindUnwrapTraits<internal::UnretainedWrapper<T>> {
  static T* Unwrap(const internal::UnretainedWrapper<T>& o) {
    return o.get();
  }
};

template <typename T>
struct BindUnwrapTraits<internal::ConstRefWrapper<T>> {
  static const T& Unwrap(const internal::ConstRefWrapper<T>& o) {
    return o.get();
  }
};

template <typename T>
struct BindUnwrapTraits<internal::RetainedRefWrapper<T>> {
  static T* Unwrap(const internal::RetainedRefWrapper<T>& o) {
    return o.get();
  }
};

template <typename T>
struct BindUnwrapTraits<internal::OwnedWrapper<T>> {
  static T* Unwrap(const internal::OwnedWrapper<T>& o) {
    return o.get();
  }
};

template <typename T>
struct BindUnwrapTraits<internal::PassedWrapper<T>> {
  static T Unwrap(const internal::PassedWrapper<T>& o) {
    return o.Take();
  }
};





template <typename Functor, typename BoundArgsTuple, typename SFINAE = void>
struct CallbackCancellationTraits {
  static constexpr bool is_cancellable = false;
};


template <typename Functor, typename... BoundArgs>
struct CallbackCancellationTraits<
    Functor,
    std::tuple<BoundArgs...>,
    std::enable_if_t<
        internal::IsWeakMethod<internal::FunctorTraits<Functor>::is_method,
                               BoundArgs...>::value>> {
  static constexpr bool is_cancellable = true;

  template <typename Receiver, typename... Args>
  static bool IsCancelled(const Functor&,
                          const Receiver& receiver,
                          const Args&...) {
    return !receiver;
  }
};


template <typename Signature, typename... BoundArgs>
struct CallbackCancellationTraits<OnceCallback<Signature>,
                                  std::tuple<BoundArgs...>> {
  static constexpr bool is_cancellable = true;

  template <typename Functor>
  static bool IsCancelled(const Functor& functor, const BoundArgs&...) {
    return functor.IsCancelled();
  }
};

template <typename Signature, typename... BoundArgs>
struct CallbackCancellationTraits<RepeatingCallback<Signature>,
                                  std::tuple<BoundArgs...>> {
  static constexpr bool is_cancellable = true;

  template <typename Functor>
  static bool IsCancelled(const Functor& functor, const BoundArgs&...) {
    return functor.IsCancelled();
  }
};

}
# 14 "../../base/bind_internal.h" 2

# 1 "../../base/memory/raw_scoped_refptr_mismatch_checker.h" 1
# 20 "../../base/memory/raw_scoped_refptr_mismatch_checker.h"
namespace base {



namespace internal {

template <typename T>
struct NeedsScopedRefptrButGetsRawPtr {
  static_assert(!std::is_reference<T>::value,
                "NeedsScopedRefptrButGetsRawPtr requires non-reference type.");

  enum {



    value =
        (std::is_pointer<T>::value &&
         (std::is_convertible<T, const subtle::RefCountedBase*>::value ||
          std::is_convertible<T,
                              const subtle::RefCountedThreadSafeBase*>::value))
  };
};

template <typename Params>
struct ParamsUseScopedRefptrCorrectly {
  enum { value = 0 };
};

template <>
struct ParamsUseScopedRefptrCorrectly<std::tuple<>> {
  enum { value = 1 };
};

template <typename Head, typename... Tail>
struct ParamsUseScopedRefptrCorrectly<std::tuple<Head, Tail...>> {
  enum { value = !NeedsScopedRefptrButGetsRawPtr<Head>::value &&
                  ParamsUseScopedRefptrCorrectly<std::tuple<Tail...>>::value };
};

}

}
# 16 "../../base/bind_internal.h" 2




namespace base {
namespace internal {
# 48 "../../base/bind_internal.h"
template <typename Callable,
          typename Signature = decltype(&Callable::operator())>
struct ExtractCallableRunTypeImpl;

template <typename Callable, typename R, typename... Args>
struct ExtractCallableRunTypeImpl<Callable, R (Callable::*)(Args...)> {
  using Type = R(Args...);
};

template <typename Callable, typename R, typename... Args>
struct ExtractCallableRunTypeImpl<Callable, R (Callable::*)(Args...) const> {
  using Type = R(Args...);
};







template <typename Callable>
using ExtractCallableRunType =
    typename ExtractCallableRunTypeImpl<Callable>::Type;
# 83 "../../base/bind_internal.h"
template <typename Functor, typename SFINAE = void>
struct IsCallableObject : std::false_type {};

template <typename Callable>
struct IsCallableObject<Callable, void_t<decltype(&Callable::operator())>>
    : std::true_type {};





template <typename... Args>
struct HasRefCountedTypeAsRawPtr : std::false_type {};




template <typename T, typename... Args>
struct HasRefCountedTypeAsRawPtr<T, Args...>
    : std::conditional_t<NeedsScopedRefptrButGetsRawPtr<T>::value,
                         std::true_type,
                         HasRefCountedTypeAsRawPtr<Args...>> {};




template <typename Sig>
struct ForceVoidReturn;

template <typename R, typename... Args>
struct ForceVoidReturn<R(Args...)> {
  using RunType = void(Args...);
};




template <typename Functor, typename SFINAE>
struct FunctorTraits;
# 142 "../../base/bind_internal.h"
template <typename Functor>
struct FunctorTraits<Functor,
                     std::enable_if_t<IsCallableObject<Functor>::value &&
                                      std::is_empty<Functor>::value>> {
  using RunType = ExtractCallableRunType<Functor>;
  static constexpr bool is_method = false;
  static constexpr bool is_nullable = false;

  template <typename RunFunctor, typename... RunArgs>
  static ExtractReturnType<RunType> Invoke(RunFunctor&& functor,
                                           RunArgs&&... args) {
    return std::forward<RunFunctor>(functor)(std::forward<RunArgs>(args)...);
  }
};


template <typename R, typename... Args>
struct FunctorTraits<R (*)(Args...)> {
  using RunType = R(Args...);
  static constexpr bool is_method = false;
  static constexpr bool is_nullable = true;

  template <typename... RunArgs>
  static R Invoke(R (*function)(Args...), RunArgs&&... args) {
    return function(std::forward<RunArgs>(args)...);
  }
};
# 201 "../../base/bind_internal.h"
template <typename R, typename Receiver, typename... Args>
struct FunctorTraits<R (Receiver::*)(Args...)> {
  using RunType = R(Receiver*, Args...);
  static constexpr bool is_method = true;
  static constexpr bool is_nullable = true;

  template <typename ReceiverPtr, typename... RunArgs>
  static R Invoke(R (Receiver::*method)(Args...),
                  ReceiverPtr&& receiver_ptr,
                  RunArgs&&... args) {
    return ((*receiver_ptr).*method)(std::forward<RunArgs>(args)...);
  }
};


template <typename R, typename Receiver, typename... Args>
struct FunctorTraits<R (Receiver::*)(Args...) const> {
  using RunType = R(const Receiver*, Args...);
  static constexpr bool is_method = true;
  static constexpr bool is_nullable = true;

  template <typename ReceiverPtr, typename... RunArgs>
  static R Invoke(R (Receiver::*method)(Args...) const,
                  ReceiverPtr&& receiver_ptr,
                  RunArgs&&... args) {
    return ((*receiver_ptr).*method)(std::forward<RunArgs>(args)...);
  }
};


template <typename T>
struct FunctorTraits<IgnoreResultHelper<T>> : FunctorTraits<T> {
  using RunType =
      typename ForceVoidReturn<typename FunctorTraits<T>::RunType>::RunType;

  template <typename IgnoreResultType, typename... RunArgs>
  static void Invoke(IgnoreResultType&& ignore_result_helper,
                     RunArgs&&... args) {
    FunctorTraits<T>::Invoke(
        std::forward<IgnoreResultType>(ignore_result_helper).functor_,
        std::forward<RunArgs>(args)...);
  }
};


template <typename R, typename... Args>
struct FunctorTraits<OnceCallback<R(Args...)>> {
  using RunType = R(Args...);
  static constexpr bool is_method = false;
  static constexpr bool is_nullable = true;

  template <typename CallbackType, typename... RunArgs>
  static R Invoke(CallbackType&& callback, RunArgs&&... args) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!callback.is_null());
    return std::forward<CallbackType>(callback).Run(
        std::forward<RunArgs>(args)...);
  }
};


template <typename R, typename... Args>
struct FunctorTraits<RepeatingCallback<R(Args...)>> {
  using RunType = R(Args...);
  static constexpr bool is_method = false;
  static constexpr bool is_nullable = true;

  template <typename CallbackType, typename... RunArgs>
  static R Invoke(CallbackType&& callback, RunArgs&&... args) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!callback.is_null());
    return std::forward<CallbackType>(callback).Run(
        std::forward<RunArgs>(args)...);
  }
};

template <typename Functor>
using MakeFunctorTraits = FunctorTraits<std::decay_t<Functor>>;
# 286 "../../base/bind_internal.h"
template <bool is_weak_call, typename ReturnType>
struct InvokeHelper;

template <typename ReturnType>
struct InvokeHelper<false, ReturnType> {
  template <typename Functor, typename... RunArgs>
  static inline ReturnType MakeItSo(Functor&& functor, RunArgs&&... args) {
    using Traits = MakeFunctorTraits<Functor>;
    return Traits::Invoke(std::forward<Functor>(functor),
                          std::forward<RunArgs>(args)...);
  }
};

template <typename ReturnType>
struct InvokeHelper<true, ReturnType> {



  static_assert(std::is_void<ReturnType>::value,
                "weak_ptrs can only bind to methods without return values");

  template <typename Functor, typename BoundWeakPtr, typename... RunArgs>
  static inline void MakeItSo(Functor&& functor,
                              BoundWeakPtr&& weak_ptr,
                              RunArgs&&... args) {
    if (!weak_ptr)
      return;
    using Traits = MakeFunctorTraits<Functor>;
    Traits::Invoke(std::forward<Functor>(functor),
                   std::forward<BoundWeakPtr>(weak_ptr),
                   std::forward<RunArgs>(args)...);
  }
};




template <typename StorageType, typename UnboundRunType>
struct Invoker;

template <typename StorageType, typename R, typename... UnboundArgs>
struct Invoker<StorageType, R(UnboundArgs...)> {
  static R RunOnce(BindStateBase* base,
                   PassingTraitsType<UnboundArgs>... unbound_args) {



    StorageType* storage = static_cast<StorageType*>(base);
    static constexpr size_t num_bound_args =
        std::tuple_size<decltype(storage->bound_args_)>::value;
    return RunImpl(std::move(storage->functor_),
                   std::move(storage->bound_args_),
                   std::make_index_sequence<num_bound_args>(),
                   std::forward<UnboundArgs>(unbound_args)...);
  }

  static R Run(BindStateBase* base,
               PassingTraitsType<UnboundArgs>... unbound_args) {



    const StorageType* storage = static_cast<StorageType*>(base);
    static constexpr size_t num_bound_args =
        std::tuple_size<decltype(storage->bound_args_)>::value;
    return RunImpl(storage->functor_, storage->bound_args_,
                   std::make_index_sequence<num_bound_args>(),
                   std::forward<UnboundArgs>(unbound_args)...);
  }

 private:
  template <typename Functor, typename BoundArgsTuple, size_t... indices>
  static inline R RunImpl(Functor&& functor,
                          BoundArgsTuple&& bound,
                          std::index_sequence<indices...>,
                          UnboundArgs&&... unbound_args) {
    static constexpr bool is_method = MakeFunctorTraits<Functor>::is_method;

    using DecayedArgsTuple = std::decay_t<BoundArgsTuple>;
    static constexpr bool is_weak_call =
        IsWeakMethod<is_method,
                     std::tuple_element_t<indices, DecayedArgsTuple>...>();

    return InvokeHelper<is_weak_call, R>::MakeItSo(
        std::forward<Functor>(functor),
        Unwrap(std::get<indices>(std::forward<BoundArgsTuple>(bound)))...,
        std::forward<UnboundArgs>(unbound_args)...);
  }
};



template <typename Functor, typename... BoundArgs>
struct BindTypeHelper {
  static constexpr size_t num_bounds = sizeof...(BoundArgs);
  using FunctorTraits = MakeFunctorTraits<Functor>;
# 392 "../../base/bind_internal.h"
  using RunType = typename FunctorTraits::RunType;
  using ReturnType = ExtractReturnType<RunType>;

  using RunParamsList = ExtractArgs<RunType>;
  using BoundParamsList = TakeTypeListItem<num_bounds, RunParamsList>;
  using UnboundParamsList = DropTypeListItem<num_bounds, RunParamsList>;

  using BoundArgsList = TypeList<BoundArgs...>;

  using UnboundRunType = MakeFunctionType<ReturnType, UnboundParamsList>;
};

template <typename Functor>
std::enable_if_t<FunctorTraits<Functor>::is_nullable, bool> IsNull(
    const Functor& functor) {
  return !functor;
}

template <typename Functor>
std::enable_if_t<!FunctorTraits<Functor>::is_nullable, bool> IsNull(
    const Functor&) {
  return false;
}


template <typename Functor, typename BoundArgsTuple, size_t... indices>
bool ApplyCancellationTraitsImpl(const Functor& functor,
                                 const BoundArgsTuple& bound_args,
                                 std::index_sequence<indices...>) {
  return CallbackCancellationTraits<Functor, BoundArgsTuple>::IsCancelled(
      functor, std::get<indices>(bound_args)...);
}



template <typename BindStateType>
bool ApplyCancellationTraits(const BindStateBase* base) {
  const BindStateType* storage = static_cast<const BindStateType*>(base);
  static constexpr size_t num_bound_args =
      std::tuple_size<decltype(storage->bound_args_)>::value;
  return ApplyCancellationTraitsImpl(
      storage->functor_, storage->bound_args_,
      std::make_index_sequence<num_bound_args>());
};




template <typename Functor, typename... BoundArgs>
struct BindState final : BindStateBase {
  using IsCancellable = std::integral_constant<
      bool,
      CallbackCancellationTraits<Functor,
                                 std::tuple<BoundArgs...>>::is_cancellable>;

  template <typename ForwardFunctor, typename... ForwardBoundArgs>
  explicit BindState(BindStateBase::InvokeFuncStorage invoke_func,
                     ForwardFunctor&& functor,
                     ForwardBoundArgs&&... bound_args)



      : BindState(IsCancellable{},
                  invoke_func,
                  std::forward<ForwardFunctor>(functor),
                  std::forward<ForwardBoundArgs>(bound_args)...) {}

  Functor functor_;
  std::tuple<BoundArgs...> bound_args_;

 private:
  template <typename ForwardFunctor, typename... ForwardBoundArgs>
  explicit BindState(std::true_type,
                     BindStateBase::InvokeFuncStorage invoke_func,
                     ForwardFunctor&& functor,
                     ForwardBoundArgs&&... bound_args)
      : BindStateBase(invoke_func,
                      &Destroy,
                      &ApplyCancellationTraits<BindState>),
        functor_(std::forward<ForwardFunctor>(functor)),
        bound_args_(std::forward<ForwardBoundArgs>(bound_args)...) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!IsNull(functor_));
  }

  template <typename ForwardFunctor, typename... ForwardBoundArgs>
  explicit BindState(std::false_type,
                     BindStateBase::InvokeFuncStorage invoke_func,
                     ForwardFunctor&& functor,
                     ForwardBoundArgs&&... bound_args)
      : BindStateBase(invoke_func, &Destroy),
        functor_(std::forward<ForwardFunctor>(functor)),
        bound_args_(std::forward<ForwardBoundArgs>(bound_args)...) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!IsNull(functor_));
  }

  ~BindState() {}

  static void Destroy(const BindStateBase* self) {
    delete static_cast<const BindState*>(self);
  }
};


template <bool is_method, typename Functor, typename... BoundArgs>
struct MakeBindStateTypeImpl;

template <typename Functor, typename... BoundArgs>
struct MakeBindStateTypeImpl<false, Functor, BoundArgs...> {
  static_assert(!HasRefCountedTypeAsRawPtr<std::decay_t<BoundArgs>...>::value,
                "A parameter is a refcounted type and needs scoped_refptr.");
  using Type = BindState<std::decay_t<Functor>, std::decay_t<BoundArgs>...>;
};

template <typename Functor>
struct MakeBindStateTypeImpl<true, Functor> {
  using Type = BindState<std::decay_t<Functor>>;
};

template <typename Functor, typename Receiver, typename... BoundArgs>
struct MakeBindStateTypeImpl<true, Functor, Receiver, BoundArgs...> {
  static_assert(!std::is_array<std::remove_reference_t<Receiver>>::value,
                "First bound argument to a method cannot be an array.");
  static_assert(!HasRefCountedTypeAsRawPtr<std::decay_t<BoundArgs>...>::value,
                "A parameter is a refcounted type and needs scoped_refptr.");

 private:
  using DecayedReceiver = std::decay_t<Receiver>;

 public:
  using Type = BindState<
      std::decay_t<Functor>,
      std::conditional_t<std::is_pointer<DecayedReceiver>::value,
                         scoped_refptr<std::remove_pointer_t<DecayedReceiver>>,
                         DecayedReceiver>,
      std::decay_t<BoundArgs>...>;
};

template <typename Functor, typename... BoundArgs>
using MakeBindStateType =
    typename MakeBindStateTypeImpl<MakeFunctorTraits<Functor>::is_method,
                                   Functor,
                                   BoundArgs...>::Type;

}



template <typename Functor, typename... BoundArgs>
using MakeUnboundRunType =
    typename internal::BindTypeHelper<Functor, BoundArgs...>::UnboundRunType;

}
# 11 "../../base/bind.h" 2
# 27 "../../base/bind.h"
namespace base {

namespace internal {


template <typename T>
struct IsOnceCallback : std::false_type {};

template <typename Signature>
struct IsOnceCallback<OnceCallback<Signature>> : std::true_type {};




template <size_t i,
          typename Arg,
          typename Storage,
          typename Unwrapped,
          typename Param>
struct AssertConstructible {
 private:
  static constexpr bool param_is_forwardable =
      std::is_constructible<Param, Unwrapped>::value;




  static_assert(
      param_is_forwardable ||
          !std::is_constructible<Param, std::decay_t<Unwrapped>&&>::value,
      "Bound argument |i| is move-only but will be forwarded by copy. "
      "Ensure |Arg| is bound using base::Passed(), not std::move().");
  static_assert(
      param_is_forwardable,
      "Bound argument |i| of type |Arg| cannot be forwarded as "
      "|Unwrapped| to the bound functor, which declares it as |Param|.");

  static constexpr bool arg_is_storable =
      std::is_constructible<Storage, Arg>::value;
  static_assert(arg_is_storable ||
                    !std::is_constructible<Storage, std::decay_t<Arg>&&>::value,
                "Bound argument |i| is move-only but will be bound by copy. "
                "Ensure |Arg| is mutable and bound using std::move().");
  static_assert(arg_is_storable,
                "Bound argument |i| of type |Arg| cannot be converted and "
                "bound as |Storage|.");
};



template <typename Index,
          typename Args,
          typename UnwrappedTypeList,
          typename ParamsList>
struct AssertBindArgsValidity;

template <size_t... Ns,
          typename... Args,
          typename... Unwrapped,
          typename... Params>
struct AssertBindArgsValidity<std::index_sequence<Ns...>,
                              TypeList<Args...>,
                              TypeList<Unwrapped...>,
                              TypeList<Params...>>
    : AssertConstructible<Ns, Args, std::decay_t<Args>, Unwrapped, Params>... {
  static constexpr bool ok = true;
};


template <bool is_once, typename T>
struct TransformToUnwrappedTypeImpl;

template <typename T>
struct TransformToUnwrappedTypeImpl<true, T> {
  using StoredType = std::decay_t<T>;
  using ForwardType = StoredType&&;
  using Unwrapped = decltype(Unwrap(std::declval<ForwardType>()));
};

template <typename T>
struct TransformToUnwrappedTypeImpl<false, T> {
  using StoredType = std::decay_t<T>;
  using ForwardType = const StoredType&;
  using Unwrapped = decltype(Unwrap(std::declval<ForwardType>()));
};
# 123 "../../base/bind.h"
template <bool is_once, typename T>
using TransformToUnwrappedType =
    typename TransformToUnwrappedTypeImpl<is_once, T>::Unwrapped;




template <bool is_once, bool is_method, typename... Args>
struct MakeUnwrappedTypeListImpl {
  using Type = TypeList<TransformToUnwrappedType<is_once, Args>...>;
};





template <bool is_once, typename Receiver, typename... Args>
struct MakeUnwrappedTypeListImpl<is_once, true, Receiver, Args...> {
  using UnwrappedReceiver = TransformToUnwrappedType<is_once, Receiver>;
  using Type = TypeList<decltype(&*std::declval<UnwrappedReceiver>()),
                        TransformToUnwrappedType<is_once, Args>...>;
};

template <bool is_once, bool is_method, typename... Args>
using MakeUnwrappedTypeList =
    typename MakeUnwrappedTypeListImpl<is_once, is_method, Args...>::Type;

}


template <typename Functor, typename... Args>
inline OnceCallback<MakeUnboundRunType<Functor, Args...>>
BindOnce(Functor&& functor, Args&&... args) {
  static_assert(!internal::IsOnceCallback<std::decay_t<Functor>>() ||
                    (std::is_rvalue_reference<Functor&&>() &&
                     !std::is_const<std::remove_reference_t<Functor>>()),
                "BindOnce requires non-const rvalue for OnceCallback binding."
                " I.e.: base::BindOnce(std::move(callback)).");




  using Helper = internal::BindTypeHelper<Functor, Args...>;
  using FunctorTraits = typename Helper::FunctorTraits;
  using BoundArgsList = typename Helper::BoundArgsList;
  using UnwrappedArgsList =
      internal::MakeUnwrappedTypeList<true, FunctorTraits::is_method,
                                      Args&&...>;
  using BoundParamsList = typename Helper::BoundParamsList;
  static_assert(internal::AssertBindArgsValidity<
                    std::make_index_sequence<Helper::num_bounds>, BoundArgsList,
                    UnwrappedArgsList, BoundParamsList>::ok,
                "The bound args need to be convertible to the target params.");

  using BindState = internal::MakeBindStateType<Functor, Args...>;
  using UnboundRunType = MakeUnboundRunType<Functor, Args...>;
  using Invoker = internal::Invoker<BindState, UnboundRunType>;
  using CallbackType = OnceCallback<UnboundRunType>;




  using PolymorphicInvoke = typename CallbackType::PolymorphicInvoke;
  PolymorphicInvoke invoke_func = &Invoker::RunOnce;

  using InvokeFuncStorage = internal::BindStateBase::InvokeFuncStorage;
  return CallbackType(new BindState(
      reinterpret_cast<InvokeFuncStorage>(invoke_func),
      std::forward<Functor>(functor),
      std::forward<Args>(args)...));
}


template <typename Functor, typename... Args>
inline RepeatingCallback<MakeUnboundRunType<Functor, Args...>>
BindRepeating(Functor&& functor, Args&&... args) {
  static_assert(
      !internal::IsOnceCallback<std::decay_t<Functor>>(),
      "BindRepeating cannot bind OnceCallback. Use BindOnce with std::move().");




  using Helper = internal::BindTypeHelper<Functor, Args...>;
  using FunctorTraits = typename Helper::FunctorTraits;
  using BoundArgsList = typename Helper::BoundArgsList;
  using UnwrappedArgsList =
      internal::MakeUnwrappedTypeList<false, FunctorTraits::is_method,
                                      Args&&...>;
  using BoundParamsList = typename Helper::BoundParamsList;
  static_assert(internal::AssertBindArgsValidity<
                    std::make_index_sequence<Helper::num_bounds>, BoundArgsList,
                    UnwrappedArgsList, BoundParamsList>::ok,
                "The bound args need to be convertible to the target params.");

  using BindState = internal::MakeBindStateType<Functor, Args...>;
  using UnboundRunType = MakeUnboundRunType<Functor, Args...>;
  using Invoker = internal::Invoker<BindState, UnboundRunType>;
  using CallbackType = RepeatingCallback<UnboundRunType>;




  using PolymorphicInvoke = typename CallbackType::PolymorphicInvoke;
  PolymorphicInvoke invoke_func = &Invoker::Run;

  using InvokeFuncStorage = internal::BindStateBase::InvokeFuncStorage;
  return CallbackType(new BindState(
      reinterpret_cast<InvokeFuncStorage>(invoke_func),
      std::forward<Functor>(functor),
      std::forward<Args>(args)...));
}




template <typename Functor, typename... Args>
inline Callback<MakeUnboundRunType<Functor, Args...>>
Bind(Functor&& functor, Args&&... args) {
  return base::BindRepeating(std::forward<Functor>(functor),
                             std::forward<Args>(args)...);
}


template <typename Signature>
OnceCallback<Signature> BindOnce(OnceCallback<Signature> closure) {
  return closure;
}

template <typename Signature>
RepeatingCallback<Signature> BindRepeating(
    RepeatingCallback<Signature> closure) {
  return closure;
}

template <typename Signature>
Callback<Signature> Bind(Callback<Signature> closure) {
  return closure;
}

}
# 68 "../../base/timer/timer.h" 2


# 1 "../../base/location.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/location.h" 2

# 1 "../../buildtools/third_party/libc++/trunk/include/cassert" 1 3
# 21 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/assert.h" 1 3 4
# 22 "../../buildtools/third_party/libc++/trunk/include/cassert" 2 3
# 25 "../../buildtools/third_party/libc++/trunk/include/cassert" 3
# 11 "../../base/location.h" 2




# 1 "../../base/hash.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/hash.h" 2
# 19 "../../base/hash.h"
namespace base {






            uint32_t Hash(const void* data, size_t length);
            uint32_t Hash(const std::string& str);
            uint32_t Hash(const string16& str);







            uint32_t PersistentHash(const void* data, size_t length);
            uint32_t PersistentHash(const std::string& str);


            size_t HashInts32(uint32_t value1, uint32_t value2);
            size_t HashInts64(uint64_t value1, uint64_t value2);

template <typename T1, typename T2>
inline size_t HashInts(T1 value1, T2 value2) {


  if (sizeof(T1) > sizeof(uint32_t) || (sizeof(T2) > sizeof(uint32_t)))
    return HashInts64(value1, value2);

  return HashInts32(value1, value2);
}





template <typename T>
struct IntPairHash;

template <typename Type1, typename Type2>
struct IntPairHash<std::pair<Type1, Type2>> {
  size_t operator()(std::pair<Type1, Type2> value) const {
    return HashInts(value.first, value.second);
  }
};

}
# 16 "../../base/location.h" 2

namespace base {



class Location {
 public:
  Location();
  Location(const Location& other);




  Location(const char* file_name, const void* program_counter);




  Location(const char* function_name,
           const char* file_name,
           int line_number,
           const void* program_counter);



  bool operator==(const Location& other) const {
    return program_counter_ == other.program_counter_;
  }




  bool has_source_info() const { return function_name_ && file_name_; }



  const char* function_name() const { return function_name_; }



  const char* file_name() const { return file_name_; }



  int line_number() const { return line_number_; }




  const void* program_counter() const { return program_counter_; }



  std::string ToString() const;

  static Location CreateFromHere(const char* file_name);
  static Location CreateFromHere(const char* function_name,
                                 const char* file_name,
                                 int line_number);

 private:
  const char* function_name_ = nullptr;
  const char* file_name_ = nullptr;
  int line_number_ = -1;
  const void* program_counter_ = nullptr;
};

            const void* GetProgramCounter();
# 102 "../../base/location.h"
}

namespace std {


template <>
struct hash<::base::Location> {
  std::size_t operator()(const ::base::Location& loc) const {
    const void* program_counter = loc.program_counter();
    return base::Hash(&program_counter, sizeof(void*));
  }
};

}
# 71 "../../base/timer/timer.h" 2


# 1 "../../base/sequenced_task_runner.h" 1
# 12 "../../base/sequenced_task_runner.h"
# 1 "../../base/sequenced_task_runner_helpers.h" 1







namespace base {

class SequencedTaskRunner;
# 20 "../../base/sequenced_task_runner_helpers.h"
template <class T>
class DeleteHelper {
 private:
  static void DoDelete(const void* object) {
    delete static_cast<const T*>(object);
  }

  friend class SequencedTaskRunner;
};

template <class T>
class ReleaseHelper {
 private:
  static void DoRelease(const void* object) {
    static_cast<const T*>(object)->Release();
  }

  friend class SequencedTaskRunner;
};

}
# 13 "../../base/sequenced_task_runner.h" 2
# 1 "../../base/task_runner.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/task_runner.h" 2







namespace base {

struct TaskRunnerTraits;
# 56 "../../base/task_runner.h"
class TaskRunner
    : public RefCountedThreadSafe<TaskRunner, TaskRunnerTraits> {
 public:





  bool PostTask(const Location& from_here, OnceClosure task);




  virtual bool PostDelayedTask(const Location& from_here,
                               OnceClosure task,
                               base::TimeDelta delay) = 0;
# 89 "../../base/task_runner.h"
  virtual bool RunsTasksInCurrentSequence() const = 0;
# 132 "../../base/task_runner.h"
  bool PostTaskAndReply(const Location& from_here,
                        OnceClosure task,
                        OnceClosure reply);

 protected:
  friend struct TaskRunnerTraits;



  friend class RefCountedThreadSafe<TaskRunner, TaskRunnerTraits>;

  TaskRunner();
  virtual ~TaskRunner();




  virtual void OnDestruct() const;
};

struct TaskRunnerTraits {
  static void Destruct(const TaskRunner* task_runner);
};

}
# 14 "../../base/sequenced_task_runner.h" 2

namespace base {
# 99 "../../base/sequenced_task_runner.h"
class SequencedTaskRunner : public TaskRunner {
 public:
# 114 "../../base/sequenced_task_runner.h"
  bool PostNonNestableTask(const Location& from_here, OnceClosure task);

  virtual bool PostNonNestableDelayedTask(const Location& from_here,
                                          OnceClosure task,
                                          base::TimeDelta delay) = 0;




  template <class T>
  bool DeleteSoon(const Location& from_here, const T* object) {
    return DeleteOrReleaseSoonInternal(from_here, &DeleteHelper<T>::DoDelete,
                                       object);
  }

  template <class T>
  bool DeleteSoon(const Location& from_here, std::unique_ptr<T> object) {
    return DeleteSoon(from_here, object.release());
  }




  template <class T>
  bool ReleaseSoon(const Location& from_here, const T* object) {
    return DeleteOrReleaseSoonInternal(from_here, &ReleaseHelper<T>::DoRelease,
                                       object);
  }

 protected:
  ~SequencedTaskRunner() override {}

 private:
  bool DeleteOrReleaseSoonInternal(const Location& from_here,
                                   void (*deleter)(const void*),
                                   const void* object);
};






struct OnTaskRunnerDeleter {
  explicit OnTaskRunnerDeleter(scoped_refptr<SequencedTaskRunner> task_runner);
  ~OnTaskRunnerDeleter();

  OnTaskRunnerDeleter(OnTaskRunnerDeleter&&);
  OnTaskRunnerDeleter& operator=(OnTaskRunnerDeleter&&);


  template <typename T>
  void operator()(const T* ptr) {
    if (ptr)
      task_runner_->DeleteSoon(::base::Location::CreateFromHere(__func__, "../../base/sequenced_task_runner.h", 168), ptr);
  }

  scoped_refptr<SequencedTaskRunner> task_runner_;
};

}
# 74 "../../base/timer/timer.h" 2


namespace base {

class BaseTimerTaskInternal;
class TickClock;



class SingleThreadTaskRunner;





class Timer {
 public:




  Timer(bool retain_user_task, bool is_repeating);
  Timer(bool retain_user_task, bool is_repeating, TickClock* tick_clock);



  Timer(const Location& posted_from,
        TimeDelta delay,
        const base::Closure& user_task,
        bool is_repeating);
  Timer(const Location& posted_from,
        TimeDelta delay,
        const base::Closure& user_task,
        bool is_repeating,
        TickClock* tick_clock);

  virtual ~Timer();


  virtual bool IsRunning() const;


  virtual TimeDelta GetCurrentDelay() const;






  void SetTaskRunner(scoped_refptr<SequencedTaskRunner> task_runner);



  virtual void Start(const Location& posted_from,
                     TimeDelta delay,
                     const base::Closure& user_task);



  virtual void Stop();


  void AbandonAndStop() {
    AbandonScheduledTask();

    Stop();

  }



  virtual void Reset();

  const base::Closure& user_task() const { return user_task_; }
  const TimeTicks& desired_run_time() const { return desired_run_time_; }

 protected:

  TimeTicks Now() const;

  void set_user_task(const Closure& task) { user_task_ = task; }
  void set_desired_run_time(TimeTicks desired) { desired_run_time_ = desired; }
  void set_is_running(bool running) { is_running_ = running; }

  const Location& posted_from() const { return posted_from_; }
  bool retain_user_task() const { return retain_user_task_; }
  bool is_repeating() const { return is_repeating_; }
  bool is_running() const { return is_running_; }

 private:
  friend class BaseTimerTaskInternal;




  void PostNewScheduledTask(TimeDelta delay);




  scoped_refptr<SequencedTaskRunner> GetTaskRunner();



  void AbandonScheduledTask();


  void RunScheduledTask();



  BaseTimerTaskInternal* scheduled_task_;



  scoped_refptr<SequencedTaskRunner> task_runner_;


  Location posted_from_;

  TimeDelta delay_;

  base::Closure user_task_;



  TimeTicks scheduled_run_time_;
# 209 "../../base/timer/timer.h"
  TimeTicks desired_run_time_;




  SequenceChecker origin_sequence_checker_;



  const bool is_repeating_;


  const bool retain_user_task_;


  TickClock* const tick_clock_;


  bool is_running_;

  Timer(const Timer&) = delete; Timer& operator=(const Timer&) = delete;
};




class BaseTimerMethodPointer : public Timer {
 public:





  using Timer::Start;

  enum RepeatMode { ONE_SHOT, REPEATING };
  BaseTimerMethodPointer(RepeatMode mode, TickClock* tick_clock)
      : Timer(mode == REPEATING, mode == REPEATING, tick_clock) {}




  template <class Receiver>
  void Start(const Location& posted_from,
             TimeDelta delay,
             Receiver* receiver,
             void (Receiver::*method)()) {
    Timer::Start(posted_from, delay,
                 base::Bind(method, base::Unretained(receiver)));
  }
};



class OneShotTimer : public BaseTimerMethodPointer {
 public:
  OneShotTimer() : OneShotTimer(nullptr) {}
  explicit OneShotTimer(TickClock* tick_clock)
      : BaseTimerMethodPointer(ONE_SHOT, tick_clock) {}
};



class RepeatingTimer : public BaseTimerMethodPointer {
 public:
  RepeatingTimer() : RepeatingTimer(nullptr) {}
  explicit RepeatingTimer(TickClock* tick_clock)
      : BaseTimerMethodPointer(REPEATING, tick_clock) {}
};
# 290 "../../base/timer/timer.h"
class DelayTimer : protected Timer {
 public:
  template <class Receiver>
  DelayTimer(const Location& posted_from,
             TimeDelta delay,
             Receiver* receiver,
             void (Receiver::*method)())
      : DelayTimer(posted_from, delay, receiver, method, nullptr) {}

  template <class Receiver>
  DelayTimer(const Location& posted_from,
             TimeDelta delay,
             Receiver* receiver,
             void (Receiver::*method)(),
             TickClock* tick_clock)
      : Timer(posted_from,
              delay,
              base::Bind(method, base::Unretained(receiver)),
              false,
              tick_clock) {}

  using Timer::Reset;
};

}
# 15 "../../base/trace_event/trace_event_system_stats_monitor.h" 2
# 1 "../../base/trace_event/trace_log.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/trace_event/trace_log.h" 2




# 1 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 1 3
# 369 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 1 3
# 27 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 31 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 2 3


namespace std {inline namespace __1 {


template <class _Key, class _Tp>
union __hash_value_type;





template <class _Key, class _Cp, class _Hash,
          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value>
class __unordered_map_hasher;

template <class _Key, class _Cp, class _Pred,
          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value
         >
class __unordered_map_equal;


template <class _Tp>
struct __is_hash_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_hash_value_type_imp<__hash_value_type<_Key, _Value>> : true_type {};

template <class ..._Args>
struct __is_hash_value_type : false_type {};

template <class _One>
struct __is_hash_value_type<_One> : __is_hash_value_type_imp<typename __uncvref<_One>::type> {};



size_t __next_prime(size_t __n);

template <class _NodePtr>
struct __hash_node_base
{
    typedef typename pointer_traits<_NodePtr>::element_type __node_type;
    typedef __hash_node_base __first_node;
    typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;
    typedef _NodePtr __node_pointer;




  typedef typename conditional<
      is_pointer<__node_pointer>::value,
      __node_base_pointer,
      __node_pointer>::type __next_pointer;


    __next_pointer __next_;

    __attribute__ ((__always_inline__))
    __next_pointer __ptr() noexcept {
        return static_cast<__next_pointer>(
            pointer_traits<__node_base_pointer>::pointer_to(*this));
    }

    __attribute__ ((__always_inline__))
    __node_pointer __upcast() noexcept {
        return static_cast<__node_pointer>(
            pointer_traits<__node_base_pointer>::pointer_to(*this));
    }

    __attribute__ ((__always_inline__))
    size_t __hash() const noexcept {
        return static_cast<__node_type const&>(*this).__hash_;
    }

    __attribute__ ((__always_inline__)) __hash_node_base() noexcept : __next_(nullptr) {}
};

template <class _Tp, class _VoidPtr>
struct __hash_node
    : public __hash_node_base
             <
                 typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr> >::type
             >
{
    typedef _Tp __node_value_type;

    size_t __hash_;
    __node_value_type __value_;
};

inline __attribute__ ((__always_inline__))
bool
__is_hash_power2(size_t __bc)
{
    return __bc > 2 && !(__bc & (__bc - 1));
}

inline __attribute__ ((__always_inline__))
size_t
__constrain_hash(size_t __h, size_t __bc)
{
    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) :
        (__h < __bc ? __h : __h % __bc);
}

inline __attribute__ ((__always_inline__))
size_t
__next_hash_pow2(size_t __n)
{
    return __n < 2 ? __n : (size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1)));
}


template <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;

template <class _NodePtr> class __hash_iterator;
template <class _ConstNodePtr> class __hash_const_iterator;
template <class _NodePtr> class __hash_local_iterator;
template <class _ConstNodePtr> class __hash_const_local_iterator;
template <class _HashIterator> class __hash_map_iterator;
template <class _HashIterator> class __hash_map_const_iterator;

template <class _Tp>
struct __hash_key_value_types {
  static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, "");
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__always_inline__))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__always_inline__))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__always_inline__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n);
  }

  __attribute__ ((__always_inline__))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v);
  }

};

template <class _Key, class _Tp>
struct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __hash_value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef pair<_Key, _Tp> __nc_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__always_inline__))
  static key_type const& __get_key(__container_value_type const& __v) {
    return __v.first;
  }

  template <class _Up>
  __attribute__ ((__always_inline__))
  static typename enable_if<__is_same_uncvref<_Up, __node_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t.__cc;
  }

  template <class _Up>
  __attribute__ ((__always_inline__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__always_inline__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n.__cc);
  }

  __attribute__ ((__always_inline__))
  static __nc_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v.__nc);
  }


};

template <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,
          bool = _KVTypes::__is_map>
struct __hash_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __hash_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >
    : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>

{
  typedef __hash_key_value_types<_Tp> __base;

public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  typedef typename __rebind_pointer<_NodePtr, void>::type __void_pointer;

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef __hash_node_base<__node_pointer> __node_base_type;
  typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef typename __node_base_type::__next_pointer __next_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;

private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _HashIterator>
struct __hash_node_types_from_iterator;
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};


template <class _NodeValueTp, class _VoidPtr>
struct __make_hash_node_types {
  typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;
  typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;
  typedef __hash_node_types<_NodePtr> type;
};

template <class _NodePtr>
class __hash_iterator
{
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__always_inline__)) __hash_iterator() noexcept : __node_(nullptr) {
        ((void)0);
    }
# 343 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__always_inline__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__always_inline__))
    __hash_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__always_inline__))
    __hash_iterator operator++(int)
    {
        __hash_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)
        {return !(__x == __y);}

private:
# 391 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    __hash_iterator(__next_pointer __node) noexcept
        : __node_(__node)
        {}

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __hash_const_iterator;
    template <class> friend class __hash_map_iterator;
    template <class, class, class, class, class> friend class unordered_map;
    template <class, class, class, class, class> friend class unordered_multimap;
};

template <class _NodePtr>
class __hash_const_iterator
{
    static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, "");
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;

public:
    typedef __hash_iterator<_NodePtr> __non_const_iterator;

    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;


    __attribute__ ((__always_inline__)) __hash_const_iterator() noexcept : __node_(nullptr) {
        ((void)0);
    }

    __attribute__ ((__always_inline__))
    __hash_const_iterator(const __non_const_iterator& __x) noexcept
        : __node_(__x.__node_)
    {
        ((void)0);
    }
# 460 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }
    __attribute__ ((__always_inline__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__always_inline__))
    __hash_const_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__always_inline__))
    __hash_const_iterator operator++(int)
    {
        __hash_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
        {return !(__x == __y);}

private:
# 507 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    __hash_const_iterator(__next_pointer __node) noexcept
        : __node_(__node)
        {}

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __hash_map_const_iterator;
    template <class, class, class, class, class> friend class unordered_map;
    template <class, class, class, class, class> friend class unordered_multimap;
};

template <class _NodePtr>
class __hash_local_iterator
{
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__always_inline__)) __hash_local_iterator() noexcept : __node_(nullptr) {
        ((void)0);
    }
# 570 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__always_inline__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__always_inline__))
    __hash_local_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__always_inline__))
    __hash_local_iterator operator++(int)
    {
        __hash_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
        {return !(__x == __y);}

private:
# 625 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    __hash_local_iterator(__next_pointer __node, size_t __bucket,
                          size_t __bucket_count) noexcept
        : __node_(__node),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __hash_const_local_iterator;
    template <class> friend class __hash_map_iterator;
};

template <class _ConstNodePtr>
class __hash_const_local_iterator
{
    typedef __hash_node_types<_ConstNodePtr> _NodeTypes;
    typedef _ConstNodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

    typedef pointer_traits<__node_pointer> __pointer_traits;
    typedef typename __pointer_traits::element_type __node;
    typedef typename remove_const<__node>::type __non_const_node;
    typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type
        __non_const_node_pointer;
public:
    typedef __hash_local_iterator<__non_const_node_pointer>
                                                    __non_const_iterator;

    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;


    __attribute__ ((__always_inline__)) __hash_const_local_iterator() noexcept : __node_(nullptr) {
        ((void)0);
    }

    __attribute__ ((__always_inline__))
    __hash_const_local_iterator(const __non_const_iterator& __x) noexcept
        : __node_(__x.__node_),
          __bucket_(__x.__bucket_),
          __bucket_count_(__x.__bucket_count_)
    {
        ((void)0);
    }
# 711 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__always_inline__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__always_inline__))
    __hash_const_local_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__always_inline__))
    __hash_const_local_iterator operator++(int)
    {
        __hash_const_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
        {return !(__x == __y);}

private:
# 766 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,
                                size_t __bucket_count) noexcept
        : __node_(__node),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __hash_map_const_iterator;
};

template <class _Alloc>
class __bucket_list_deallocator
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;

    __compressed_pair<size_type, allocator_type> __data_;
public:
    typedef typename __alloc_traits::pointer pointer;

    __attribute__ ((__always_inline__))
    __bucket_list_deallocator()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
        : __data_(0) {}

    __attribute__ ((__always_inline__))
    __bucket_list_deallocator(const allocator_type& __a, size_type __size)
        noexcept(is_nothrow_copy_constructible<allocator_type>::value)
        : __data_(__size, __a) {}


    __attribute__ ((__always_inline__))
    __bucket_list_deallocator(__bucket_list_deallocator&& __x)
        noexcept(is_nothrow_move_constructible<allocator_type>::value)
        : __data_(std::__1::move(__x.__data_))
    {
        __x.size() = 0;
    }


    __attribute__ ((__always_inline__))
    size_type& size() noexcept {return __data_.first();}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __data_.first();}

    __attribute__ ((__always_inline__))
    allocator_type& __alloc() noexcept {return __data_.second();}
    __attribute__ ((__always_inline__))
    const allocator_type& __alloc() const noexcept {return __data_.second();}

    __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
    {
        __alloc_traits::deallocate(__alloc(), __p, size());
    }
};

template <class _Alloc> class __hash_map_node_destructor;

template <class _Alloc>
class __hash_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __hash_node_types<pointer> _NodeTypes;

    allocator_type& __na_;

    __hash_node_destructor& operator=(const __hash_node_destructor&);

public:
    bool __value_constructed;

    __attribute__ ((__always_inline__))
    explicit __hash_node_destructor(allocator_type& __na,
                                    bool __constructed = false) noexcept
        : __na_(__na),
          __value_constructed(__constructed)
        {}

    __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __hash_map_node_destructor;
};



template <class _Key, class _Hash, class _Equal, class _Alloc>
struct __diagnose_hash_table_helper {
  static constexpr bool __trigger_diagnostics()
    __attribute__((diagnose_if(__check_hash_requirements<_Key, _Hash>::value && !__invokable<_Hash const&, _Key const&>::value, "the specified hash functor does not provide a const call operator", "warning")))


    __attribute__((diagnose_if(is_copy_constructible<_Equal>::value && !__invokable<_Equal const&, _Key const&, _Key const&>::value, "the specified comparator type does not provide a const call operator", "warning")))


  {
    static_assert(__check_hash_requirements<_Key, _Hash>::value,
      "the specified hash does not meet the Hash requirements");
    static_assert(is_copy_constructible<_Equal>::value,
      "the specified comparator is required to be copy constructible");
    return true;
  }
};

template <class _Key, class _Value, class _Hash, class _Equal, class _Alloc>
struct __diagnose_hash_table_helper<
  __hash_value_type<_Key, _Value>,
  __unordered_map_hasher<_Key, __hash_value_type<_Key, _Value>, _Hash>,
  __unordered_map_equal<_Key, __hash_value_type<_Key, _Value>, _Equal>,
  _Alloc>
: __diagnose_hash_table_helper<_Key, _Hash, _Equal, _Alloc>
{
};


template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table
{
public:
    typedef _Tp value_type;
    typedef _Hash hasher;
    typedef _Equal key_equal;
    typedef _Alloc allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename
      __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type
                                                                     _NodeTypes;
public:

    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;
    typedef typename _NodeTypes::key_type key_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef typename __alloc_traits::size_type size_type;



    typedef typename _NodeTypes::difference_type difference_type;
public:


    typedef typename _NodeTypes::__node_type __node;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename _NodeTypes::__void_pointer __void_pointer;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_pointer __node_const_pointer;
    typedef typename _NodeTypes::__node_base_type __first_node;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

private:



    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:

    typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;
    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;
    typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;
    typedef allocator_traits<__pointer_allocator> __pointer_alloc_traits;
    typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;


    static_assert(__diagnose_hash_table_helper<_Tp, _Hash, _Equal, _Alloc>::__trigger_diagnostics(), "");



    __bucket_list __bucket_list_;
    __compressed_pair<__first_node, __node_allocator> __p1_;
    __compressed_pair<size_type, hasher> __p2_;
    __compressed_pair<float, key_equal> __p3_;


    __attribute__ ((__always_inline__))
    size_type& size() noexcept {return __p2_.first();}
public:
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __p2_.first();}

    __attribute__ ((__always_inline__))
    hasher& hash_function() noexcept {return __p2_.second();}
    __attribute__ ((__always_inline__))
    const hasher& hash_function() const noexcept {return __p2_.second();}

    __attribute__ ((__always_inline__))
    float& max_load_factor() noexcept {return __p3_.first();}
    __attribute__ ((__always_inline__))
    float max_load_factor() const noexcept {return __p3_.first();}

    __attribute__ ((__always_inline__))
    key_equal& key_eq() noexcept {return __p3_.second();}
    __attribute__ ((__always_inline__))
    const key_equal& key_eq() const noexcept {return __p3_.second();}

    __attribute__ ((__always_inline__))
    __node_allocator& __node_alloc() noexcept {return __p1_.second();}
    __attribute__ ((__always_inline__))
    const __node_allocator& __node_alloc() const noexcept
        {return __p1_.second();}

public:
    typedef __hash_iterator<__node_pointer> iterator;
    typedef __hash_const_iterator<__node_pointer> const_iterator;
    typedef __hash_local_iterator<__node_pointer> local_iterator;
    typedef __hash_const_local_iterator<__node_pointer> const_local_iterator;

    __attribute__ ((__always_inline__))
    __hash_table()
        noexcept(is_nothrow_default_constructible<__bucket_list>::value && is_nothrow_default_constructible<__first_node>::value && is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_default_constructible<hasher>::value && is_nothrow_default_constructible<key_equal>::value);





    __attribute__ ((__always_inline__))
    __hash_table(const hasher& __hf, const key_equal& __eql);
    __hash_table(const hasher& __hf, const key_equal& __eql,
                 const allocator_type& __a);
    explicit __hash_table(const allocator_type& __a);
    __hash_table(const __hash_table& __u);
    __hash_table(const __hash_table& __u, const allocator_type& __a);

    __hash_table(__hash_table&& __u)
        noexcept(is_nothrow_move_constructible<__bucket_list>::value && is_nothrow_move_constructible<__first_node>::value && is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<hasher>::value && is_nothrow_move_constructible<key_equal>::value);





    __hash_table(__hash_table&& __u, const allocator_type& __a);

    ~__hash_table();

    __hash_table& operator=(const __hash_table& __u);

    __attribute__ ((__always_inline__))
    __hash_table& operator=(__hash_table&& __u)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value);





    template <class _InputIterator>
        void __assign_unique(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept
    {
        return std::min<size_type>(
            __node_traits::max_size(__node_alloc()),
            numeric_limits<difference_type >::max()
        );
    }

    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
    iterator __node_insert_multi(__node_pointer __nd);
    iterator __node_insert_multi(const_iterator __p,
                                             __node_pointer __nd);


    template <class _Key, class ..._Args>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);

    template <class... _Args>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
      return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                          __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__always_inline__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
      return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
    }
    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
    }
    template <class _Pp>
    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
    }

    template <class... _Args>
    __attribute__ ((__always_inline__))
    iterator __emplace_multi(_Args&&... __args);
    template <class... _Args>
    __attribute__ ((__always_inline__))
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);


    __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __insert_unique(__container_value_type&& __x) {
      return __emplace_unique_key_args(_NodeTypes::__get_key(__x), std::__1::move(__x));
    }

    template <class _Pp, class = typename enable_if<
            !__is_same_uncvref<_Pp, __container_value_type>::value
        >::type>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(_Pp&& __x) {
      return __emplace_unique(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    iterator __insert_multi(_Pp&& __x) {
      return __emplace_multi(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__always_inline__))
    iterator __insert_multi(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_multi(__p, std::__1::forward<_Pp>(__x));
    }
# 1155 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(const __container_value_type& __x) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);
    }

    void clear() noexcept;
    void rehash(size_type __n);
    __attribute__ ((__always_inline__)) void reserve(size_type __n)
        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}

    __attribute__ ((__always_inline__))
    size_type bucket_count() const noexcept
    {
        return __bucket_list_.get_deleter().size();
    }

    __attribute__ ((__always_inline__))
    iterator begin() noexcept;
    __attribute__ ((__always_inline__))
    iterator end() noexcept;
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept;
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept;

    template <class _Key>
        __attribute__ ((__always_inline__))
        size_type bucket(const _Key& __k) const
        {
            ((void)0);

            return __constrain_hash(hash_function()(__k), bucket_count());
        }

    template <class _Key>
        iterator find(const _Key& __x);
    template <class _Key>
        const_iterator find(const _Key& __x) const;

    typedef __hash_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __first, const_iterator __last);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);
    __node_holder remove(const_iterator __p) noexcept;

    template <class _Key>
        __attribute__ ((__always_inline__))
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    void swap(__hash_table& __u)
# 1235 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
     noexcept(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value);


    __attribute__ ((__always_inline__))
    size_type max_bucket_count() const noexcept
        {return max_size(); }
    size_type bucket_size(size_type __n) const;
    __attribute__ ((__always_inline__)) float load_factor() const noexcept
    {
        size_type __bc = bucket_count();
        return __bc != 0 ? (float)size() / __bc : 0.f;
    }
    __attribute__ ((__always_inline__)) void max_load_factor(float __mlf) noexcept
    {
        ((void)0);

        max_load_factor() = std::__1::max(__mlf, load_factor());
    }

    __attribute__ ((__always_inline__))
    local_iterator
    begin(size_type __n)
    {
        ((void)0);




        return local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__always_inline__))
    local_iterator
    end(size_type __n)
    {
        ((void)0);




        return local_iterator(nullptr, __n, bucket_count());

    }

    __attribute__ ((__always_inline__))
    const_local_iterator
    cbegin(size_type __n) const
    {
        ((void)0);




        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__always_inline__))
    const_local_iterator
    cend(size_type __n) const
    {
        ((void)0);




        return const_local_iterator(nullptr, __n, bucket_count());

    }
# 1315 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
private:
    void __rehash(size_type __n);


    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);

    template <class _First, class ..._Rest>
    __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);






    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __hash_table& __u)
        {__copy_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}
    void __copy_assign_alloc(const __hash_table& __u, true_type);
    __attribute__ ((__always_inline__))
        void __copy_assign_alloc(const __hash_table&, false_type) {}


    void __move_assign(__hash_table& __u, false_type);
    void __move_assign(__hash_table& __u, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value);



    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__hash_table& __u)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || (is_nothrow_move_assignable<__pointer_allocator>::value && is_nothrow_move_assignable<__node_allocator>::value))



        {__move_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__hash_table& __u, true_type)
        noexcept(is_nothrow_move_assignable<__pointer_allocator>::value && is_nothrow_move_assignable<__node_allocator>::value)


    {
        __bucket_list_.get_deleter().__alloc() =
                std::__1::move(__u.__bucket_list_.get_deleter().__alloc());
        __node_alloc() = std::__1::move(__u.__node_alloc());
    }
    __attribute__ ((__always_inline__))
        void __move_assign_alloc(__hash_table&, false_type) noexcept {}


    void __deallocate_node(__next_pointer __np) noexcept;
    __next_pointer __detach() noexcept;

    template <class, class, class, class, class> friend class unordered_map;
    template <class, class, class, class, class> friend class unordered_multimap;
};

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()
    noexcept(is_nothrow_default_constructible<__bucket_list>::value && is_nothrow_default_constructible<__first_node>::value && is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_default_constructible<hasher>::value && is_nothrow_default_constructible<key_equal>::value)





    : __p2_(0),
      __p3_(1.0f)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql)
    : __bucket_list_(nullptr, __bucket_list_deleter()),
      __p1_(),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__second_tag(), __node_allocator(__a)),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__second_tag(), __node_allocator(__a)),
      __p2_(0),
      __p3_(1.0f)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)
    : __bucket_list_(nullptr,
          __bucket_list_deleter(allocator_traits<__pointer_allocator>::
              select_on_container_copy_construction(
                  __u.__bucket_list_.get_deleter().__alloc()), 0)),
      __p1_(__second_tag(), allocator_traits<__node_allocator>::
          select_on_container_copy_construction(__u.__node_alloc())),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__second_tag(), __node_allocator(__a)),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)
        noexcept(is_nothrow_move_constructible<__bucket_list>::value && is_nothrow_move_constructible<__first_node>::value && is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<hasher>::value && is_nothrow_move_constructible<key_equal>::value)





    : __bucket_list_(std::__1::move(__u.__bucket_list_)),
      __p1_(std::__1::move(__u.__p1_)),
      __p2_(std::__1::move(__u.__p2_)),
      __p3_(std::__1::move(__u.__p3_))
{
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__second_tag(), __node_allocator(__a)),
      __p2_(0, std::__1::move(__u.hash_function())),
      __p3_(std::__1::move(__u.__p3_))
{
    if (__a == allocator_type(__u.__node_alloc()))
    {
        __bucket_list_.reset(__u.__bucket_list_.release());
        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
        __u.__bucket_list_.get_deleter().size() = 0;
        if (__u.size() > 0)
        {
            __p1_.first().__next_ = __u.__p1_.first().__next_;
            __u.__p1_.first().__next_ = nullptr;
            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
                __p1_.first().__ptr();
            size() = __u.size();
            __u.size() = 0;
        }
    }
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()
{







    __deallocate_node(__p1_.first().__next_);



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(
        const __hash_table& __u, true_type)
{
    if (__node_alloc() != __u.__node_alloc())
    {
        clear();
        __bucket_list_.reset();
        __bucket_list_.get_deleter().size() = 0;
    }
    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();
    __node_alloc() = __u.__node_alloc();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)
{
    if (this != &__u)
    {
        __copy_assign_alloc(__u);
        hash_function() = __u.hash_function();
        key_eq() = __u.key_eq();
        max_load_factor() = __u.max_load_factor();
        __assign_multi(__u.begin(), __u.end());
    }
    return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np)
    noexcept
{
    __node_allocator& __na = __node_alloc();
    while (__np != nullptr)
    {
        __next_pointer __next = __np->__next_;
# 1563 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
        __node_pointer __real_np = __np->__upcast();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));
        __node_traits::deallocate(__na, __real_np, 1);
        __np = __next;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() noexcept
{
    size_type __bc = bucket_count();
    for (size_type __i = 0; __i < __bc; ++__i)
        __bucket_list_[__i] = nullptr;
    size() = 0;
    __next_pointer __cache = __p1_.first().__next_;
    __p1_.first().__next_ = nullptr;
    return __cache;
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, true_type)
    noexcept(is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value)



{
    clear();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
    __u.__bucket_list_.get_deleter().size() = 0;
    __move_assign_alloc(__u);
    size() = __u.size();
    hash_function() = std::__1::move(__u.hash_function());
    max_load_factor() = __u.max_load_factor();
    key_eq() = std::__1::move(__u.key_eq());
    __p1_.first().__next_ = __u.__p1_.first().__next_;
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, false_type)
{
    if (__node_alloc() == __u.__node_alloc())
        __move_assign(__u, true_type());
    else
    {
        hash_function() = std::__1::move(__u.hash_function());
        key_eq() = std::__1::move(__u.key_eq());
        max_load_factor() = __u.max_load_factor();
        if (bucket_count() != 0)
        {
            __next_pointer __cache = __detach();




                const_iterator __i = __u.begin();
                while (__cache != nullptr && __u.size() != 0)
                {
                    __cache->__upcast()->__value_ =
                        std::__1::move(__u.remove(__i++)->__value_);
                    __next_pointer __next = __cache->__next_;
                    __node_insert_multi(__cache->__upcast());
                    __cache = __next;
                }
# 1652 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
            __deallocate_node(__cache);
        }
        const_iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));
            __node_insert_multi(__h.get());
            __h.release();
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value)




{
    __move_assign(__u, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,
                                                          _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");

    if (bucket_count() != 0)
    {
        __next_pointer __cache = __detach();




            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__upcast()->__value_ = *__first;
                __next_pointer __next = __cache->__next_;
                __node_insert_unique(__cache->__upcast());
                __cache = __next;
            }
# 1714 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
        __deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,
                                                         _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (bucket_count() != 0)
    {
        __next_pointer __cache = __detach();




            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__upcast()->__value_ = *__first;
                __next_pointer __next = __cache->__next_;
                __node_insert_multi(__cache->__upcast());
                __cache = __next;
            }
# 1754 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
        __deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() noexcept
{



    return iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() noexcept
{



    return iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const noexcept
{



    return const_iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const noexcept
{



    return const_iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() noexcept
{
    if (size() > 0)
    {
        __deallocate_node(__p1_.first().__next_);
        __p1_.first().__next_ = nullptr;
        size_type __bc = bucket_count();
        for (size_type __i = 0; __i < __bc; ++__i)
            __bucket_list_[__i] = nullptr;
        size() = 0;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)
{
    __nd->__hash_ = hash_function()(__nd->__value_);
    size_type __bc = bucket_count();
    bool __inserted = false;
    __next_pointer __ndptr;
    size_t __chash;
    if (__bc != 0)
    {
        __chash = __constrain_hash(__nd->__hash_, __bc);
        __ndptr = __bucket_list_[__chash];
        if (__ndptr != nullptr)
        {
            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&
                                             __constrain_hash(__ndptr->__hash(), __bc) == __chash;
                                                     __ndptr = __ndptr->__next_)
            {
                if (key_eq()(__ndptr->__upcast()->__value_, __nd->__value_))
                    goto __done;
            }
        }
    }
    {
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
            __chash = __constrain_hash(__nd->__hash_, __bc);
        }

        __next_pointer __pn = __bucket_list_[__chash];
        if (__pn == nullptr)
        {
            __pn =__p1_.first().__ptr();
            __nd->__next_ = __pn->__next_;
            __pn->__next_ = __nd->__ptr();

            __bucket_list_[__chash] = __pn;
            if (__nd->__next_ != nullptr)
                __bucket_list_[__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();
        }
        else
        {
            __nd->__next_ = __pn->__next_;
            __pn->__next_ = __nd->__ptr();
        }
        __ndptr = __nd->__ptr();

        ++size();
        __inserted = true;
    }
__done:



    return pair<iterator, bool>(iterator(__ndptr), __inserted);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)
{
    __cp->__hash_ = hash_function()(__cp->__value_);
    size_type __bc = bucket_count();
    if (size()+1 > __bc * max_load_factor() || __bc == 0)
    {
        rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                       size_type(ceil(float(size() + 1) / max_load_factor()))));
        __bc = bucket_count();
    }
    size_t __chash = __constrain_hash(__cp->__hash_, __bc);
    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn == nullptr)
    {
        __pn =__p1_.first().__ptr();
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp->__ptr();

        __bucket_list_[__chash] = __pn;
        if (__cp->__next_ != nullptr)
            __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)]
                = __cp->__ptr();
    }
    else
    {
        for (bool __found = false; __pn->__next_ != nullptr &&
                                   __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;
                                                           __pn = __pn->__next_)
        {





            if (__found != (__pn->__next_->__hash() == __cp->__hash_ &&
                            key_eq()(__pn->__next_->__upcast()->__value_, __cp->__value_)))
            {
                if (!__found)
                    __found = true;
                else
                    break;
            }
        }
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp->__ptr();
        if (__cp->__next_ != nullptr)
        {
            size_t __nhash = __constrain_hash(__cp->__next_->__hash(), __bc);
            if (__nhash != __chash)
                __bucket_list_[__nhash] = __cp->__ptr();
        }
    }
    ++size();



    return iterator(__cp->__ptr());

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(
        const_iterator __p, __node_pointer __cp)
{





    if (__p != end() && key_eq()(*__p, __cp->__value_))
    {
        __next_pointer __np = __p.__node_;
        __cp->__hash_ = __np->__hash();
        size_type __bc = bucket_count();
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
        }
        size_t __chash = __constrain_hash(__cp->__hash_, __bc);
        __next_pointer __pp = __bucket_list_[__chash];
        while (__pp->__next_ != __np)
            __pp = __pp->__next_;
        __cp->__next_ = __np;
        __pp->__next_ = static_cast<__next_pointer>(__cp);
        ++size();



        return iterator(static_cast<__next_pointer>(__cp));

    }
    return __node_insert_multi(__cp);
}




template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key, class ..._Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)






{

    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    bool __inserted = false;
    __next_pointer __nd;
    size_t __chash;
    if (__bc != 0)
    {
        __chash = __constrain_hash(__hash, __bc);
        __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if (key_eq()(__nd->__upcast()->__value_, __k))
                    goto __done;
            }
        }
    }
    {

        __node_holder __h = __construct_node_hash(__hash, std::__1::forward<_Args>(__args)...);



        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
            __chash = __constrain_hash(__hash, __bc);
        }

        __next_pointer __pn = __bucket_list_[__chash];
        if (__pn == nullptr)
        {
            __pn = __p1_.first().__ptr();
            __h->__next_ = __pn->__next_;
            __pn->__next_ = __h.get()->__ptr();

            __bucket_list_[__chash] = __pn;
            if (__h->__next_ != nullptr)
                __bucket_list_[__constrain_hash(__h->__next_->__hash(), __bc)]
                    = __h.get()->__ptr();
        }
        else
        {
            __h->__next_ = __pn->__next_;
            __pn->__next_ = static_cast<__next_pointer>(__h.get());
        }
        __nd = static_cast<__next_pointer>(__h.release());

        ++size();
        __inserted = true;
    }
__done:



    return pair<iterator, bool>(iterator(__nd), __inserted);

}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(
        const_iterator __p, _Args&&... __args)
{





    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__p, __h.get());
    __h.release();
    return __r;
}
# 2135 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)
{
    if (__n == 1)
        __n = 2;
    else if (__n & (__n - 1))
        __n = __next_prime(__n);
    size_type __bc = bucket_count();
    if (__n > __bc)
        __rehash(__n);
    else if (__n < __bc)
    {
        __n = std::__1::max<size_type>
              (
                  __n,
                  __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) :
                                           __next_prime(size_t(ceil(float(size()) / max_load_factor())))
              );
        if (__n < __bc)
            __rehash(__n);
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)
{



    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();
    __bucket_list_.reset(__nbc > 0 ?
                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);
    __bucket_list_.get_deleter().size() = __nbc;
    if (__nbc > 0)
    {
        for (size_type __i = 0; __i < __nbc; ++__i)
            __bucket_list_[__i] = nullptr;
        __next_pointer __pp = __p1_.first().__ptr();
        __next_pointer __cp = __pp->__next_;
        if (__cp != nullptr)
        {
            size_type __chash = __constrain_hash(__cp->__hash(), __nbc);
            __bucket_list_[__chash] = __pp;
            size_type __phash = __chash;
            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;
                                                           __cp = __pp->__next_)
            {
                __chash = __constrain_hash(__cp->__hash(), __nbc);
                if (__chash == __phash)
                    __pp = __cp;
                else
                {
                    if (__bucket_list_[__chash] == nullptr)
                    {
                        __bucket_list_[__chash] = __pp;
                        __pp = __cp;
                        __phash = __chash;
                    }
                    else
                    {
                        __next_pointer __np = __cp;
                        for (; __np->__next_ != nullptr &&
                               key_eq()(__cp->__upcast()->__value_,
                                        __np->__next_->__upcast()->__value_);
                                                           __np = __np->__next_)
                            ;
                        __pp->__next_ = __np->__next_;
                        __np->__next_ = __bucket_list_[__chash]->__next_;
                        __bucket_list_[__chash]->__next_ = __cp;

                    }
                }
            }
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__nd->__hash() == __hash
                  || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if ((__nd->__hash() == __hash)
                    && key_eq()(__nd->__upcast()->__value_, __k))



                    return iterator(__nd);

            }
        }
    }
    return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__hash == __nd->__hash()
                    || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if ((__nd->__hash() == __hash)
                    && key_eq()(__nd->__upcast()->__value_, __k))



                    return const_iterator(__nd);

            }
        }

    }
    return end();
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class ..._Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_hash_value_type<_Args...>::value,
                  "Construct cannot be called with a hash value type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = hash_function()(__h->__value_);
    __h->__next_ = nullptr;
    return __h;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _First, class ..._Rest>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(
    size_t __hash, _First&& __f, _Rest&& ...__rest)
{
    static_assert(!__is_hash_value_type<_First, _Rest...>::value,
                  "Construct cannot be called with a hash value type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),
                             std::__1::forward<_First>(__f),
                             std::__1::forward<_Rest>(__rest)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = __hash;
    __h->__next_ = nullptr;
    return __h;
}
# 2345 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)
{
    __next_pointer __np = __p.__node_;
# 2358 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    iterator __r(__np);

    ++__r;
    remove(__p);
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,
                                                const_iterator __last)
{
# 2378 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    for (const_iterator __p = __first; __first != __last; __p = __first)
    {
        ++__first;
        erase(__p);
    }
    __next_pointer __np = __last.__node_;



    return iterator (__np);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)
{
    size_type __r = 0;
    iterator __i = find(__k);
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            erase(__i++);
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) noexcept
{

    __next_pointer __cn = __p.__node_;
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cn->__hash(), __bc);

    __next_pointer __pn = __bucket_list_[__chash];
    for (; __pn->__next_ != __cn; __pn = __pn->__next_)
        ;



    if (__pn == __p1_.first().__ptr()
            || __constrain_hash(__pn->__hash(), __bc) != __chash)
    {
        if (__cn->__next_ == nullptr
            || __constrain_hash(__cn->__next_->__hash(), __bc) != __chash)
            __bucket_list_[__chash] = nullptr;
    }

    if (__cn->__next_ != nullptr)
    {
        size_t __nhash = __constrain_hash(__cn->__next_->__hash(), __bc);
        if (__nhash != __chash)
            __bucket_list_[__nhash] = __pn;
    }

    __pn->__next_ = __cn->__next_;
    __cn->__next_ = nullptr;
    --size();
# 2470 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const
{
    return static_cast<size_type>(find(__k) != end());
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const
{
    size_type __r = 0;
    const_iterator __i = find(__k);
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__i;
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)
# 2581 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
  noexcept(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value)

{
    ((void)0);



    {
    __node_pointer_pointer __npp = __bucket_list_.release();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __u.__bucket_list_.reset(__npp);
    }
    std::__1::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());
    __swap_allocator(__bucket_list_.get_deleter().__alloc(),
             __u.__bucket_list_.get_deleter().__alloc());
    __swap_allocator(__node_alloc(), __u.__node_alloc());
    std::__1::swap(__p1_.first().__next_, __u.__p1_.first().__next_);
    __p2_.swap(__u.__p2_);
    __p3_.swap(__u.__p3_);
    if (size() > 0)
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
    if (__u.size() > 0)
        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =
            __u.__p1_.first().__ptr();



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const
{
    ((void)0);

    __next_pointer __np = __bucket_list_[__n];
    size_type __bc = bucket_count();
    size_type __r = 0;
    if (__np != nullptr)
    {
        for (__np = __np->__next_; __np != nullptr &&
                                   __constrain_hash(__np->__hash(), __bc) == __n;
                                                    __np = __np->__next_, ++__r)
            ;
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__always_inline__))
void
swap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,
     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2672 "../../buildtools/third_party/libc++/trunk/include/__hash_table" 3
} }
# 370 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 2 3
# 378 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3


namespace std {inline namespace __1 {

template <class _Key, class _Cp, class _Hash, bool _IsEmpty>
class __unordered_map_hasher
    : private _Hash
{
public:
    __attribute__ ((__always_inline__))
    __unordered_map_hasher()
        noexcept(is_nothrow_default_constructible<_Hash>::value)
        : _Hash() {}
    __attribute__ ((__always_inline__))
    __unordered_map_hasher(const _Hash& __h)
        noexcept(is_nothrow_copy_constructible<_Hash>::value)
        : _Hash(__h) {}
    __attribute__ ((__always_inline__))
    const _Hash& hash_function() const noexcept {return *this;}
    __attribute__ ((__always_inline__))
    size_t operator()(const _Cp& __x) const
        {return static_cast<const _Hash&>(*this)(__x.__cc.first);}
    __attribute__ ((__always_inline__))
    size_t operator()(const _Key& __x) const
        {return static_cast<const _Hash&>(*this)(__x);}
    void swap(__unordered_map_hasher&__y)
        noexcept(__is_nothrow_swappable<_Hash>::value)
    {
        using std::__1::swap;
        swap(static_cast<_Hash&>(*this), static_cast<_Hash&>(__y));
    }
};

template <class _Key, class _Cp, class _Hash>
class __unordered_map_hasher<_Key, _Cp, _Hash, false>
{
    _Hash __hash_;
public:
    __attribute__ ((__always_inline__))
    __unordered_map_hasher()
        noexcept(is_nothrow_default_constructible<_Hash>::value)
        : __hash_() {}
    __attribute__ ((__always_inline__))
    __unordered_map_hasher(const _Hash& __h)
        noexcept(is_nothrow_copy_constructible<_Hash>::value)
        : __hash_(__h) {}
    __attribute__ ((__always_inline__))
    const _Hash& hash_function() const noexcept {return __hash_;}
    __attribute__ ((__always_inline__))
    size_t operator()(const _Cp& __x) const
        {return __hash_(__x.__cc.first);}
    __attribute__ ((__always_inline__))
    size_t operator()(const _Key& __x) const
        {return __hash_(__x);}
    void swap(__unordered_map_hasher&__y)
        noexcept(__is_nothrow_swappable<_Hash>::value)
    {
        using std::__1::swap;
        swap(__hash_, __y.__hash_);
    }
};

template <class _Key, class _Cp, class _Hash, bool __b>
inline __attribute__ ((__always_inline__))
void
swap(__unordered_map_hasher<_Key, _Cp, _Hash, __b>& __x,
     __unordered_map_hasher<_Key, _Cp, _Hash, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Key, class _Cp, class _Pred, bool _IsEmpty>
class __unordered_map_equal
    : private _Pred
{
public:
    __attribute__ ((__always_inline__))
    __unordered_map_equal()
        noexcept(is_nothrow_default_constructible<_Pred>::value)
        : _Pred() {}
    __attribute__ ((__always_inline__))
    __unordered_map_equal(const _Pred& __p)
        noexcept(is_nothrow_copy_constructible<_Pred>::value)
        : _Pred(__p) {}
    __attribute__ ((__always_inline__))
    const _Pred& key_eq() const noexcept {return *this;}
    __attribute__ ((__always_inline__))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__always_inline__))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y);}
    __attribute__ ((__always_inline__))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x, __y.__cc.first);}
    void swap(__unordered_map_equal&__y)
        noexcept(__is_nothrow_swappable<_Pred>::value)
    {
        using std::__1::swap;
        swap(static_cast<_Pred&>(*this), static_cast<_Pred&>(__y));
    }
};

template <class _Key, class _Cp, class _Pred>
class __unordered_map_equal<_Key, _Cp, _Pred, false>
{
    _Pred __pred_;
public:
    __attribute__ ((__always_inline__))
    __unordered_map_equal()
        noexcept(is_nothrow_default_constructible<_Pred>::value)
        : __pred_() {}
    __attribute__ ((__always_inline__))
    __unordered_map_equal(const _Pred& __p)
        noexcept(is_nothrow_copy_constructible<_Pred>::value)
        : __pred_(__p) {}
    __attribute__ ((__always_inline__))
    const _Pred& key_eq() const noexcept {return __pred_;}
    __attribute__ ((__always_inline__))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return __pred_(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__always_inline__))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return __pred_(__x.__cc.first, __y);}
    __attribute__ ((__always_inline__))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return __pred_(__x, __y.__cc.first);}
    void swap(__unordered_map_equal&__y)
        noexcept(__is_nothrow_swappable<_Pred>::value)
    {
        using std::__1::swap;
        swap(__pred_, __y.__pred_);
    }
};

template <class _Key, class _Cp, class _Pred, bool __b>
inline __attribute__ ((__always_inline__))
void
swap(__unordered_map_equal<_Key, _Cp, _Pred, __b>& __x,
     __unordered_map_equal<_Key, _Cp, _Pred, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Alloc>
class __hash_map_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:

    typedef typename __alloc_traits::pointer pointer;
private:

    allocator_type& __na_;

    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__always_inline__))
    explicit __hash_map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__always_inline__))
    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)
        noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }
# 571 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
    __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__cc.second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__cc.first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};


template <class _Key, class _Tp>
union __hash_value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;

    value_type __cc;
    __nc_value_type __nc;

    __attribute__ ((__always_inline__))
    __hash_value_type& operator=(const __hash_value_type& __v)
        {__nc = __v.__cc; return *this;}

    __attribute__ ((__always_inline__))
    __hash_value_type& operator=(__hash_value_type&& __v)
        {__nc = std::__1::move(__v.__nc); return *this;}

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__always_inline__))
    __hash_value_type& operator=(_ValueTp&& __v) {
        __nc = std::__1::forward<_ValueTp>(__v); return *this;
    }

private:
    __hash_value_type(const __hash_value_type& __v) = delete;
    __hash_value_type(__hash_value_type&& __v) = delete;
    template <class ..._Args>
    explicit __hash_value_type(_Args&& ...__args) = delete;

    ~__hash_value_type() = delete;
};
# 639 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
template <class _HashIterator>
class __hash_map_iterator
{
    _HashIterator __i_;

    typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__always_inline__))
    __hash_map_iterator() noexcept {}

    __attribute__ ((__always_inline__))
    __hash_map_iterator(_HashIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__always_inline__))
    __hash_map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__always_inline__))
    __hash_map_iterator operator++(int)
    {
        __hash_map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__always_inline__))
        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class unordered_map;
    template <class, class, class, class, class> friend class unordered_multimap;
    template <class> friend class __hash_const_iterator;
    template <class> friend class __hash_const_local_iterator;
    template <class> friend class __hash_map_const_iterator;
};

template <class _HashIterator>
class __hash_map_const_iterator
{
    _HashIterator __i_;

    typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__always_inline__))
    __hash_map_const_iterator() noexcept {}

    __attribute__ ((__always_inline__))
    __hash_map_const_iterator(_HashIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__always_inline__))
    __hash_map_const_iterator(
            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)
                 noexcept
                : __i_(__i.__i_) {}

    __attribute__ ((__always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__always_inline__))
    __hash_map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__always_inline__))
    __hash_map_const_iterator operator++(int)
    {
        __hash_map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__always_inline__))
        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class unordered_map;
    template <class, class, class, class, class> friend class unordered_multimap;
    template <class> friend class __hash_const_iterator;
    template <class> friend class __hash_const_local_iterator;
};

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class unordered_map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef _Hash hasher;
    typedef _Pred key_equal;
    typedef _Alloc allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::_NodeTypes _NodeTypes;
    typedef typename __table::__node_pointer __node_pointer;
    typedef typename __table::__node_const_pointer __node_const_pointer;
    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;

    static_assert((is_same<typename __table::__container_value_type, value_type>::value), "");
    static_assert((is_same<typename __table::__node_value_type, __value_type>::value), "");
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;

    __attribute__ ((__always_inline__))
    unordered_map()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),
                           const key_equal& __eql = key_equal());
    unordered_map(size_type __n, const hasher& __hf,
                  const key_equal& __eql,
                  const allocator_type& __a);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    __attribute__ ((__always_inline__))
    explicit unordered_map(const allocator_type& __a);
    unordered_map(const unordered_map& __u);
    unordered_map(const unordered_map& __u, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    unordered_map(unordered_map&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_map(unordered_map&& __u, const allocator_type& __a);
    unordered_map(initializer_list<value_type> __il);
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);


    __attribute__ ((__always_inline__))
    unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__always_inline__))
    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__always_inline__))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__always_inline__))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__always_inline__))
    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__always_inline__))
    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__il, __n, __hf, key_equal(), __a) {}


    __attribute__ ((__always_inline__))
    unordered_map& operator=(const unordered_map& __u)
    {

        __table_ = __u.__table_;
# 874 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
        return *this;
    }

    __attribute__ ((__always_inline__))
    unordered_map& operator=(unordered_map&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__always_inline__))
    unordered_map& operator=(initializer_list<value_type> __il);


    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__always_inline__))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return __table_.end();}

    __attribute__ ((__always_inline__))
    pair<iterator, bool> insert(const value_type& __x)
        {return __table_.__insert_unique(__x);}

    iterator insert(const_iterator __p, const value_type& __x) {





        ((void)__p);

        return insert(__x).first;
    }

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        void insert(_InputIterator __first, _InputIterator __last);


    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    __attribute__ ((__always_inline__))
    pair<iterator, bool> insert(value_type&& __x)
        {return __table_.__insert_unique(std::__1::move(__x));}

    iterator insert(const_iterator __p, value_type&& __x) {





        ((void)__p);

        return __table_.__insert_unique(std::__1::move(__x)).first;
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__always_inline__))
        pair<iterator, bool> insert(_Pp&& __x)
            {return __table_.__insert_unique(std::__1::forward<_Pp>(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__always_inline__))
        iterator insert(const_iterator __p, _Pp&& __x)
        {





          ((void)__p);

            return insert(std::__1::forward<_Pp>(__x)).first;
        }

    template <class... _Args>
    __attribute__ ((__always_inline__))
    pair<iterator, bool> emplace(_Args&&... __args) {
        return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...);
    }

    template <class... _Args>
    __attribute__ ((__always_inline__))
    iterator emplace_hint(const_iterator __p, _Args&&... __args) {





          ((void)__p);

        return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...).first;
    }
# 1077 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    iterator erase(iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {__table_.clear();}

    __attribute__ ((__always_inline__))
    void swap(unordered_map& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        { __table_.swap(__u.__table_);}

    __attribute__ ((__always_inline__))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__always_inline__))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
    __attribute__ ((__always_inline__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_unique(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_unique(__k);}

    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


    mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__always_inline__))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__always_inline__))
    size_type max_bucket_count() const noexcept {return __table_.max_bucket_count();}

    __attribute__ ((__always_inline__))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__always_inline__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__always_inline__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__always_inline__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__always_inline__))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__always_inline__))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__always_inline__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__always_inline__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__always_inline__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1170 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
private:




};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a))
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), typename __table::allocator_type(__a))
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0) {
            __table_.__emplace_unique(std::__1::move(
                __u.__table_.remove((__i++).__i_)->__value_.__nc));
        }
    }




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_unique(__il.begin(), __il.end());
    return *this;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                       _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_unique(*__first);
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)
{
    return __table_.__emplace_unique_key_args(__k,
        std::piecewise_construct, std::forward_as_tuple(__k),
                                  std::forward_as_tuple()).first->__cc.second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)
{
    return __table_.__emplace_unique_key_args(__k,
        std::piecewise_construct, std::forward_as_tuple(std::move(__k)),
                                  std::forward_as_tuple()).first->__cc.second;
}
# 1429 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)
{
    iterator __i = find(__k);




    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
const _Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const
{
    const_iterator __i = find(__k);




    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
void
swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
            __i != __ex; ++__i)
    {
        const_iterator __j = __y.find(__i->first);
        if (__j == __ey || !(*__i == *__j))
            return false;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class unordered_multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef _Hash hasher;
    typedef _Pred key_equal;
    typedef _Alloc allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::_NodeTypes _NodeTypes;
    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;
    static_assert((is_same<typename __node_traits::size_type,
                          typename __alloc_traits::size_type>::value),
                 "Allocator uses different size_type for different types");
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;

    __attribute__ ((__always_inline__))
    unordered_multimap()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),
                                const key_equal& __eql = key_equal());
    unordered_multimap(size_type __n, const hasher& __hf,
                                const key_equal& __eql,
                                const allocator_type& __a);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    __attribute__ ((__always_inline__))
    explicit unordered_multimap(const allocator_type& __a);
    unordered_multimap(const unordered_multimap& __u);
    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    unordered_multimap(unordered_multimap&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);
    unordered_multimap(initializer_list<value_type> __il);
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf = hasher(),
                       const key_equal& __eql = key_equal());
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf, const key_equal& __eql,
                       const allocator_type& __a);


    __attribute__ ((__always_inline__))
    unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__always_inline__))
    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__always_inline__))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__always_inline__))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__always_inline__))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__always_inline__))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}


    __attribute__ ((__always_inline__))
    unordered_multimap& operator=(const unordered_multimap& __u)
    {

        __table_ = __u.__table_;
# 1623 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
        return *this;
    }

    __attribute__ ((__always_inline__))
    unordered_multimap& operator=(unordered_multimap&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__always_inline__))
    unordered_multimap& operator=(initializer_list<value_type> __il);


    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__always_inline__))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return __table_.end();}

    __attribute__ ((__always_inline__))
    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __x)
        {return __table_.__insert_multi(__p.__i_, __x);}

    template <class _InputIterator>
    __attribute__ ((__always_inline__))
    void insert(_InputIterator __first, _InputIterator __last);


    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}
    __attribute__ ((__always_inline__))
    iterator insert(value_type&& __x) {return __table_.__insert_multi(std::__1::move(__x));}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __x)
        {return __table_.__insert_multi(__p.__i_, std::__1::move(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
    __attribute__ ((__always_inline__))
    iterator insert(_Pp&& __x)
        {return __table_.__insert_multi(std::__1::forward<_Pp>(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, _Pp&& __x)
        {return __table_.__insert_multi(__p.__i_, std::__1::forward<_Pp>(__x));}

    template <class... _Args>
    iterator emplace(_Args&&... __args) {
        return __table_.__emplace_multi(std::__1::forward<_Args>(__args)...);
    }

    template <class... _Args>
    iterator emplace_hint(const_iterator __p, _Args&&... __args) {
        return __table_.__emplace_hint_multi(__p.__i_, std::__1::forward<_Args>(__args)...);
    }



    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    iterator erase(iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {__table_.clear();}

    __attribute__ ((__always_inline__))
    void swap(unordered_multimap& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        {__table_.swap(__u.__table_);}

    __attribute__ ((__always_inline__))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__always_inline__))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
    __attribute__ ((__always_inline__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_multi(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_multi(__k);}

    __attribute__ ((__always_inline__))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__always_inline__))
    size_type max_bucket_count() const noexcept
        {return __table_.max_bucket_count();}

    __attribute__ ((__always_inline__))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__always_inline__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__always_inline__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__always_inline__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__always_inline__))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__always_inline__))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__always_inline__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__always_inline__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__always_inline__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1790 "../../buildtools/third_party/libc++/trunk/include/unordered_map" 3
};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a))
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), typename __table::allocator_type(__a))
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __table_.__insert_multi(
                      std::__1::move(__u.__table_.remove((__i++).__i_)->__value_.__nc)
                                   );
        }
    }




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_multi(__il.begin(), __il.end());
    return *this;
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                            _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_multi(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
void
swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    typedef pair<const_iterator, const_iterator> _EqRng;
    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
    {
        _EqRng __xeq = __x.equal_range(__i->first);
        _EqRng __yeq = __y.equal_range(__i->first);
        if (std::__1::distance(__xeq.first, __xeq.second) !=
            std::__1::distance(__yeq.first, __yeq.second) ||
                  !std::__1::is_permutation(__xeq.first, __xeq.second, __yeq.first))
            return false;
        __i = __xeq.second;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

} }
# 14 "../../base/trace_event/trace_log.h" 2



# 1 "../../base/containers/stack.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stack" 1 3
# 86 "../../buildtools/third_party/libc++/trunk/include/stack" 3
# 1 "../../buildtools/third_party/libc++/trunk/include/deque" 1 3
# 163 "../../buildtools/third_party/libc++/trunk/include/deque" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 167 "../../buildtools/third_party/libc++/trunk/include/deque" 2 3


namespace std {inline namespace __1 {

template <class _Tp, class _Allocator> class __deque_base;
template <class _Tp, class _Allocator = allocator<_Tp> > class deque;

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
class __deque_iterator;

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _ValueType, class _DiffType>
struct __deque_block_size {
  static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BS =





                               __deque_block_size<_ValueType, _DiffType>::value

          >
class __deque_iterator
{
    typedef _MapPointer __map_iterator;
public:
    typedef _Pointer pointer;
    typedef _DiffType difference_type;
private:
    __map_iterator __m_iter_;
    pointer __ptr_;

    static const difference_type __block_size;
public:
    typedef _ValueType value_type;
    typedef random_access_iterator_tag iterator_category;
    typedef _Reference reference;

    __attribute__ ((__always_inline__)) __deque_iterator() noexcept

     : __m_iter_(nullptr), __ptr_(nullptr)

     {}

    template <class _Pp, class _Rp, class _MP>
    __attribute__ ((__always_inline__))
    __deque_iterator(const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, _BS>& __it,
                typename enable_if<is_convertible<_Pp, pointer>::value>::type* = 0) noexcept
        : __m_iter_(__it.__m_iter_), __ptr_(__it.__ptr_) {}

    __attribute__ ((__always_inline__)) reference operator*() const {return *__ptr_;}
    __attribute__ ((__always_inline__)) pointer operator->() const {return __ptr_;}

    __attribute__ ((__always_inline__)) __deque_iterator& operator++()
    {
        if (++__ptr_ - *__m_iter_ == __block_size)
        {
            ++__m_iter_;
            __ptr_ = *__m_iter_;
        }
        return *this;
    }

    __attribute__ ((__always_inline__)) __deque_iterator operator++(int)
    {
        __deque_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__always_inline__)) __deque_iterator& operator--()
    {
        if (__ptr_ == *__m_iter_)
        {
            --__m_iter_;
            __ptr_ = *__m_iter_ + __block_size;
        }
        --__ptr_;
        return *this;
    }

    __attribute__ ((__always_inline__)) __deque_iterator operator--(int)
    {
        __deque_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__always_inline__)) __deque_iterator& operator+=(difference_type __n)
    {
        if (__n != 0)
        {
            __n += __ptr_ - *__m_iter_;
            if (__n > 0)
            {
                __m_iter_ += __n / __block_size;
                __ptr_ = *__m_iter_ + __n % __block_size;
            }
            else
            {
                difference_type __z = __block_size - 1 - __n;
                __m_iter_ -= __z / __block_size;
                __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);
            }
        }
        return *this;
    }

    __attribute__ ((__always_inline__)) __deque_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__always_inline__)) __deque_iterator operator+(difference_type __n) const
    {
        __deque_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__always_inline__)) __deque_iterator operator-(difference_type __n) const
    {
        __deque_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__always_inline__))
    friend __deque_iterator operator+(difference_type __n, const __deque_iterator& __it)
        {return __it + __n;}

    __attribute__ ((__always_inline__))
    friend difference_type operator-(const __deque_iterator& __x, const __deque_iterator& __y)
    {
        if (__x != __y)
            return (__x.__m_iter_ - __y.__m_iter_) * __block_size
                 + (__x.__ptr_ - *__x.__m_iter_)
                 - (__y.__ptr_ - *__y.__m_iter_);
        return 0;
    }

    __attribute__ ((__always_inline__)) reference operator[](difference_type __n) const
        {return *(*this + __n);}

    __attribute__ ((__always_inline__)) friend
        bool operator==(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}

    __attribute__ ((__always_inline__)) friend
        bool operator!=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__always_inline__)) friend
        bool operator<(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __x.__m_iter_ < __y.__m_iter_ ||
               (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);}

    __attribute__ ((__always_inline__)) friend
        bool operator>(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__always_inline__)) friend
        bool operator<=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__always_inline__)) friend
        bool operator>=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__always_inline__)) __deque_iterator(__map_iterator __m, pointer __p) noexcept
        : __m_iter_(__m), __ptr_(__p) {}

    template <class _Tp, class _Ap> friend class __deque_base;
    template <class _Tp, class _Ap> friend class deque;
    template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>
        friend class __deque_iterator;

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy(_RAIter __f,
         _RAIter __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy_backward(_RAIter __f,
                  _RAIter __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move(_RAIter __f,
         _RAIter __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(_RAIter __f,
                  _RAIter __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
const _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer,
                                 _DiffType, _BlockSize>::__block_size =
    __deque_block_size<_ValueType, _DiffType>::value;



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
    while (__f != __l)
    {
        pointer __rb = __r.__ptr_;
        pointer __re = *__r.__m_iter_ + __block_size;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __l;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __f + __n;
        }
        std::__1::copy(__f, __m, __rb);
        __f = __m;
        __r += __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::copy(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::copy(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
        pointer __rb = *__rp.__m_iter_;
        pointer __re = __rp.__ptr_ + 1;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __f;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __l - __n;
        }
        std::__1::copy_backward(__m, __l, __re);
        __l = __m;
        __r -= __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::copy_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::copy_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
    while (__f != __l)
    {
        pointer __rb = __r.__ptr_;
        pointer __re = *__r.__m_iter_ + __block_size;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __l;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __f + __n;
        }
        std::__1::move(__f, __m, __rb);
        __f = __m;
        __r += __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
        pointer __rb = *__rp.__m_iter_;
        pointer __re = __rp.__ptr_ + 1;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __f;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __l - __n;
        }
        std::__1::move_backward(__m, __l, __re);
        __l = __m;
        __r -= __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <bool>
class __deque_base_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__deque_base_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("deque");
}

template <bool __b>
void
__deque_base_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("deque");
}

template <class _Tp, class _Allocator>
class __deque_base
    : protected __deque_base_common<true>
{
    __deque_base(const __deque_base& __c);
    __deque_base& operator=(const __deque_base& __c);
protected:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static const difference_type __block_size;

    typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type __pointer_allocator;
    typedef allocator_traits<__pointer_allocator> __map_traits;
    typedef typename __map_traits::pointer __map_pointer;
    typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type __const_pointer_allocator;
    typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;
    typedef __split_buffer<pointer, __pointer_allocator> __map;

    typedef __deque_iterator<value_type, pointer, reference, __map_pointer,
                             difference_type> iterator;
    typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,
                             difference_type> const_iterator;

    __map __map_;
    size_type __start_;
    __compressed_pair<size_type, allocator_type> __size_;

    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;

    __attribute__ ((__always_inline__)) size_type& size() {return __size_.first();}
    __attribute__ ((__always_inline__))
    const size_type& size() const noexcept {return __size_.first();}
    __attribute__ ((__always_inline__)) allocator_type& __alloc() {return __size_.second();}
    __attribute__ ((__always_inline__))
    const allocator_type& __alloc() const noexcept {return __size_.second();}

    __attribute__ ((__always_inline__))
    __deque_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__always_inline__))
    explicit __deque_base(const allocator_type& __a);
public:
    ~__deque_base();


    __deque_base(__deque_base&& __c)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __deque_base(__deque_base&& __c, const allocator_type& __a);


    void swap(__deque_base& __c)

        noexcept;




protected:
    void clear() noexcept;

    bool __invariants() const;

    __attribute__ ((__always_inline__))
    void __move_assign(__deque_base& __c)
        noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value)

    {
        __map_ = std::__1::move(__c.__map_);
        __start_ = __c.__start_;
        size() = __c.size();
        __move_assign_alloc(__c);
        __c.__start_ = __c.size() = 0;
    }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__deque_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)

        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

private:
    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__deque_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__deque_base&, false_type) noexcept
        {}
};

template <class _Tp, class _Allocator>
const typename __deque_base<_Tp, _Allocator>::difference_type
    __deque_base<_Tp, _Allocator>::__block_size =
        __deque_block_size<value_type, difference_type>::value;

template <class _Tp, class _Allocator>
bool
__deque_base<_Tp, _Allocator>::__invariants() const
{
    if (!__map_.__invariants())
        return false;
    if (__map_.size() >= size_type(-1) / __block_size)
        return false;
    for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();
         __i != __e; ++__i)
        if (*__i == nullptr)
            return false;
    if (__map_.size() != 0)
    {
        if (size() >= __map_.size() * __block_size)
            return false;
        if (__start_ >= __map_.size() * __block_size - size())
            return false;
    }
    else
    {
        if (size() != 0)
            return false;
        if (__start_ != 0)
            return false;
    }
    return true;
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::begin() noexcept
{
    __map_pointer __mp = __map_.begin() + __start_ / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::begin() const noexcept
{
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __start_ / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::end() noexcept
{
    size_type __p = size() + __start_;
    __map_pointer __mp = __map_.begin() + __p / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::end() const noexcept
{
    size_type __p = size() + __start_;
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline
__deque_base<_Tp, _Allocator>::__deque_base()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __start_(0), __size_(0) {}

template <class _Tp, class _Allocator>
inline
__deque_base<_Tp, _Allocator>::__deque_base(const allocator_type& __a)
    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {}

template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::~__deque_base()
{
    clear();
    typename __map::iterator __i = __map_.begin();
    typename __map::iterator __e = __map_.end();
    for (; __i != __e; ++__i)
        __alloc_traits::deallocate(__alloc(), *__i, __block_size);
}



template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __map_(std::__1::move(__c.__map_)),
      __start_(std::__1::move(__c.__start_)),
      __size_(std::__1::move(__c.__size_))
{
    __c.__start_ = 0;
    __c.size() = 0;
}

template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c, const allocator_type& __a)
    : __map_(std::__1::move(__c.__map_), __pointer_allocator(__a)),
      __start_(std::__1::move(__c.__start_)),
      __size_(std::__1::move(__c.size()), __a)
{
    if (__a == __c.__alloc())
    {
        __c.__start_ = 0;
        __c.size() = 0;
    }
    else
    {
        __map_.clear();
        __start_ = 0;
        size() = 0;
    }
}



template <class _Tp, class _Allocator>
void
__deque_base<_Tp, _Allocator>::swap(__deque_base& __c)

        noexcept




{
    __map_.swap(__c.__map_);
    std::__1::swap(__start_, __c.__start_);
    std::__1::swap(size(), __c.size());
    __swap_allocator(__alloc(), __c.__alloc());
}

template <class _Tp, class _Allocator>
void
__deque_base<_Tp, _Allocator>::clear() noexcept
{
    allocator_type& __a = __alloc();
    for (iterator __i = begin(), __e = end(); __i != __e; ++__i)
        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
    size() = 0;
    while (__map_.size() > 2)
    {
        __alloc_traits::deallocate(__a, __map_.front(), __block_size);
        __map_.pop_front();
    }
    switch (__map_.size())
    {
    case 1:
        __start_ = __block_size / 2;
        break;
    case 2:
        __start_ = __block_size;
        break;
    }
}

template <class _Tp, class _Allocator >
class deque
    : private __deque_base<_Tp, _Allocator>
{
public:


    typedef _Tp value_type;
    typedef _Allocator allocator_type;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef __deque_base<value_type, allocator_type> __base;

    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;

    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    __attribute__ ((__always_inline__))
    deque()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
        {}
    __attribute__ ((__always_inline__)) explicit deque(const allocator_type& __a) : __base(__a) {}
    explicit deque(size_type __n);

    explicit deque(size_type __n, const _Allocator& __a);

    deque(size_type __n, const value_type& __v);
    deque(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIter>
        deque(_InputIter __f, _InputIter __l,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);
    template <class _InputIter>
        deque(_InputIter __f, _InputIter __l, const allocator_type& __a,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);
    deque(const deque& __c);
    deque(const deque& __c, const allocator_type& __a);

    deque& operator=(const deque& __c);


    deque(initializer_list<value_type> __il);
    deque(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    deque& operator=(initializer_list<value_type> __il) {assign(__il); return *this;}

    __attribute__ ((__always_inline__))
    deque(deque&& __c) noexcept(is_nothrow_move_constructible<__base>::value);
    __attribute__ ((__always_inline__))
    deque(deque&& __c, const allocator_type& __a);
    __attribute__ ((__always_inline__))
    deque& operator=(deque&& __c)
        noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value);


    __attribute__ ((__always_inline__))
    void assign(initializer_list<value_type> __il) {assign(__il.begin(), __il.end());}


    template <class _InputIter>
        void assign(_InputIter __f, _InputIter __l,
                    typename enable_if<__is_input_iterator<_InputIter>::value &&
                                      !__is_random_access_iterator<_InputIter>::value>::type* = 0);
    template <class _RAIter>
        void assign(_RAIter __f, _RAIter __l,
                    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);
    void assign(size_type __n, const value_type& __v);

    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept;



    __attribute__ ((__always_inline__))
    iterator begin() noexcept {return __base::begin();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __base::begin();}
    __attribute__ ((__always_inline__))
    iterator end() noexcept {return __base::end();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __base::end();}

    __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(__base::end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(__base::end());}
    __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(__base::begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(__base::begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return __base::begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return __base::end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return const_reverse_iterator(__base::end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return const_reverse_iterator(__base::begin());}


    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __base::size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept
        {return std::min<size_type>(
            __alloc_traits::max_size(__base::__alloc()),
            numeric_limits<difference_type>::max());}
    void resize(size_type __n);
    void resize(size_type __n, const value_type& __v);
    void shrink_to_fit() noexcept;
    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __base::size() == 0;}


    __attribute__ ((__always_inline__))
    reference operator[](size_type __i);
    __attribute__ ((__always_inline__))
    const_reference operator[](size_type __i) const;
    __attribute__ ((__always_inline__))
    reference at(size_type __i);
    __attribute__ ((__always_inline__))
    const_reference at(size_type __i) const;
    __attribute__ ((__always_inline__))
    reference front();
    __attribute__ ((__always_inline__))
    const_reference front() const;
    __attribute__ ((__always_inline__))
    reference back();
    __attribute__ ((__always_inline__))
    const_reference back() const;


    void push_front(const value_type& __v);
    void push_back(const value_type& __v);





    template <class... _Args> void emplace_front(_Args&&... __args);
    template <class... _Args> void emplace_back (_Args&&... __args);

    template <class... _Args> iterator emplace(const_iterator __p, _Args&&... __args);

    void push_front(value_type&& __v);
    void push_back(value_type&& __v);
    iterator insert(const_iterator __p, value_type&& __v);

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, initializer_list<value_type> __il)
        {return insert(__p, __il.begin(), __il.end());}

    iterator insert(const_iterator __p, const value_type& __v);
    iterator insert(const_iterator __p, size_type __n, const value_type& __v);
    template <class _InputIter>
        iterator insert(const_iterator __p, _InputIter __f, _InputIter __l,
                         typename enable_if<__is_input_iterator<_InputIter>::value
                                         &&!__is_forward_iterator<_InputIter>::value>::type* = 0);
    template <class _ForwardIterator>
        iterator insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
                               typename enable_if<__is_forward_iterator<_ForwardIterator>::value
                                         &&!__is_bidirectional_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _BiIter>
        iterator insert(const_iterator __p, _BiIter __f, _BiIter __l,
                         typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type* = 0);

    void pop_front();
    void pop_back();
    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);

    __attribute__ ((__always_inline__))
    void swap(deque& __c)

        noexcept;




    __attribute__ ((__always_inline__))
    void clear() noexcept;

    __attribute__ ((__always_inline__))
    bool __invariants() const {return __base::__invariants();}
private:
    typedef typename __base::__map_const_pointer __map_const_pointer;

    __attribute__ ((__always_inline__))
    static size_type __recommend_blocks(size_type __n)
    {
        return __n / __base::__block_size + (__n % __base::__block_size != 0);
    }
    __attribute__ ((__always_inline__))
    size_type __capacity() const
    {
        return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;
    }
    __attribute__ ((__always_inline__))
    size_type __front_spare() const
    {
        return __base::__start_;
    }
    __attribute__ ((__always_inline__))
    size_type __back_spare() const
    {
        return __capacity() - (__base::__start_ + __base::size());
    }

    template <class _InpIter>
        void __append(_InpIter __f, _InpIter __l,
                 typename enable_if<__is_input_iterator<_InpIter>::value &&
                                   !__is_forward_iterator<_InpIter>::value>::type* = 0);
    template <class _ForIter>
        void __append(_ForIter __f, _ForIter __l,
                      typename enable_if<__is_forward_iterator<_ForIter>::value>::type* = 0);
    void __append(size_type __n);
    void __append(size_type __n, const value_type& __v);
    void __erase_to_end(const_iterator __f);
    void __add_front_capacity();
    void __add_front_capacity(size_type __n);
    void __add_back_capacity();
    void __add_back_capacity(size_type __n);
    iterator __move_and_check(iterator __f, iterator __l, iterator __r,
                              const_pointer& __vt);
    iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                       const_pointer& __vt);
    void __move_construct_and_check(iterator __f, iterator __l,
                                    iterator __r, const_pointer& __vt);
    void __move_construct_backward_and_check(iterator __f, iterator __l,
                                             iterator __r, const_pointer& __vt);

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const deque& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const deque& __c, true_type)
        {
            if (__base::__alloc() != __c.__alloc())
            {
                clear();
                shrink_to_fit();
            }
            __base::__alloc() = __c.__alloc();
            __base::__map_.__alloc() = __c.__map_.__alloc();
        }

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const deque&, false_type)
        {}

    void __move_assign(deque& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(deque& __c, false_type);
};

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n)
{
    if (__n > 0)
        __append(__n);
}


template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const _Allocator& __a)
    : __base(__a)
{
    if (__n > 0)
        __append(__n);
}


template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v)
{
    if (__n > 0)
        __append(__n, __v);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v, const allocator_type& __a)
    : __base(__a)
{
    if (__n > 0)
        __append(__n, __v);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)
{
    __append(__f, __l);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l, const allocator_type& __a,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)
    : __base(__a)
{
    __append(__f, __l);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c)
    : __base(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))
{
    __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c, const allocator_type& __a)
    : __base(__a)
{
    __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>&
deque<_Tp, _Allocator>::operator=(const deque& __c)
{
    if (this != &__c)
    {
        __copy_assign_alloc(__c);
        assign(__c.begin(), __c.end());
    }
    return *this;
}



template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il)
{
    __append(__il.begin(), __il.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{
    __append(__il.begin(), __il.end());
}

template <class _Tp, class _Allocator>
inline
deque<_Tp, _Allocator>::deque(deque&& __c)
    noexcept(is_nothrow_move_constructible<__base>::value)
    : __base(std::__1::move(__c))
{
}

template <class _Tp, class _Allocator>
inline
deque<_Tp, _Allocator>::deque(deque&& __c, const allocator_type& __a)
    : __base(std::__1::move(__c), __a)
{
    if (__a != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
inline
deque<_Tp, _Allocator>&
deque<_Tp, _Allocator>::operator=(deque&& __c)
        noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value)

{
    __move_assign(__c, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_assign(deque& __c, false_type)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_assign(deque& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    clear();
    shrink_to_fit();
    __base::__move_assign(__c);
}



template <class _Tp, class _Allocator>
template <class _InputIter>
void
deque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l,
                               typename enable_if<__is_input_iterator<_InputIter>::value &&
                                                 !__is_random_access_iterator<_InputIter>::value>::type*)
{
    iterator __i = __base::begin();
    iterator __e = __base::end();
    for (; __f != __l && __i != __e; ++__f, (void) ++__i)
        *__i = *__f;
    if (__f != __l)
        __append(__f, __l);
    else
        __erase_to_end(__i);
}

template <class _Tp, class _Allocator>
template <class _RAIter>
void
deque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l,
                               typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    if (static_cast<size_type>(__l - __f) > __base::size())
    {
        _RAIter __m = __f + __base::size();
        std::__1::copy(__f, __m, __base::begin());
        __append(__m, __l);
    }
    else
        __erase_to_end(std::__1::copy(__f, __l, __base::begin()));
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::assign(size_type __n, const value_type& __v)
{
    if (__n > __base::size())
    {
        std::__1::fill_n(__base::begin(), __base::size(), __v);
        __n -= __base::size();
        __append(__n, __v);
    }
    else
        __erase_to_end(std::__1::fill_n(__base::begin(), __n, __v));
}

template <class _Tp, class _Allocator>
inline
_Allocator
deque<_Tp, _Allocator>::get_allocator() const noexcept
{
    return __base::__alloc();
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::resize(size_type __n)
{
    if (__n > __base::size())
        __append(__n - __base::size());
    else if (__n < __base::size())
        __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::resize(size_type __n, const value_type& __v)
{
    if (__n > __base::size())
        __append(__n - __base::size(), __v);
    else if (__n < __base::size())
        __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    allocator_type& __a = __base::__alloc();
    if (empty())
    {
        while (__base::__map_.size() > 0)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
        __base::__start_ = 0;
    }
    else
    {
        if (__front_spare() >= __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
            __base::__map_.pop_front();
            __base::__start_ -= __base::__block_size;
        }
        if (__back_spare() >= __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
    }
    __base::__map_.shrink_to_fit();
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::operator[](size_type __i)
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::operator[](size_type __i) const
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::at(size_type __i)
{
    if (__i >= __base::size())
        __base::__throw_out_of_range();
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::at(size_type __i) const
{
    if (__i >= __base::size())
        __base::__throw_out_of_range();
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::front()
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)
                                      + __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::front() const
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)
                                      + __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::back()
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::back() const
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_back(const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() == 0)
        __add_back_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
    ++__base::size();
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_front(const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() == 0)
        __add_front_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
    --__base::__start_;
    ++__base::size();
}


template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_back(value_type&& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() == 0)
        __add_back_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), std::__1::move(__v));
    ++__base::size();
}

template <class _Tp, class _Allocator>
template <class... _Args>



void

deque<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() == 0)
        __add_back_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()),
                              std::__1::forward<_Args>(__args)...);
    ++__base::size();



}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_front(value_type&& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() == 0)
        __add_front_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::move(__v));
    --__base::__start_;
    ++__base::size();
}


template <class _Tp, class _Allocator>
template <class... _Args>



void

deque<_Tp, _Allocator>::emplace_front(_Args&&... __args)
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() == 0)
        __add_front_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::forward<_Args>(__args)...);
    --__base::__start_;
    ++__base::size();



}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, value_type&& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__front_spare() == 0)
            __add_front_capacity();

        if (__pos == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::move(__v));
            --__base::__start_;
            ++__base::size();
        }
        else
        {
            iterator __b = __base::begin();
            iterator __bm1 = std::__1::prev(__b);
            __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
            --__base::__start_;
            ++__base::size();
            if (__pos > 1)
                __b = std::__1::move(std::__1::next(__b), __b + __pos, __b);
            *__b = std::__1::move(__v);
        }
    }
    else
    {
        if (__back_spare() == 0)
            __add_back_capacity();

        size_type __de = __base::size() - __pos;
        if (__de == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), std::__1::move(__v));
            ++__base::size();
        }
        else
        {
            iterator __e = __base::end();
            iterator __em1 = std::__1::prev(__e);
            __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
            ++__base::size();
            if (__de > 1)
                __e = std::__1::move_backward(__e - __de, __em1, __e);
            *--__e = std::__1::move(__v);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::emplace(const_iterator __p, _Args&&... __args)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__front_spare() == 0)
            __add_front_capacity();

        if (__pos == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::forward<_Args>(__args)...);
            --__base::__start_;
            ++__base::size();
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            iterator __b = __base::begin();
            iterator __bm1 = std::__1::prev(__b);
            __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
            --__base::__start_;
            ++__base::size();
            if (__pos > 1)
                __b = std::__1::move(std::__1::next(__b), __b + __pos, __b);
            *__b = std::__1::move(__tmp.get());
        }
    }
    else
    {
        if (__back_spare() == 0)
            __add_back_capacity();

        size_type __de = __base::size() - __pos;
        if (__de == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), std::__1::forward<_Args>(__args)...);
            ++__base::size();
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            iterator __e = __base::end();
            iterator __em1 = std::__1::prev(__e);
            __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
            ++__base::size();
            if (__de > 1)
                __e = std::__1::move_backward(__e - __de, __em1, __e);
            *--__e = std::__1::move(__tmp.get());
        }
    }
    return __base::begin() + __pos;
}




template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, const value_type& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__front_spare() == 0)
            __add_front_capacity();

        if (__pos == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
            --__base::__start_;
            ++__base::size();
        }
        else
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __b = __base::begin();
            iterator __bm1 = std::__1::prev(__b);
            if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))
                __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
            __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
            --__base::__start_;
            ++__base::size();
            if (__pos > 1)
                __b = __move_and_check(std::__1::next(__b), __b + __pos, __b, __vt);
            *__b = *__vt;
        }
    }
    else
    {
        if (__back_spare() == 0)
            __add_back_capacity();

        size_type __de = __base::size() - __pos;
        if (__de == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
            ++__base::size();
        }
        else
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __e = __base::end();
            iterator __em1 = std::__1::prev(__e);
            if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))
                __vt = pointer_traits<const_pointer>::pointer_to(*__e);
            __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
            ++__base::size();
            if (__de > 1)
                __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);
            *--__e = *__vt;
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__n > __front_spare())
            __add_front_capacity(__n - __front_spare());

        iterator __old_begin = __base::begin();
        iterator __i = __old_begin;
        if (__n > __pos)
        {
            for (size_type __m = __n - __pos; __m; --__m, --__base::__start_, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), __v);
            __n = __pos;
        }
        if (__n > 0)
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __obn = __old_begin + __n;
            __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
            if (__n < __pos)
                __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
            std::__1::fill_n(__old_begin, __n, *__vt);
        }
    }
    else
    {
        size_type __back_capacity = __back_spare();
        if (__n > __back_capacity)
            __add_back_capacity(__n - __back_capacity);

        iterator __old_end = __base::end();
        iterator __i = __old_end;
        size_type __de = __base::size() - __pos;
        if (__n > __de)
        {
            for (size_type __m = __n - __de; __m; --__m, ++__i, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
            __n = __de;
        }
        if (__n > 0)
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __oen = __old_end - __n;
            __move_construct_and_check(__oen, __old_end, __i, __vt);
            if (__n < __de)
                __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
            std::__1::fill_n(__old_end - __n, __n, *__vt);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l,
                               typename enable_if<__is_input_iterator<_InputIter>::value
                                               &&!__is_forward_iterator<_InputIter>::value>::type*)
{
    __split_buffer<value_type, allocator_type&> __buf(__base::__alloc());
    __buf.__construct_at_end(__f, __l);
    typedef typename __split_buffer<value_type, allocator_type&>::iterator __bi;
    return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
                               typename enable_if<__is_forward_iterator<_ForwardIterator>::value
                                               &&!__is_bidirectional_iterator<_ForwardIterator>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    __split_buffer<value_type, allocator_type&> __buf(__n, 0, __base::__alloc());
    __buf.__construct_at_end(__f, __l);
    typedef typename __split_buffer<value_type, allocator_type&>::iterator __fwd;
    return insert(__p, move_iterator<__fwd>(__buf.begin()), move_iterator<__fwd>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _BiIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l,
                               typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__n > __front_spare())
            __add_front_capacity(__n - __front_spare());

        iterator __old_begin = __base::begin();
        iterator __i = __old_begin;
        _BiIter __m = __f;
        if (__n > __pos)
        {
            __m = __pos < __n / 2 ? std::__1::prev(__l, __pos) : std::__1::next(__f, __n - __pos);
            for (_BiIter __j = __m; __j != __f; --__base::__start_, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), *--__j);
            __n = __pos;
        }
        if (__n > 0)
        {
            iterator __obn = __old_begin + __n;
            for (iterator __j = __obn; __j != __old_begin;)
            {
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), std::__1::move(*--__j));
                --__base::__start_;
                ++__base::size();
            }
            if (__n < __pos)
                __old_begin = std::__1::move(__obn, __old_begin + __pos, __old_begin);
            std::__1::copy(__m, __l, __old_begin);
        }
    }
    else
    {
        size_type __back_capacity = __back_spare();
        if (__n > __back_capacity)
            __add_back_capacity(__n - __back_capacity);

        iterator __old_end = __base::end();
        iterator __i = __old_end;
        _BiIter __m = __l;
        size_type __de = __base::size() - __pos;
        if (__n > __de)
        {
            __m = __de < __n / 2 ? std::__1::next(__f, __de) : std::__1::prev(__l, __n - __de);
            for (_BiIter __j = __m; __j != __l; ++__i, (void) ++__j, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), *__j);
            __n = __de;
        }
        if (__n > 0)
        {
            iterator __oen = __old_end - __n;
            for (iterator __j = __oen; __j != __old_end; ++__i, ++__j, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), std::__1::move(*__j));
            if (__n < __de)
                __old_end = std::__1::move_backward(__old_end - __de, __oen, __old_end);
            std::__1::copy_backward(__f, __m, __old_end);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InpIter>
void
deque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l,
                                 typename enable_if<__is_input_iterator<_InpIter>::value &&
                                                   !__is_forward_iterator<_InpIter>::value>::type*)
{
    for (; __f != __l; ++__f)



        emplace_back(*__f);

}

template <class _Tp, class _Allocator>
template <class _ForIter>
void
deque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l,
                                 typename enable_if<__is_forward_iterator<_ForIter>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (iterator __i = __base::end(); __f != __l; ++__i, (void) ++__f, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i), *__f);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__append(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i));
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__append(size_type __n, const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_front_capacity()
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() >= __base::__block_size)
    {
        __base::__start_ += __base::__block_size;
        pointer __pt = __base::__map_.back();
        __base::__map_.pop_back();
        __base::__map_.push_front(__pt);
    }

    else if (__base::__map_.size() < __base::__map_.capacity())
    {


        if (__base::__map_.__front_spare() > 0)
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
        else
        {
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));

            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
        __base::__start_ = __base::__map_.size() == 1 ?
                               __base::__block_size / 2 :
                               __base::__start_ + __base::__block_size;
    }

    else
    {
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2 * __base::__map_.capacity(), 1),
                  0, __base::__map_.__alloc());

        typedef __allocator_destructor<_Allocator> _Dp;
        unique_ptr<pointer, _Dp> __hold(
            __alloc_traits::allocate(__a, __base::__block_size),
                _Dp(__a, __base::__block_size));
        __buf.push_back(__hold.get());
        __hold.release();

        for (typename __base::__map_pointer __i = __base::__map_.begin();
                __i != __base::__map_.end(); ++__i)
            __buf.push_back(*__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ = __base::__map_.size() == 1 ?
                               __base::__block_size / 2 :
                               __base::__start_ + __base::__block_size;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_front_capacity(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

    size_type __back_capacity = __back_spare() / __base::__block_size;
    __back_capacity = std::__1::min(__back_capacity, __nb);
    __nb -= __back_capacity;

    if (__nb == 0)
    {
        __base::__start_ += __base::__block_size * __back_capacity;
        for (; __back_capacity > 0; --__back_capacity)
        {
            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
    }

    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {


        for (; __nb > 0; --__nb, __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))
        {
            if (__base::__map_.__front_spare() == 0)
                break;
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
        }
        for (; __nb > 0; --__nb, ++__back_capacity)
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));

        __base::__start_ += __back_capacity * __base::__block_size;
        for (; __back_capacity > 0; --__back_capacity)
        {
            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
    }

    else
    {
        size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(),
                                 __nb + __base::__map_.size()),
                  0, __base::__map_.__alloc());




            for (; __nb > 0; --__nb)
                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
# 2404 "../../buildtools/third_party/libc++/trunk/include/deque" 3
        for (; __back_capacity > 0; --__back_capacity)
        {
            __buf.push_back(__base::__map_.back());
            __base::__map_.pop_back();
        }
        for (typename __base::__map_pointer __i = __base::__map_.begin();
                __i != __base::__map_.end(); ++__i)
            __buf.push_back(*__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ += __ds;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_back_capacity()
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() >= __base::__block_size)
    {
        __base::__start_ -= __base::__block_size;
        pointer __pt = __base::__map_.front();
        __base::__map_.pop_front();
        __base::__map_.push_back(__pt);
    }

    else if (__base::__map_.size() < __base::__map_.capacity())
    {


        if (__base::__map_.__back_spare() != 0)
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
        else
        {
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));

            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else
    {
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(), 1),
                  __base::__map_.size(),
                  __base::__map_.__alloc());

        typedef __allocator_destructor<_Allocator> _Dp;
        unique_ptr<pointer, _Dp> __hold(
            __alloc_traits::allocate(__a, __base::__block_size),
                _Dp(__a, __base::__block_size));
        __buf.push_back(__hold.get());
        __hold.release();

        for (typename __base::__map_pointer __i = __base::__map_.end();
                __i != __base::__map_.begin();)
            __buf.push_front(*--__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_back_capacity(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

    size_type __front_capacity = __front_spare() / __base::__block_size;
    __front_capacity = std::__1::min(__front_capacity, __nb);
    __nb -= __front_capacity;

    if (__nb == 0)
    {
        __base::__start_ -= __base::__block_size * __front_capacity;
        for (; __front_capacity > 0; --__front_capacity)
        {
            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {


        for (; __nb > 0; --__nb)
        {
            if (__base::__map_.__back_spare() == 0)
                break;
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
        }
        for (; __nb > 0; --__nb, ++__front_capacity, __base::__start_ +=
                                 __base::__block_size - (__base::__map_.size() == 1))
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));

        __base::__start_ -= __base::__block_size * __front_capacity;
        for (; __front_capacity > 0; --__front_capacity)
        {
            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else
    {
        size_type __ds = __front_capacity * __base::__block_size;
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(),
                                 __nb + __base::__map_.size()),
                  __base::__map_.size() - __front_capacity,
                  __base::__map_.__alloc());




            for (; __nb > 0; --__nb)
                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
# 2546 "../../buildtools/third_party/libc++/trunk/include/deque" 3
        for (; __front_capacity > 0; --__front_capacity)
        {
            __buf.push_back(__base::__map_.front());
            __base::__map_.pop_front();
        }
        for (typename __base::__map_pointer __i = __base::__map_.end();
                __i != __base::__map_.begin();)
            __buf.push_front(*--__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ -= __ds;
    }
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::pop_front()
{
    allocator_type& __a = __base::__alloc();
    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +
                                                    __base::__start_ / __base::__block_size) +
                                                    __base::__start_ % __base::__block_size));
    --__base::size();
    if (++__base::__start_ >= 2 * __base::__block_size)
    {
        __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
        __base::__map_.pop_front();
        __base::__start_ -= __base::__block_size;
    }
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::pop_back()
{
    allocator_type& __a = __base::__alloc();
    size_type __p = __base::size() + __base::__start_ - 1;
    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +
                                                    __p / __base::__block_size) +
                                                    __p % __base::__block_size));
    --__base::size();
    if (__back_spare() >= 2 * __base::__block_size)
    {
        __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
        __base::__map_.pop_back();
    }
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r,
                                         const_pointer& __vt)
{



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __base::__block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        if (__fb <= __vt && __vt < __fe)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                                  const_pointer& __vt)
{



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        if (__lb <= __vt && __vt < __le)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l,
                                                   iterator __r, const_pointer& __vt)
{
    allocator_type& __a = __base::__alloc();



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __base::__block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        if (__fb <= __vt && __vt < __fe)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;
        for (; __fb != __fe; ++__fb, ++__r, ++__base::size())
            __alloc_traits::construct(__a, std::__1::addressof(*__r), std::__1::move(*__fb));
        __n -= __bs;
        __f += __bs;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_construct_backward_and_check(iterator __f, iterator __l,
                                                            iterator __r, const_pointer& __vt)
{
    allocator_type& __a = __base::__alloc();







    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        if (__lb <= __vt && __vt < __le)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;
        while (__le != __lb)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__r), std::__1::move(*--__le));
            --__base::__start_;
            ++__base::size();
        }
        __n -= __bs;
        __l -= __bs - 1;
    }
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f)
{
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    allocator_type& __a = __base::__alloc();
    if (static_cast<size_t>(__pos) <= (__base::size() - 1) / 2)
    {
        std::__1::move_backward(__b, __p, std::__1::next(__p));
        __alloc_traits::destroy(__a, std::__1::addressof(*__b));
        --__base::size();
        ++__base::__start_;
        if (__front_spare() >= 2 * __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
            __base::__map_.pop_front();
            __base::__start_ -= __base::__block_size;
        }
    }
    else
    {
        iterator __i = std::__1::move(std::__1::next(__p), __base::end(), __p);
        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
        --__base::size();
        if (__back_spare() >= 2 * __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    difference_type __n = __l - __f;
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    if (__n > 0)
    {
        allocator_type& __a = __base::__alloc();
        if (static_cast<size_t>(__pos) <= (__base::size() - __n) / 2)
        {
            iterator __i = std::__1::move_backward(__b, __p, __p + __n);
            for (; __b != __i; ++__b)
                __alloc_traits::destroy(__a, std::__1::addressof(*__b));
            __base::size() -= __n;
            __base::__start_ += __n;
            while (__front_spare() >= 2 * __base::__block_size)
            {
                __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
                __base::__map_.pop_front();
                __base::__start_ -= __base::__block_size;
            }
        }
        else
        {
            iterator __i = std::__1::move(__p + __n, __base::end(), __p);
            for (iterator __e = __base::end(); __i != __e; ++__i)
                __alloc_traits::destroy(__a, std::__1::addressof(*__i));
            __base::size() -= __n;
            while (__back_spare() >= 2 * __base::__block_size)
            {
                __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
                __base::__map_.pop_back();
            }
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__erase_to_end(const_iterator __f)
{
    iterator __e = __base::end();
    difference_type __n = __e - __f;
    if (__n > 0)
    {
        allocator_type& __a = __base::__alloc();
        iterator __b = __base::begin();
        difference_type __pos = __f - __b;
        for (iterator __p = __b + __pos; __p != __e; ++__p)
            __alloc_traits::destroy(__a, std::__1::addressof(*__p));
        __base::size() -= __n;
        while (__back_spare() >= 2 * __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
    }
}

template <class _Tp, class _Allocator>
inline
void
deque<_Tp, _Allocator>::swap(deque& __c)

        noexcept




{
    __base::swap(__c);
}

template <class _Tp, class _Allocator>
inline
void
deque<_Tp, _Allocator>::clear() noexcept
{
    __base::clear();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(deque<_Tp, _Allocator>& __x, deque<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 87 "../../buildtools/third_party/libc++/trunk/include/stack" 2 3
# 90 "../../buildtools/third_party/libc++/trunk/include/stack" 3


namespace std {inline namespace __1 {

template <class _Tp, class _Container = deque<_Tp> > class stack;

template <class _Tp, class _Container>
__attribute__ ((__always_inline__))
bool
operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container>
__attribute__ ((__always_inline__))
bool
operator< (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container >
class stack
{
public:
    typedef _Container container_type;
    typedef typename container_type::value_type value_type;
    typedef typename container_type::reference reference;
    typedef typename container_type::const_reference const_reference;
    typedef typename container_type::size_type size_type;
    static_assert((is_same<_Tp, value_type>::value), "" );

protected:
    container_type c;

public:
    __attribute__ ((__always_inline__))
    stack()
        noexcept(is_nothrow_default_constructible<container_type>::value)
        : c() {}

    __attribute__ ((__always_inline__))
    stack(const stack& __q) : c(__q.c) {}

    __attribute__ ((__always_inline__))
    stack& operator=(const stack& __q) {c = __q.c; return *this;}



    __attribute__ ((__always_inline__))
    stack(stack&& __q)
        noexcept(is_nothrow_move_constructible<container_type>::value)
        : c(std::__1::move(__q.c)) {}

    __attribute__ ((__always_inline__))
    stack& operator=(stack&& __q)
        noexcept(is_nothrow_move_assignable<container_type>::value)
        {c = std::__1::move(__q.c); return *this;}

    __attribute__ ((__always_inline__))
    explicit stack(container_type&& __c) : c(std::__1::move(__c)) {}


    __attribute__ ((__always_inline__))
    explicit stack(const container_type& __c) : c(__c) {}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        explicit stack(const _Alloc& __a,
                       typename enable_if<uses_allocator<container_type,
                                                         _Alloc>::value>::type* = 0)
            : c(__a) {}
    template <class _Alloc>
        __attribute__ ((__always_inline__))
        stack(const container_type& __c, const _Alloc& __a,
              typename enable_if<uses_allocator<container_type,
                                                _Alloc>::value>::type* = 0)
            : c(__c, __a) {}
    template <class _Alloc>
        __attribute__ ((__always_inline__))
        stack(const stack& __s, const _Alloc& __a,
              typename enable_if<uses_allocator<container_type,
                                                _Alloc>::value>::type* = 0)
            : c(__s.c, __a) {}

    template <class _Alloc>
        __attribute__ ((__always_inline__))
        stack(container_type&& __c, const _Alloc& __a,
              typename enable_if<uses_allocator<container_type,
                                                _Alloc>::value>::type* = 0)
            : c(std::__1::move(__c), __a) {}
    template <class _Alloc>
        __attribute__ ((__always_inline__))
        stack(stack&& __s, const _Alloc& __a,
              typename enable_if<uses_allocator<container_type,
                                                _Alloc>::value>::type* = 0)
            : c(std::__1::move(__s.c), __a) {}


    __attribute__ ((__always_inline__))
    bool empty() const {return c.empty();}
    __attribute__ ((__always_inline__))
    size_type size() const {return c.size();}
    __attribute__ ((__always_inline__))
    reference top() {return c.back();}
    __attribute__ ((__always_inline__))
    const_reference top() const {return c.back();}

    __attribute__ ((__always_inline__))
    void push(const value_type& __v) {c.push_back(__v);}

    __attribute__ ((__always_inline__))
    void push(value_type&& __v) {c.push_back(std::__1::move(__v));}

    template <class... _Args>
        __attribute__ ((__always_inline__))




        void emplace(_Args&&... __args)
        { c.emplace_back(std::__1::forward<_Args>(__args)...);}



    __attribute__ ((__always_inline__))
    void pop() {c.pop_back();}

    __attribute__ ((__always_inline__))
    void swap(stack& __s)
        noexcept(__is_nothrow_swappable<container_type>::value)
    {
        using std::__1::swap;
        swap(c, __s.c);
    }

    template <class T1, class _C1>
    friend
    bool
    operator==(const stack<T1, _C1>& __x, const stack<T1, _C1>& __y);

    template <class T1, class _C1>
    friend
    bool
    operator< (const stack<T1, _C1>& __x, const stack<T1, _C1>& __y);
};

template <class _Tp, class _Container>
inline __attribute__ ((__always_inline__))
bool
operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __x.c == __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__always_inline__))
bool
operator< (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __x.c < __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__always_inline__))
bool
operator!=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__always_inline__))
bool
operator> (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Container>
inline __attribute__ ((__always_inline__))
bool
operator>=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__always_inline__))
bool
operator<=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Container>
inline __attribute__ ((__always_inline__))
typename enable_if<
    __is_swappable<_Container>::value,
    void
>::type
swap(stack<_Tp, _Container>& __x, stack<_Tp, _Container>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, class _Container, class _Alloc>
struct uses_allocator<stack<_Tp, _Container>, _Alloc>
    : public uses_allocator<_Container, _Alloc>
{
};

} }
# 9 "../../base/containers/stack.h" 2

# 1 "../../base/containers/circular_deque.h" 1
# 14 "../../base/containers/circular_deque.h"
# 1 "../../base/containers/vector_buffer.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stdlib.h" 1 3
# 9 "../../base/containers/vector_buffer.h" 2








namespace base {
namespace internal {
# 37 "../../base/containers/vector_buffer.h"
template <typename T>
class VectorBuffer {
 public:
  VectorBuffer() {}




  __attribute__((no_sanitize("cfi-unrelated-cast", "vptr")))

  VectorBuffer(size_t count)
      : buffer_(reinterpret_cast<T*>(malloc(sizeof(T) * count))),
        capacity_(count) {
  }
  VectorBuffer(VectorBuffer&& other) noexcept
      : buffer_(other.buffer_), capacity_(other.capacity_) {
    other.buffer_ = nullptr;
    other.capacity_ = 0;
  }

  ~VectorBuffer() { free(buffer_); }

  VectorBuffer& operator=(VectorBuffer&& other) {
    free(buffer_);
    buffer_ = other.buffer_;
    capacity_ = other.capacity_;

    other.buffer_ = nullptr;
    other.capacity_ = 0;
    return *this;
  }

  size_t capacity() const { return capacity_; }

  T& operator[](size_t i) { return buffer_[i]; }
  const T& operator[](size_t i) const { return buffer_[i]; }
  T* begin() { return buffer_; }
  T* end() { return &buffer_[capacity_]; }




  template <typename T2 = T,
            typename std::enable_if<std::is_trivially_destructible<T2>::value,
                                    int>::type = 0>
  void DestructRange(T* begin, T* end) {}



  template <typename T2 = T,
            typename std::enable_if<!std::is_trivially_destructible<T2>::value,
                                    int>::type = 0>
  void DestructRange(T* begin, T* end) {
    while (begin != end) {
      begin->~T();
      begin++;
    }
  }
# 107 "../../base/containers/vector_buffer.h"
  template <typename T2 = T,
            typename std::enable_if<base::is_trivially_copyable<T2>::value,
                                    int>::type = 0>
  static void MoveRange(T* from_begin, T* from_end, T* to) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!RangesOverlap(from_begin, from_end, to));
    memcpy(to, from_begin, (from_end - from_begin) * sizeof(T));
  }



  template <typename T2 = T,
            typename std::enable_if<std::is_move_constructible<T2>::value &&
                                        !base::is_trivially_copyable<T2>::value,
                                    int>::type = 0>
  static void MoveRange(T* from_begin, T* from_end, T* to) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!RangesOverlap(from_begin, from_end, to));
    while (from_begin != from_end) {
      new (to) T(std::move(*from_begin));
      from_begin->~T();
      from_begin++;
      to++;
    }
  }



  template <typename T2 = T,
            typename std::enable_if<!std::is_move_constructible<T2>::value &&
                                        !base::is_trivially_copyable<T2>::value,
                                    int>::type = 0>
  static void MoveRange(T* from_begin, T* from_end, T* to) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!RangesOverlap(from_begin, from_end, to));
    while (from_begin != from_end) {
      new (to) T(*from_begin);
      from_begin->~T();
      from_begin++;
      to++;
    }
  }

 private:
  static bool RangesOverlap(const T* from_begin,
                            const T* from_end,
                            const T* to) {
    return !(to >= from_end || to + (from_end - from_begin) <= from_begin);
  }

  T* buffer_ = nullptr;
  size_t capacity_ = 0;

  VectorBuffer(const VectorBuffer&) = delete; VectorBuffer& operator=(const VectorBuffer&) = delete;
};

}
}
# 15 "../../base/containers/circular_deque.h" 2
# 117 "../../base/containers/circular_deque.h"
namespace base {

template <class T>
class circular_deque;

namespace internal {





constexpr size_t kCircularBufferInitialCapacity = 3;

template <typename T>
class circular_deque_const_iterator {
 public:
  using difference_type = std::ptrdiff_t;
  using value_type = T;
  using pointer = const T*;
  using reference = const T&;
  using iterator_category = std::random_access_iterator_tag;

  circular_deque_const_iterator() : parent_deque_(nullptr), index_(0) {



  }


  const T& operator*() const {
    CheckUnstableUsage();
    parent_deque_->CheckValidIndex(index_);
    return parent_deque_->buffer_[index_];
  }
  const T* operator->() const {
    CheckUnstableUsage();
    parent_deque_->CheckValidIndex(index_);
    return &parent_deque_->buffer_[index_];
  }
  const value_type& operator[](difference_type i) const { return *(*this + i); }


  circular_deque_const_iterator& operator++() {
    Increment();
    return *this;
  }
  circular_deque_const_iterator operator++(int) {
    circular_deque_const_iterator ret = *this;
    Increment();
    return ret;
  }
  circular_deque_const_iterator& operator--() {
    Decrement();
    return *this;
  }
  circular_deque_const_iterator operator--(int) {
    circular_deque_const_iterator ret = *this;
    Decrement();
    return ret;
  }


  friend circular_deque_const_iterator operator+(
      const circular_deque_const_iterator& iter,
      difference_type offset) {
    circular_deque_const_iterator ret = iter;
    ret.Add(offset);
    return ret;
  }
  circular_deque_const_iterator& operator+=(difference_type offset) {
    Add(offset);
    return *this;
  }
  friend circular_deque_const_iterator operator-(
      const circular_deque_const_iterator& iter,
      difference_type offset) {
    circular_deque_const_iterator ret = iter;
    ret.Add(-offset);
    return ret;
  }
  circular_deque_const_iterator& operator-=(difference_type offset) {
    Add(-offset);
    return *this;
  }

  friend std::ptrdiff_t operator-(const circular_deque_const_iterator& lhs,
                                  const circular_deque_const_iterator& rhs) {
    lhs.CheckComparable(rhs);
    return lhs.OffsetFromBegin() - rhs.OffsetFromBegin();
  }


  friend bool operator==(const circular_deque_const_iterator& lhs,
                         const circular_deque_const_iterator& rhs) {
    lhs.CheckComparable(rhs);
    return lhs.index_ == rhs.index_;
  }
  friend bool operator!=(const circular_deque_const_iterator& lhs,
                         const circular_deque_const_iterator& rhs) {
    return !(lhs == rhs);
  }
  friend bool operator<(const circular_deque_const_iterator& lhs,
                        const circular_deque_const_iterator& rhs) {
    lhs.CheckComparable(rhs);
    return lhs.OffsetFromBegin() < rhs.OffsetFromBegin();
  }
  friend bool operator<=(const circular_deque_const_iterator& lhs,
                         const circular_deque_const_iterator& rhs) {
    return !(lhs > rhs);
  }
  friend bool operator>(const circular_deque_const_iterator& lhs,
                        const circular_deque_const_iterator& rhs) {
    lhs.CheckComparable(rhs);
    return lhs.OffsetFromBegin() > rhs.OffsetFromBegin();
  }
  friend bool operator>=(const circular_deque_const_iterator& lhs,
                         const circular_deque_const_iterator& rhs) {
    return !(lhs < rhs);
  }

 protected:
  friend class circular_deque<T>;

  circular_deque_const_iterator(const circular_deque<T>* parent, size_t index)
      : parent_deque_(parent), index_(index) {



  }



  size_t OffsetFromBegin() const {
    if (index_ >= parent_deque_->begin_)
      return index_ - parent_deque_->begin_;
    return parent_deque_->buffer_.capacity() - parent_deque_->begin_ + index_;
  }


  void Increment() {
    CheckUnstableUsage();
    parent_deque_->CheckValidIndex(index_);
    index_++;
    if (index_ == parent_deque_->buffer_.capacity())
      index_ = 0;
  }
  void Decrement() {
    CheckUnstableUsage();
    parent_deque_->CheckValidIndexOrEnd(index_);
    if (index_ == 0)
      index_ = parent_deque_->buffer_.capacity() - 1;
    else
      index_--;
  }
  void Add(difference_type delta) {
    CheckUnstableUsage();
# 283 "../../base/containers/circular_deque.h"
    if (delta == 0)
      return;

    difference_type new_offset = OffsetFromBegin() + delta;
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(new_offset >= 0 && new_offset <= static_cast<difference_type>(parent_deque_->size()));

    index_ = (new_offset + parent_deque_->begin_) %
             parent_deque_->buffer_.capacity();
  }
# 311 "../../base/containers/circular_deque.h"
  inline void CheckUnstableUsage() const {}
  inline void CheckComparable(const circular_deque_const_iterator&) const {}


  const circular_deque<T>* parent_deque_;
  size_t index_;







};

template <typename T>
class circular_deque_iterator : public circular_deque_const_iterator<T> {
  using base = circular_deque_const_iterator<T>;

 public:
  friend class circular_deque<T>;

  using difference_type = std::ptrdiff_t;
  using value_type = T;
  using pointer = T*;
  using reference = T&;
  using iterator_category = std::random_access_iterator_tag;


  circular_deque_iterator() : circular_deque_const_iterator<T>() {}


  T& operator*() const { return const_cast<T&>(base::operator*()); }
  T* operator->() const { return const_cast<T*>(base::operator->()); }
  T& operator[](difference_type i) {
    return const_cast<T&>(base::operator[](i));
  }


  friend circular_deque_iterator operator+(const circular_deque_iterator& iter,
                                           difference_type offset) {
    circular_deque_iterator ret = iter;
    ret.Add(offset);
    return ret;
  }
  circular_deque_iterator& operator+=(difference_type offset) {
    base::Add(offset);
    return *this;
  }
  friend circular_deque_iterator operator-(const circular_deque_iterator& iter,
                                           difference_type offset) {
    circular_deque_iterator ret = iter;
    ret.Add(-offset);
    return ret;
  }
  circular_deque_iterator& operator-=(difference_type offset) {
    base::Add(-offset);
    return *this;
  }


  circular_deque_iterator& operator++() {
    base::Increment();
    return *this;
  }
  circular_deque_iterator operator++(int) {
    circular_deque_iterator ret = *this;
    base::Increment();
    return ret;
  }
  circular_deque_iterator& operator--() {
    base::Decrement();
    return *this;
  }
  circular_deque_iterator operator--(int) {
    circular_deque_iterator ret = *this;
    base::Decrement();
    return ret;
  }

 private:
  circular_deque_iterator(const circular_deque<T>* parent, size_t index)
      : circular_deque_const_iterator<T>(parent, index) {}
};

}

template <typename T>
class circular_deque {
 private:
  using VectorBuffer = internal::VectorBuffer<T>;

 public:
  using value_type = T;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;
  using reference = value_type&;
  using const_reference = const value_type&;
  using pointer = value_type*;
  using const_pointer = const value_type*;

  using iterator = internal::circular_deque_iterator<T>;
  using const_iterator = internal::circular_deque_const_iterator<T>;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;




  circular_deque() = default;


  circular_deque(size_type count) { resize(count); }
  circular_deque(size_type count, const T& value) { resize(count, value); }


  template <class InputIterator>
  circular_deque(InputIterator first, InputIterator last) {
    assign(first, last);
  }


  circular_deque(const circular_deque& other) : buffer_(other.size() + 1) {
    assign(other.begin(), other.end());
  }
  circular_deque(circular_deque&& other) noexcept
      : buffer_(std::move(other.buffer_)),
        begin_(other.begin_),
        end_(other.end_) {
    other.begin_ = 0;
    other.end_ = 0;
  }

  circular_deque(std::initializer_list<value_type> init) { assign(init); }

  ~circular_deque() { DestructRange(begin_, end_); }






  circular_deque& operator=(const circular_deque& other) {
    if (&other == this)
      return *this;

    reserve(other.size());
    assign(other.begin(), other.end());
    return *this;
  }
  circular_deque& operator=(circular_deque&& other) noexcept {
    if (&other == this)
      return *this;



    ClearRetainCapacity();
    buffer_ = std::move(other.buffer_);
    begin_ = other.begin_;
    end_ = other.end_;

    other.begin_ = 0;
    other.end_ = 0;

    IncrementGeneration();
    return *this;
  }
  circular_deque& operator=(std::initializer_list<value_type> ilist) {
    reserve(ilist.size());
    assign(std::begin(ilist), std::end(ilist));
    return *this;
  }

  void assign(size_type count, const value_type& value) {
    ClearRetainCapacity();
    reserve(count);
    for (size_t i = 0; i < count; i++)
      emplace_back(value);
    IncrementGeneration();
  }


  template <typename InputIterator>
  typename std::enable_if<::base::internal::is_iterator<InputIterator>::value,
                          void>::type
  assign(InputIterator first, InputIterator last) {



    ClearRetainCapacity();
    for (; first != last; ++first)
      emplace_back(*first);
    IncrementGeneration();
  }

  void assign(std::initializer_list<value_type> value) {
    reserve(std::distance(value.begin(), value.end()));
    assign(value.begin(), value.end());
  }






  const value_type& at(size_type i) const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(i < size());
    size_t right_size = buffer_.capacity() - begin_;
    if (begin_ <= end_ || i < right_size)
      return buffer_[begin_ + i];
    return buffer_[i - right_size];
  }
  value_type& at(size_type i) {
    return const_cast<value_type&>(
        const_cast<const circular_deque*>(this)->at(i));
  }

  value_type& operator[](size_type i) { return at(i); }
  const value_type& operator[](size_type i) const {
    return const_cast<circular_deque*>(this)->at(i);
  }

  value_type& front() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!empty());
    return buffer_[begin_];
  }
  const value_type& front() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!empty());
    return buffer_[begin_];
  }

  value_type& back() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!empty());
    return *(--end());
  }
  const value_type& back() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!empty());
    return *(--end());
  }




  iterator begin() { return iterator(this, begin_); }
  const_iterator begin() const { return const_iterator(this, begin_); }
  const_iterator cbegin() const { return const_iterator(this, begin_); }

  iterator end() { return iterator(this, end_); }
  const_iterator end() const { return const_iterator(this, end_); }
  const_iterator cend() const { return const_iterator(this, end_); }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crbegin() const { return rbegin(); }

  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crend() const { return rend(); }
# 585 "../../base/containers/circular_deque.h"
  void reserve(size_type new_capacity) {
    if (new_capacity > capacity())
      SetCapacityTo(new_capacity);
  }

  size_type capacity() const {

    return buffer_.capacity() == 0 ? 0 : buffer_.capacity() - 1;
  }

  void shrink_to_fit() {
    if (empty()) {


      if (buffer_.capacity())
        buffer_ = VectorBuffer();
    } else {
      SetCapacityTo(size());
    }
  }





  void clear() {


    ClearRetainCapacity();
    buffer_ = VectorBuffer();
  }

  bool empty() const { return begin_ == end_; }

  size_type size() const {
    if (begin_ <= end_)
      return end_ - begin_;
    return buffer_.capacity() - begin_ + end_;
  }
# 636 "../../base/containers/circular_deque.h"
  void resize(size_type count) {

    if (count > size()) {




      ExpandCapacityIfNecessary(count - size());
      while (size() < count)
        emplace_back();
    } else if (count < size()) {
      size_t new_end = (begin_ + count) % buffer_.capacity();
      DestructRange(new_end, end_);
      end_ = new_end;

      ShrinkCapacityIfNecessary();
    }
    IncrementGeneration();
  }
  void resize(size_type count, const value_type& value) {

    if (count > size()) {
      ExpandCapacityIfNecessary(count - size());
      while (size() < count)
        emplace_back(value);
    } else if (count < size()) {
      size_t new_end = (begin_ + count) % buffer_.capacity();
      DestructRange(new_end, end_);
      end_ = new_end;

      ShrinkCapacityIfNecessary();
    }
    IncrementGeneration();
  }
# 685 "../../base/containers/circular_deque.h"
  void insert(const_iterator pos, size_type count, const T& value) {
    ValidateIterator(pos);


    if (pos == begin()) {
      ExpandCapacityIfNecessary(count);
      for (size_t i = 0; i < count; i++)
        push_front(value);
      return;
    }

    iterator insert_cur(this, pos.index_);
    iterator insert_end;
    MakeRoomFor(count, &insert_cur, &insert_end);
    while (insert_cur < insert_end) {
      new (&buffer_[insert_cur.index_]) T(value);
      ++insert_cur;
    }

    IncrementGeneration();
  }



  template <class InputIterator>
  typename std::enable_if<::base::internal::is_iterator<InputIterator>::value,
                          void>::type
  insert(const_iterator pos, InputIterator first, InputIterator last) {
    ValidateIterator(pos);

    size_t inserted_items = std::distance(first, last);
    if (inserted_items == 0)
      return;


    iterator insert_cur;
    iterator insert_end;
    if (pos == begin()) {


      ExpandCapacityIfNecessary(inserted_items);
      insert_end = begin();
      begin_ =
          (begin_ + buffer_.capacity() - inserted_items) % buffer_.capacity();
      insert_cur = begin();
    } else {
      insert_cur = iterator(this, pos.index_);
      MakeRoomFor(inserted_items, &insert_cur, &insert_end);
    }


    while (insert_cur < insert_end) {
      new (&buffer_[insert_cur.index_]) T(*first);
      ++insert_cur;
      ++first;
    }

    IncrementGeneration();
  }



  iterator insert(const_iterator pos, const T& value) {
    return emplace(pos, value);
  }
  iterator insert(const_iterator pos, T&& value) {
    return emplace(pos, std::move(value));
  }
  template <class... Args>
  iterator emplace(const_iterator pos, Args&&... args) {
    ValidateIterator(pos);


    if (pos == cbegin()) {
      emplace_front(std::forward<Args>(args)...);
      return begin();
    }


    IncrementGeneration();

    iterator insert_begin(this, pos.index_);
    iterator insert_end;
    MakeRoomFor(1, &insert_begin, &insert_end);
    new (&buffer_[insert_begin.index_]) T(std::forward<Args>(args)...);

    return insert_begin;
  }







  iterator erase(const_iterator pos) { return erase(pos, pos + 1); }
  iterator erase(const_iterator first, const_iterator last) {
    ValidateIterator(first);
    ValidateIterator(last);

    IncrementGeneration();


    if (first.index_ == last.index_) {


      return iterator(this, first.index_);
    } else if (first.index_ < last.index_) {

      buffer_.DestructRange(&buffer_[first.index_], &buffer_[last.index_]);
    } else {

      buffer_.DestructRange(&buffer_[first.index_],
                            &buffer_[buffer_.capacity()]);
      buffer_.DestructRange(&buffer_[0], &buffer_[last.index_]);
    }

    if (first.index_ == begin_) {


      begin_ = last.index_;
      return iterator(this, last.index_);
    }



    iterator move_src(this, last.index_);
    iterator move_src_end = end();
    iterator move_dest(this, first.index_);
    for (; move_src < move_src_end; move_src++, move_dest++) {
      buffer_.MoveRange(&buffer_[move_src.index_],
                        &buffer_[move_src.index_ + 1],
                        &buffer_[move_dest.index_]);
    }

    end_ = move_dest.index_;




    return iterator(this, first.index_);
  }




  void push_front(const T& value) { emplace_front(value); }
  void push_front(T&& value) { emplace_front(std::move(value)); }

  void push_back(const T& value) { emplace_back(value); }
  void push_back(T&& value) { emplace_back(std::move(value)); }

  template <class... Args>
  void emplace_front(Args&&... args) {
    ExpandCapacityIfNecessary(1);
    if (begin_ == 0)
      begin_ = buffer_.capacity() - 1;
    else
      begin_--;
    IncrementGeneration();
    new (&buffer_[begin_]) T(std::forward<Args>(args)...);
  }

  template <class... Args>
  void emplace_back(Args&&... args) {
    ExpandCapacityIfNecessary(1);
    new (&buffer_[end_]) T(std::forward<Args>(args)...);
    if (end_ == buffer_.capacity() - 1)
      end_ = 0;
    else
      end_++;
    IncrementGeneration();
  }

  void pop_front() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(size());
    buffer_.DestructRange(&buffer_[begin_], &buffer_[begin_ + 1]);
    begin_++;
    if (begin_ == buffer_.capacity())
      begin_ = 0;

    ShrinkCapacityIfNecessary();





    IncrementGeneration();
  }
  void pop_back() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(size());
    if (end_ == 0)
      end_ = buffer_.capacity() - 1;
    else
      end_--;
    buffer_.DestructRange(&buffer_[end_], &buffer_[end_ + 1]);

    ShrinkCapacityIfNecessary();


    IncrementGeneration();
  }




  void swap(circular_deque& other) {
    std::swap(buffer_, other.buffer_);
    std::swap(begin_, other.begin_);
    std::swap(end_, other.end_);
    IncrementGeneration();
  }

  friend void swap(circular_deque& lhs, circular_deque& rhs) { lhs.swap(rhs); }

 private:
  friend internal::circular_deque_iterator<T>;
  friend internal::circular_deque_const_iterator<T>;




  static void MoveBuffer(VectorBuffer& from_buf,
                         size_t from_begin,
                         size_t from_end,
                         VectorBuffer* to_buf,
                         size_t* to_begin,
                         size_t* to_end) {
    size_t from_capacity = from_buf.capacity();

    *to_begin = 0;
    if (from_begin < from_end) {

      from_buf.MoveRange(&from_buf[from_begin], &from_buf[from_end],
                         to_buf->begin());
      *to_end = from_end - from_begin;
    } else if (from_begin > from_end) {

      from_buf.MoveRange(&from_buf[from_begin], &from_buf[from_capacity],
                         to_buf->begin());
      size_t right_size = from_capacity - from_begin;

      from_buf.MoveRange(&from_buf[0], &from_buf[from_end],
                         &(*to_buf)[right_size]);
      *to_end = right_size + from_end;
    } else {

      *to_end = 0;
    }
  }



  void SetCapacityTo(size_t new_capacity) {


    VectorBuffer new_buffer(new_capacity + 1);
    MoveBuffer(buffer_, begin_, end_, &new_buffer, &begin_, &end_);
    buffer_ = std::move(new_buffer);
  }
  void ExpandCapacityIfNecessary(size_t additional_elts) {
    size_t min_new_capacity = size() + additional_elts;
    if (capacity() >= min_new_capacity)
      return;

    min_new_capacity =
        std::max(min_new_capacity, internal::kCircularBufferInitialCapacity);




    size_t new_capacity =
        std::max(min_new_capacity, capacity() + capacity() / 4);
    SetCapacityTo(new_capacity);
  }

  void ShrinkCapacityIfNecessary() {

    if (capacity() <= internal::kCircularBufferInitialCapacity)
      return;


    size_t sz = size();
    size_t empty_spaces = capacity() - sz;
    if (empty_spaces < sz)
      return;



    size_t new_capacity =
        std::max(internal::kCircularBufferInitialCapacity, sz + sz / 4);
    if (new_capacity < capacity()) {

      SetCapacityTo(new_capacity);
    }
  }


  void ClearRetainCapacity() {


    DestructRange(begin_, end_);
    begin_ = 0;
    end_ = 0;
    IncrementGeneration();
  }




  void DestructRange(size_t begin, size_t end) {
    if (end == begin) {
      return;
    } else if (end > begin) {
      buffer_.DestructRange(&buffer_[begin], &buffer_[end]);
    } else {
      buffer_.DestructRange(&buffer_[begin], &buffer_[buffer_.capacity()]);
      buffer_.DestructRange(&buffer_[0], &buffer_[end]);
    }
  }





  void MakeRoomFor(size_t count, iterator* insert_begin, iterator* insert_end) {
    if (count == 0) {
      *insert_end = *insert_begin;
      return;
    }


    size_t begin_offset = insert_begin->OffsetFromBegin();
    ExpandCapacityIfNecessary(count);

    insert_begin->index_ = (begin_ + begin_offset) % buffer_.capacity();
    *insert_end =
        iterator(this, (insert_begin->index_ + count) % buffer_.capacity());


    iterator src = end();
    end_ = (end_ + count) % buffer_.capacity();
    iterator dest = end();



    while (true) {
      if (src == *insert_begin)
        break;
      --src;
      --dest;
      buffer_.MoveRange(&buffer_[src.index_], &buffer_[src.index_ + 1],
                        &buffer_[dest.index_]);
    }
  }
# 1067 "../../base/containers/circular_deque.h"
  void CheckValidIndex(size_t) const {}
  void CheckValidIndexOrEnd(size_t) const {}
  void ValidateIterator(const const_iterator& i) const {}
  void IncrementGeneration() {}
# 1083 "../../base/containers/circular_deque.h"
  VectorBuffer buffer_;
  size_type begin_ = 0;
  size_type end_ = 0;






};


template <class T, class Value>
void Erase(circular_deque<T>& container, const Value& value) {
  container.erase(std::remove(container.begin(), container.end(), value),
                  container.end());
}

template <class T, class Predicate>
void EraseIf(circular_deque<T>& container, Predicate pred) {
  container.erase(std::remove_if(container.begin(), container.end(), pred),
                  container.end());
}

}
# 11 "../../base/containers/stack.h" 2

namespace base {





template <class T, class Container = circular_deque<T>>
using stack = std::stack<T, Container>;

}
# 18 "../../base/trace_event/trace_log.h" 2


# 1 "../../base/trace_event/memory_dump_provider.h" 1
# 11 "../../base/trace_event/memory_dump_provider.h"
# 1 "../../base/trace_event/memory_dump_request_args.h" 1
# 18 "../../base/trace_event/memory_dump_request_args.h"
# 1 "../../base/optional.h" 1
# 12 "../../base/optional.h"
namespace base {



struct in_place_t {};



struct nullopt_t {
  constexpr explicit nullopt_t(int) {}
};



constexpr in_place_t in_place = {};



constexpr nullopt_t nullopt(0);

namespace internal {

template <typename T, bool = std::is_trivially_destructible<T>::value>
struct OptionalStorage {


  constexpr OptionalStorage() : empty_('\0') {}

  constexpr explicit OptionalStorage(const T& value)
      : is_null_(false), value_(value) {}

  constexpr explicit OptionalStorage(T&& value)
      : is_null_(false), value_(std::move(value)) {}

  template <class... Args>
  constexpr explicit OptionalStorage(base::in_place_t, Args&&... args)
      : is_null_(false), value_(std::forward<Args>(args)...) {}



  ~OptionalStorage() {
    if (!is_null_)
      value_.~T();
  }

  bool is_null_ = true;
  union {



    char empty_;
    T value_;
  };
};

template <typename T>
struct OptionalStorage<T, true> {


  constexpr OptionalStorage() : empty_('\0') {}

  constexpr explicit OptionalStorage(const T& value)
      : is_null_(false), value_(value) {}

  constexpr explicit OptionalStorage(T&& value)
      : is_null_(false), value_(std::move(value)) {}

  template <class... Args>
  constexpr explicit OptionalStorage(base::in_place_t, Args&&... args)
      : is_null_(false), value_(std::forward<Args>(args)...) {}




  ~OptionalStorage() = default;

  bool is_null_ = true;
  union {



    char empty_;
    T value_;
  };
};

}
# 113 "../../base/optional.h"
template <typename T>
class Optional {
 public:
  using value_type = T;

  constexpr Optional() {}

  constexpr Optional(base::nullopt_t) {}


  Optional(const Optional& other) {
    if (!other.storage_.is_null_)
      Init(other.value());
  }

  Optional(Optional&& other) {
    if (!other.storage_.is_null_)
      Init(std::move(other.value()));
  }

  constexpr Optional(const T& value) : storage_(value) {}

  constexpr Optional(T&& value) : storage_(std::move(value)) {}

  template <class... Args>
  constexpr explicit Optional(base::in_place_t, Args&&... args)
      : storage_(base::in_place, std::forward<Args>(args)...) {}

  ~Optional() = default;

  Optional& operator=(base::nullopt_t) {
    FreeIfNeeded();
    return *this;
  }

  Optional& operator=(const Optional& other) {
    if (other.storage_.is_null_) {
      FreeIfNeeded();
      return *this;
    }

    InitOrAssign(other.value());
    return *this;
  }

  Optional& operator=(Optional&& other) {
    if (other.storage_.is_null_) {
      FreeIfNeeded();
      return *this;
    }

    InitOrAssign(std::move(other.value()));
    return *this;
  }

  template <class U>
  typename std::enable_if<std::is_same<std::decay_t<U>, T>::value,
                          Optional&>::type
  operator=(U&& value) {
    InitOrAssign(std::forward<U>(value));
    return *this;
  }

  constexpr const T* operator->() const {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!storage_.is_null_);
    return &value();
  }

  constexpr T* operator->() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!storage_.is_null_);
    return &value();
  }

  constexpr const T& operator*() const& { return value(); }

  constexpr T& operator*() & { return value(); }

  constexpr const T&& operator*() const&& { return std::move(value()); }

  constexpr T&& operator*() && { return std::move(value()); }

  constexpr explicit operator bool() const { return !storage_.is_null_; }

  constexpr bool has_value() const { return !storage_.is_null_; }

  constexpr T& value() & {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!storage_.is_null_);
    return storage_.value_;
  }

  constexpr const T& value() const & {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!storage_.is_null_);
    return storage_.value_;
  }

  constexpr T&& value() && {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!storage_.is_null_);
    return std::move(storage_.value_);
  }

  constexpr const T&& value() const && {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!storage_.is_null_);
    return std::move(storage_.value_);
  }

  template <class U>
  constexpr T value_or(U&& default_value) const& {



    static_assert(std::is_convertible<U, T>::value,
                  "U must be convertible to T");
    return storage_.is_null_ ? static_cast<T>(std::forward<U>(default_value))
                             : value();
  }

  template <class U>
  T value_or(U&& default_value) && {



    static_assert(std::is_convertible<U, T>::value,
                  "U must be convertible to T");
    return storage_.is_null_ ? static_cast<T>(std::forward<U>(default_value))
                             : std::move(value());
  }

  void swap(Optional& other) {
    if (storage_.is_null_ && other.storage_.is_null_)
      return;

    if (storage_.is_null_ != other.storage_.is_null_) {
      if (storage_.is_null_) {
        Init(std::move(other.storage_.value_));
        other.FreeIfNeeded();
      } else {
        other.Init(std::move(storage_.value_));
        FreeIfNeeded();
      }
      return;
    }

    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(!storage_.is_null_ && !other.storage_.is_null_);
    using std::swap;
    swap(**this, *other);
  }

  void reset() {
    FreeIfNeeded();
  }

  template <class... Args>
  void emplace(Args&&... args) {
    FreeIfNeeded();
    Init(std::forward<Args>(args)...);
  }

 private:
  void Init(const T& value) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(storage_.is_null_);
    new (&storage_.value_) T(value);
    storage_.is_null_ = false;
  }

  void Init(T&& value) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(storage_.is_null_);
    new (&storage_.value_) T(std::move(value));
    storage_.is_null_ = false;
  }

  template <class... Args>
  void Init(Args&&... args) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(storage_.is_null_);
    new (&storage_.value_) T(std::forward<Args>(args)...);
    storage_.is_null_ = false;
  }

  void InitOrAssign(const T& value) {
    if (storage_.is_null_)
      Init(value);
    else
      storage_.value_ = value;
  }

  void InitOrAssign(T&& value) {
    if (storage_.is_null_)
      Init(std::move(value));
    else
      storage_.value_ = std::move(value);
  }

  void FreeIfNeeded() {
    if (storage_.is_null_)
      return;
    storage_.value_.~T();
    storage_.is_null_ = true;
  }

  internal::OptionalStorage<T> storage_;
};

template <class T>
constexpr bool operator==(const Optional<T>& lhs, const Optional<T>& rhs) {
  return !!lhs != !!rhs ? false : lhs == nullopt || (*lhs == *rhs);
}

template <class T>
constexpr bool operator!=(const Optional<T>& lhs, const Optional<T>& rhs) {
  return !(lhs == rhs);
}

template <class T>
constexpr bool operator<(const Optional<T>& lhs, const Optional<T>& rhs) {
  return rhs == nullopt ? false : (lhs == nullopt ? true : *lhs < *rhs);
}

template <class T>
constexpr bool operator<=(const Optional<T>& lhs, const Optional<T>& rhs) {
  return !(rhs < lhs);
}

template <class T>
constexpr bool operator>(const Optional<T>& lhs, const Optional<T>& rhs) {
  return rhs < lhs;
}

template <class T>
constexpr bool operator>=(const Optional<T>& lhs, const Optional<T>& rhs) {
  return !(lhs < rhs);
}

template <class T>
constexpr bool operator==(const Optional<T>& opt, base::nullopt_t) {
  return !opt;
}

template <class T>
constexpr bool operator==(base::nullopt_t, const Optional<T>& opt) {
  return !opt;
}

template <class T>
constexpr bool operator!=(const Optional<T>& opt, base::nullopt_t) {
  return !!opt;
}

template <class T>
constexpr bool operator!=(base::nullopt_t, const Optional<T>& opt) {
  return !!opt;
}

template <class T>
constexpr bool operator<(const Optional<T>& opt, base::nullopt_t) {
  return false;
}

template <class T>
constexpr bool operator<(base::nullopt_t, const Optional<T>& opt) {
  return !!opt;
}

template <class T>
constexpr bool operator<=(const Optional<T>& opt, base::nullopt_t) {
  return !opt;
}

template <class T>
constexpr bool operator<=(base::nullopt_t, const Optional<T>& opt) {
  return true;
}

template <class T>
constexpr bool operator>(const Optional<T>& opt, base::nullopt_t) {
  return !!opt;
}

template <class T>
constexpr bool operator>(base::nullopt_t, const Optional<T>& opt) {
  return false;
}

template <class T>
constexpr bool operator>=(const Optional<T>& opt, base::nullopt_t) {
  return true;
}

template <class T>
constexpr bool operator>=(base::nullopt_t, const Optional<T>& opt) {
  return !opt;
}

template <class T>
constexpr bool operator==(const Optional<T>& opt, const T& value) {
  return opt != nullopt ? *opt == value : false;
}

template <class T>
constexpr bool operator==(const T& value, const Optional<T>& opt) {
  return opt == value;
}

template <class T>
constexpr bool operator!=(const Optional<T>& opt, const T& value) {
  return !(opt == value);
}

template <class T>
constexpr bool operator!=(const T& value, const Optional<T>& opt) {
  return !(opt == value);
}

template <class T>
constexpr bool operator<(const Optional<T>& opt, const T& value) {
  return opt != nullopt ? *opt < value : true;
}

template <class T>
constexpr bool operator<(const T& value, const Optional<T>& opt) {
  return opt != nullopt ? value < *opt : false;
}

template <class T>
constexpr bool operator<=(const Optional<T>& opt, const T& value) {
  return !(opt > value);
}

template <class T>
constexpr bool operator<=(const T& value, const Optional<T>& opt) {
  return !(value > opt);
}

template <class T>
constexpr bool operator>(const Optional<T>& opt, const T& value) {
  return value < opt;
}

template <class T>
constexpr bool operator>(const T& value, const Optional<T>& opt) {
  return opt < value;
}

template <class T>
constexpr bool operator>=(const Optional<T>& opt, const T& value) {
  return !(opt < value);
}

template <class T>
constexpr bool operator>=(const T& value, const Optional<T>& opt) {
  return !(value < opt);
}

template <class T>
constexpr Optional<typename std::decay<T>::type> make_optional(T&& value) {
  return Optional<typename std::decay<T>::type>(std::forward<T>(value));
}

template <class T>
void swap(Optional<T>& lhs, Optional<T>& rhs) {
  lhs.swap(rhs);
}

}

namespace std {

template <class T>
struct hash<base::Optional<T>> {
  size_t operator()(const base::Optional<T>& opt) const {
    return opt == base::nullopt ? 0 : std::hash<T>()(*opt);
  }
};

}
# 19 "../../base/trace_event/memory_dump_request_args.h" 2


namespace base {
namespace trace_event {

class ProcessMemoryDump;





enum class MemoryDumpType {
  PERIODIC_INTERVAL,
  EXPLICITLY_TRIGGERED,
  PEAK_MEMORY_USAGE,
  SUMMARY_ONLY,
  LAST = SUMMARY_ONLY
};




enum class MemoryDumpLevelOfDetail : uint32_t {
  FIRST,




  BACKGROUND = FIRST,






  LIGHT,


  VM_REGIONS_ONLY_FOR_HEAP_PROFILER,


  DETAILED,

  LAST = DETAILED
};



struct MemoryDumpRequestArgs {



  uint64_t dump_guid;

  MemoryDumpType dump_type;
  MemoryDumpLevelOfDetail level_of_detail;
};





struct GlobalMemoryDumpRequestArgs {
  MemoryDumpType dump_type;
  MemoryDumpLevelOfDetail level_of_detail;
};



struct MemoryDumpArgs {

  MemoryDumpLevelOfDetail level_of_detail;




  uint64_t dump_guid;
};

using ProcessMemoryDumpCallback = Callback<
    void(bool success, uint64_t dump_guid, std::unique_ptr<ProcessMemoryDump>)>;

            const char* MemoryDumpTypeToString(const MemoryDumpType& dump_type);

            MemoryDumpType StringToMemoryDumpType(const std::string& str);

            const char* MemoryDumpLevelOfDetailToString(
    const MemoryDumpLevelOfDetail& level_of_detail);

            MemoryDumpLevelOfDetail
StringToMemoryDumpLevelOfDetail(const std::string& str);

}
}
# 12 "../../base/trace_event/memory_dump_provider.h" 2

namespace base {
namespace trace_event {

class ProcessMemoryDump;


class MemoryDumpProvider {
 public:

  struct Options {
    Options()
        : dumps_on_single_thread_task_runner(false),
          is_fast_polling_supported(false),
          supports_heap_profiling(false) {}




    bool dumps_on_single_thread_task_runner;




    bool is_fast_polling_supported;



    bool supports_heap_profiling;
  };

  virtual ~MemoryDumpProvider() {}
# 52 "../../base/trace_event/memory_dump_provider.h"
  virtual bool OnMemoryDump(const MemoryDumpArgs& args,
                            ProcessMemoryDump* pmd) = 0;




  virtual void OnHeapProfilingEnabled(bool enabled) {}






  virtual void PollFastMemoryTotal(uint64_t* memory_total) {}




  virtual void SuspendFastMemoryPolling() {}

 protected:
  MemoryDumpProvider() {}

  MemoryDumpProvider(const MemoryDumpProvider&) = delete; MemoryDumpProvider& operator=(const MemoryDumpProvider&) = delete;
};

}
}
# 21 "../../base/trace_event/trace_log.h" 2
# 1 "../../base/trace_event/trace_config.h" 1
# 11 "../../base/trace_event/trace_config.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/set" 1 3
# 394 "../../buildtools/third_party/libc++/trunk/include/set" 3


namespace std {inline namespace __1 {

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class set
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    __attribute__ ((__always_inline__))
    set()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__always_inline__))
    explicit set(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__always_inline__))
    explicit set(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        set(_InputIterator __f, _InputIterator __l,
            const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,
            const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }


        template <class _InputIterator>
        __attribute__ ((__always_inline__))
        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
            : set(__f, __l, key_compare(), __a) {}


    __attribute__ ((__always_inline__))
    set(const set& __s)
        : __tree_(__s.__tree_)
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__always_inline__))
    set& operator=(const set& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__always_inline__))
    set(set&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__s.__tree_)) {}


    __attribute__ ((__always_inline__))
    explicit set(const allocator_type& __a)
        : __tree_(__a) {}

    __attribute__ ((__always_inline__))
    set(const set& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    set(set&& __s, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__always_inline__))
    set(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__always_inline__))
    set(initializer_list<value_type> __il, const allocator_type& __a)
        : set(__il, key_compare(), __a) {}


    __attribute__ ((__always_inline__))
    set& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__always_inline__))
    set& operator=(set&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__always_inline__))
        pair<iterator, bool> emplace(_Args&&... __args)
            {return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__always_inline__))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_unique(__p, std::__1::forward<_Args>(__args)...);}


    __attribute__ ((__always_inline__))
    pair<iterator,bool> insert(const value_type& __v)
        {return __tree_.__insert_unique(__v);}
    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_unique(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_unique(__e, *__f);
        }


    __attribute__ ((__always_inline__))
    pair<iterator,bool> insert(value_type&& __v)
        {return __tree_.__insert_unique(std::__1::move(__v));}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_unique(__p, std::__1::move(__v));}

    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {__tree_.clear();}

    __attribute__ ((__always_inline__))
    void swap(set& __s) noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__always_inline__))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_unique(__k);}

    __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_unique(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}

};



template <class _Key, class _Compare, class _Allocator>
set<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)
    : __tree_(std::__1::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}


template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(set<_Key, _Compare, _Allocator>& __x,
     set<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class multiset
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    __attribute__ ((__always_inline__))
    multiset()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__always_inline__))
    explicit multiset(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__always_inline__))
    explicit multiset(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }


        template <class _InputIterator>
        __attribute__ ((__always_inline__))
        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
            : multiset(__f, __l, key_compare(), __a) {}


    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }

    __attribute__ ((__always_inline__))
    multiset(const multiset& __s)
        : __tree_(__s.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__always_inline__))
    multiset& operator=(const multiset& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__always_inline__))
    multiset(multiset&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__s.__tree_)) {}

    multiset(multiset&& __s, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    explicit multiset(const allocator_type& __a)
        : __tree_(__a) {}
    __attribute__ ((__always_inline__))
    multiset(const multiset& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    __attribute__ ((__always_inline__))
    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__always_inline__))
    multiset(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__always_inline__))
    multiset(initializer_list<value_type> __il, const allocator_type& __a)
        : multiset(__il, key_compare(), __a) {}


    __attribute__ ((__always_inline__))
    multiset& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__always_inline__))
    multiset& operator=(multiset&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__always_inline__))
        iterator emplace(_Args&&... __args)
            {return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__always_inline__))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_multi(__p, std::__1::forward<_Args>(__args)...);}


    __attribute__ ((__always_inline__))
    iterator insert(const value_type& __v)
        {return __tree_.__insert_multi(__v);}
    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_multi(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e, *__f);
        }


    __attribute__ ((__always_inline__))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__1::move(__v));}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p, std::__1::move(__v));}

    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {__tree_.clear();}

    __attribute__ ((__always_inline__))
    void swap(multiset& __s)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__always_inline__))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) {return __tree_.__count_multi(__k);}


    __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__always_inline__))
    typename std::__1::enable_if<std::__1::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}

};



template <class _Key, class _Compare, class _Allocator>
multiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)
    : __tree_(std::__1::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator==(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator< (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator!=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator> (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator>=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
bool
operator<=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__always_inline__))
void
swap(multiset<_Key, _Compare, _Allocator>& __x,
     multiset<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 12 "../../base/trace_event/trace_config.h" 2

# 1 "../../buildtools/third_party/libc++/trunk/include/unordered_set" 1 3
# 330 "../../buildtools/third_party/libc++/trunk/include/unordered_set" 3


namespace std {inline namespace __1 {

template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,
          class _Alloc = allocator<_Value> >
class unordered_set
{
public:

    typedef _Value key_type;
    typedef key_type value_type;
    typedef _Hash hasher;
    typedef _Pred key_equal;
    typedef _Alloc allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;

    __table __table_;

public:
    typedef typename __table::pointer pointer;
    typedef typename __table::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef typename __table::const_iterator iterator;
    typedef typename __table::const_iterator const_iterator;
    typedef typename __table::const_local_iterator local_iterator;
    typedef typename __table::const_local_iterator const_local_iterator;

    __attribute__ ((__always_inline__))
    unordered_set()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_set(size_type __n, const hasher& __hf = hasher(),
                           const key_equal& __eql = key_equal());

    inline __attribute__ ((__always_inline__))
    unordered_set(size_type __n, const allocator_type& __a)
        : unordered_set(__n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__always_inline__))
    unordered_set(size_type __n, const hasher& __hf, const allocator_type& __a)
        : unordered_set(__n, __hf, key_equal(), __a) {}

    unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf, const key_equal& __eql,
                      const allocator_type& __a);

    template <class _InputIterator>
    inline __attribute__ ((__always_inline__))
        unordered_set(_InputIterator __first, _InputIterator __last,
                    size_type __n, const allocator_type& __a)
            : unordered_set(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf, const allocator_type& __a)
            : unordered_set(__first, __last, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__always_inline__))
    explicit unordered_set(const allocator_type& __a);
    unordered_set(const unordered_set& __u);
    unordered_set(const unordered_set& __u, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    unordered_set(unordered_set&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_set(unordered_set&& __u, const allocator_type& __a);
    unordered_set(initializer_list<value_type> __il);
    unordered_set(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf = hasher(),
                  const key_equal& __eql = key_equal());
    unordered_set(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);

    inline __attribute__ ((__always_inline__))
    unordered_set(initializer_list<value_type> __il, size_type __n,
                                                      const allocator_type& __a)
        : unordered_set(__il, __n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__always_inline__))
    unordered_set(initializer_list<value_type> __il, size_type __n,
                                  const hasher& __hf, const allocator_type& __a)
        : unordered_set(__il, __n, __hf, key_equal(), __a) {}



    __attribute__ ((__always_inline__))
    unordered_set& operator=(const unordered_set& __u)
    {
        __table_ = __u.__table_;
        return *this;
    }

    __attribute__ ((__always_inline__))
    unordered_set& operator=(unordered_set&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__always_inline__))
    unordered_set& operator=(initializer_list<value_type> __il);


    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__always_inline__))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return __table_.end();}


    template <class... _Args>
        __attribute__ ((__always_inline__))
        pair<iterator, bool> emplace(_Args&&... __args)
            {return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__always_inline__))
# 489 "../../buildtools/third_party/libc++/trunk/include/unordered_set" 3
        iterator emplace_hint(const_iterator, _Args&&... __args)
            {return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...).first;}


    __attribute__ ((__always_inline__))
    pair<iterator, bool> insert(value_type&& __x)
        {return __table_.__insert_unique(std::__1::move(__x));}
    __attribute__ ((__always_inline__))
# 506 "../../buildtools/third_party/libc++/trunk/include/unordered_set" 3
    iterator insert(const_iterator, value_type&& __x)
        {return insert(std::__1::move(__x)).first;}

    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    __attribute__ ((__always_inline__))
    pair<iterator, bool> insert(const value_type& __x)
        {return __table_.__insert_unique(__x);}

    __attribute__ ((__always_inline__))
# 527 "../../buildtools/third_party/libc++/trunk/include/unordered_set" 3
    iterator insert(const_iterator, const value_type& __x)
        {return insert(__x).first;}

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        void insert(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __table_.erase(__p);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first, __last);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {__table_.clear();}

    __attribute__ ((__always_inline__))
    void swap(unordered_set& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        {__table_.swap(__u.__table_);}

    __attribute__ ((__always_inline__))
    hasher hash_function() const {return __table_.hash_function();}
    __attribute__ ((__always_inline__))
    key_equal key_eq() const {return __table_.key_eq();}

    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
    __attribute__ ((__always_inline__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_unique(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_unique(__k);}

    __attribute__ ((__always_inline__))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__always_inline__))
    size_type max_bucket_count() const noexcept {return __table_.max_bucket_count();}

    __attribute__ ((__always_inline__))
    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}
    __attribute__ ((__always_inline__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__always_inline__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__always_inline__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__always_inline__))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__always_inline__))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__always_inline__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__always_inline__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__always_inline__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 614 "../../buildtools/third_party/libc++/trunk/include/unordered_set" 3
};

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        const allocator_type& __a)
    : __table_(__a)
{



}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        const unordered_set& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        const unordered_set& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        unordered_set&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        unordered_set&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), __a)
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
            __table_.__insert_unique(std::__1::move(__u.__table_.remove(__i++)->__value_));
    }




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>&
unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_set&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>&
unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_unique(__il.begin(), __il.end());
    return *this;
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_set<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                    _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_unique(*__first);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
void
swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
     unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_set<_Value, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
            __i != __ex; ++__i)
    {
        const_iterator __j = __y.find(*__i);
        if (__j == __ey || !(*__i == *__j))
            return false;
    }
    return true;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,
          class _Alloc = allocator<_Value> >
class unordered_multiset
{
public:

    typedef _Value key_type;
    typedef key_type value_type;
    typedef _Hash hasher;
    typedef _Pred key_equal;
    typedef _Alloc allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;

    __table __table_;

public:
    typedef typename __table::pointer pointer;
    typedef typename __table::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef typename __table::const_iterator iterator;
    typedef typename __table::const_iterator const_iterator;
    typedef typename __table::const_local_iterator local_iterator;
    typedef typename __table::const_local_iterator const_local_iterator;

    __attribute__ ((__always_inline__))
    unordered_multiset()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_multiset(size_type __n, const hasher& __hf = hasher(),
                                const key_equal& __eql = key_equal());
    unordered_multiset(size_type __n, const hasher& __hf,
                       const key_equal& __eql, const allocator_type& __a);

    inline __attribute__ ((__always_inline__))
    unordered_multiset(size_type __n, const allocator_type& __a)
        : unordered_multiset(__n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__always_inline__))
    unordered_multiset(size_type __n, const hasher& __hf, const allocator_type& __a)
        : unordered_multiset(__n, __hf, key_equal(), __a) {}

    template <class _InputIterator>
        unordered_multiset(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_multiset(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_multiset(_InputIterator __first, _InputIterator __last,
                      size_type __n , const hasher& __hf,
                      const key_equal& __eql, const allocator_type& __a);

    template <class _InputIterator>
    inline __attribute__ ((__always_inline__))
    unordered_multiset(_InputIterator __first, _InputIterator __last,
                       size_type __n, const allocator_type& __a)
        : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    inline __attribute__ ((__always_inline__))
    unordered_multiset(_InputIterator __first, _InputIterator __last,
                       size_type __n, const hasher& __hf, const allocator_type& __a)
        : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__always_inline__))
    explicit unordered_multiset(const allocator_type& __a);
    unordered_multiset(const unordered_multiset& __u);
    unordered_multiset(const unordered_multiset& __u, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    unordered_multiset(unordered_multiset&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_multiset(unordered_multiset&& __u, const allocator_type& __a);
    unordered_multiset(initializer_list<value_type> __il);
    unordered_multiset(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf = hasher(),
                       const key_equal& __eql = key_equal());
    unordered_multiset(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf, const key_equal& __eql,
                       const allocator_type& __a);

    inline __attribute__ ((__always_inline__))
    unordered_multiset(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_multiset(__il, __n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__always_inline__))
    unordered_multiset(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multiset(__il, __n, __hf, key_equal(), __a) {}



    __attribute__ ((__always_inline__))
    unordered_multiset& operator=(const unordered_multiset& __u)
    {
        __table_ = __u.__table_;
        return *this;
    }

    __attribute__ ((__always_inline__))
    unordered_multiset& operator=(unordered_multiset&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    unordered_multiset& operator=(initializer_list<value_type> __il);


    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__always_inline__))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return __table_.end();}


    template <class... _Args>
        __attribute__ ((__always_inline__))
        iterator emplace(_Args&&... __args)
            {return __table_.__emplace_multi(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__always_inline__))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __table_.__emplace_hint_multi(__p, std::__1::forward<_Args>(__args)...);}

    __attribute__ ((__always_inline__))
    iterator insert(value_type&& __x) {return __table_.__insert_multi(std::__1::move(__x));}
    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __x)
        {return __table_.__insert_multi(__p, std::__1::move(__x));}
    __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__always_inline__))
    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __x)
        {return __table_.__insert_multi(__p, __x);}

    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        void insert(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __table_.erase(__p);}
    __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
    __attribute__ ((__always_inline__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first, __last);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {__table_.clear();}

    __attribute__ ((__always_inline__))
    void swap(unordered_multiset& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        {__table_.swap(__u.__table_);}

    __attribute__ ((__always_inline__))
    hasher hash_function() const {return __table_.hash_function();}
    __attribute__ ((__always_inline__))
    key_equal key_eq() const {return __table_.key_eq();}

    __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
    __attribute__ ((__always_inline__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_multi(__k);}
    __attribute__ ((__always_inline__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_multi(__k);}

    __attribute__ ((__always_inline__))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__always_inline__))
    size_type max_bucket_count() const noexcept {return __table_.max_bucket_count();}

    __attribute__ ((__always_inline__))
    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}
    __attribute__ ((__always_inline__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__always_inline__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__always_inline__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__always_inline__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__always_inline__))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__always_inline__))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__always_inline__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__always_inline__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__always_inline__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1102 "../../buildtools/third_party/libc++/trunk/include/unordered_set" 3
};

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        const allocator_type& __a)
    : __table_(__a)
{



}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        const unordered_multiset& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        const unordered_multiset& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        unordered_multiset&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        unordered_multiset&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), __a)
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
            __table_.__insert_multi(std::__1::move(__u.__table_.remove(__i++)->__value_));
    }




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(
        unordered_multiset&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_multi(__il.begin(), __il.end());
    return *this;
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                         _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_multi(*__first);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
void
swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
     unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    typedef pair<const_iterator, const_iterator> _EqRng;
    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
    {
        _EqRng __xeq = __x.equal_range(*__i);
        _EqRng __yeq = __y.equal_range(*__i);
        if (std::__1::distance(__xeq.first, __xeq.second) !=
            std::__1::distance(__yeq.first, __yeq.second) ||
                  !std::__1::is_permutation(__xeq.first, __xeq.second, __yeq.first))
            return false;
        __i = __xeq.second;
    }
    return true;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

} }
# 14 "../../base/trace_event/trace_config.h" 2






# 1 "../../base/trace_event/trace_config_category_filter.h" 1
# 15 "../../base/trace_event/trace_config_category_filter.h"
namespace base {
namespace trace_event {


class TraceConfigCategoryFilter {
 public:
  using StringList = std::vector<std::string>;

  TraceConfigCategoryFilter();
  TraceConfigCategoryFilter(const TraceConfigCategoryFilter& other);
  ~TraceConfigCategoryFilter();

  TraceConfigCategoryFilter& operator=(const TraceConfigCategoryFilter& rhs);



  void InitializeFromString(const StringPiece& category_filter_string);


  void InitializeFromConfigDict(const DictionaryValue& dict);


  void Merge(const TraceConfigCategoryFilter& config);
  void Clear();




  bool IsCategoryGroupEnabled(const StringPiece& category_group_name) const;





  bool IsCategoryEnabled(const StringPiece& category_name) const;

  void ToDict(DictionaryValue* dict) const;

  std::string ToFilterString() const;


  static bool IsCategoryNameAllowed(StringPiece str);

  const StringList& included_categories() const { return included_categories_; }
  const StringList& excluded_categories() const { return excluded_categories_; }

 private:
  void SetCategoriesFromIncludedList(const ListValue& included_list);
  void SetCategoriesFromExcludedList(const ListValue& excluded_list);

  void AddCategoriesToDict(const StringList& categories,
                           const char* param,
                           DictionaryValue* dict) const;

  void WriteCategoryFilterString(const StringList& values,
                                 std::string* out,
                                 bool included) const;

  StringList included_categories_;
  StringList disabled_categories_;
  StringList excluded_categories_;
};

}
}
# 21 "../../base/trace_event/trace_config.h" 2


namespace base {
namespace trace_event {

class ConvertableToTraceFormat;


enum TraceRecordMode {

  RECORD_UNTIL_FULL,



  RECORD_CONTINUOUSLY,


  RECORD_AS_MUCH_AS_POSSIBLE,


  ECHO_TO_CONSOLE,
};

class TraceConfig {
 public:
  using StringList = std::vector<std::string>;



  struct MemoryDumpConfig {
    MemoryDumpConfig();
    MemoryDumpConfig(const MemoryDumpConfig& other);
    ~MemoryDumpConfig();


    struct Trigger {
      uint32_t min_time_between_dumps_ms;
      MemoryDumpLevelOfDetail level_of_detail;
      MemoryDumpType trigger_type;
    };


    struct HeapProfiler {

      enum { kDefaultBreakdownThresholdBytes = 1024 };

      HeapProfiler();


      void Clear();

      uint32_t breakdown_threshold_bytes;
    };


    void Clear();

    void Merge(const MemoryDumpConfig& config);




    std::set<MemoryDumpLevelOfDetail> allowed_dump_modes;

    std::vector<Trigger> triggers;
    HeapProfiler heap_profiler_options;
  };

  class EventFilterConfig {
   public:
    EventFilterConfig(const std::string& predicate_name);
    EventFilterConfig(const EventFilterConfig& tc);

    ~EventFilterConfig();

    EventFilterConfig& operator=(const EventFilterConfig& rhs);

    void InitializeFromConfigDict(const base::DictionaryValue* event_filter);

    void SetCategoryFilter(const TraceConfigCategoryFilter& category_filter);

    void ToDict(DictionaryValue* filter_dict) const;

    bool GetArgAsSet(const char* key, std::unordered_set<std::string>*) const;

    bool IsCategoryGroupEnabled(const StringPiece& category_group_name) const;

    const std::string& predicate_name() const { return predicate_name_; }
    base::DictionaryValue* filter_args() const { return args_.get(); }
    const TraceConfigCategoryFilter& category_filter() const {
      return category_filter_;
    }

   private:
    std::string predicate_name_;
    TraceConfigCategoryFilter category_filter_;
    std::unique_ptr<base::DictionaryValue> args_;
  };
  typedef std::vector<EventFilterConfig> EventFilters;

  TraceConfig();
# 155 "../../base/trace_event/trace_config.h"
  TraceConfig(StringPiece category_filter_string,
              StringPiece trace_options_string);

  TraceConfig(StringPiece category_filter_string, TraceRecordMode record_mode);
# 186 "../../base/trace_event/trace_config.h"
  explicit TraceConfig(StringPiece config_string);



  explicit TraceConfig(const DictionaryValue& config);

  TraceConfig(const TraceConfig& tc);

  ~TraceConfig();

  TraceConfig& operator=(const TraceConfig& rhs);

  TraceRecordMode GetTraceRecordMode() const { return record_mode_; }
  bool IsSystraceEnabled() const { return enable_systrace_; }
  bool IsArgumentFilterEnabled() const { return enable_argument_filter_; }

  void SetTraceRecordMode(TraceRecordMode mode) { record_mode_ = mode; }
  void EnableSystrace() { enable_systrace_ = true; }
  void EnableArgumentFilter() { enable_argument_filter_ = true; }



  std::string ToString() const;


  std::unique_ptr<ConvertableToTraceFormat> AsConvertableToTraceFormat() const;


  std::string ToCategoryFilterString() const;




  bool IsCategoryGroupEnabled(const StringPiece& category_group_name) const;


  void Merge(const TraceConfig& config);

  void Clear();


  void ResetMemoryDumpConfig(const MemoryDumpConfig& memory_dump_config);

  const TraceConfigCategoryFilter& category_filter() const {
    return category_filter_;
  }

  const MemoryDumpConfig& memory_dump_config() const {
    return memory_dump_config_;
  }

  const EventFilters& event_filters() const { return event_filters_; }
  void SetEventFilters(const EventFilters& filter_configs) {
    event_filters_ = filter_configs;
  }

 private:
  friend class TraceConfigTest_TraceConfigFromValidLegacyFormat_Test; friend class TraceConfigTest_DISABLED_TraceConfigFromValidLegacyFormat_Test; friend class TraceConfigTest_FLAKY_TraceConfigFromValidLegacyFormat_Test;
  friend class TraceConfigTest_TraceConfigFromInvalidLegacyStrings_Test; friend class TraceConfigTest_DISABLED_TraceConfigFromInvalidLegacyStrings_Test; friend class TraceConfigTest_FLAKY_TraceConfigFromInvalidLegacyStrings_Test;





  void InitializeDefault();


  void InitializeFromConfigDict(const DictionaryValue& dict);


  void InitializeFromConfigString(StringPiece config_string);


  void InitializeFromStrings(StringPiece category_filter_string,
                             StringPiece trace_options_string);

  void SetMemoryDumpConfigFromConfigDict(
      const DictionaryValue& memory_dump_config);
  void SetDefaultMemoryDumpConfig();

  void SetEventFiltersFromConfigList(const base::ListValue& event_filters);
  std::unique_ptr<DictionaryValue> ToDict() const;

  std::string ToTraceOptionsString() const;

  TraceRecordMode record_mode_;
  bool enable_systrace_ : 1;
  bool enable_argument_filter_ : 1;

  TraceConfigCategoryFilter category_filter_;

  MemoryDumpConfig memory_dump_config_;

  EventFilters event_filters_;
};

}
}
# 22 "../../base/trace_event/trace_log.h" 2
# 1 "../../base/trace_event/trace_event_impl.h" 1
# 18 "../../base/trace_event/trace_event_impl.h"
# 1 "../../base/containers/hash_tables.h" 1
# 21 "../../base/containers/hash_tables.h"
namespace base_hash {




template<typename T>
struct hash {
  std::size_t operator()(const T& value) const { return std::hash<T>()(value); }
};


template <typename Type1, typename Type2>
struct hash<std::pair<Type1, Type2>> {
  std::size_t operator()(std::pair<Type1, Type2> value) const {
    return base::HashInts(value.first, value.second);
  }
};

}

namespace base {


template <class Key,
          class T,
          class Hash = base_hash::hash<Key>,
          class Pred = std::equal_to<Key>,
          class Alloc = std::allocator<std::pair<const Key, T>>>
using hash_map = std::unordered_map<Key, T, Hash, Pred, Alloc>;


template <class Key,
          class T,
          class Hash = base_hash::hash<Key>,
          class Pred = std::equal_to<Key>,
          class Alloc = std::allocator<std::pair<const Key, T>>>
using hash_multimap = std::unordered_multimap<Key, T, Hash, Pred, Alloc>;


template <class Key,
          class Hash = base_hash::hash<Key>,
          class Pred = std::equal_to<Key>,
          class Alloc = std::allocator<Key>>
using hash_multiset = std::unordered_multiset<Key, Hash, Pred, Alloc>;


template <class Key,
          class Hash = base_hash::hash<Key>,
          class Pred = std::equal_to<Key>,
          class Alloc = std::allocator<Key>>
using hash_set = std::unordered_set<Key, Hash, Pred, Alloc>;

}
# 19 "../../base/trace_event/trace_event_impl.h" 2

# 1 "../../base/observer_list.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/observer_list.h" 2
# 18 "../../base/observer_list.h"
# 1 "../../base/stl_util.h" 1
# 12 "../../base/stl_util.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/forward_list" 1 3
# 178 "../../buildtools/third_party/libc++/trunk/include/forward_list" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 182 "../../buildtools/third_party/libc++/trunk/include/forward_list" 2 3


namespace std {inline namespace __1 {

template <class _Tp, class _VoidPtr> struct __forward_list_node;
template <class _NodePtr> struct __forward_begin_node;


template <class>
struct __forward_list_node_value_type;

template <class _Tp, class _VoidPtr>
struct __forward_list_node_value_type<__forward_list_node<_Tp, _VoidPtr> > {
  typedef _Tp type;
};

template <class _NodePtr>
struct __forward_node_traits {

  typedef typename remove_cv<
        typename pointer_traits<_NodePtr>::element_type>::type __node;
  typedef typename __forward_list_node_value_type<__node>::type __node_value_type;
  typedef _NodePtr __node_pointer;
  typedef __forward_begin_node<_NodePtr> __begin_node;
  typedef typename __rebind_pointer<_NodePtr, __begin_node>::type
                                                                __begin_node_pointer;
  typedef typename __rebind_pointer<_NodePtr, void>::type __void_pointer;




  typedef typename conditional<
          is_pointer<__void_pointer>::value,
          __begin_node_pointer,
          __node_pointer
    >::type __iter_node_pointer;


  typedef typename conditional<
          is_same<__iter_node_pointer, __node_pointer>::value,
          __begin_node_pointer,
          __node_pointer
    >::type __non_iter_node_pointer;

  __attribute__ ((__always_inline__))
  static __iter_node_pointer __as_iter_node(__iter_node_pointer __p) {
      return __p;
  }
  __attribute__ ((__always_inline__))
  static __iter_node_pointer __as_iter_node(__non_iter_node_pointer __p) {
      return static_cast<__iter_node_pointer>(static_cast<__void_pointer>(__p));
  }
};

template <class _NodePtr>
struct __forward_begin_node
{
    typedef _NodePtr pointer;
    typedef typename __rebind_pointer<_NodePtr, __forward_begin_node>::type __begin_node_pointer;

    pointer __next_;

    __attribute__ ((__always_inline__)) __forward_begin_node() : __next_(nullptr) {}

    __attribute__ ((__always_inline__))
    __begin_node_pointer __next_as_begin() const {
        return static_cast<__begin_node_pointer>(__next_);
    }
};

template <class _Tp, class _VoidPtr>
struct __begin_node_of
{
    typedef __forward_begin_node<
        typename __rebind_pointer<_VoidPtr, __forward_list_node<_Tp, _VoidPtr> >::type
    > type;
};

template <class _Tp, class _VoidPtr>
struct __forward_list_node
    : public __begin_node_of<_Tp, _VoidPtr>::type
{
    typedef _Tp value_type;

    value_type __value_;
};


template <class _Tp, class _Alloc = allocator<_Tp> > class forward_list;
template<class _NodeConstPtr> class __forward_list_const_iterator;

template <class _NodePtr>
class __forward_list_iterator
{
    typedef __forward_node_traits<_NodePtr> __traits;
    typedef typename __traits::__node_pointer __node_pointer;
    typedef typename __traits::__begin_node_pointer __begin_node_pointer;
    typedef typename __traits::__iter_node_pointer __iter_node_pointer;
    typedef typename __traits::__void_pointer __void_pointer;

    __iter_node_pointer __ptr_;

    __attribute__ ((__always_inline__))
    __begin_node_pointer __get_begin() const {
        return static_cast<__begin_node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }
    __attribute__ ((__always_inline__))
    __node_pointer __get_unsafe_node_pointer() const {
        return static_cast<__node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }

    __attribute__ ((__always_inline__))
    explicit __forward_list_iterator(nullptr_t) noexcept : __ptr_(nullptr) {}

    __attribute__ ((__always_inline__))
    explicit __forward_list_iterator(__begin_node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    __attribute__ ((__always_inline__))
    explicit __forward_list_iterator(__node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    template<class, class> friend class forward_list;
    template<class> friend class __forward_list_const_iterator;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __traits::__node_value_type value_type;
    typedef value_type& reference;
    typedef typename pointer_traits<__node_pointer>::difference_type
                                                              difference_type;
    typedef typename __rebind_pointer<__node_pointer, value_type>::type pointer;

    __attribute__ ((__always_inline__))
    __forward_list_iterator() noexcept : __ptr_(nullptr) {}

    __attribute__ ((__always_inline__))
    reference operator*() const {return __get_unsafe_node_pointer()->__value_;}
    __attribute__ ((__always_inline__))
    pointer operator->() const {
        return pointer_traits<pointer>::pointer_to(__get_unsafe_node_pointer()->__value_);
    }

    __attribute__ ((__always_inline__))
    __forward_list_iterator& operator++()
    {
        __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
        return *this;
    }
    __attribute__ ((__always_inline__))
    __forward_list_iterator operator++(int)
    {
        __forward_list_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __forward_list_iterator& __x,
                    const __forward_list_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __forward_list_iterator& __x,
                    const __forward_list_iterator& __y)
        {return !(__x == __y);}
};

template <class _NodeConstPtr>
class __forward_list_const_iterator
{
    static_assert((!is_const<typename pointer_traits<_NodeConstPtr>::element_type>::value), "");
    typedef _NodeConstPtr _NodePtr;

    typedef __forward_node_traits<_NodePtr> __traits;
    typedef typename __traits::__node __node;
    typedef typename __traits::__node_pointer __node_pointer;
    typedef typename __traits::__begin_node_pointer __begin_node_pointer;
    typedef typename __traits::__iter_node_pointer __iter_node_pointer;
    typedef typename __traits::__void_pointer __void_pointer;

    __iter_node_pointer __ptr_;

    __begin_node_pointer __get_begin() const {
        return static_cast<__begin_node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }
    __node_pointer __get_unsafe_node_pointer() const {
        return static_cast<__node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }

    __attribute__ ((__always_inline__))
    explicit __forward_list_const_iterator(nullptr_t) noexcept
        : __ptr_(nullptr) {}

    __attribute__ ((__always_inline__))
    explicit __forward_list_const_iterator(__begin_node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    __attribute__ ((__always_inline__))
    explicit __forward_list_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}


    template<class, class> friend class forward_list;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __traits::__node_value_type value_type;
    typedef const value_type& reference;
    typedef typename pointer_traits<__node_pointer>::difference_type
                                                              difference_type;
    typedef typename __rebind_pointer<__node_pointer, const value_type>::type
                                                              pointer;

    __attribute__ ((__always_inline__))
    __forward_list_const_iterator() noexcept : __ptr_(nullptr) {}
    __attribute__ ((__always_inline__))
    __forward_list_const_iterator(__forward_list_iterator<__node_pointer> __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__always_inline__))
    reference operator*() const {return __get_unsafe_node_pointer()->__value_;}
    __attribute__ ((__always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(
                __get_unsafe_node_pointer()->__value_);}

    __attribute__ ((__always_inline__))
    __forward_list_const_iterator& operator++()
    {
        __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
        return *this;
    }
    __attribute__ ((__always_inline__))
    __forward_list_const_iterator operator++(int)
    {
        __forward_list_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__always_inline__))
    bool operator==(const __forward_list_const_iterator& __x,
                    const __forward_list_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __forward_list_const_iterator& __x,
                           const __forward_list_const_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _Alloc>
class __forward_list_base
{
protected:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;

    typedef typename allocator_traits<allocator_type>::void_pointer void_pointer;
    typedef __forward_list_node<value_type, void_pointer> __node;
    typedef typename __begin_node_of<value_type, void_pointer>::type __begin_node;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename __node_traits::pointer __node_pointer;

    typedef typename __rebind_alloc_helper<
        allocator_traits<allocator_type>, __begin_node
    >::type __begin_node_allocator;
    typedef typename allocator_traits<__begin_node_allocator>::pointer
                                                      __begin_node_pointer;

    __compressed_pair<__begin_node, __node_allocator> __before_begin_;

    __attribute__ ((__always_inline__))
    __begin_node_pointer __before_begin() noexcept
        {return pointer_traits<__begin_node_pointer>::pointer_to(__before_begin_.first());}
    __attribute__ ((__always_inline__))
    __begin_node_pointer __before_begin() const noexcept
        {return pointer_traits<__begin_node_pointer>::pointer_to(const_cast<__begin_node&>(__before_begin_.first()));}

    __attribute__ ((__always_inline__))
          __node_allocator& __alloc() noexcept
            {return __before_begin_.second();}
    __attribute__ ((__always_inline__))
    const __node_allocator& __alloc() const noexcept
        {return __before_begin_.second();}

    typedef __forward_list_iterator<__node_pointer> iterator;
    typedef __forward_list_const_iterator<__node_pointer> const_iterator;

    __attribute__ ((__always_inline__))
    __forward_list_base()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
        : __before_begin_(__begin_node()) {}
    __attribute__ ((__always_inline__))
    __forward_list_base(const allocator_type& __a)
        : __before_begin_(__begin_node(), __node_allocator(__a)) {}


public:
    __attribute__ ((__always_inline__))
    __forward_list_base(__forward_list_base&& __x)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value);
    __attribute__ ((__always_inline__))
    __forward_list_base(__forward_list_base&& __x, const allocator_type& __a);


private:
    __forward_list_base(const __forward_list_base&);
    __forward_list_base& operator=(const __forward_list_base&);

public:
    ~__forward_list_base();

protected:
    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __forward_list_base& __x)
        {__copy_assign_alloc(__x, integral_constant<bool,
              __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__forward_list_base& __x)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)

        {__move_assign_alloc(__x, integral_constant<bool,
              __node_traits::propagate_on_container_move_assignment::value>());}

public:
    __attribute__ ((__always_inline__))
    void swap(__forward_list_base& __x)

        noexcept;




protected:
    void clear() noexcept;

private:
    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __forward_list_base&, false_type) {}
    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __forward_list_base& __x, true_type)
    {
        if (__alloc() != __x.__alloc())
            clear();
        __alloc() = __x.__alloc();
    }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__forward_list_base&, false_type) noexcept
        {}
    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__forward_list_base& __x, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__alloc() = std::__1::move(__x.__alloc());}
};



template <class _Tp, class _Alloc>
inline
__forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value)
    : __before_begin_(std::__1::move(__x.__before_begin_))
{
    __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
inline
__forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x,
                                                      const allocator_type& __a)
    : __before_begin_(__begin_node(), __node_allocator(__a))
{
    if (__alloc() == __x.__alloc())
    {
        __before_begin()->__next_ = __x.__before_begin()->__next_;
        __x.__before_begin()->__next_ = nullptr;
    }
}



template <class _Tp, class _Alloc>
__forward_list_base<_Tp, _Alloc>::~__forward_list_base()
{
    clear();
}

template <class _Tp, class _Alloc>
inline
void
__forward_list_base<_Tp, _Alloc>::swap(__forward_list_base& __x)

        noexcept




{
    __swap_allocator(__alloc(), __x.__alloc(),
            integral_constant<bool, __node_traits::propagate_on_container_swap::value>());
    using std::__1::swap;
    swap(__before_begin()->__next_, __x.__before_begin()->__next_);
}

template <class _Tp, class _Alloc>
void
__forward_list_base<_Tp, _Alloc>::clear() noexcept
{
    __node_allocator& __a = __alloc();
    for (__node_pointer __p = __before_begin()->__next_; __p != nullptr;)
    {
        __node_pointer __next = __p->__next_;
        __node_traits::destroy(__a, std::__1::addressof(__p->__value_));
        __node_traits::deallocate(__a, __p, 1);
        __p = __next;
    }
    __before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc >
class forward_list
    : private __forward_list_base<_Tp, _Alloc>
{
    typedef __forward_list_base<_Tp, _Alloc> base;
    typedef typename base::__node_allocator __node_allocator;
    typedef typename base::__node __node;
    typedef typename base::__node_traits __node_traits;
    typedef typename base::__node_pointer __node_pointer;
    typedef typename base::__begin_node_pointer __begin_node_pointer;

public:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename allocator_traits<allocator_type>::pointer pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef typename base::iterator iterator;
    typedef typename base::const_iterator const_iterator;

    __attribute__ ((__always_inline__))
    forward_list()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
        {}
    __attribute__ ((__always_inline__))
    explicit forward_list(const allocator_type& __a);
    explicit forward_list(size_type __n);

    explicit forward_list(size_type __n, const allocator_type& __a);

    forward_list(size_type __n, const value_type& __v);
    forward_list(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        forward_list(_InputIterator __f, _InputIterator __l,
                     typename enable_if<
                       __is_input_iterator<_InputIterator>::value
                     >::type* = nullptr);
    template <class _InputIterator>
        forward_list(_InputIterator __f, _InputIterator __l,
                     const allocator_type& __a,
                     typename enable_if<
                       __is_input_iterator<_InputIterator>::value
                     >::type* = nullptr);
    forward_list(const forward_list& __x);
    forward_list(const forward_list& __x, const allocator_type& __a);

    forward_list& operator=(const forward_list& __x);


    __attribute__ ((__always_inline__))
    forward_list(forward_list&& __x)
        noexcept(is_nothrow_move_constructible<base>::value)
        : base(std::__1::move(__x)) {}
    forward_list(forward_list&& __x, const allocator_type& __a);

    forward_list(initializer_list<value_type> __il);
    forward_list(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    forward_list& operator=(forward_list&& __x)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value);



    __attribute__ ((__always_inline__))
    forward_list& operator=(initializer_list<value_type> __il);

    __attribute__ ((__always_inline__))
    void assign(initializer_list<value_type> __il);




    template <class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            void
        >::type
        assign(_InputIterator __f, _InputIterator __l);
    void assign(size_type __n, const value_type& __v);

    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept
        {return allocator_type(base::__alloc());}

    __attribute__ ((__always_inline__))
    iterator begin() noexcept
        {return iterator(base::__before_begin()->__next_);}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept
        {return const_iterator(base::__before_begin()->__next_);}
    __attribute__ ((__always_inline__))
    iterator end() noexcept
        {return iterator(nullptr);}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept
        {return const_iterator(nullptr);}

    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return const_iterator(base::__before_begin()->__next_);}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return const_iterator(nullptr);}

    __attribute__ ((__always_inline__))
    iterator before_begin() noexcept
        {return iterator(base::__before_begin());}
    __attribute__ ((__always_inline__))
    const_iterator before_begin() const noexcept
        {return const_iterator(base::__before_begin());}
    __attribute__ ((__always_inline__))
    const_iterator cbefore_begin() const noexcept
        {return const_iterator(base::__before_begin());}

    __attribute__ ((__always_inline__))
    bool empty() const noexcept
        {return base::__before_begin()->__next_ == nullptr;}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {
        return std::min<size_type>(
            __node_traits::max_size(base::__alloc()),
            numeric_limits<difference_type>::max());
    }

    __attribute__ ((__always_inline__))
    reference front() {return base::__before_begin()->__next_->__value_;}
    __attribute__ ((__always_inline__))
    const_reference front() const {return base::__before_begin()->__next_->__value_;}





    template <class... _Args> void emplace_front(_Args&&... __args);

    void push_front(value_type&& __v);

    void push_front(const value_type& __v);

    void pop_front();


    template <class... _Args>
        iterator emplace_after(const_iterator __p, _Args&&... __args);

    iterator insert_after(const_iterator __p, value_type&& __v);
    iterator insert_after(const_iterator __p, initializer_list<value_type> __il)
        {return insert_after(__p, __il.begin(), __il.end());}

    iterator insert_after(const_iterator __p, const value_type& __v);
    iterator insert_after(const_iterator __p, size_type __n, const value_type& __v);
    template <class _InputIterator>
        __attribute__ ((__always_inline__))
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            iterator
        >::type
        insert_after(const_iterator __p, _InputIterator __f, _InputIterator __l);

    iterator erase_after(const_iterator __p);
    iterator erase_after(const_iterator __f, const_iterator __l);

    __attribute__ ((__always_inline__))
    void swap(forward_list& __x)

        noexcept




        {base::swap(__x);}

    void resize(size_type __n);
    void resize(size_type __n, const value_type& __v);
    __attribute__ ((__always_inline__))
    void clear() noexcept {base::clear();}


    __attribute__ ((__always_inline__))
    void splice_after(const_iterator __p, forward_list&& __x);
    __attribute__ ((__always_inline__))
    void splice_after(const_iterator __p, forward_list&& __x, const_iterator __i);
    __attribute__ ((__always_inline__))
    void splice_after(const_iterator __p, forward_list&& __x,
                      const_iterator __f, const_iterator __l);

    void splice_after(const_iterator __p, forward_list& __x);
    void splice_after(const_iterator __p, forward_list& __x, const_iterator __i);
    void splice_after(const_iterator __p, forward_list& __x,
                      const_iterator __f, const_iterator __l);
    void remove(const value_type& __v);
    template <class _Predicate> void remove_if(_Predicate __pred);
    __attribute__ ((__always_inline__))
    void unique() {unique(__equal_to<value_type>());}
    template <class _BinaryPredicate> void unique(_BinaryPredicate __binary_pred);

    __attribute__ ((__always_inline__))
    void merge(forward_list&& __x) {merge(__x, __less<value_type>());}
    template <class _Compare>
        __attribute__ ((__always_inline__))
        void merge(forward_list&& __x, _Compare __comp)
        {merge(__x, std::__1::move(__comp));}

    __attribute__ ((__always_inline__))
    void merge(forward_list& __x) {merge(__x, __less<value_type>());}
    template <class _Compare> void merge(forward_list& __x, _Compare __comp);
    __attribute__ ((__always_inline__))
    void sort() {sort(__less<value_type>());}
    template <class _Compare> __attribute__ ((__always_inline__)) void sort(_Compare __comp);
    void reverse() noexcept;

private:


    void __move_assign(forward_list& __x, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(forward_list& __x, false_type);


    template <class _Compare>
        static
        __node_pointer
        __merge(__node_pointer __f1, __node_pointer __f2, _Compare& __comp);

    template <class _Compare>
        static
        __node_pointer
        __sort(__node_pointer __f, difference_type __sz, _Compare& __comp);
};

template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>::forward_list(const allocator_type& __a)
    : base(__a)
{
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n)
{
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
        for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n,
                                                             __p = __p->__next_as_begin())
        {
            __h.reset(__node_traits::allocate(__a, 1));
            __node_traits::construct(__a, std::__1::addressof(__h->__value_));
            __h->__next_ = nullptr;
            __p->__next_ = __h.release();
        }
    }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n,
                                        const allocator_type& __base_alloc)
    : base ( __base_alloc )
{
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
        for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n,
                                                             __p = __p->__next_as_begin())
        {
            __h.reset(__node_traits::allocate(__a, 1));
            __node_traits::construct(__a, std::__1::addressof(__h->__value_));
            __h->__next_ = nullptr;
            __p->__next_ = __h.release();
        }
    }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const value_type& __v)
{
    insert_after(cbefore_begin(), __n, __v);
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const value_type& __v,
                                        const allocator_type& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __n, __v);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l,
                                        typename enable_if<
                                          __is_input_iterator<_InputIterator>::value
                                        >::type*)
{
    insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l,
                                        const allocator_type& __a,
                                        typename enable_if<
                                          __is_input_iterator<_InputIterator>::value
                                        >::type*)
    : base(__a)
{
    insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x)
    : base(allocator_type(
             __node_traits::select_on_container_copy_construction(__x.__alloc())
                         )
          )
{
    insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x,
                                        const allocator_type& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(const forward_list& __x)
{
    if (this != &__x)
    {
        base::__copy_assign_alloc(__x);
        assign(__x.begin(), __x.end());
    }
    return *this;
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(forward_list&& __x,
                                        const allocator_type& __a)
    : base(std::__1::move(__x), __a)
{
    if (base::__alloc() != __x.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        insert_after(cbefore_begin(), _Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il)
{
    insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il,
                                        const allocator_type& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    clear();
    base::__move_assign_alloc(__x);
    base::__before_begin()->__next_ = __x.__before_begin()->__next_;
    __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, false_type)
{
    if (base::__alloc() == __x.__alloc())
        __move_assign(__x, true_type());
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(forward_list&& __x)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value)


{
    __move_assign(__x, integral_constant<bool,
          __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(initializer_list<value_type> __il)
{
    assign(__il.begin(), __il.end());
    return *this;
}



template <class _Tp, class _Alloc>
template <class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    void
>::type
forward_list<_Tp, _Alloc>::assign(_InputIterator __f, _InputIterator __l)
{
    iterator __i = before_begin();
    iterator __j = std::__1::next(__i);
    iterator __e = end();
    for (; __j != __e && __f != __l; ++__i, (void) ++__j, ++__f)
        *__j = *__f;
    if (__j == __e)
        insert_after(__i, __f, __l);
    else
        erase_after(__i, __e);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::assign(size_type __n, const value_type& __v)
{
    iterator __i = before_begin();
    iterator __j = std::__1::next(__i);
    iterator __e = end();
    for (; __j != __e && __n > 0; --__n, ++__i, ++__j)
        *__j = __v;
    if (__j == __e)
        insert_after(__i, __n, __v);
    else
        erase_after(__i, __e);
}



template <class _Tp, class _Alloc>
inline
void
forward_list<_Tp, _Alloc>::assign(initializer_list<value_type> __il)
{
    assign(__il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
template <class... _Args>



void

forward_list<_Tp, _Alloc>::emplace_front(_Args&&... __args)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_),
                                  std::__1::forward<_Args>(__args)...);
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();



}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::push_front(value_type&& __v)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), std::__1::move(__v));
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();
}



template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::push_front(const value_type& __v)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::pop_front()
{
    __node_allocator& __a = base::__alloc();
    __node_pointer __p = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __p->__next_;
    __node_traits::destroy(__a, std::__1::addressof(__p->__value_));
    __node_traits::deallocate(__a, __p, 1);
}



template <class _Tp, class _Alloc>
template <class... _Args>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::emplace_after(const_iterator __p, _Args&&... __args)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_),
                                  std::__1::forward<_Args>(__args)...);
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, value_type&& __v)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), std::__1::move(__v));
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}



template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, const value_type& __v)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, size_type __n,
                                        const value_type& __v)
{
    __begin_node_pointer __r = __p.__get_begin();
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
        __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
        __node_pointer __first = __h.release();
        __node_pointer __last = __first;




            for (--__n; __n != 0; --__n, __last = __last->__next_)
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
                __last->__next_ = __h.release();
            }
# 1227 "../../buildtools/third_party/libc++/trunk/include/forward_list" 3
        __last->__next_ = __r->__next_;
        __r->__next_ = __first;
        __r = static_cast<__begin_node_pointer>(__last);
    }
    return iterator(__r);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    typename forward_list<_Tp, _Alloc>::iterator
>::type
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p,
                                        _InputIterator __f, _InputIterator __l)
{
    __begin_node_pointer __r = __p.__get_begin();
    if (__f != __l)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
        __node_traits::construct(__a, std::__1::addressof(__h->__value_), *__f);
        __node_pointer __first = __h.release();
        __node_pointer __last = __first;




            for (++__f; __f != __l; ++__f, ((void)(__last = __last->__next_)))
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), *__f);
                __last->__next_ = __h.release();
            }
# 1277 "../../buildtools/third_party/libc++/trunk/include/forward_list" 3
        __last->__next_ = __r->__next_;
        __r->__next_ = __first;
        __r = static_cast<__begin_node_pointer>(__last);
    }
    return iterator(__r);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::erase_after(const_iterator __f)
{
    __begin_node_pointer __p = __f.__get_begin();
    __node_pointer __n = __p->__next_;
    __p->__next_ = __n->__next_;
    __node_allocator& __a = base::__alloc();
    __node_traits::destroy(__a, std::__1::addressof(__n->__value_));
    __node_traits::deallocate(__a, __n, 1);
    return iterator(__p->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::erase_after(const_iterator __f, const_iterator __l)
{
    __node_pointer __e = __l.__get_unsafe_node_pointer();
    if (__f != __l)
    {
        __begin_node_pointer __bp = __f.__get_begin();

        __node_pointer __n = __bp->__next_;
        if (__n != __e)
        {
            __bp->__next_ = __e;
            __node_allocator& __a = base::__alloc();
            do
            {
                __node_pointer __tmp = __n->__next_;
                __node_traits::destroy(__a, std::__1::addressof(__n->__value_));
                __node_traits::deallocate(__a, __n, 1);
                __n = __tmp;
            } while (__n != __e);
        }
    }
    return iterator(__e);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::resize(size_type __n)
{
    size_type __sz = 0;
    iterator __p = before_begin();
    iterator __i = begin();
    iterator __e = end();
    for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
        ;
    if (__i != __e)
        erase_after(__p, __e);
    else
    {
        __n -= __sz;
        if (__n > 0)
        {
            __node_allocator& __a = base::__alloc();
            typedef __allocator_destructor<__node_allocator> _Dp;
            unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
            for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n,
                                                         __ptr = __ptr->__next_as_begin())
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_));
                __h->__next_ = nullptr;
                __ptr->__next_ = __h.release();
            }
        }
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::resize(size_type __n, const value_type& __v)
{
    size_type __sz = 0;
    iterator __p = before_begin();
    iterator __i = begin();
    iterator __e = end();
    for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
        ;
    if (__i != __e)
        erase_after(__p, __e);
    else
    {
        __n -= __sz;
        if (__n > 0)
        {
            __node_allocator& __a = base::__alloc();
            typedef __allocator_destructor<__node_allocator> _Dp;
            unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
            for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n,
                                                         __ptr = __ptr->__next_as_begin())
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
                __h->__next_ = nullptr;
                __ptr->__next_ = __h.release();
            }
        }
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& __x)
{
    if (!__x.empty())
    {
        if (__p.__get_begin()->__next_ != nullptr)
        {
            const_iterator __lm1 = __x.before_begin();
            while (__lm1.__get_begin()->__next_ != nullptr)
                ++__lm1;
            __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
        }
        __p.__get_begin()->__next_ = __x.__before_begin()->__next_;
        __x.__before_begin()->__next_ = nullptr;
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& ,
                                        const_iterator __i)
{
    const_iterator __lm1 = std::__1::next(__i);
    if (__p != __i && __p != __lm1)
    {
        __i.__get_begin()->__next_ = __lm1.__get_begin()->__next_;
        __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
        __p.__get_begin()->__next_ = __lm1.__get_unsafe_node_pointer();
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& ,
                                        const_iterator __f, const_iterator __l)
{
    if (__f != __l && __p != __f)
    {
        const_iterator __lm1 = __f;
        while (__lm1.__get_begin()->__next_ != __l.__get_begin())
            ++__lm1;
        if (__f != __lm1)
        {
            __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
            __p.__get_begin()->__next_ = __f.__get_begin()->__next_;
            __f.__get_begin()->__next_ = __l.__get_unsafe_node_pointer();
        }
    }
}



template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x)
{
    splice_after(__p, __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x,
                                        const_iterator __i)
{
    splice_after(__p, __x, __i);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x,
                                        const_iterator __f, const_iterator __l)
{
    splice_after(__p, __x, __f, __l);
}



template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::remove(const value_type& __v)
{
    forward_list<_Tp, _Alloc> __deleted_nodes;
    iterator __e = end();
    for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;)
    {
        if (__i.__get_begin()->__next_->__value_ == __v)
        {
            iterator __j = std::__1::next(__i, 2);
            for (; __j != __e && *__j == __v; ++__j)
                ;
            __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }
}

template <class _Tp, class _Alloc>
template <class _Predicate>
void
forward_list<_Tp, _Alloc>::remove_if(_Predicate __pred)
{
    iterator __e = end();
    for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;)
    {
        if (__pred(__i.__get_begin()->__next_->__value_))
        {
            iterator __j = std::__1::next(__i, 2);
            for (; __j != __e && __pred(*__j); ++__j)
                ;
            erase_after(__i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }
}

template <class _Tp, class _Alloc>
template <class _BinaryPredicate>
void
forward_list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred)
{
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        iterator __j = std::__1::next(__i);
        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
            ;
        if (__i.__get_begin()->__next_ != __j.__get_unsafe_node_pointer())
            erase_after(__i, __j);
        __i = __j;
    }
}

template <class _Tp, class _Alloc>
template <class _Compare>
void
forward_list<_Tp, _Alloc>::merge(forward_list& __x, _Compare __comp)
{
    if (this != &__x)
    {
        base::__before_begin()->__next_ = __merge(base::__before_begin()->__next_,
                                                    __x.__before_begin()->__next_,
                                                    __comp);
        __x.__before_begin()->__next_ = nullptr;
    }
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__merge(__node_pointer __f1, __node_pointer __f2,
                                   _Compare& __comp)
{
    if (__f1 == nullptr)
        return __f2;
    if (__f2 == nullptr)
        return __f1;
    __node_pointer __r;
    if (__comp(__f2->__value_, __f1->__value_))
    {
        __node_pointer __t = __f2;
        while (__t->__next_ != nullptr &&
                             __comp(__t->__next_->__value_, __f1->__value_))
            __t = __t->__next_;
        __r = __f2;
        __f2 = __t->__next_;
        __t->__next_ = __f1;
    }
    else
        __r = __f1;
    __node_pointer __p = __f1;
    __f1 = __f1->__next_;
    while (__f1 != nullptr && __f2 != nullptr)
    {
        if (__comp(__f2->__value_, __f1->__value_))
        {
            __node_pointer __t = __f2;
            while (__t->__next_ != nullptr &&
                                 __comp(__t->__next_->__value_, __f1->__value_))
                __t = __t->__next_;
            __p->__next_ = __f2;
            __f2 = __t->__next_;
            __t->__next_ = __f1;
        }
        __p = __f1;
        __f1 = __f1->__next_;
    }
    if (__f2 != nullptr)
        __p->__next_ = __f2;
    return __r;
}

template <class _Tp, class _Alloc>
template <class _Compare>
inline
void
forward_list<_Tp, _Alloc>::sort(_Compare __comp)
{
    base::__before_begin()->__next_ = __sort(base::__before_begin()->__next_,
                                       std::__1::distance(begin(), end()), __comp);
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__sort(__node_pointer __f1, difference_type __sz,
                                  _Compare& __comp)
{
    switch (__sz)
    {
    case 0:
    case 1:
        return __f1;
    case 2:
        if (__comp(__f1->__next_->__value_, __f1->__value_))
        {
            __node_pointer __t = __f1->__next_;
            __t->__next_ = __f1;
            __f1->__next_ = nullptr;
            __f1 = __t;
        }
        return __f1;
    }
    difference_type __sz1 = __sz / 2;
    difference_type __sz2 = __sz - __sz1;
    __node_pointer __t = std::__1::next(iterator(__f1), __sz1 - 1).__get_unsafe_node_pointer();
    __node_pointer __f2 = __t->__next_;
    __t->__next_ = nullptr;
    return __merge(__sort(__f1, __sz1, __comp),
                   __sort(__f2, __sz2, __comp), __comp);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::reverse() noexcept
{
    __node_pointer __p = base::__before_begin()->__next_;
    if (__p != nullptr)
    {
        __node_pointer __f = __p->__next_;
        __p->__next_ = nullptr;
        while (__f != nullptr)
        {
            __node_pointer __t = __f->__next_;
            __f->__next_ = __p;
            __p = __f;
            __f = __t;
        }
        base::__before_begin()->__next_ = __p;
    }
}

template <class _Tp, class _Alloc>
bool operator==(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    typedef forward_list<_Tp, _Alloc> _Cp;
    typedef typename _Cp::const_iterator _Ip;
    _Ip __ix = __x.begin();
    _Ip __ex = __x.end();
    _Ip __iy = __y.begin();
    _Ip __ey = __y.end();
    for (; __ix != __ex && __iy != __ey; ++__ix, ++__iy)
        if (!(*__ix == *__iy))
            return false;
    return (__ix == __ex) == (__iy == __ey);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool operator!=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool operator< (const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(),
                                         __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool operator> (const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool operator>=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool operator<=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
void
swap(forward_list<_Tp, _Alloc>& __x, forward_list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 13 "../../base/stl_util.h" 2


# 1 "../../buildtools/third_party/libc++/trunk/include/list" 1 3
# 184 "../../buildtools/third_party/libc++/trunk/include/list" 3



# 1 "../../buildtools/third_party/libc++/trunk/include/__undef_macros" 1 3
# 188 "../../buildtools/third_party/libc++/trunk/include/list" 2 3


namespace std {inline namespace __1 {

template <class _Tp, class _VoidPtr> struct __list_node;
template <class _Tp, class _VoidPtr> struct __list_node_base;

template <class _Tp, class _VoidPtr>
struct __list_node_pointer_traits {
  typedef typename __rebind_pointer<_VoidPtr, __list_node<_Tp, _VoidPtr> >::type
        __node_pointer;
  typedef typename __rebind_pointer<_VoidPtr, __list_node_base<_Tp, _VoidPtr> >::type
        __base_pointer;




  typedef typename conditional<
          is_pointer<_VoidPtr>::value,
          __base_pointer,
          __node_pointer
  >::type __link_pointer;


  typedef typename conditional<
          is_same<__link_pointer, __node_pointer>::value,
          __base_pointer,
          __node_pointer
  >::type __non_link_pointer;

  static __attribute__ ((__always_inline__))
  __link_pointer __unsafe_link_pointer_cast(__link_pointer __p) {
      return __p;
  }

  static __attribute__ ((__always_inline__))
  __link_pointer __unsafe_link_pointer_cast(__non_link_pointer __p) {
      return static_cast<__link_pointer>(static_cast<_VoidPtr>(__p));
  }

};

template <class _Tp, class _VoidPtr>
struct __list_node_base
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__node_pointer __node_pointer;
    typedef typename _NodeTraits::__base_pointer __base_pointer;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __prev_;
    __link_pointer __next_;

    __attribute__ ((__always_inline__))
    __list_node_base() : __prev_(_NodeTraits::__unsafe_link_pointer_cast(__self())),
                         __next_(_NodeTraits::__unsafe_link_pointer_cast(__self())) {}

    __attribute__ ((__always_inline__))
    __base_pointer __self() {
        return pointer_traits<__base_pointer>::pointer_to(*this);
    }

    __attribute__ ((__always_inline__))
    __node_pointer __as_node() {
        return static_cast<__node_pointer>(__self());
    }
};

template <class _Tp, class _VoidPtr>
struct __list_node
    : public __list_node_base<_Tp, _VoidPtr>
{
    _Tp __value_;

    typedef __list_node_base<_Tp, _VoidPtr> __base;
    typedef typename __base::__link_pointer __link_pointer;

    __attribute__ ((__always_inline__))
    __link_pointer __as_link() {
        return static_cast<__link_pointer>(__base::__self());
    }
};

template <class _Tp, class _Alloc = allocator<_Tp> > class list;
template <class _Tp, class _Alloc> class __list_imp;
template <class _Tp, class _VoidPtr> class __list_const_iterator;

template <class _Tp, class _VoidPtr>
class __list_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __ptr_;
# 291 "../../buildtools/third_party/libc++/trunk/include/list" 3
    __attribute__ ((__always_inline__))
    explicit __list_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}




    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
    template<class, class> friend class __list_const_iterator;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;

    __attribute__ ((__always_inline__))
    __list_iterator() noexcept : __ptr_(nullptr)
    {



    }
# 343 "../../buildtools/third_party/libc++/trunk/include/list" 3
    __attribute__ ((__always_inline__))
    reference operator*() const
    {




        return __ptr_->__as_node()->__value_;
    }
    __attribute__ ((__always_inline__))
    pointer operator->() const
    {




        return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
    }

    __attribute__ ((__always_inline__))
    __list_iterator& operator++()
    {




        __ptr_ = __ptr_->__next_;
        return *this;
    }
    __attribute__ ((__always_inline__))
    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__always_inline__))
    __list_iterator& operator--()
    {




        __ptr_ = __ptr_->__prev_;
        return *this;
    }
    __attribute__ ((__always_inline__))
    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__always_inline__))
    bool operator==(const __list_iterator& __x, const __list_iterator& __y)
    {
        return __x.__ptr_ == __y.__ptr_;
    }
    friend __attribute__ ((__always_inline__))
     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _VoidPtr>
class __list_const_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __ptr_;
# 414 "../../buildtools/third_party/libc++/trunk/include/list" 3
    __attribute__ ((__always_inline__))
    explicit __list_const_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}


    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef const value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, const value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;

    __attribute__ ((__always_inline__))
    __list_const_iterator() noexcept : __ptr_(nullptr)
    {



    }
    __attribute__ ((__always_inline__))
    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) noexcept
        : __ptr_(__p.__ptr_)
    {



    }
# 470 "../../buildtools/third_party/libc++/trunk/include/list" 3
    __attribute__ ((__always_inline__))
    reference operator*() const
    {




        return __ptr_->__as_node()->__value_;
    }
    __attribute__ ((__always_inline__))
    pointer operator->() const
    {




        return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
    }

    __attribute__ ((__always_inline__))
    __list_const_iterator& operator++()
    {




        __ptr_ = __ptr_->__next_;
        return *this;
    }
    __attribute__ ((__always_inline__))
    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__always_inline__))
    __list_const_iterator& operator--()
    {




        __ptr_ = __ptr_->__prev_;
        return *this;
    }
    __attribute__ ((__always_inline__))
    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__always_inline__))
    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)
    {
        return __x.__ptr_ == __y.__ptr_;
    }
    friend __attribute__ ((__always_inline__))
    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _Alloc>
class __list_imp
{
    __list_imp(const __list_imp&);
    __list_imp& operator=(const __list_imp&);
protected:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::void_pointer __void_pointer;
    typedef __list_iterator<value_type, __void_pointer> iterator;
    typedef __list_const_iterator<value_type, __void_pointer> const_iterator;
    typedef __list_node_base<value_type, __void_pointer> __node_base;
    typedef __list_node<value_type, __void_pointer> __node;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_alloc_traits;
    typedef typename __node_alloc_traits::pointer __node_pointer;
    typedef typename __node_alloc_traits::pointer __node_const_pointer;
    typedef __list_node_pointer_traits<value_type, __void_pointer> __node_pointer_traits;
    typedef typename __node_pointer_traits::__link_pointer __link_pointer;
    typedef __link_pointer __link_const_pointer;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node_base>::type __node_base_allocator;
    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;

    __node_base __end_;
    __compressed_pair<size_type, __node_allocator> __size_alloc_;

    __attribute__ ((__always_inline__))
    __link_pointer __end_as_link() const noexcept {
        return __node_pointer_traits::__unsafe_link_pointer_cast(
                const_cast<__node_base&>(__end_).__self());
    }

    __attribute__ ((__always_inline__))
          size_type& __sz() noexcept {return __size_alloc_.first();}
    __attribute__ ((__always_inline__))
    const size_type& __sz() const noexcept
        {return __size_alloc_.first();}
    __attribute__ ((__always_inline__))
          __node_allocator& __node_alloc() noexcept
          {return __size_alloc_.second();}
    __attribute__ ((__always_inline__))
    const __node_allocator& __node_alloc() const noexcept
        {return __size_alloc_.second();}

    __attribute__ ((__always_inline__))
    size_type __node_alloc_max_size() const noexcept {
        return __node_alloc_traits::max_size(__node_alloc());
    }
    __attribute__ ((__always_inline__))
    static void __unlink_nodes(__link_pointer __f, __link_pointer __l) noexcept;

    __attribute__ ((__always_inline__))
    __list_imp()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value);
    __attribute__ ((__always_inline__))
    __list_imp(const allocator_type& __a);
    ~__list_imp();
    void clear() noexcept;
    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __sz() == 0;}

    __attribute__ ((__always_inline__))
    iterator begin() noexcept
    {



        return iterator(__end_.__next_);

    }
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept
    {



        return const_iterator(__end_.__next_);

    }
    __attribute__ ((__always_inline__))
    iterator end() noexcept
    {



        return iterator(__end_as_link());

    }
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept
    {



        return const_iterator(__end_as_link());

    }

    void swap(__list_imp& __c)

        noexcept;





    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __list_imp& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__list_imp& __c)
        noexcept(!__node_alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}

private:
    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __list_imp& __c, true_type)
        {
            if (__node_alloc() != __c.__node_alloc())
                clear();
            __node_alloc() = __c.__node_alloc();
        }

    __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __list_imp&, false_type)
        {}

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__list_imp& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {
            __node_alloc() = std::__1::move(__c.__node_alloc());
        }

    __attribute__ ((__always_inline__))
    void __move_assign_alloc(__list_imp&, false_type)
        noexcept
        {}

    __attribute__ ((__always_inline__))
    void __invalidate_all_iterators() {



    }
};


template <class _Tp, class _Alloc>
inline
void
__list_imp<_Tp, _Alloc>::__unlink_nodes(__link_pointer __f, __link_pointer __l)
    noexcept
{
    __f->__prev_->__next_ = __l->__next_;
    __l->__next_->__prev_ = __f->__prev_;
}

template <class _Tp, class _Alloc>
inline
__list_imp<_Tp, _Alloc>::__list_imp()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
    : __size_alloc_(0)
{
}

template <class _Tp, class _Alloc>
inline
__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)
    : __size_alloc_(0, __node_allocator(__a))
{
}

template <class _Tp, class _Alloc>
__list_imp<_Tp, _Alloc>::~__list_imp()
{
    clear();



}

template <class _Tp, class _Alloc>
void
__list_imp<_Tp, _Alloc>::clear() noexcept
{
    if (!empty())
    {
        __node_allocator& __na = __node_alloc();
        __link_pointer __f = __end_.__next_;
        __link_pointer __l = __end_as_link();
        __unlink_nodes(__f, __l->__prev_);
        __sz() = 0;
        while (__f != __l)
        {
            __node_pointer __np = __f->__as_node();
            __f = __f->__next_;
            __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
            __node_alloc_traits::deallocate(__na, __np, 1);
        }
        __invalidate_all_iterators();
    }
}

template <class _Tp, class _Alloc>
void
__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)

        noexcept




{
    ((void)0);



    using std::__1::swap;
    __swap_allocator(__node_alloc(), __c.__node_alloc());
    swap(__sz(), __c.__sz());
    swap(__end_, __c.__end_);
    if (__sz() == 0)
        __end_.__next_ = __end_.__prev_ = __end_as_link();
    else
        __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_as_link();
    if (__c.__sz() == 0)
        __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_as_link();
    else
        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ = __c.__end_as_link();
# 802 "../../buildtools/third_party/libc++/trunk/include/list" 3
}

template <class _Tp, class _Alloc >
class list
    : private __list_imp<_Tp, _Alloc>
{
    typedef __list_imp<_Tp, _Alloc> base;
    typedef typename base::__node __node;
    typedef typename base::__node_allocator __node_allocator;
    typedef typename base::__node_pointer __node_pointer;
    typedef typename base::__node_alloc_traits __node_alloc_traits;
    typedef typename base::__node_base __node_base;
    typedef typename base::__node_base_pointer __node_base_pointer;
    typedef typename base::__link_pointer __link_pointer;

public:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename base::pointer pointer;
    typedef typename base::const_pointer const_pointer;
    typedef typename base::size_type size_type;
    typedef typename base::difference_type difference_type;
    typedef typename base::iterator iterator;
    typedef typename base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    __attribute__ ((__always_inline__))
    list()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
    {



    }
    __attribute__ ((__always_inline__))
    explicit list(const allocator_type& __a) : base(__a)
    {



    }
    explicit list(size_type __n);

    explicit list(size_type __n, const allocator_type& __a);

    list(size_type __n, const value_type& __x);
    list(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InpIter>
        list(_InpIter __f, _InpIter __l,
             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);
    template <class _InpIter>
        list(_InpIter __f, _InpIter __l, const allocator_type& __a,
             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);

    list(const list& __c);
    list(const list& __c, const allocator_type& __a);
    __attribute__ ((__always_inline__))
    list& operator=(const list& __c);

    list(initializer_list<value_type> __il);
    list(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__always_inline__))
    list(list&& __c)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value);
    __attribute__ ((__always_inline__))
    list(list&& __c, const allocator_type& __a);
    __attribute__ ((__always_inline__))
    list& operator=(list&& __c)
        noexcept(__node_alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value);



    __attribute__ ((__always_inline__))
    list& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}

    __attribute__ ((__always_inline__))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    template <class _InpIter>
        void assign(_InpIter __f, _InpIter __l,
             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);
    void assign(size_type __n, const value_type& __x);

    __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept;

    __attribute__ ((__always_inline__))
    size_type size() const noexcept {return base::__sz();}
    __attribute__ ((__always_inline__))
    bool empty() const noexcept {return base::empty();}
    __attribute__ ((__always_inline__))
    size_type max_size() const noexcept
        {
            return std::min<size_type>(
                base::__node_alloc_max_size(),
                numeric_limits<difference_type >::max());
        }

    __attribute__ ((__always_inline__))
          iterator begin() noexcept {return base::begin();}
    __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return base::begin();}
    __attribute__ ((__always_inline__))
          iterator end() noexcept {return base::end();}
    __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return base::end();}
    __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return base::begin();}
    __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return base::end();}

    __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__always_inline__))
    reference front()
    {
        ((void)0);
        return base::__end_.__next_->__as_node()->__value_;
    }
    __attribute__ ((__always_inline__))
    const_reference front() const
    {
        ((void)0);
        return base::__end_.__next_->__as_node()->__value_;
    }
    __attribute__ ((__always_inline__))
    reference back()
    {
        ((void)0);
        return base::__end_.__prev_->__as_node()->__value_;
    }
    __attribute__ ((__always_inline__))
    const_reference back() const
    {
        ((void)0);
        return base::__end_.__prev_->__as_node()->__value_;
    }


    void push_front(value_type&& __x);
    void push_back(value_type&& __x);

    template <class... _Args>



       void emplace_front(_Args&&... __args);

    template <class... _Args>



       void emplace_back(_Args&&... __args);

    template <class... _Args>
        iterator emplace(const_iterator __p, _Args&&... __args);

    iterator insert(const_iterator __p, value_type&& __x);

    __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, initializer_list<value_type> __il)
        {return insert(__p, __il.begin(), __il.end());}


    void push_front(const value_type& __x);
    void push_back(const value_type& __x);


    template <class _Arg>
    __attribute__ ((__always_inline__))
    void __emplace_back(_Arg&& __arg) { emplace_back(std::__1::forward<_Arg>(__arg)); }





    iterator insert(const_iterator __p, const value_type& __x);
    iterator insert(const_iterator __p, size_type __n, const value_type& __x);
    template <class _InpIter>
        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,
             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);

    __attribute__ ((__always_inline__))
    void swap(list& __c)

        noexcept




        {base::swap(__c);}
    __attribute__ ((__always_inline__))
    void clear() noexcept {base::clear();}

    void pop_front();
    void pop_back();

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);

    void resize(size_type __n);
    void resize(size_type __n, const value_type& __x);

    void splice(const_iterator __p, list& __c);

    __attribute__ ((__always_inline__))
    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}
    __attribute__ ((__always_inline__))
    void splice(const_iterator __p, list&& __c, const_iterator __i)
        {splice(__p, __c, __i);}
    __attribute__ ((__always_inline__))
    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)
        {splice(__p, __c, __f, __l);}

    void splice(const_iterator __p, list& __c, const_iterator __i);
    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);

    void remove(const value_type& __x);
    template <class _Pred> void remove_if(_Pred __pred);
    __attribute__ ((__always_inline__))
    void unique();
    template <class _BinaryPred>
        void unique(_BinaryPred __binary_pred);
    __attribute__ ((__always_inline__))
    void merge(list& __c);

    __attribute__ ((__always_inline__))
    void merge(list&& __c) {merge(__c);}

    template <class _Comp>
    __attribute__ ((__always_inline__))
        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}

    template <class _Comp>
        void merge(list& __c, _Comp __comp);

    __attribute__ ((__always_inline__))
    void sort();
    template <class _Comp>
        __attribute__ ((__always_inline__))
        void sort(_Comp __comp);

    void reverse() noexcept;

    bool __invariants() const;

    typedef __allocator_destructor<__node_allocator> __node_destructor;
    typedef unique_ptr<__node, __node_destructor> __hold_pointer;

    __attribute__ ((__always_inline__))
    __hold_pointer __allocate_node(__node_allocator& __na) {
      __node_pointer __p = __node_alloc_traits::allocate(__na, 1);
      __p->__prev_ = nullptr;
      return __hold_pointer(__p, __node_destructor(__na, 1));
    }
# 1093 "../../buildtools/third_party/libc++/trunk/include/list" 3
private:
    __attribute__ ((__always_inline__))
    static void __link_nodes (__link_pointer __p, __link_pointer __f, __link_pointer __l);
    __attribute__ ((__always_inline__))
    void __link_nodes_at_front(__link_pointer __f, __link_pointer __l);
    __attribute__ ((__always_inline__))
    void __link_nodes_at_back (__link_pointer __f, __link_pointer __l);
    iterator __iterator(size_type __n);
    template <class _Comp>
        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);

    void __move_assign(list& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value);
    void __move_assign(list& __c, false_type);
};


template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes(__link_pointer __p, __link_pointer __f, __link_pointer __l)
{
    __p->__prev_->__next_ = __f;
    __f->__prev_ = __p->__prev_;
    __p->__prev_ = __l;
    __l->__next_ = __p;
}


template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes_at_front(__link_pointer __f, __link_pointer __l)
{
    __f->__prev_ = base::__end_as_link();
    __l->__next_ = base::__end_.__next_;
    __l->__next_->__prev_ = __l;
    base::__end_.__next_ = __f;
}


template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes_at_back(__link_pointer __f, __link_pointer __l)
{
    __l->__next_ = base::__end_as_link();
    __f->__prev_ = base::__end_.__prev_;
    __f->__prev_->__next_ = __f;
    base::__end_.__prev_ = __l;
}


template <class _Tp, class _Alloc>
inline
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__iterator(size_type __n)
{
    return __n <= base::__sz() / 2 ? std::__1::next(begin(), __n)
                                   : std::__1::prev(end(), base::__sz() - __n);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n)
{



    for (; __n > 0; --__n)

        emplace_back();



}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)
{



    for (; __n > 0; --__n)
        emplace_back();
}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type& __x)
{



    for (; __n > 0; --__n)
        push_back(__x);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)
    : base(__a)
{



    for (; __n > 0; --__n)
        push_back(__x);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,
                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)
{



    for (; __f != __l; ++__f)
        __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,
                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)
    : base(__a)
{



    for (; __f != __l; ++__f)
        __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c)
    : base(allocator_type(
           __node_alloc_traits::select_on_container_copy_construction(
                __c.__node_alloc())))
{



    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c, const allocator_type& __a)
    : base(__a)
{



    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
        push_back(*__i);
}



template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)
    : base(__a)
{



    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
            __e = __il.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il)
{



    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
            __e = __il.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>::list(list&& __c)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value)
    : base(allocator_type(std::__1::move(__c.__node_alloc())))
{



    splice(end(), __c);
}

template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>::list(list&& __c, const allocator_type& __a)
    : base(__a)
{



    if (__a == __c.get_allocator())
        splice(end(), __c);
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>&
list<_Tp, _Alloc>::operator=(list&& __c)
        noexcept(__node_alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value)


{
    __move_assign(__c, integral_constant<bool,
          __node_alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::__move_assign(list& __c, false_type)
{
    if (base::__node_alloc() != __c.__node_alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::__move_assign(list& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
{
    clear();
    base::__move_assign_alloc(__c);
    splice(end(), __c);
}



template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>&
list<_Tp, _Alloc>::operator=(const list& __c)
{
    if (this != &__c)
    {
        base::__copy_assign_alloc(__c);
        assign(__c.begin(), __c.end());
    }
    return *this;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
void
list<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,
                          typename enable_if<__is_input_iterator<_InpIter>::value>::type*)
{
    iterator __i = begin();
    iterator __e = end();
    for (; __f != __l && __i != __e; ++__f, ++__i)
        *__i = *__f;
    if (__i == __e)
        insert(__e, __f, __l);
    else
        erase(__i, __e);



}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)
{
    iterator __i = begin();
    iterator __e = end();
    for (; __n > 0 && __i != __e; --__n, ++__i)
        *__i = __x;
    if (__i == __e)
        insert(__e, __n, __x);
    else
        erase(__i, __e);



}

template <class _Tp, class _Alloc>
inline
_Alloc
list<_Tp, _Alloc>::get_allocator() const noexcept
{
    return allocator_type(base::__node_alloc());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_nodes(__p.__ptr_, __hold->__as_link(), __hold->__as_link());
    ++base::__sz();



    return iterator(__hold.release()->__as_link());

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)
{






    iterator __r(__p.__ptr_);

    if (__n > 0)
    {
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
        ++__ds;



        __r = iterator(__hold->__as_link());

        __hold.release();
        iterator __e = __r;




            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
                __e.__ptr_->__next_ = __hold->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }
# 1479 "../../buildtools/third_party/libc++/trunk/include/list" 3
        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
    return __r;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,
             typename enable_if<__is_input_iterator<_InpIter>::value>::type*)
{






    iterator __r(__p.__ptr_);

    if (__f != __l)
    {
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), *__f);
        ++__ds;



        __r = iterator(__hold.get()->__as_link());

        __hold.release();
        iterator __e = __r;




            for (++__f; __f != __l; ++__f, (void) ++__e, (void) ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), *__f);
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }
# 1545 "../../buildtools/third_party/libc++/trunk/include/list" 3
        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
    return __r;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_front(const value_type& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_pointer __nl = __hold->__as_link();
    __link_nodes_at_front(__nl, __nl);
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_back(const value_type& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}



template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_front(value_type&& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_back(value_type&& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
template <class... _Args>



void

list<_Tp, _Alloc>::emplace_front(_Args&&... __args)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();



    __hold.release();

}

template <class _Tp, class _Alloc>
template <class... _Args>



void

list<_Tp, _Alloc>::emplace_back(_Args&&... __args)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_pointer __nl = __hold->__as_link();
    __link_nodes_at_back(__nl, __nl);
    ++base::__sz();



    __hold.release();

}

template <class _Tp, class _Alloc>
template <class... _Args>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_pointer __nl = __hold.get()->__as_link();
    __link_nodes(__p.__ptr_, __nl, __nl);
    ++base::__sz();
    __hold.release();



    return iterator(__nl);

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_pointer __nl = __hold->__as_link();
    __link_nodes(__p.__ptr_, __nl, __nl);
    ++base::__sz();
    __hold.release();



    return iterator(__nl);

}



template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::pop_front()
{
    ((void)0);
    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = base::__end_.__next_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1718 "../../buildtools/third_party/libc++/trunk/include/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::pop_back()
{
    ((void)0);
    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = base::__end_.__prev_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1747 "../../buildtools/third_party/libc++/trunk/include/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __p)
{





    ((void)0);

    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = __p.__ptr_;
    __link_pointer __r = __n->__next_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1783 "../../buildtools/third_party/libc++/trunk/include/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);



    return iterator(__r);

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)
{
# 1805 "../../buildtools/third_party/libc++/trunk/include/list" 3
    if (__f != __l)
    {
        __node_allocator& __na = base::__node_alloc();
        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);
        while (__f != __l)
        {
            __link_pointer __n = __f.__ptr_;
            ++__f;
            --base::__sz();
# 1829 "../../buildtools/third_party/libc++/trunk/include/list" 3
            __node_pointer __np = __n->__as_node();
            __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
            __node_alloc_traits::deallocate(__na, __np, 1);
        }
    }



    return iterator(__l.__ptr_);

}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::resize(size_type __n)
{
    if (__n < base::__sz())
        erase(__iterator(__n), end());
    else if (__n > base::__sz())
    {
        __n -= base::__sz();
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_));
        ++__ds;



        iterator __r = iterator(__hold.release()->__as_link());

        iterator __e = __r;




            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_));
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }
# 1893 "../../buildtools/third_party/libc++/trunk/include/list" 3
        __link_nodes_at_back(__r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)
{
    if (__n < base::__sz())
        erase(__iterator(__n), end());
    else if (__n > base::__sz())
    {
        __n -= base::__sz();
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
        ++__ds;
        __link_pointer __nl = __hold.release()->__as_link();



        iterator __r = iterator(__nl);

        iterator __e = __r;




            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }
# 1951 "../../buildtools/third_party/libc++/trunk/include/list" 3
        __link_nodes(base::__end_as_link(), __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c)
{
    ((void)0);






    if (!__c.empty())
    {
        __link_pointer __f = __c.__end_.__next_;
        __link_pointer __l = __c.__end_.__prev_;
        base::__unlink_nodes(__f, __l);
        __link_nodes(__p.__ptr_, __f, __l);
        base::__sz() += __c.__sz();
        __c.__sz() = 0;
# 1993 "../../buildtools/third_party/libc++/trunk/include/list" 3
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)
{
# 2011 "../../buildtools/third_party/libc++/trunk/include/list" 3
    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)
    {
        __link_pointer __f = __i.__ptr_;
        base::__unlink_nodes(__f, __f);
        __link_nodes(__p.__ptr_, __f, __f);
        --__c.__sz();
        ++base::__sz();
# 2036 "../../buildtools/third_party/libc++/trunk/include/list" 3
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)
{
# 2059 "../../buildtools/third_party/libc++/trunk/include/list" 3
    if (__f != __l)
    {
        if (this != &__c)
        {
            size_type __s = std::__1::distance(__f, __l);
            __c.__sz() -= __s;
            base::__sz() += __s;
        }
        __link_pointer __first = __f.__ptr_;
        --__l;
        __link_pointer __last = __l.__ptr_;
        base::__unlink_nodes(__first, __last);
        __link_nodes(__p.__ptr_, __first, __last);
# 2094 "../../buildtools/third_party/libc++/trunk/include/list" 3
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::remove(const value_type& __x)
{
    list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    for (const_iterator __i = begin(), __e = end(); __i != __e;)
    {
        if (*__i == __x)
        {
            const_iterator __j = std::__1::next(__i);
            for (; __j != __e && *__j == __x; ++__j)
                ;
            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
            __i = __j;
            if (__i != __e)
                ++__i;
        }
        else
            ++__i;
    }
}

template <class _Tp, class _Alloc>
template <class _Pred>
void
list<_Tp, _Alloc>::remove_if(_Pred __pred)
{
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        if (__pred(*__i))
        {
            iterator __j = std::__1::next(__i);
            for (; __j != __e && __pred(*__j); ++__j)
                ;
            __i = erase(__i, __j);
            if (__i != __e)
                ++__i;
        }
        else
            ++__i;
    }
}

template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::unique()
{
    unique(__equal_to<value_type>());
}

template <class _Tp, class _Alloc>
template <class _BinaryPred>
void
list<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)
{
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        iterator __j = std::__1::next(__i);
        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
            ;
        if (++__i != __j)
            __i = erase(__i, __j);
    }
}

template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::merge(list& __c)
{
    merge(__c, __less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
void
list<_Tp, _Alloc>::merge(list& __c, _Comp __comp)
{
    if (this != &__c)
    {
        iterator __f1 = begin();
        iterator __e1 = end();
        iterator __f2 = __c.begin();
        iterator __e2 = __c.end();
        while (__f1 != __e1 && __f2 != __e2)
        {
            if (__comp(*__f2, *__f1))
            {
                size_type __ds = 1;
                iterator __m2 = std::__1::next(__f2);
                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)
                    ;
                base::__sz() += __ds;
                __c.__sz() -= __ds;
                __link_pointer __f = __f2.__ptr_;
                __link_pointer __l = __m2.__ptr_->__prev_;
                __f2 = __m2;
                base::__unlink_nodes(__f, __l);
                __m2 = std::__1::next(__f1);
                __link_nodes(__f1.__ptr_, __f, __l);
                __f1 = __m2;
            }
            else
                ++__f1;
        }
        splice(__e1, __c);
# 2222 "../../buildtools/third_party/libc++/trunk/include/list" 3
    }
}

template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::sort()
{
    sort(__less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
inline
void
list<_Tp, _Alloc>::sort(_Comp __comp)
{
    __sort(begin(), end(), base::__sz(), __comp);
}

template <class _Tp, class _Alloc>
template <class _Comp>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)
{
    switch (__n)
    {
    case 0:
    case 1:
        return __f1;
    case 2:
        if (__comp(*--__e2, *__f1))
        {
            __link_pointer __f = __e2.__ptr_;
            base::__unlink_nodes(__f, __f);
            __link_nodes(__f1.__ptr_, __f, __f);
            return __e2;
        }
        return __f1;
    }
    size_type __n2 = __n / 2;
    iterator __e1 = std::__1::next(__f1, __n2);
    iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp);
    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);
    if (__comp(*__f2, *__f1))
    {
        iterator __m2 = std::__1::next(__f2);
        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
            ;
        __link_pointer __f = __f2.__ptr_;
        __link_pointer __l = __m2.__ptr_->__prev_;
        __r = __f2;
        __e1 = __f2 = __m2;
        base::__unlink_nodes(__f, __l);
        __m2 = std::__1::next(__f1);
        __link_nodes(__f1.__ptr_, __f, __l);
        __f1 = __m2;
    }
    else
        ++__f1;
    while (__f1 != __e1 && __f2 != __e2)
    {
        if (__comp(*__f2, *__f1))
        {
            iterator __m2 = std::__1::next(__f2);
            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
                ;
            __link_pointer __f = __f2.__ptr_;
            __link_pointer __l = __m2.__ptr_->__prev_;
            if (__e1 == __f2)
                __e1 = __m2;
            __f2 = __m2;
            base::__unlink_nodes(__f, __l);
            __m2 = std::__1::next(__f1);
            __link_nodes(__f1.__ptr_, __f, __l);
            __f1 = __m2;
        }
        else
            ++__f1;
    }
    return __r;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::reverse() noexcept
{
    if (base::__sz() > 1)
    {
        iterator __e = end();
        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)
        {
            std::__1::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);
            __i.__ptr_ = __i.__ptr_->__prev_;
        }
        std::__1::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);
    }
}

template <class _Tp, class _Alloc>
bool
list<_Tp, _Alloc>::__invariants() const
{
    return size() == std::__1::distance(begin(), end());
}
# 2360 "../../buildtools/third_party/libc++/trunk/include/list" 3
template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
bool
operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__always_inline__))
void
swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 16 "../../base/stl_util.h" 2
# 25 "../../base/stl_util.h"
namespace base {

namespace internal {


template <typename Container, typename Predicate>
void IterateAndEraseIf(Container& container, Predicate pred) {
  for (auto it = container.begin(); it != container.end();) {
    if (pred(*it))
      it = container.erase(it);
    else
      ++it;
  }
}

}




template<class T>
void STLClearObject(T* obj) {
  T tmp;
  tmp.swap(*obj);


  obj->reserve(0);
}


template <typename Container, typename T>
typename std::iterator_traits<
    typename Container::const_iterator>::difference_type
STLCount(const Container& container, const T& val) {
  return std::count(container.begin(), container.end(), val);
}
# 74 "../../base/stl_util.h"
inline char* string_as_array(std::string* str) {

  return str->empty() ? __null : &*str->begin();
}



template <typename Collection, typename Key>
bool ContainsKey(const Collection& collection, const Key& key) {
  return collection.find(key) != collection.end();
}

namespace internal {

template <typename Collection>
class HasKeyType {
  template <typename C>
  static std::true_type test(typename C::key_type*);
  template <typename C>
  static std::false_type test(...);

 public:
  static constexpr bool value = decltype(test<Collection>(nullptr))::value;
};

}





template <typename Collection,
          typename Value,
          typename std::enable_if<!internal::HasKeyType<Collection>::value,
                                  int>::type = 0>
bool ContainsValue(const Collection& collection, const Value& value) {
  return std::find(std::begin(collection), std::end(collection), value) !=
         std::end(collection);
}


template <typename Container>
bool STLIsSorted(const Container& cont) {


  return std::adjacent_find(cont.rbegin(), cont.rend(),
                            std::less<typename Container::value_type>())
      == cont.rend();
}


template <typename ResultType, typename Arg1, typename Arg2>
ResultType STLSetDifference(const Arg1& a1, const Arg2& a2) {
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a1));
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a2));
  ResultType difference;
  std::set_difference(a1.begin(), a1.end(),
                      a2.begin(), a2.end(),
                      std::inserter(difference, difference.end()));
  return difference;
}


template <typename ResultType, typename Arg1, typename Arg2>
ResultType STLSetUnion(const Arg1& a1, const Arg2& a2) {
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a1));
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a2));
  ResultType result;
  std::set_union(a1.begin(), a1.end(),
                 a2.begin(), a2.end(),
                 std::inserter(result, result.end()));
  return result;
}



template <typename ResultType, typename Arg1, typename Arg2>
ResultType STLSetIntersection(const Arg1& a1, const Arg2& a2) {
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a1));
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a2));
  ResultType result;
  std::set_intersection(a1.begin(), a1.end(),
                        a2.begin(), a2.end(),
                        std::inserter(result, result.end()));
  return result;
}



template <typename Arg1, typename Arg2>
bool STLIncludes(const Arg1& a1, const Arg2& a2) {
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a1));
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(STLIsSorted(a2));
  return std::includes(a1.begin(), a1.end(),
                       a2.begin(), a2.end());
}
# 181 "../../base/stl_util.h"
template <typename CharT, typename Traits, typename Allocator, typename Value>
void Erase(std::basic_string<CharT, Traits, Allocator>& container,
           const Value& value) {
  container.erase(std::remove(container.begin(), container.end(), value),
                  container.end());
}

template <typename CharT, typename Traits, typename Allocator, class Predicate>
void EraseIf(std::basic_string<CharT, Traits, Allocator>& container,
             Predicate pred) {
  container.erase(std::remove_if(container.begin(), container.end(), pred),
                  container.end());
}

template <class T, class Allocator, class Value>
void Erase(std::deque<T, Allocator>& container, const Value& value) {
  container.erase(std::remove(container.begin(), container.end(), value),
                  container.end());
}

template <class T, class Allocator, class Predicate>
void EraseIf(std::deque<T, Allocator>& container, Predicate pred) {
  container.erase(std::remove_if(container.begin(), container.end(), pred),
                  container.end());
}

template <class T, class Allocator, class Value>
void Erase(std::vector<T, Allocator>& container, const Value& value) {
  container.erase(std::remove(container.begin(), container.end(), value),
                  container.end());
}

template <class T, class Allocator, class Predicate>
void EraseIf(std::vector<T, Allocator>& container, Predicate pred) {
  container.erase(std::remove_if(container.begin(), container.end(), pred),
                  container.end());
}

template <class T, class Allocator, class Value>
void Erase(std::forward_list<T, Allocator>& container, const Value& value) {



  container.remove_if([&](const T& cur) { return cur == value; });
}

template <class T, class Allocator, class Predicate>
void EraseIf(std::forward_list<T, Allocator>& container, Predicate pred) {
  container.remove_if(pred);
}

template <class T, class Allocator, class Value>
void Erase(std::list<T, Allocator>& container, const Value& value) {



  container.remove_if([&](const T& cur) { return cur == value; });
}

template <class T, class Allocator, class Predicate>
void EraseIf(std::list<T, Allocator>& container, Predicate pred) {
  container.remove_if(pred);
}

template <class Key, class T, class Compare, class Allocator, class Predicate>
void EraseIf(std::map<Key, T, Compare, Allocator>& container, Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}

template <class Key, class T, class Compare, class Allocator, class Predicate>
void EraseIf(std::multimap<Key, T, Compare, Allocator>& container,
             Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}

template <class Key, class Compare, class Allocator, class Predicate>
void EraseIf(std::set<Key, Compare, Allocator>& container, Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}

template <class Key, class Compare, class Allocator, class Predicate>
void EraseIf(std::multiset<Key, Compare, Allocator>& container,
             Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}

template <class Key,
          class T,
          class Hash,
          class KeyEqual,
          class Allocator,
          class Predicate>
void EraseIf(std::unordered_map<Key, T, Hash, KeyEqual, Allocator>& container,
             Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}

template <class Key,
          class T,
          class Hash,
          class KeyEqual,
          class Allocator,
          class Predicate>
void EraseIf(
    std::unordered_multimap<Key, T, Hash, KeyEqual, Allocator>& container,
    Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}

template <class Key,
          class Hash,
          class KeyEqual,
          class Allocator,
          class Predicate>
void EraseIf(std::unordered_set<Key, Hash, KeyEqual, Allocator>& container,
             Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}

template <class Key,
          class Hash,
          class KeyEqual,
          class Allocator,
          class Predicate>
void EraseIf(std::unordered_multiset<Key, Hash, KeyEqual, Allocator>& container,
             Predicate pred) {
  internal::IterateAndEraseIf(container, pred);
}







template <class Collection>
class IsNotIn {
 public:
  explicit IsNotIn(const Collection& collection)
      : i_(collection.begin()), end_(collection.end()) {}

  bool operator()(const typename Collection::value_type& x) {
    while (i_ != end_ && *i_ < x)
      ++i_;
    if (i_ == end_)
      return true;
    if (*i_ == x) {
      ++i_;
      return false;
    }
    return true;
  }

 private:
  typename Collection::const_iterator i_;
  const typename Collection::const_iterator end_;
};

}
# 19 "../../base/observer_list.h" 2
# 76 "../../base/observer_list.h"
namespace base {


enum class ObserverListPolicy {


  ALL,



  EXISTING_ONLY,
};


template <class ObserverType, bool check_empty = false>
class ObserverList
    : public SupportsWeakPtr<ObserverList<ObserverType, check_empty>> {
 public:

  class Iter {
   public:
    Iter() : index_(0), max_index_(0) {}

    explicit Iter(const ObserverList* list)
        : list_(const_cast<ObserverList*>(list)->AsWeakPtr()),
          index_(0),
          max_index_(list->policy_ == ObserverListPolicy::ALL
                         ? std::numeric_limits<size_t>::max()
                         : list->observers_.size()) {
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(list_);
      EnsureValidIndex();
      ++list_->live_iterator_count_;
    }

    ~Iter() {
      if (!list_)
        return;

      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << (::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, list_->live_iterator_count_), ::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, 0), (list_->live_iterator_count_)>(0));
      if (--list_->live_iterator_count_ == 0)
        list_->Compact();
    }

    Iter(const Iter& other)
        : list_(other.list_),
          index_(other.index_),
          max_index_(other.max_index_) {
      if (list_)
        ++list_->live_iterator_count_;
    }

    Iter& operator=(Iter other) {
      using std::swap;
      swap(list_, other.list_);
      swap(index_, other.index_);
      swap(max_index_, other.max_index_);
      return *this;
    }

    bool operator==(const Iter& other) const {
      return (is_end() && other.is_end()) ||
             (list_.get() == other.list_.get() && index_ == other.index_);
    }

    bool operator!=(const Iter& other) const { return !(*this == other); }

    Iter& operator++() {
      if (list_) {
        ++index_;
        EnsureValidIndex();
      }
      return *this;
    }

    ObserverType* operator->() const {
      ObserverType* const current = GetCurrent();
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(current);
      return current;
    }

    ObserverType& operator*() const {
      ObserverType* const current = GetCurrent();
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(current);
      return *current;
    }

   private:
    friend class ObserverListTest_BasicStdIterator_Test; friend class ObserverListTest_DISABLED_BasicStdIterator_Test; friend class ObserverListTest_FLAKY_BasicStdIterator_Test;
    friend class ObserverListTest_StdIteratorRemoveFront_Test; friend class ObserverListTest_DISABLED_StdIteratorRemoveFront_Test; friend class ObserverListTest_FLAKY_StdIteratorRemoveFront_Test;

    ObserverType* GetCurrent() const {
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(list_);
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << (::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, index_), ::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, clamped_max_index()), (index_)<(clamped_max_index()));
      return list_->observers_[index_];
    }

    void EnsureValidIndex() {
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(list_);
      const size_t max_index = clamped_max_index();
      while (index_ < max_index && !list_->observers_[index_])
        ++index_;
    }

    size_t clamped_max_index() const {
      return std::min(max_index_, list_->observers_.size());
    }

    bool is_end() const { return !list_ || index_ == clamped_max_index(); }

    WeakPtr<ObserverList> list_;




    size_t index_;
    size_t max_index_;
  };

  using iterator = Iter;
  using const_iterator = Iter;

  const_iterator begin() const {

    return observers_.empty() ? const_iterator() : const_iterator(this);
  }

  const_iterator end() const { return const_iterator(); }

  ObserverList() {}
  explicit ObserverList(ObserverListPolicy policy) : policy_(policy) {}

  ~ObserverList() {
    if (check_empty) {
      Compact();
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(observers_.empty());
    }
  }






  void AddObserver(ObserverType* obs) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(obs);
    if (HasObserver(obs)) {
      true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(false) << "Observers can only be added once!";
      return;
    }
    observers_.push_back(obs);
  }



  void RemoveObserver(const ObserverType* obs) {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(obs);
    const auto it = std::find(observers_.begin(), observers_.end(), obs);
    if (it == observers_.end())
      return;

    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << (::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, live_iterator_count_), ::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, 0), (live_iterator_count_)>=(0));
    if (live_iterator_count_) {
      *it = nullptr;
    } else {
      observers_.erase(it);
    }
  }


  bool HasObserver(const ObserverType* obs) const {
    return ContainsValue(observers_, obs);
  }


  void Clear() {
    true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << (::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, live_iterator_count_), ::logging::MakeCheckOpValueString( ::logging::g_swallow_stream, 0), (live_iterator_count_)>=(0));
    if (live_iterator_count_) {
      std::fill(observers_.begin(), observers_.end(), nullptr);
    } else {
      observers_.clear();
    }
  }

  bool might_have_observers() const { return !observers_.empty(); }

 private:

  void Compact() {
    observers_.erase(std::remove(observers_.begin(), observers_.end(), nullptr),
                     observers_.end());
  }

  std::vector<ObserverType*> observers_;





  int live_iterator_count_ = 0;

  const ObserverListPolicy policy_ = ObserverListPolicy::ALL;

  ObserverList(const ObserverList&) = delete; ObserverList& operator=(const ObserverList&) = delete;
};

}
# 21 "../../base/trace_event/trace_event_impl.h" 2
# 1 "../../base/single_thread_task_runner.h" 1
# 11 "../../base/single_thread_task_runner.h"
namespace base {
# 25 "../../base/single_thread_task_runner.h"
class SingleThreadTaskRunner : public SequencedTaskRunner {
 public:

  bool BelongsToCurrentThread() const { return RunsTasksInCurrentSequence(); }

 protected:
  ~SingleThreadTaskRunner() override {}
};

}
# 22 "../../base/trace_event/trace_event_impl.h" 2
# 1 "../../base/strings/string_util.h" 1
# 12 "../../base/strings/string_util.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 13 "../../base/strings/string_util.h" 2
# 25 "../../base/strings/string_util.h"
namespace base {
# 35 "../../base/strings/string_util.h"
int vsnprintf(char* buffer, size_t size, const char* format, va_list arguments)
    __attribute__((format(printf, 3, 0)));





inline int snprintf(char* buffer,
                    size_t size,
                                           const char* format,
                    ...) __attribute__((format(printf, 3, 4)));
inline int snprintf(char* buffer,
                    size_t size,
                                           const char* format,
                    ...) {
  va_list arguments;
  __builtin_va_start(arguments, format);
  int result = vsnprintf(buffer, size, format, arguments);
  __builtin_va_end(arguments);
  return result;
}







            size_t strlcpy(char* dst, const char* src, size_t dst_size);
            size_t wcslcpy(wchar_t* dst, const wchar_t* src, size_t dst_size);
# 87 "../../base/strings/string_util.h"
            bool IsWprintfFormatPortable(const wchar_t* format);



inline char ToLowerASCII(char c) {
  return (c >= 'A' && c <= 'Z') ? (c + ('a' - 'A')) : c;
}
inline char16 ToLowerASCII(char16 c) {
  return (c >= 'A' && c <= 'Z') ? (c + ('a' - 'A')) : c;
}



inline char ToUpperASCII(char c) {
  return (c >= 'a' && c <= 'z') ? (c + ('A' - 'a')) : c;
}
inline char16 ToUpperASCII(char16 c) {
  return (c >= 'a' && c <= 'z') ? (c + ('A' - 'a')) : c;
}


            std::string ToLowerASCII(StringPiece str);
            string16 ToLowerASCII(StringPiece16 str);


            std::string ToUpperASCII(StringPiece str);
            string16 ToUpperASCII(StringPiece16 str);
# 123 "../../base/strings/string_util.h"
template<typename Char> struct CaseInsensitiveCompareASCII {
 public:
  bool operator()(Char x, Char y) const {
    return ToLowerASCII(x) == ToLowerASCII(y);
  }
};
# 137 "../../base/strings/string_util.h"
            int CompareCaseInsensitiveASCII(StringPiece a, StringPiece b);
            int CompareCaseInsensitiveASCII(StringPiece16 a, StringPiece16 b);




            bool EqualsCaseInsensitiveASCII(StringPiece a, StringPiece b);
            bool EqualsCaseInsensitiveASCII(StringPiece16 a, StringPiece16 b);
# 159 "../../base/strings/string_util.h"
            const std::string& EmptyString();
            const string16& EmptyString16();




            extern const wchar_t kWhitespaceWide[];
            extern const char16 kWhitespaceUTF16[];
            extern const char kWhitespaceASCII[];
            extern const char16 kWhitespaceASCIIAs16[];


            extern const char kUtf8ByteOrderMark[];




            bool RemoveChars(const string16& input,
                             const StringPiece16& remove_chars,
                             string16* output);
            bool RemoveChars(const std::string& input,
                             const StringPiece& remove_chars,
                             std::string* output);






            bool ReplaceChars(const string16& input,
                              const StringPiece16& replace_chars,
                              const string16& replace_with,
                              string16* output);
            bool ReplaceChars(const std::string& input,
                              const StringPiece& replace_chars,
                              const std::string& replace_with,
                              std::string* output);

enum TrimPositions {
  TRIM_NONE = 0,
  TRIM_LEADING = 1 << 0,
  TRIM_TRAILING = 1 << 1,
  TRIM_ALL = TRIM_LEADING | TRIM_TRAILING,
};







            bool TrimString(const string16& input,
                            StringPiece16 trim_chars,
                            string16* output);
            bool TrimString(const std::string& input,
                            StringPiece trim_chars,
                            std::string* output);



            StringPiece16 TrimString(StringPiece16 input,
                                     const StringPiece16& trim_chars,
                                     TrimPositions positions);
            StringPiece TrimString(StringPiece input,
                                   const StringPiece& trim_chars,
                                   TrimPositions positions);



            void TruncateUTF8ToByteSize(const std::string& input,
                                        const size_t byte_size,
                                        std::string* output);
# 239 "../../base/strings/string_util.h"
            TrimPositions TrimWhitespace(const string16& input,
                                         TrimPositions positions,
                                         string16* output);
            StringPiece16 TrimWhitespace(StringPiece16 input,
                                         TrimPositions positions);
            TrimPositions TrimWhitespaceASCII(const std::string& input,
                                              TrimPositions positions,
                                              std::string* output);
            StringPiece TrimWhitespaceASCII(StringPiece input,
                                            TrimPositions positions);
# 258 "../../base/strings/string_util.h"
            string16 CollapseWhitespace(
    const string16& text,
    bool trim_sequences_with_line_breaks);
            std::string CollapseWhitespaceASCII(
    const std::string& text,
    bool trim_sequences_with_line_breaks);



            bool ContainsOnlyChars(const StringPiece& input,
                                   const StringPiece& characters);
            bool ContainsOnlyChars(const StringPiece16& input,
                                   const StringPiece16& characters);
# 286 "../../base/strings/string_util.h"
            bool IsStringUTF8(const StringPiece& str);
            bool IsStringASCII(const StringPiece& str);
            bool IsStringASCII(const StringPiece16& str);
            bool IsStringASCII(const string16& str);

            bool IsStringASCII(const std::wstring& str);




            bool LowerCaseEqualsASCII(StringPiece str,
                                      StringPiece lowecase_ascii);
            bool LowerCaseEqualsASCII(StringPiece16 str,
                                      StringPiece lowecase_ascii);




            bool EqualsASCII(StringPiece16 str, StringPiece ascii);
# 314 "../../base/strings/string_util.h"
enum class CompareCase {
  SENSITIVE,
  INSENSITIVE_ASCII,
};

            bool StartsWith(StringPiece str,
                            StringPiece search_for,
                            CompareCase case_sensitivity);
            bool StartsWith(StringPiece16 str,
                            StringPiece16 search_for,
                            CompareCase case_sensitivity);
            bool EndsWith(StringPiece str,
                          StringPiece search_for,
                          CompareCase case_sensitivity);
            bool EndsWith(StringPiece16 str,
                          StringPiece16 search_for,
                          CompareCase case_sensitivity);



template <typename Char>
inline bool IsAsciiWhitespace(Char c) {
  return c == ' ' || c == '\r' || c == '\n' || c == '\t';
}
template <typename Char>
inline bool IsAsciiAlpha(Char c) {
  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}
template <typename Char>
inline bool IsAsciiUpper(Char c) {
  return c >= 'A' && c <= 'Z';
}
template <typename Char>
inline bool IsAsciiLower(Char c) {
  return c >= 'a' && c <= 'z';
}
template <typename Char>
inline bool IsAsciiDigit(Char c) {
  return c >= '0' && c <= '9';
}

template <typename Char>
inline bool IsHexDigit(Char c) {
  return (c >= '0' && c <= '9') ||
         (c >= 'A' && c <= 'F') ||
         (c >= 'a' && c <= 'f');
}






            char HexDigitToInt(wchar_t c);


            bool IsUnicodeWhitespace(wchar_t c);





            string16 FormatBytesUnlocalized(int64_t bytes);



            void ReplaceFirstSubstringAfterOffset(
    base::string16* str,
    size_t start_offset,
    StringPiece16 find_this,
    StringPiece16 replace_with);
            void ReplaceFirstSubstringAfterOffset(
    std::string* str,
    size_t start_offset,
    StringPiece find_this,
    StringPiece replace_with);







            void ReplaceSubstringsAfterOffset(
    string16* str,
    size_t start_offset,
    StringPiece16 find_this,
    StringPiece16 replace_with);
            void ReplaceSubstringsAfterOffset(
    std::string* str,
    size_t start_offset,
    StringPiece find_this,
    StringPiece replace_with);
# 428 "../../base/strings/string_util.h"
            char* WriteInto(std::string* str, size_t length_with_null);
            char16* WriteInto(string16* str, size_t length_with_null);
# 440 "../../base/strings/string_util.h"
            std::string JoinString(const std::vector<std::string>& parts,
                                   StringPiece separator);
            string16 JoinString(const std::vector<string16>& parts,
                                StringPiece16 separator);
            std::string JoinString(const std::vector<StringPiece>& parts,
                                   StringPiece separator);
            string16 JoinString(const std::vector<StringPiece16>& parts,
                                StringPiece16 separator);



            std::string JoinString(std::initializer_list<StringPiece> parts,
                                   StringPiece separator);
            string16 JoinString(std::initializer_list<StringPiece16> parts,
                                StringPiece16 separator);





            string16 ReplaceStringPlaceholders(
    const string16& format_string,
    const std::vector<string16>& subst,
    std::vector<size_t>* offsets);

            std::string ReplaceStringPlaceholders(
    const StringPiece& format_string,
    const std::vector<std::string>& subst,
    std::vector<size_t>* offsets);


            string16 ReplaceStringPlaceholders(const string16& format_string,
                                               const string16& a,
                                               size_t* offset);

}





# 1 "../../base/strings/string_util_posix.h" 1








# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 10 "../../base/strings/string_util_posix.h" 2
# 1 "../../buildtools/third_party/libc++/trunk/include/stdio.h" 1 3
# 11 "../../base/strings/string_util_posix.h" 2

# 1 "../../buildtools/third_party/libc++/trunk/include/wchar.h" 1 3
# 13 "../../base/strings/string_util_posix.h" 2



namespace base {



inline char* strdup(const char* str) {
  return ::strdup(str);
}

inline int vsnprintf(char* buffer, size_t size,
                     const char* format, va_list arguments) {
  return ::vsnprintf(buffer, size, format, arguments);
}

inline int vswprintf(wchar_t* buffer, size_t size,
                     const wchar_t* format, va_list arguments) {
  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(IsWprintfFormatPortable(format));
  return ::vswprintf(buffer, size, format, arguments);
}

}
# 481 "../../base/strings/string_util.h" 2
# 23 "../../base/trace_event/trace_event_impl.h" 2
# 1 "../../base/synchronization/condition_variable.h" 1
# 82 "../../base/synchronization/condition_variable.h"
namespace base {

class TimeDelta;

class ConditionVariable {
 public:

  explicit ConditionVariable(Lock* user_lock);

  ~ConditionVariable();




  void Wait();
  void TimedWait(const TimeDelta& max_time);



  void Broadcast();

  void Signal();

 private:





  pthread_cond_t condition_;
  pthread_mutex_t* user_mutex_;






  ConditionVariable(const ConditionVariable&) = delete; ConditionVariable& operator=(const ConditionVariable&) = delete;
};

}
# 24 "../../base/trace_event/trace_event_impl.h" 2

# 1 "../../base/threading/thread_local.h" 1
# 54 "../../base/threading/thread_local.h"
# 1 "../../base/threading/thread_local_storage.h" 1
# 21 "../../base/threading/thread_local_storage.h"
namespace base {

namespace internal {







class PlatformThreadLocalStorage {
 public:





  typedef pthread_key_t TLSKey;




  enum { TLS_KEY_OUT_OF_INDEXES = 0x7FFFFFFF };
# 53 "../../base/threading/thread_local_storage.h"
  static bool AllocTLS(TLSKey* key);



  static void FreeTLS(TLSKey key);
  static void SetTLSValue(TLSKey key, void* value);
  static void* GetTLSValue(TLSKey key) {



    return pthread_getspecific(key);

  }
# 83 "../../base/threading/thread_local_storage.h"
  static void OnThreadExit(void* value);

};

}



class ThreadLocalStorage {
 public:




  typedef void (*TLSDestructorFunc)(void* value);
# 108 "../../base/threading/thread_local_storage.h"
  struct StaticSlot {



    void Initialize(TLSDestructorFunc destructor);





    void Free();



    void* Get() const;



    void Set(void* value);

    bool initialized() const {
      return base::subtle::Acquire_Load(&initialized_) != 0;
    }


    base::subtle::Atomic32 initialized_;
    int slot_;
    uint32_t version_;
  };



  class Slot {
   public:
    explicit Slot(TLSDestructorFunc destructor = __null);
    ~Slot();



    void* Get() const;


    void Set(void* value);

   private:
    StaticSlot tls_slot_;

    Slot(const Slot&) = delete; Slot& operator=(const Slot&) = delete;
  };

 private:
  ThreadLocalStorage(const ThreadLocalStorage&) = delete; ThreadLocalStorage& operator=(const ThreadLocalStorage&) = delete;
};

}
# 55 "../../base/threading/thread_local.h" 2

namespace base {

template <typename Type>
class ThreadLocalPointer {
 public:
  ThreadLocalPointer() = default;
  ~ThreadLocalPointer() = default;

  Type* Get() {
    return static_cast<Type*>(slot_.Get());
  }

  void Set(Type* ptr) {
    slot_.Set(const_cast<void*>(static_cast<const void*>(ptr)));
  }

 private:
  ThreadLocalStorage::Slot slot_;

  ThreadLocalPointer<Type>(const ThreadLocalPointer<Type>&) = delete; ThreadLocalPointer<Type>& operator=(const ThreadLocalPointer<Type>&) = delete;
};

class ThreadLocalBoolean {
 public:
  ThreadLocalBoolean() = default;
  ~ThreadLocalBoolean() = default;

  bool Get() {
    return tlp_.Get() != nullptr;
  }

  void Set(bool val) {
    tlp_.Set(val ? this : nullptr);
  }

 private:
  ThreadLocalPointer<void> tlp_;

  ThreadLocalBoolean(const ThreadLocalBoolean&) = delete; ThreadLocalBoolean& operator=(const ThreadLocalBoolean&) = delete;
};

}
# 26 "../../base/trace_event/trace_event_impl.h" 2
# 1 "../../base/trace_event/trace_event_memory_overhead.h" 1







# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 9 "../../base/trace_event/trace_event_memory_overhead.h" 2







namespace base {

class RefCountedString;
class Value;

namespace trace_event {

class ProcessMemoryDump;


class TraceEventMemoryOverhead {
 public:
  enum ObjectType : uint32_t {
    kOther = 0,
    kTraceBuffer,
    kTraceBufferChunk,
    kTraceEvent,
    kUnusedTraceEvent,
    kTracedValue,
    kConvertableToTraceFormat,
    kHeapProfilerAllocationRegister,
    kHeapProfilerTypeNameDeduplicator,
    kHeapProfilerStackFrameDeduplicator,
    kStdString,
    kBaseValue,
    kTraceEventMemoryOverhead,
    kLast
  };

  TraceEventMemoryOverhead();
  ~TraceEventMemoryOverhead();



  void Add(ObjectType object_type,
           size_t allocated_size_in_bytes,
           size_t resident_size_in_bytes);



  void Add(ObjectType object_type, size_t allocated_size_in_bytes);


  void AddString(const std::string& str);
  void AddValue(const Value& value);
  void AddRefCountedString(const RefCountedString& str);



  void AddSelf();


  size_t GetCount(ObjectType object_type) const;


  void Update(const TraceEventMemoryOverhead& other);

  void DumpInto(const char* base_name, ProcessMemoryDump* pmd) const;

 private:
  struct ObjectCountAndSize {
    size_t count;
    size_t allocated_size_in_bytes;
    size_t resident_size_in_bytes;
  };
  ObjectCountAndSize allocated_objects_[ObjectType::kLast];

  void AddInternal(ObjectType object_type,
                   size_t count,
                   size_t allocated_size_in_bytes,
                   size_t resident_size_in_bytes);

  TraceEventMemoryOverhead(const TraceEventMemoryOverhead&) = delete; TraceEventMemoryOverhead& operator=(const TraceEventMemoryOverhead&) = delete;
};

}
}
# 27 "../../base/trace_event/trace_event_impl.h" 2


namespace base {
namespace trace_event {

typedef base::Callback<bool(const char* arg_name)> ArgumentNameFilterPredicate;

typedef base::Callback<bool(const char* category_group_name,
                            const char* event_name,
                            ArgumentNameFilterPredicate*)>
    ArgumentFilterPredicate;



class ConvertableToTraceFormat {
 public:
  ConvertableToTraceFormat() {}
  virtual ~ConvertableToTraceFormat() {}





  virtual void AppendAsTraceFormat(std::string* out) const = 0;

  virtual void EstimateTraceMemoryOverhead(TraceEventMemoryOverhead* overhead);

  std::string ToString() const {
    std::string result;
    AppendAsTraceFormat(&result);
    return result;
  }

 private:
  ConvertableToTraceFormat(const ConvertableToTraceFormat&) = delete; ConvertableToTraceFormat& operator=(const ConvertableToTraceFormat&) = delete;
};

const int kTraceMaxNumArgs = 2;

struct TraceEventHandle {
  uint32_t chunk_seq;



  unsigned chunk_index : 26;
  unsigned event_index : 6;
};

class TraceEvent {
 public:
  union TraceValue {
    bool as_bool;
    unsigned long long as_uint;
    long long as_int;
    double as_double;
    const void* as_pointer;
    const char* as_string;
  };

  TraceEvent();
  ~TraceEvent();

  void MoveFrom(std::unique_ptr<TraceEvent> other);

  void Initialize(int thread_id,
                  TimeTicks timestamp,
                  ThreadTicks thread_timestamp,
                  char phase,
                  const unsigned char* category_group_enabled,
                  const char* name,
                  const char* scope,
                  unsigned long long id,
                  unsigned long long bind_id,
                  int num_args,
                  const char* const* arg_names,
                  const unsigned char* arg_types,
                  const unsigned long long* arg_values,
                  std::unique_ptr<ConvertableToTraceFormat>* convertable_values,
                  unsigned int flags);

  void Reset();

  void UpdateDuration(const TimeTicks& now, const ThreadTicks& thread_now);

  void EstimateTraceMemoryOverhead(TraceEventMemoryOverhead* overhead);


  void AppendAsJSON(
      std::string* out,
      const ArgumentFilterPredicate& argument_filter_predicate) const;
  void AppendPrettyPrinted(std::ostringstream* out) const;

  static void AppendValueAsJSON(unsigned char type,
                                TraceValue value,
                                std::string* out);

  TimeTicks timestamp() const { return timestamp_; }
  ThreadTicks thread_timestamp() const { return thread_timestamp_; }
  char phase() const { return phase_; }
  int thread_id() const { return thread_id_; }
  TimeDelta duration() const { return duration_; }
  TimeDelta thread_duration() const { return thread_duration_; }
  const char* scope() const { return scope_; }
  unsigned long long id() const { return id_; }
  unsigned int flags() const { return flags_; }



  const std::string* parameter_copy_storage() const {
    return parameter_copy_storage_.get();
  }

  const unsigned char* category_group_enabled() const {
    return category_group_enabled_;
  }

  const char* name() const { return name_; }





 private:

  TimeTicks timestamp_;
  ThreadTicks thread_timestamp_;
  TimeDelta duration_;
  TimeDelta thread_duration_;

  const char* scope_;
  unsigned long long id_;
  TraceValue arg_values_[kTraceMaxNumArgs];
  const char* arg_names_[kTraceMaxNumArgs];
  std::unique_ptr<ConvertableToTraceFormat>
      convertable_values_[kTraceMaxNumArgs];
  const unsigned char* category_group_enabled_;
  const char* name_;
  std::unique_ptr<std::string> parameter_copy_storage_;



  union {
    int thread_id_;
    int process_id_;
  };
  unsigned int flags_;
  unsigned long long bind_id_;
  unsigned char arg_types_[kTraceMaxNumArgs];
  char phase_;

  TraceEvent(const TraceEvent&) = delete; TraceEvent& operator=(const TraceEvent&) = delete;
};

}
}
# 23 "../../base/trace_event/trace_log.h" 2


namespace base {

template <typename Type>
struct DefaultSingletonTraits;
class MessageLoop;
class RefCountedString;

namespace trace_event {

struct TraceCategory;
class TraceBuffer;
class TraceBufferChunk;
class TraceEvent;
class TraceEventFilter;
class TraceEventMemoryOverhead;

struct TraceLogStatus {
  TraceLogStatus();
  ~TraceLogStatus();
  uint32_t event_capacity;
  uint32_t event_count;
};

class TraceLog : public MemoryDumpProvider {
 public:

  enum Mode : uint8_t {

    RECORDING_MODE = 1 << 0,



    FILTERING_MODE = 1 << 1
  };

  static TraceLog* GetInstance();



  void GetKnownCategoryGroups(std::vector<std::string>* category_groups);


  TraceConfig GetCurrentTraceConfig() const;



  void InitializeThreadLocalEventBufferIfSupported();
# 81 "../../base/trace_event/trace_log.h"
  void SetEnabled(const TraceConfig& trace_config, uint8_t modes_to_enable);






  void SetDisabled();
  void SetDisabled(uint8_t modes_to_disable);



  bool IsEnabled() { return enabled_modes_ & RECORDING_MODE; }


  uint8_t enabled_modes() { return enabled_modes_; }






  int GetNumTracesRecorded();
# 114 "../../base/trace_event/trace_log.h"
  class EnabledStateObserver {
   public:
    virtual ~EnabledStateObserver() = default;



    virtual void OnTraceLogEnabled() = 0;



    virtual void OnTraceLogDisabled() = 0;
  };
  void AddEnabledStateObserver(EnabledStateObserver* listener);
  void RemoveEnabledStateObserver(EnabledStateObserver* listener);
  bool HasEnabledStateObserver(EnabledStateObserver* listener) const;






  class AsyncEnabledStateObserver {
   public:
    virtual ~AsyncEnabledStateObserver() = default;



    virtual void OnTraceLogEnabled() = 0;



    virtual void OnTraceLogDisabled() = 0;
  };
  void AddAsyncEnabledStateObserver(
      WeakPtr<AsyncEnabledStateObserver> listener);
  void RemoveAsyncEnabledStateObserver(AsyncEnabledStateObserver* listener);
  bool HasAsyncEnabledStateObserver(AsyncEnabledStateObserver* listener) const;

  TraceLogStatus GetStatus() const;
  bool BufferIsFull() const;



  void EstimateTraceMemoryOverhead(TraceEventMemoryOverhead* overhead);

  void SetArgumentFilterPredicate(
      const ArgumentFilterPredicate& argument_filter_predicate);
# 172 "../../base/trace_event/trace_log.h"
  typedef base::Callback<void(const scoped_refptr<base::RefCountedString>&,
                              bool has_more_events)> OutputCallback;
  void Flush(const OutputCallback& cb, bool use_worker_thread = false);


  void CancelTracing(const OutputCallback& cb);




  static const unsigned char* GetCategoryGroupEnabled(const char* name);
  static const char* GetCategoryGroupName(
      const unsigned char* category_group_enabled);




  TraceEventHandle AddTraceEvent(
      char phase,
      const unsigned char* category_group_enabled,
      const char* name,
      const char* scope,
      unsigned long long id,
      int num_args,
      const char* const* arg_names,
      const unsigned char* arg_types,
      const unsigned long long* arg_values,
      std::unique_ptr<ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);
  TraceEventHandle AddTraceEventWithBindId(
      char phase,
      const unsigned char* category_group_enabled,
      const char* name,
      const char* scope,
      unsigned long long id,
      unsigned long long bind_id,
      int num_args,
      const char* const* arg_names,
      const unsigned char* arg_types,
      const unsigned long long* arg_values,
      std::unique_ptr<ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);
  TraceEventHandle AddTraceEventWithProcessId(
      char phase,
      const unsigned char* category_group_enabled,
      const char* name,
      const char* scope,
      unsigned long long id,
      int process_id,
      int num_args,
      const char* const* arg_names,
      const unsigned char* arg_types,
      const unsigned long long* arg_values,
      std::unique_ptr<ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);
  TraceEventHandle AddTraceEventWithThreadIdAndTimestamp(
      char phase,
      const unsigned char* category_group_enabled,
      const char* name,
      const char* scope,
      unsigned long long id,
      int thread_id,
      const TimeTicks& timestamp,
      int num_args,
      const char* const* arg_names,
      const unsigned char* arg_types,
      const unsigned long long* arg_values,
      std::unique_ptr<ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);
  TraceEventHandle AddTraceEventWithThreadIdAndTimestamp(
      char phase,
      const unsigned char* category_group_enabled,
      const char* name,
      const char* scope,
      unsigned long long id,
      unsigned long long bind_id,
      int thread_id,
      const TimeTicks& timestamp,
      int num_args,
      const char* const* arg_names,
      const unsigned char* arg_types,
      const unsigned long long* arg_values,
      std::unique_ptr<ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);


  void AddMetadataEvent(
      const unsigned char* category_group_enabled,
      const char* name,
      int num_args,
      const char* const* arg_names,
      const unsigned char* arg_types,
      const unsigned long long* arg_values,
      std::unique_ptr<ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);

  void UpdateTraceEventDuration(const unsigned char* category_group_enabled,
                                const char* name,
                                TraceEventHandle handle);

  void UpdateTraceEventDurationExplicit(
      const unsigned char* category_group_enabled,
      const char* name,
      TraceEventHandle handle,
      const TimeTicks& now,
      const ThreadTicks& thread_now);

  void EndFilteredEvent(const unsigned char* category_group_enabled,
                        const char* name,
                        TraceEventHandle handle);

  int process_id() const { return process_id_; }

  uint64_t MangleEventId(uint64_t id);




  typedef std::unique_ptr<TraceEventFilter> (*FilterFactoryForTesting)(
      const std::string& );
  void SetFilterFactoryForTesting(FilterFactoryForTesting factory) {
    filter_factory_for_testing_ = factory;
  }


  static void DeleteForTesting();


  TraceEvent* GetEventByHandle(TraceEventHandle handle);

  void SetProcessID(int process_id);




  void SetProcessSortIndex(int sort_index);


  void set_process_name(const std::string& process_name) {
    AutoLock lock(lock_);
    process_name_ = process_name;
  }

  bool IsProcessNameEmpty() const { return process_name_.empty(); }



  void UpdateProcessLabel(int label_id, const std::string& current_label);
  void RemoveProcessLabel(int label_id);




  void SetThreadSortIndex(PlatformThreadId thread_id, int sort_index);



  void SetTimeOffset(TimeDelta offset);

  size_t GetObserverCountForTest() const;




  void SetCurrentThreadBlocksMessageLoop();
# 346 "../../base/trace_event/trace_log.h"
  void SetTraceBufferForTesting(std::unique_ptr<TraceBuffer> trace_buffer);

 private:
  typedef unsigned int InternalTraceOptions;

  friend class TraceEventTestFixture_TraceBufferRingBufferGetReturnChunk_Test; friend class TraceEventTestFixture_DISABLED_TraceBufferRingBufferGetReturnChunk_Test; friend class TraceEventTestFixture_FLAKY_TraceBufferRingBufferGetReturnChunk_Test;

  friend class TraceEventTestFixture_TraceBufferRingBufferHalfIteration_Test; friend class TraceEventTestFixture_DISABLED_TraceBufferRingBufferHalfIteration_Test; friend class TraceEventTestFixture_FLAKY_TraceBufferRingBufferHalfIteration_Test;

  friend class TraceEventTestFixture_TraceBufferRingBufferFullIteration_Test; friend class TraceEventTestFixture_DISABLED_TraceBufferRingBufferFullIteration_Test; friend class TraceEventTestFixture_FLAKY_TraceBufferRingBufferFullIteration_Test;

  friend class TraceEventTestFixture_TraceBufferVectorReportFull_Test; friend class TraceEventTestFixture_DISABLED_TraceBufferVectorReportFull_Test; friend class TraceEventTestFixture_FLAKY_TraceBufferVectorReportFull_Test;
  friend class TraceEventTestFixture_ConvertTraceConfigToInternalOptions_Test; friend class TraceEventTestFixture_DISABLED_ConvertTraceConfigToInternalOptions_Test; friend class TraceEventTestFixture_FLAKY_ConvertTraceConfigToInternalOptions_Test;

  friend class TraceEventTestFixture_TraceRecordAsMuchAsPossibleMode_Test; friend class TraceEventTestFixture_DISABLED_TraceRecordAsMuchAsPossibleMode_Test; friend class TraceEventTestFixture_FLAKY_TraceRecordAsMuchAsPossibleMode_Test;




  friend struct DefaultSingletonTraits<TraceLog>;


  bool OnMemoryDump(const MemoryDumpArgs& args,
                    ProcessMemoryDump* pmd) override;






  void UpdateCategoryRegistry();
  void UpdateCategoryState(TraceCategory* category);

  void CreateFiltersForTraceConfig();

  InternalTraceOptions GetInternalOptionsFromTraceConfig(
      const TraceConfig& config);

  class ThreadLocalEventBuffer;
  class OptionalAutoLock;
  struct RegisteredAsyncObserver;

  TraceLog();
  ~TraceLog() override;
  void AddMetadataEventsWhileLocked();

  InternalTraceOptions trace_options() const {
    return static_cast<InternalTraceOptions>(
        subtle::NoBarrier_Load(&trace_options_));
  }

  TraceBuffer* trace_buffer() const { return logged_events_.get(); }
  TraceBuffer* CreateTraceBuffer();

  std::string EventToConsoleMessage(unsigned char phase,
                                    const TimeTicks& timestamp,
                                    TraceEvent* trace_event);

  TraceEvent* AddEventToThreadSharedChunkWhileLocked(TraceEventHandle* handle,
                                                     bool check_buffer_is_full);
  void CheckIfBufferIsFullWhileLocked();
  void SetDisabledWhileLocked(uint8_t modes);

  TraceEvent* GetEventByHandleInternal(TraceEventHandle handle,
                                       OptionalAutoLock* lock);

  void FlushInternal(const OutputCallback& cb,
                     bool use_worker_thread,
                     bool discard_events);



  void FlushCurrentThread(int generation, bool discard_events);

  static void ConvertTraceEventsToTraceFormat(
      std::unique_ptr<TraceBuffer> logged_events,
      const TraceLog::OutputCallback& flush_output_callback,
      const ArgumentFilterPredicate& argument_filter_predicate);
  void FinishFlush(int generation, bool discard_events);
  void OnFlushTimeout(int generation, bool discard_events);

  int generation() const {
    return static_cast<int>(subtle::NoBarrier_Load(&generation_));
  }
  bool CheckGeneration(int generation) const {
    return generation == this->generation();
  }
  void UseNextTraceBuffer();

  TimeTicks OffsetNow() const { return OffsetTimestamp(TimeTicks::Now()); }
  TimeTicks OffsetTimestamp(const TimeTicks& timestamp) const {
    return timestamp - time_offset_;
  }



  static const InternalTraceOptions kInternalNone;
  static const InternalTraceOptions kInternalRecordUntilFull;
  static const InternalTraceOptions kInternalRecordContinuously;
  static const InternalTraceOptions kInternalEchoToConsole;
  static const InternalTraceOptions kInternalRecordAsMuchAsPossible;
  static const InternalTraceOptions kInternalEnableArgumentFilter;



  mutable Lock lock_;


  Lock thread_info_lock_;
  uint8_t enabled_modes_;
  int num_traces_recorded_;
  std::unique_ptr<TraceBuffer> logged_events_;
  std::vector<std::unique_ptr<TraceEvent>> metadata_events_;
  bool dispatching_to_observer_list_;
  std::vector<EnabledStateObserver*> enabled_state_observer_list_;
  std::map<AsyncEnabledStateObserver*, RegisteredAsyncObserver>
      async_observers_;

  std::string process_name_;
  std::unordered_map<int, std::string> process_labels_;
  int process_sort_index_;
  std::unordered_map<int, int> thread_sort_indices_;
  std::unordered_map<int, std::string> thread_names_;


  std::unordered_map<int, base::stack<TimeTicks>> thread_event_start_times_;
  std::unordered_map<std::string, int> thread_colors_;

  TimeTicks buffer_limit_reached_timestamp_;


  unsigned long long process_id_hash_;

  int process_id_;

  TimeDelta time_offset_;

  subtle::AtomicWord trace_options_;

  TraceConfig trace_config_;
  TraceConfig::EventFilters enabled_event_filters_;

  ThreadLocalPointer<ThreadLocalEventBuffer> thread_local_event_buffer_;
  ThreadLocalBoolean thread_blocks_message_loop_;
  ThreadLocalBoolean thread_is_in_trace_event_;




  hash_set<MessageLoop*> thread_message_loops_;



  std::unique_ptr<TraceBufferChunk> thread_shared_chunk_;
  size_t thread_shared_chunk_index_;


  OutputCallback flush_output_callback_;
  scoped_refptr<SingleThreadTaskRunner> flush_task_runner_;
  ArgumentFilterPredicate argument_filter_predicate_;
  subtle::AtomicWord generation_;
  bool use_worker_thread_;

  FilterFactoryForTesting filter_factory_for_testing_;

  TraceLog(const TraceLog&) = delete; TraceLog& operator=(const TraceLog&) = delete;
};

}
}
# 16 "../../base/trace_event/trace_event_system_stats_monitor.h" 2

namespace base {

class SingleThreadTaskRunner;

namespace trace_event {




class TraceEventSystemStatsMonitor
    : public TraceLog::EnabledStateObserver {
 public:

  static const int kSamplingIntervalMilliseconds = 2000;



  explicit TraceEventSystemStatsMonitor(
      scoped_refptr<SingleThreadTaskRunner> task_runner);

  ~TraceEventSystemStatsMonitor() override;


  void OnTraceLogEnabled() override;
  void OnTraceLogDisabled() override;


  void DumpSystemStats();

 private:
  friend class TraceSystemStatsMonitorTest_TraceEventSystemStatsMonitor_Test; friend class TraceSystemStatsMonitorTest_DISABLED_TraceEventSystemStatsMonitor_Test; friend class TraceSystemStatsMonitorTest_FLAKY_TraceEventSystemStatsMonitor_Test;


  bool IsTimerRunningForTest() const;

  void StartProfiling();

  void StopProfiling();


  scoped_refptr<SingleThreadTaskRunner> task_runner_;


  RepeatingTimer dump_timer_;

  WeakPtrFactory<TraceEventSystemStatsMonitor> weak_factory_;

  TraceEventSystemStatsMonitor(const TraceEventSystemStatsMonitor&) = delete; TraceEventSystemStatsMonitor& operator=(const TraceEventSystemStatsMonitor&) = delete;
};



            void AppendSystemProfileAsTraceFormat(const SystemMetrics&
                                                  system_stats,
                                                  std::string* output);

}
}
# 25 "../../base/trace_event/trace_event.h" 2
# 460 "../../base/trace_event/trace_event.h"
namespace trace_event_internal {



const int kZeroNumArgs = 0;
const std::nullptr_t kGlobalScope = nullptr;
const unsigned long long kNoId = 0;




class TraceID {
 public:

  class LocalId {
   public:
    explicit LocalId(const void* raw_id)
        : raw_id_(static_cast<unsigned long long>(
              reinterpret_cast<uintptr_t>(raw_id))) {}
    explicit LocalId(unsigned long long raw_id) : raw_id_(raw_id) {}
    unsigned long long raw_id() const { return raw_id_; }
   private:
    unsigned long long raw_id_;
  };


  class GlobalId {
   public:
    explicit GlobalId(unsigned long long raw_id) : raw_id_(raw_id) {}
    unsigned long long raw_id() const { return raw_id_; }
   private:
    unsigned long long raw_id_;
  };

  class WithScope {
   public:
    WithScope(const char* scope, unsigned long long raw_id)
        : scope_(scope), raw_id_(raw_id) {}
    WithScope(const char* scope, LocalId local_id)
        : scope_(scope), raw_id_(local_id.raw_id()) {
      id_flags_ = (static_cast<unsigned int>(1 << 12));
    }
    WithScope(const char* scope, GlobalId global_id)
        : scope_(scope), raw_id_(global_id.raw_id()) {
      id_flags_ = (static_cast<unsigned int>(1 << 13));
    }
    WithScope(const char* scope,
              unsigned long long prefix,
              unsigned long long raw_id)
        : scope_(scope), has_prefix_(true), prefix_(prefix), raw_id_(raw_id) {}
    WithScope(const char* scope, unsigned long long prefix, GlobalId global_id)
        : scope_(scope),
          has_prefix_(true),
          prefix_(prefix),
          raw_id_(global_id.raw_id()) {
      id_flags_ = (static_cast<unsigned int>(1 << 13));
    }
    unsigned long long raw_id() const { return raw_id_; }
    const char* scope() const { return scope_; }
    bool has_prefix() const { return has_prefix_; }
    unsigned long long prefix() const { return prefix_; }
    unsigned int id_flags() const { return id_flags_; }

   private:
    const char* scope_ = nullptr;
    bool has_prefix_ = false;
    unsigned long long prefix_;
    unsigned long long raw_id_;
    unsigned int id_flags_ = (static_cast<unsigned int>(1 << 1));
  };


  class DontMangle {
   public:
    explicit DontMangle(const void* raw_id)
        : raw_id_(static_cast<unsigned long long>(
              reinterpret_cast<uintptr_t>(raw_id))) {}
    explicit DontMangle(unsigned long long raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned long raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned int raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned short raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned char raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(long long raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit DontMangle(long raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit DontMangle(int raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit DontMangle(short raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit DontMangle(signed char raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    unsigned long long raw_id() const { return raw_id_; }
   private:
    unsigned long long raw_id_;
  };


  class ForceMangle {
   public:
    explicit ForceMangle(unsigned long long raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned long raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned int raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned short raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned char raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(long long raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit ForceMangle(long raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit ForceMangle(int raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit ForceMangle(short raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    explicit ForceMangle(signed char raw_id)
        : raw_id_(static_cast<unsigned long long>(raw_id)) {}
    unsigned long long raw_id() const { return raw_id_; }
   private:
    unsigned long long raw_id_;
  };

  TraceID(const void* raw_id) : raw_id_(static_cast<unsigned long long>(
                                        reinterpret_cast<uintptr_t>(raw_id))) {
    id_flags_ = (static_cast<unsigned int>(1 << 1)) | (static_cast<unsigned int>(1 << 2));
  }
  TraceID(ForceMangle raw_id) : raw_id_(raw_id.raw_id()) {
    id_flags_ = (static_cast<unsigned int>(1 << 1)) | (static_cast<unsigned int>(1 << 2));
  }
  TraceID(DontMangle raw_id) : raw_id_(raw_id.raw_id()) {}
  TraceID(unsigned long long raw_id) : raw_id_(raw_id) {}
  TraceID(unsigned long raw_id) : raw_id_(raw_id) {}
  TraceID(unsigned int raw_id) : raw_id_(raw_id) {}
  TraceID(unsigned short raw_id) : raw_id_(raw_id) {}
  TraceID(unsigned char raw_id) : raw_id_(raw_id) {}
  TraceID(long long raw_id)
      : raw_id_(static_cast<unsigned long long>(raw_id)) {}
  TraceID(long raw_id)
      : raw_id_(static_cast<unsigned long long>(raw_id)) {}
  TraceID(int raw_id)
      : raw_id_(static_cast<unsigned long long>(raw_id)) {}
  TraceID(short raw_id)
      : raw_id_(static_cast<unsigned long long>(raw_id)) {}
  TraceID(signed char raw_id)
      : raw_id_(static_cast<unsigned long long>(raw_id)) {}
  TraceID(LocalId raw_id) : raw_id_(raw_id.raw_id()) {
    id_flags_ = (static_cast<unsigned int>(1 << 12));
  }
  TraceID(GlobalId raw_id) : raw_id_(raw_id.raw_id()) {
    id_flags_ = (static_cast<unsigned int>(1 << 13));
  }
  TraceID(WithScope scoped_id)
      : scope_(scoped_id.scope()),
        has_prefix_(scoped_id.has_prefix()),
        prefix_(scoped_id.prefix()),
        raw_id_(scoped_id.raw_id()),
        id_flags_(scoped_id.id_flags()) {}

  unsigned long long raw_id() const { return raw_id_; }
  const char* scope() const { return scope_; }
  bool has_prefix() const { return has_prefix_; }
  unsigned long long prefix() const { return prefix_; }
  unsigned int id_flags() const { return id_flags_; }

  std::unique_ptr<base::trace_event::ConvertableToTraceFormat>
  AsConvertableToTraceFormat() const;

 private:
  const char* scope_ = nullptr;
  bool has_prefix_ = false;
  unsigned long long prefix_;
  unsigned long long raw_id_;
  unsigned int id_flags_ = (static_cast<unsigned int>(1 << 1));
};


union TraceValueUnion {
  bool as_bool;
  unsigned long long as_uint;
  long long as_int;
  double as_double;
  const void* as_pointer;
  const char* as_string;
};


class TraceStringWithCopy {
 public:
  explicit TraceStringWithCopy(const char* str) : str_(str) {}
  const char* str() const { return str_; }
 private:
  const char* str_;
};
# 679 "../../base/trace_event/trace_event.h"
static inline void SetTraceValue( unsigned long long arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(2)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( unsigned long arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(2)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( unsigned int arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(2)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( unsigned short arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(2)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( unsigned char arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(2)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( long long arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(3)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( long arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(3)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( int arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(3)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( short arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(3)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( signed char arg, unsigned char* type, unsigned long long* value) { *type = (static_cast<unsigned char>(3)); *value = static_cast<unsigned long long>(arg); }
static inline void SetTraceValue( bool arg, unsigned char* type, unsigned long long* value) { TraceValueUnion type_value; type_value.as_bool = arg; *type = (static_cast<unsigned char>(1)); *value = type_value.as_uint; }
static inline void SetTraceValue( double arg, unsigned char* type, unsigned long long* value) { TraceValueUnion type_value; type_value.as_double = arg; *type = (static_cast<unsigned char>(4)); *value = type_value.as_uint; }

static inline void SetTraceValue( const void* arg, unsigned char* type, unsigned long long* value) { TraceValueUnion type_value; type_value.as_pointer = arg; *type = (static_cast<unsigned char>(5)); *value = type_value.as_uint; }

static inline void SetTraceValue( const char* arg, unsigned char* type, unsigned long long* value) { TraceValueUnion type_value; type_value.as_string = arg; *type = (static_cast<unsigned char>(6)); *value = type_value.as_uint; }

static inline void SetTraceValue( const TraceStringWithCopy& arg, unsigned char* type, unsigned long long* value) { TraceValueUnion type_value; type_value.as_string = arg.str(); *type = (static_cast<unsigned char>(7)); *value = type_value.as_uint; }






static inline void SetTraceValue(const std::string& arg,
                                 unsigned char* type,
                                 unsigned long long* value) {
  TraceValueUnion type_value;
  type_value.as_string = arg.c_str();
  *type = (static_cast<unsigned char>(7));
  *value = type_value.as_uint;
}



static inline void SetTraceValue(const base::Time arg,
                                 unsigned char* type,
                                 unsigned long long* value) {
  *type = (static_cast<unsigned char>(3));
  *value = arg.ToInternalValue();
}

static inline void SetTraceValue(const base::TimeTicks arg,
                                 unsigned char* type,
                                 unsigned long long* value) {
  *type = (static_cast<unsigned char>(3));
  *value = arg.ToInternalValue();
}

static inline void SetTraceValue(const base::ThreadTicks arg,
                                 unsigned char* type,
                                 unsigned long long* value) {
  *type = (static_cast<unsigned char>(3));
  *value = arg.ToInternalValue();
}







template <class ARG1_CONVERTABLE_TYPE>
static inline base::trace_event::TraceEventHandle
AddTraceEventWithThreadIdAndTimestamp(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    int thread_id,
    const base::TimeTicks& timestamp,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    std::unique_ptr<ARG1_CONVERTABLE_TYPE> arg1_val) {
  const int num_args = 1;
  unsigned char arg_types[1] = { (static_cast<unsigned char>(8)) };
  std::unique_ptr<base::trace_event::ConvertableToTraceFormat>
      convertable_values[1] = {std::move(arg1_val)};
  return base::trace_event::TraceLog::GetInstance() ->AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, thread_id,
      timestamp, num_args, &arg1_name, arg_types, __null, convertable_values,
      flags);
}

template <class ARG1_TYPE, class ARG2_CONVERTABLE_TYPE>
static inline base::trace_event::TraceEventHandle
AddTraceEventWithThreadIdAndTimestamp(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    int thread_id,
    const base::TimeTicks& timestamp,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    const ARG1_TYPE& arg1_val,
    const char* arg2_name,
    std::unique_ptr<ARG2_CONVERTABLE_TYPE> arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = { arg1_name, arg2_name };

  unsigned char arg_types[2];
  unsigned long long arg_values[2];
  SetTraceValue(arg1_val, &arg_types[0], &arg_values[0]);
  arg_types[1] = (static_cast<unsigned char>(8));
  std::unique_ptr<base::trace_event::ConvertableToTraceFormat>
      convertable_values[2] = {nullptr, std::move(arg2_val)};
  return base::trace_event::TraceLog::GetInstance() ->AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, thread_id,
      timestamp, num_args, arg_names, arg_types, arg_values, convertable_values,
      flags);
}

template <class ARG1_CONVERTABLE_TYPE, class ARG2_TYPE>
static inline base::trace_event::TraceEventHandle
AddTraceEventWithThreadIdAndTimestamp(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    int thread_id,
    const base::TimeTicks& timestamp,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    std::unique_ptr<ARG1_CONVERTABLE_TYPE> arg1_val,
    const char* arg2_name,
    const ARG2_TYPE& arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = { arg1_name, arg2_name };

  unsigned char arg_types[2];
  unsigned long long arg_values[2];
  arg_types[0] = (static_cast<unsigned char>(8));
  arg_values[0] = 0;
  SetTraceValue(arg2_val, &arg_types[1], &arg_values[1]);
  std::unique_ptr<base::trace_event::ConvertableToTraceFormat>
      convertable_values[2] = {std::move(arg1_val), nullptr};
  return base::trace_event::TraceLog::GetInstance() ->AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, thread_id,
      timestamp, num_args, arg_names, arg_types, arg_values, convertable_values,
      flags);
}

template <class ARG1_CONVERTABLE_TYPE, class ARG2_CONVERTABLE_TYPE>
static inline base::trace_event::TraceEventHandle
AddTraceEventWithThreadIdAndTimestamp(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    int thread_id,
    const base::TimeTicks& timestamp,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    std::unique_ptr<ARG1_CONVERTABLE_TYPE> arg1_val,
    const char* arg2_name,
    std::unique_ptr<ARG2_CONVERTABLE_TYPE> arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = { arg1_name, arg2_name };
  unsigned char arg_types[2] =
      { (static_cast<unsigned char>(8)), (static_cast<unsigned char>(8)) };
  std::unique_ptr<base::trace_event::ConvertableToTraceFormat>
      convertable_values[2] = {std::move(arg1_val), std::move(arg2_val)};
  return base::trace_event::TraceLog::GetInstance() ->AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, thread_id,
      timestamp, num_args, arg_names, arg_types, __null, convertable_values,
      flags);
}

static inline base::trace_event::TraceEventHandle
AddTraceEventWithThreadIdAndTimestamp(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    int thread_id,
    const base::TimeTicks& timestamp,
    unsigned int flags,
    unsigned long long bind_id) {
  return base::trace_event::TraceLog::GetInstance() ->AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, thread_id,
      timestamp, kZeroNumArgs, __null, __null, __null, __null, flags);
}

static inline base::trace_event::TraceEventHandle AddTraceEvent(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    unsigned int flags,
    unsigned long long bind_id) {
  const int thread_id = static_cast<int>(base::PlatformThread::CurrentId());
  const base::TimeTicks now = base::TimeTicks::Now();
  return AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, thread_id, now, flags,
      bind_id);
}

template<class ARG1_TYPE>
static inline base::trace_event::TraceEventHandle
AddTraceEventWithThreadIdAndTimestamp(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    int thread_id,
    const base::TimeTicks& timestamp,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    const ARG1_TYPE& arg1_val) {
  const int num_args = 1;
  unsigned char arg_types[1];
  unsigned long long arg_values[1];
  SetTraceValue(arg1_val, &arg_types[0], &arg_values[0]);
  return base::trace_event::TraceLog::GetInstance() ->AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, thread_id,
      timestamp, num_args, &arg1_name, arg_types, arg_values, __null, flags);
}

template<class ARG1_TYPE>
static inline base::trace_event::TraceEventHandle AddTraceEvent(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    const ARG1_TYPE& arg1_val) {
  int thread_id = static_cast<int>(base::PlatformThread::CurrentId());
  base::TimeTicks now = base::TimeTicks::Now();
  return AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, thread_id, now, flags,
      bind_id, arg1_name, arg1_val);
}

template <class ARG1_CONVERTABLE_TYPE>
static inline base::trace_event::TraceEventHandle AddTraceEvent(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    std::unique_ptr<ARG1_CONVERTABLE_TYPE> arg1_val) {
  int thread_id = static_cast<int>(base::PlatformThread::CurrentId());
  base::TimeTicks now = base::TimeTicks::Now();
  return AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, thread_id, now, flags,
      bind_id, arg1_name, std::move(arg1_val));
}

template<class ARG1_TYPE, class ARG2_TYPE>
static inline base::trace_event::TraceEventHandle
AddTraceEventWithThreadIdAndTimestamp(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    int thread_id,
    const base::TimeTicks& timestamp,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    const ARG1_TYPE& arg1_val,
    const char* arg2_name,
    const ARG2_TYPE& arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = { arg1_name, arg2_name };
  unsigned char arg_types[2];
  unsigned long long arg_values[2];
  SetTraceValue(arg1_val, &arg_types[0], &arg_values[0]);
  SetTraceValue(arg2_val, &arg_types[1], &arg_values[1]);
  return base::trace_event::TraceLog::GetInstance() ->AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, thread_id,
      timestamp, num_args, arg_names, arg_types, arg_values, __null, flags);
}

template <class ARG1_CONVERTABLE_TYPE, class ARG2_TYPE>
static inline base::trace_event::TraceEventHandle AddTraceEvent(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    std::unique_ptr<ARG1_CONVERTABLE_TYPE> arg1_val,
    const char* arg2_name,
    const ARG2_TYPE& arg2_val) {
  int thread_id = static_cast<int>(base::PlatformThread::CurrentId());
  base::TimeTicks now = base::TimeTicks::Now();
  return AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, thread_id, now, flags,
      bind_id, arg1_name, std::move(arg1_val), arg2_name, arg2_val);
}

template <class ARG1_TYPE, class ARG2_CONVERTABLE_TYPE>
static inline base::trace_event::TraceEventHandle AddTraceEvent(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    const ARG1_TYPE& arg1_val,
    const char* arg2_name,
    std::unique_ptr<ARG2_CONVERTABLE_TYPE> arg2_val) {
  int thread_id = static_cast<int>(base::PlatformThread::CurrentId());
  base::TimeTicks now = base::TimeTicks::Now();
  return AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, thread_id, now, flags,
      bind_id, arg1_name, arg1_val, arg2_name, std::move(arg2_val));
}

template <class ARG1_CONVERTABLE_TYPE, class ARG2_CONVERTABLE_TYPE>
static inline base::trace_event::TraceEventHandle AddTraceEvent(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    std::unique_ptr<ARG1_CONVERTABLE_TYPE> arg1_val,
    const char* arg2_name,
    std::unique_ptr<ARG2_CONVERTABLE_TYPE> arg2_val) {
  int thread_id = static_cast<int>(base::PlatformThread::CurrentId());
  base::TimeTicks now = base::TimeTicks::Now();
  return AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, thread_id, now, flags,
      bind_id, arg1_name, std::move(arg1_val), arg2_name, std::move(arg2_val));
}

template<class ARG1_TYPE, class ARG2_TYPE>
static inline base::trace_event::TraceEventHandle AddTraceEvent(
    char phase,
    const unsigned char* category_group_enabled,
    const char* name,
    const char* scope,
    unsigned long long id,
    unsigned int flags,
    unsigned long long bind_id,
    const char* arg1_name,
    const ARG1_TYPE& arg1_val,
    const char* arg2_name,
    const ARG2_TYPE& arg2_val) {
  int thread_id = static_cast<int>(base::PlatformThread::CurrentId());
  base::TimeTicks now = base::TimeTicks::Now();
  return AddTraceEventWithThreadIdAndTimestamp(
      phase, category_group_enabled, name, scope, id, thread_id, now, flags,
      bind_id, arg1_name, arg1_val, arg2_name, arg2_val);
}

template <class ARG1_CONVERTABLE_TYPE>
static inline void AddMetadataEvent(
    const unsigned char* category_group_enabled,
    const char* event_name,
    const char* arg_name,
    std::unique_ptr<ARG1_CONVERTABLE_TYPE> arg_value) {
  const char* arg_names[1] = {arg_name};
  unsigned char arg_types[1] = {(static_cast<unsigned char>(8))};
  std::unique_ptr<base::trace_event::ConvertableToTraceFormat>
      convertable_values[1] = {std::move(arg_value)};
  base::trace_event::TraceLog::GetInstance()->AddMetadataEvent(
      category_group_enabled, event_name,
      1,
      arg_names, arg_types,
      nullptr,
      convertable_values, (static_cast<unsigned int>(0)));
}

template <class ARG1_TYPE>
static void AddMetadataEvent(const unsigned char* category_group_enabled,
                             const char* event_name,
                             const char* arg_name,
                             const ARG1_TYPE& arg_val) {
  const int num_args = 1;
  const char* arg_names[1] = {arg_name};
  unsigned char arg_types[1];
  unsigned long long arg_values[1];
  SetTraceValue(arg_val, &arg_types[0], &arg_values[0]);

  base::trace_event::TraceLog::GetInstance()->AddMetadataEvent(
      category_group_enabled, event_name, num_args, arg_names, arg_types,
      arg_values, nullptr, (static_cast<unsigned int>(0)));
}


class ScopedTracer {
 public:

  ScopedTracer() : p_data_(__null) {}

  ~ScopedTracer() {
    if (p_data_ && *data_.category_group_enabled) {
      base::trace_event::TraceLog::GetInstance()->UpdateTraceEventDuration(
          data_.category_group_enabled, data_.name, data_.event_handle);
    }
  }

  void Initialize(const unsigned char* category_group_enabled,
                  const char* name,
                  base::trace_event::TraceEventHandle event_handle) {
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }

 private:





  struct Data {
    const unsigned char* category_group_enabled;
    const char* name;
    base::trace_event::TraceEventHandle event_handle;
  };
  Data* p_data_;
  Data data_;
};


class ScopedTraceBinaryEfficient {
 public:
  ScopedTraceBinaryEfficient(const char* category_group, const char* name);
  ~ScopedTraceBinaryEfficient();

 private:
  const unsigned char* category_group_enabled_;
  const char* name_;
  base::trace_event::TraceEventHandle event_handle_;
};
# 1145 "../../base/trace_event/trace_event.h"
}

namespace base {
namespace trace_event {

template<typename IDType> class TraceScopedTrackableObject {
 public:
  TraceScopedTrackableObject(const char* category_group, const char* name,
      IDType id)
    : category_group_(category_group),
      name_(name),
      id_(id) {
    do { static base::subtle::AtomicWord trace_event_unique_atomic1157 = 0; const unsigned char* trace_event_unique_category_group_enabled1157; trace_event_unique_category_group_enabled1157 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic1157))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled1157), 0)) { trace_event_unique_category_group_enabled1157 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category_group_); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic1157), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled1157))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled1157 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((id_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEvent( ('N'), trace_event_unique_category_group_enabled1157, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), trace_event_flags, trace_event_internal::kNoId); } } while (0);
  }

  template <typename ArgType> void snapshot(ArgType snapshot) {
    do { static base::subtle::AtomicWord trace_event_unique_atomic1161 = 0; const unsigned char* trace_event_unique_category_group_enabled1161; trace_event_unique_category_group_enabled1161 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic1161))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled1161), 0)) { trace_event_unique_category_group_enabled1161 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category_group_); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic1161), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled1161))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled1161 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((id_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEvent( ('O'), trace_event_unique_category_group_enabled1161, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), trace_event_flags, trace_event_internal::kNoId, "snapshot", snapshot); } } while (0);
  }

  ~TraceScopedTrackableObject() {
    do { static base::subtle::AtomicWord trace_event_unique_atomic1165 = 0; const unsigned char* trace_event_unique_category_group_enabled1165; trace_event_unique_category_group_enabled1165 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic1165))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled1165), 0)) { trace_event_unique_category_group_enabled1165 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category_group_); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic1165), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled1165))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled1165 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((id_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEvent( ('D'), trace_event_unique_category_group_enabled1165, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), trace_event_flags, trace_event_internal::kNoId); } } while (0);
  }

 private:
  const char* category_group_;
  const char* name_;
  IDType id_;

  TraceScopedTrackableObject(const TraceScopedTrackableObject&) = delete; TraceScopedTrackableObject& operator=(const TraceScopedTrackableObject&) = delete;
};

}
}
# 11 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.h" 2
# 1 "../../third_party/WebKit/Source/platform/PlatformExport.h" 1
# 12 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.h" 2

namespace blink {
namespace scheduler {




                extern const char kTracingCategoryNameDefault[];
                extern const char kTracingCategoryNameInfo[];
                extern const char kTracingCategoryNameDebug[];

namespace internal {

                void ValidateTracingCategory(const char* category);

}

                void WarmupTracingCategories();

                bool AreVerboseSnapshotsEnabled();



namespace util {

                std::string PointerToString(const void* pointer);
                const char* BackgroundStateToString(bool is_backgrounded);
                const char* AudioPlayingStateToString(bool is_audio_playing);
                const char* YesNoStateToString(bool is_yes);
                double TimeDeltaToMilliseconds(const base::TimeDelta& value);

}
# 73 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.h"
template <typename T, const char* category>
class TraceableState {
 public:
  using ConverterFuncPtr = const char* (*)(T);

  TraceableState(T initial_state,
                 const char* name,
                 const void* object,
                 ConverterFuncPtr converter)
      : name_(name),
        object_(object),
        converter_(converter),
        state_(initial_state),
        started_(false) {
    internal::ValidateTracingCategory(category);
    Trace();
  }

  ~TraceableState() {
    if (started_)
      do { static base::subtle::AtomicWord trace_event_unique_atomic93 = 0; const unsigned char* trace_event_unique_category_group_enabled93; trace_event_unique_category_group_enabled93 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic93))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled93), 0)) { trace_event_unique_category_group_enabled93 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic93), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled93))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled93 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((object_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEvent( ('F'), trace_event_unique_category_group_enabled93, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), trace_event_flags, trace_event_internal::kNoId); } } while (0);
  }

  TraceableState& operator =(const T& value) {
    Assign(value);
    return *this;
  }
  TraceableState& operator =(const TraceableState& another) {
    Assign(another.state_);
    return *this;
  }

  operator T() const {
    return state_;
  }

  void OnTraceLogEnabled() {
    Trace();
  }

 private:
  void Assign(T new_state) {
    if (state_ != new_state) {
      state_ = new_state;
      Trace();
    }
  }

  void Trace() {
    if (started_)
      do { static base::subtle::AtomicWord trace_event_unique_atomic123 = 0; const unsigned char* trace_event_unique_category_group_enabled123; trace_event_unique_category_group_enabled123 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic123))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled123), 0)) { trace_event_unique_category_group_enabled123 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic123), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled123))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled123 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((object_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEvent( ('F'), trace_event_unique_category_group_enabled123, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), trace_event_flags, trace_event_internal::kNoId); } } while (0);

    started_ = is_enabled();
    if (started_) {


      base::TimeTicks now = base::TimeTicks::Now();
      do { static base::subtle::AtomicWord trace_event_unique_atomic130 = 0; const unsigned char* trace_event_unique_category_group_enabled130; trace_event_unique_category_group_enabled130 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic130))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled130), 0)) { trace_event_unique_category_group_enabled130 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic130), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled130))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled130 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((object_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEventWithThreadIdAndTimestamp( ('S'), trace_event_unique_category_group_enabled130, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), static_cast<int>(base::PlatformThread::CurrentId()), now, trace_event_flags | (static_cast<unsigned int>(1 << 5)), trace_event_internal::kNoId); } } while (0);
      do { static base::subtle::AtomicWord trace_event_unique_atomic132 = 0; const unsigned char* trace_event_unique_category_group_enabled132; trace_event_unique_category_group_enabled132 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic132))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled132), 0)) { trace_event_unique_category_group_enabled132 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic132), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled132))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled132 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((object_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEventWithThreadIdAndTimestamp( ('T'), trace_event_unique_category_group_enabled132, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), static_cast<int>(base::PlatformThread::CurrentId()), now, trace_event_flags | (static_cast<unsigned int>(1 << 5)), trace_event_internal::kNoId, "step", converter_(state_)); } } while (0);

    }
  }

  bool is_enabled() const {
    bool result = false;
    do { static base::subtle::AtomicWord trace_event_unique_atomic138 = 0; const unsigned char* trace_event_unique_category_group_enabled138; trace_event_unique_category_group_enabled138 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic138))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled138), 0)) { trace_event_unique_category_group_enabled138 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic138), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled138))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled138 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT)), 0)) { *&result = true; } else { *&result = false; } } while (0);
    return result;
  }

  const char* const name_;
  const void* const object_;
  const ConverterFuncPtr converter_;

  T state_;


  bool started_;

  TraceableState(const TraceableState&) = delete;
};

template <typename T, const char* category>
class TraceableCounter {
 public:
  using ConverterFuncPtr = double (*)(const T&);

  TraceableCounter(T initial_value,
                   const char* name,
                   const void* object,
                   ConverterFuncPtr converter)
      : name_(name),
        object_(object),
        converter_(converter),
        value_(initial_value) {
    internal::ValidateTracingCategory(category);
    Trace();
  }

  TraceableCounter& operator =(const T& value) {
    value_ = value;
    Trace();
    return *this;
  }
  TraceableCounter& operator =(const TraceableCounter& another) {
    value_ = another.value_;
    Trace();
    return *this;
  }

  TraceableCounter& operator +=(const T& value) {
    value_ += value;
    Trace();
    return *this;
  }
  TraceableCounter& operator -=(const T& value) {
    value_ -= value;
    Trace();
    return *this;
  }

  const T& value() const {
    return value_;
  }
  const T* operator ->() const {
    return &value_;
  }
  operator T() const {
    return value_;
  }

  void Trace() const {
    do { static base::subtle::AtomicWord trace_event_unique_atomic204 = 0; const unsigned char* trace_event_unique_category_group_enabled204; trace_event_unique_category_group_enabled204 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic204))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled204), 0)) { trace_event_unique_category_group_enabled204 = base::trace_event::TraceLog::GetCategoryGroupEnabled(category); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic204), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled204))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled204 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT | base::trace_event::TraceCategory::ENABLED_FOR_FILTERING)), 0)) { trace_event_internal::TraceID trace_event_trace_id((object_)); unsigned int trace_event_flags = (static_cast<unsigned int>(0)) | trace_event_trace_id.id_flags(); trace_event_internal::AddTraceEvent( ('C'), trace_event_unique_category_group_enabled204, name_, trace_event_trace_id.scope(), trace_event_trace_id.raw_id(), trace_event_flags, trace_event_internal::kNoId, "value", static_cast<int>(converter_(value_))); } } while (0);
  }

 private:
  const char* const name_;
  const void* const object_;
  const ConverterFuncPtr converter_;

  T value_;
  TraceableCounter(const TraceableCounter&) = delete;
};



template <typename T, const char* category>
constexpr T operator -(const TraceableCounter<T, category>& counter) {
  return -counter.value();
}

template <typename T, const char* category>
constexpr T operator /(const TraceableCounter<T, category>& lhs, const T& rhs) {
  return lhs.value() / rhs;
}

template <typename T, const char* category>
constexpr bool operator >(
    const TraceableCounter<T, category>& lhs, const T& rhs) {
  return lhs.value() > rhs;
}

}
}
# 6 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.cc" 2

# 1 "../../base/format_macros.h" 1
# 24 "../../base/format_macros.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/stddef.h" 1 3
# 25 "../../base/format_macros.h" 2
# 39 "../../base/format_macros.h"
# 1 "../../buildtools/third_party/libc++/trunk/include/inttypes.h" 1 3
# 238 "../../buildtools/third_party/libc++/trunk/include/inttypes.h" 3
# 247 "../../buildtools/third_party/libc++/trunk/include/inttypes.h" 3
# 1 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/inttypes.h" 1 3
# 30 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/inttypes.h" 3
# 1 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/inttypes.h" 1 3 4
# 266 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/inttypes.h" 3 4
extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();





extern long int __strtol_internal (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
 strtoimax (const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __strtoul_internal (const char *__restrict __nptr,
          char ** __restrict __endptr,
          int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
 strtoumax (const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtoul_internal (nptr, endptr, base, 0);
}

extern long int __wcstol_internal (const wchar_t * __restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
 wcstoimax (const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __wcstoul_internal (const wchar_t *
          __restrict __nptr,
          wchar_t **
          __restrict __endptr,
          int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
 wcstoumax (const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstoul_internal (nptr, endptr, base, 0);
}
# 432 "../../build/linux/debian_stretch_amd64-sysroot/usr/include/inttypes.h" 3 4
}
# 31 "../../third_party/llvm-build/Release+Asserts/lib/clang/6.0.0/include/inttypes.h" 2 3
# 248 "../../buildtools/third_party/libc++/trunk/include/inttypes.h" 2 3
# 40 "../../base/format_macros.h" 2
# 8 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.cc" 2
# 1 "../../base/strings/stringprintf.h" 1
# 16 "../../base/strings/stringprintf.h"
namespace base {


            std::string StringPrintf( const char* format,
                                     ...)
    __attribute__((format(printf, 1, 2))) __attribute__((warn_unused_result));







            std::string StringPrintV(const char* format, va_list ap)
    __attribute__((format(printf, 1, 0))) __attribute__((warn_unused_result));


            const std::string& SStringPrintf(
    std::string* dst,
                           const char* format,
    ...) __attribute__((format(printf, 2, 3)));
# 45 "../../base/strings/stringprintf.h"
            void StringAppendF(std::string* dst,
                                                      const char* format,
                               ...) __attribute__((format(printf, 2, 3)));
# 56 "../../base/strings/stringprintf.h"
            void StringAppendV(std::string* dst, const char* format, va_list ap)
    __attribute__((format(printf, 2, 0)));






}
# 9 "../../third_party/WebKit/Source/platform/scheduler/util/tracing_helper.cc" 2

namespace blink {
namespace scheduler {

const char kTracingCategoryNameDefault[] = "renderer.scheduler";
const char kTracingCategoryNameInfo[] =
    "disabled-by-default-" "renderer.scheduler";
const char kTracingCategoryNameDebug[] =
    "disabled-by-default-" "renderer.scheduler.debug";

namespace {


const char kTracingCategoryNameVerboseSnapshots[] =
    "disabled-by-default-" "renderer.scheduler.enable_verbose_snapshots";

}

namespace internal {

void ValidateTracingCategory(const char* category) {



  true ? (void)0 : ::logging::LogMessageVoidify() & (*::logging::g_swallow_stream) << !(category == kTracingCategoryNameDefault || category == kTracingCategoryNameInfo || category == kTracingCategoryNameDebug);


}

}

bool AreVerboseSnapshotsEnabled() {
  bool result = false;
  omfg
  do { static base::subtle::AtomicWord trace_event_unique_atomic44 = 0; const unsigned char* trace_event_unique_category_group_enabled44; trace_event_unique_category_group_enabled44 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic44))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled44), 0)) { trace_event_unique_category_group_enabled44 = base::trace_event::TraceLog::GetCategoryGroupEnabled(kTracingCategoryNameVerboseSnapshots); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic44), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled44))); };; if (__builtin_expect(!!(*trace_event_unique_category_group_enabled44 & (base::trace_event::TraceCategory::ENABLED_FOR_RECORDING | base::trace_event::TraceCategory::ENABLED_FOR_ETW_EXPORT)), 0)) { *&result = true; } else { *&result = false; } } while (0);

  return result;
}

void WarmupTracingCategories() {
  static base::subtle::AtomicWord trace_event_unique_atomic49 = 0; const unsigned char* trace_event_unique_category_group_enabled49; trace_event_unique_category_group_enabled49 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic49))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled49), 0)) { trace_event_unique_category_group_enabled49 = base::trace_event::TraceLog::GetCategoryGroupEnabled(kTracingCategoryNameDefault); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic49), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled49))); };;
  static base::subtle::AtomicWord trace_event_unique_atomic50 = 0; const unsigned char* trace_event_unique_category_group_enabled50; trace_event_unique_category_group_enabled50 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic50))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled50), 0)) { trace_event_unique_category_group_enabled50 = base::trace_event::TraceLog::GetCategoryGroupEnabled(kTracingCategoryNameInfo); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic50), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled50))); };;
  static base::subtle::AtomicWord trace_event_unique_atomic51 = 0; const unsigned char* trace_event_unique_category_group_enabled51; trace_event_unique_category_group_enabled51 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic51))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled51), 0)) { trace_event_unique_category_group_enabled51 = base::trace_event::TraceLog::GetCategoryGroupEnabled(kTracingCategoryNameDebug); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic51), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled51))); };;
  static base::subtle::AtomicWord trace_event_unique_atomic52 = 0; const unsigned char* trace_event_unique_category_group_enabled52; trace_event_unique_category_group_enabled52 = reinterpret_cast<const unsigned char*>(base::subtle::NoBarrier_Load(&(trace_event_unique_atomic52))); if (__builtin_expect(!!(!trace_event_unique_category_group_enabled52), 0)) { trace_event_unique_category_group_enabled52 = base::trace_event::TraceLog::GetCategoryGroupEnabled(kTracingCategoryNameVerboseSnapshots); base::subtle::NoBarrier_Store(&(trace_event_unique_atomic52), (reinterpret_cast<base::subtle::AtomicWord>( trace_event_unique_category_group_enabled52))); };;
}

namespace util {

std::string PointerToString(const void* pointer) {
  return base::StringPrintf(
      "0x%" "l" "x",
      static_cast<uint64_t>(reinterpret_cast<uintptr_t>(pointer)));
}

const char* BackgroundStateToString(bool is_backgrounded) {
  if (is_backgrounded) {
    return "backgrounded";
  } else {
    return "foregrounded";
  }
}

const char* AudioPlayingStateToString(bool is_audio_playing) {
  if (is_audio_playing) {
    return "playing";
  } else {
    return "muted";
  }
}

const char* YesNoStateToString(bool is_yes) {
  if (is_yes) {
    return "yes";
  } else {
    return "no";
  }
}

double TimeDeltaToMilliseconds(const base::TimeDelta& value) {
  return value.InMillisecondsF();
}

}

}
}
