{
  "comments": [
    {
      "key": {
        "uuid": "05f2ba00_e23d4d89",
        "filename": "third_party/WebKit/Source/bindings/core/v8/V8Initializer.cpp",
        "patchSetId": 29
      },
      "lineNbr": 548,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2018-01-19T21:57:56Z",
      "side": 1,
      "message": "Nit: It\u0027s better to do TODO(crbug.com/1234).",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c1bed9a_df795138",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 52,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2018-01-19T21:57:56Z",
      "side": 1,
      "message": "This could be a\n\n  void* partitions[kMaxPartitions];\n\ninstead of a vector, right? Primitives are smaller and faster, perhaps? Also, see below about mapping from ArrayBufferContents back to these Partitions/avoiding inline metadata. Maybe we just need a\n\n  struct PartitionAllocationPair{\n    void* partition;\n    void* allocation;\n  };\n  static PartitionAllocationPair[kMaxPartitions];\n\nSee also base/memory/protected_memory.h; maybe it should be a `PROTECTED_MEMORY_SECTION`:\n\n  static PROTECTED_MEMORY_SECTION PartitionAllocationPair[kMaxPartitions];\n\n?",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bc5420f_980f48cf",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 52,
      "author": {
        "id": 1001213
      },
      "writtenOn": "2018-02-02T00:10:57Z",
      "side": 1,
      "message": "It\u0027s a one-to-many relation between Partitions and ArrayBufferContents. There are potentially many ArrayBuffers that belong to a partition. My initial CLs used a std::map. This was deemed a show-stopper.\n\nI used a WTF::Vector because I wasn\u0027t able to easily create thread-safe statics with other types (array, std::array). The vector is templated to have enough space for kMaxPartitions without a heap allocation.",
      "parentUuid": "1c1bed9a_df795138",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e4be3d4_4d05b13d",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 66,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2018-01-19T21:57:56Z",
      "side": 1,
      "message": "Nit: TODO(crbug) again.\n\nAlso, is it worth printing a debug log message, tracking an UMA counter, or similar? (Could be done in later CL, even if the answer is Yes, which I\u0027m not sure is the case.)",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a3a03a9_69e2008e",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 66,
      "author": {
        "id": 1001213
      },
      "writtenOn": "2018-02-02T00:10:57Z",
      "side": 1,
      "message": "I hope to attend to this soon (fixing it so the first partition is always given to the main frame\u0027s origin, even if it doesn\u0027t create ArrayBuffers.)",
      "parentUuid": "7e4be3d4_4d05b13d",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "65fcebef_23d04d15",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 148,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2018-01-19T21:57:56Z",
      "side": 1,
      "message": "I\u0027m a little wary of putting metadata inline like this. A linear overwrite could cause this pointer to get mangled, and then we\u0027d follow a bogus `PartitionRootGeneric*`, leading to further (very likely exploitable) memory corruption.\n\nIf possible, can we keep this metadata out of line from the allocation? Since we know we have a fixed `kMaxPartitions`, we could store a static map (primitive array?) of ArrayBufferContents -\u003e PartitionRootGenerics, right?",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e26541b_e443f7f3",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 148,
      "author": {
        "id": 1001213
      },
      "writtenOn": "2018-01-19T22:13:19Z",
      "side": 1,
      "message": "It makes me nervous too. However, a map containing all allocations/partitions was deemed to heavyweight and a show stopper. We need to track an unbounded number of allocations.\n\nThe long term solution is for V8 to help us out with a modified ArrayBuffer::Allocator API, that gives us this information. Right now all we know is the raw pointer when it\u0027s freed.",
      "parentUuid": "65fcebef_23d04d15",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e3f70d0f_914da28a",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 150,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2018-01-19T21:57:56Z",
      "side": 1,
      "message": "Nit: It might? be cleaner to do:\n\n  size_t alloc_size \u003d CheckAdd(...).ValueOrDie();\n\nSee the docs at https://chromium.googlesource.com/chromium/src/+/master/base/numerics/README.md.",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a97e3143_ea995544",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 29
      },
      "lineNbr": 150,
      "author": {
        "id": 1001213
      },
      "writtenOn": "2018-02-02T00:10:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e3f70d0f_914da28a",
      "revId": "81f4490cfd76adcc9992a37abb2cc65e0649dc8d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}