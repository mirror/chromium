// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_ELF_WHITELIST_WHITELIST_COMPONENT_FORMAT_H_
#define CHROME_ELF_WHITELIST_WHITELIST_COMPONENT_FORMAT_H_

namespace whitelist {

enum PackedWhitelistVersion : uint32_t {
  kInitialVersion = 1,
  kLatest = kInitialVersion,
};

struct PackedWhitelistMetadata {
  // The version of the packed whitelist format. This should always be ordered
  // first for backward compatibility purposes.
  PackedWhitelistVersion version;

  // The number of PackedWhitelistModule elements that follows the metadata in
  // the packed whitelist file.
  uint32_t module_count;
};

struct PackedWhitelistModule {
  // SHA1 of only basename (no path).
  uint8_t basename_hash[20];
  // Code ID. This is equivalent to the string generated by formatting
  // the FileHeader.TimeDateStamp and OptionalHeader.SizeOfImage with the
  // formatting string %08X%x.
  // Then the string is passed to the sha - 1 function.
  uint8_t code_id_hash[20];
};

// These struct are directly written to a file. Therefore the padding should
// be consistent accross compilations.
static_assert(sizeof(PackedWhitelistMetadata) == 8,
              "The actual padding of the PackedWhitelistMetadata struct "
              "doesn't match the expected padding");
static_assert(sizeof(PackedWhitelistModule) == 40,
              "The actual padding of the PackedWhitelistModule struct doesn't "
              "match the expected padding");

}  // namespace whitelist

#endif  // CHROME_ELF_WHITELIST_WHITELIST_COMPONENT_FORMAT_H_
