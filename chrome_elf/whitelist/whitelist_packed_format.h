// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// -----------------------------------------------------------------------------
// This defines the expected contents of a packed whitelist file.
// - At offset 0 of the file: {PackedWhitelistMetadata}
// - Immediately following: {Array of PackedWhitelistModule}
// - Anything else can be stored in the rest of the file.
//
// - It's a requirement that the file be packed little-endian and also that
//   32-bit alignment == 64-bit alignment (so no handling required).
// - It's also required that the array be *sorted*. First by basename hash,
//   second by code_id hash (there can be multiple of the same basename hash).
// -----------------------------------------------------------------------------

#ifndef CHROME_ELF_WHITELIST_WHITELIST_PACKED_FORMAT_H_
#define CHROME_ELF_WHITELIST_WHITELIST_PACKED_FORMAT_H_

#include <stdint.h>

namespace whitelist {

// Subdir relative to install_static::GetUserDataDirectory().
extern const wchar_t kFileSubdir[];

// Packed module data cache file.
extern const wchar_t kBlFileName[];

enum PackedWhitelistVersion : uint32_t {
  kInitialVersion = 1,
  kCurrent = kInitialVersion,
  kUnsupported
};

struct PackedWhitelistMetadata {
  // The version of the packed whitelist format. This should always be ordered
  // first for backward compatibility purposes.
  PackedWhitelistVersion version;
  // The number of PackedWhitelistModule elements that follows the metadata in
  // the packed whitelist file.
  uint32_t module_count;
};

struct PackedWhitelistModule {
  // SHA1 of lowercase basename (no path).
  uint8_t basename_hash[20];
  // Code ID. This is equivalent to the string generated by formatting
  // the FileHeader.TimeDateStamp and OptionalHeader.SizeOfImage with the
  // formatting string %08X%x. Then SHA1 the string.
  uint8_t code_id_hash[20];
  // A timestamp used for tracking "last attempted load".  Used to manage
  // lifetime of entries in the local caches.
  uint32_t time_date_stamp;
};

// These struct are directly written to a file. Therefore the padding should
// be consistent across compilations.
static_assert(sizeof(PackedWhitelistMetadata) == 8,
              "The actual padding of the PackedWhitelistMetadata struct "
              "doesn't match the expected padding");
static_assert(sizeof(PackedWhitelistModule) == 44,
              "The actual padding of the PackedWhitelistModule struct doesn't "
              "match the expected padding");

//------------------------------------------------------------------------------
// Exported chrome_elf log API
//------------------------------------------------------------------------------

// Define a flat log entry for any attempted module load.
// The total size in bytes of each log entry will be exactly
// sizeof(LogEntry) + LogEntry.path_extra_size.  The next entry in a buffer from
// the DrainLog() API would follow immediately after that, and will be 32-bit
// aligned for access.
//
// - If this is a |blocked| entry, |path_len| and |path_extra_size| will be 0.
//   (Full path not required for a blacklisted module log.)
// - |path| (and |path_extra_size|) may include extra trailing null
//   characters to ensure the path (and full entry) ends on 32-bit alignment.
struct LogEntry {
  // Module load blocked if true, or allowed if false.
  bool blocked;
  uint8_t basename_hash[20];
  uint8_t code_id_hash[20];
  // Number of characters in |path| string, not including null terminator.
  uint32_t path_len;
  // |path_extra_size| is needed for padding and alignment reasons.
  uint32_t path_extra_size;
  // Null terminated path guaranteed.
  char path[1];
};

static_assert(sizeof(LogEntry) == 56,
              "Ensure expectations for padding and alignment are correct.");

}  // namespace whitelist

extern "C" {
// Exported API for calling from outside chrome_elf.dll.
// Drains the load attempt LogEntries into the provided buffer.
// - Returns the number of bytes written.  See comments above for LogEntry
//   details.
// - If provided, |log_remaining| receives the number of bytes remaining in the
//   module log, that didn't fit in |buffer|.
// - |buffer_size| can be 0, in which case this simply queries the size of the
//   module log.
uint32_t DrainLog(uint8_t* buffer,
                  uint32_t buffer_size,
                  uint32_t* log_remaining);

// WHAT ABOUT AN EVENT TO FIRE INSTEAD OF A FUNCTION POINTER?
// EXPORT bool RegisterNotificationCallback(func_ptr);
}  // extern "C"

#endif  // CHROME_ELF_WHITELIST_WHITELIST_PACKED_FORMAT_H_
