{
  "comments": [
    {
      "key": {
        "uuid": "041e83d7_75a811e5",
        "filename": "mojo/common/time.mojom",
        "patchSetId": 4
      },
      "lineNbr": 8,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-10-19T16:28:57Z",
      "side": 1,
      "message": "Does it make sense to use int64 origin_offset_us directly here?\n\nNested structs have an extra cost, every usage of Time with nested structs would be:\n\n8-byte pointer to Time struct\nTime struct: 8-byte struct header + 8-byte pointer to TimeDelta\nTimeDelta struct: 8-byte struct header + int64\n\nThat is 40 bytes and two layers of indirection. Using int64 will be 24 bytes and one layer of indirection.\n\nWDYT?",
      "revId": "7823760f4fabe7192a66d23e17164ba9a004c5c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5474b3e_706e6564",
        "filename": "mojo/common/time.mojom",
        "patchSetId": 4
      },
      "lineNbr": 8,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-19T19:55:16Z",
      "side": 1,
      "message": "Hmm... we\u0027ve been recommending people use the appropriate Time types where possible, so it would be nice to do the same in the base version \u003d)\n\nThis is a surprising amount of overhead to me. I would have expected simple structs like this to use InlinedStructPtr (and be flattened into the same stream of bytes) so we don\u0027t pay a pointer for indirection. I /would/ have also expected that sizeof(InlinedStructPtr\u003cmojo::common::mojom::Time\u003e) \u003d\u003d sizeof(mojo::common::mojom::Time), but it looks like we store a state bit in InlinedStructPtr as well...",
      "parentUuid": "041e83d7_75a811e5",
      "revId": "7823760f4fabe7192a66d23e17164ba9a004c5c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5348a73e_98e8a03d",
        "filename": "mojo/common/time.mojom",
        "patchSetId": 4
      },
      "lineNbr": 8,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-10-19T20:03:21Z",
      "side": 1,
      "message": "I am not talking about the \"wapper types\", I am talking about the \"wire format\" in messages. Because we use typemapping, the wrapper types will be the types that we map to, so there won\u0027t be difference there.\n\nIn the wire format, structs are always non-inlined.\n\nI don\u0027t think it is much less clear to use int64 in this case. Time/TimeTicks are also very basic types, I don\u0027t think they have to base on the concept of TimeDelta. The win of \"conceptually more clear\" seems minimal but the actual cost of message size increase is significant, IMHO. :)",
      "parentUuid": "d5474b3e_706e6564",
      "revId": "7823760f4fabe7192a66d23e17164ba9a004c5c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbb3adcf_fff8a9b6",
        "filename": "mojo/common/time.mojom",
        "patchSetId": 4
      },
      "lineNbr": 8,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-19T20:10:22Z",
      "side": 1,
      "message": "I guess I kind of assumed that the wire format and the way the generated C++ types are laid out (without typemapping) would have some correlation. Oh well. The overhead makes me sad though...\n\nDone.",
      "parentUuid": "5348a73e_98e8a03d",
      "revId": "7823760f4fabe7192a66d23e17164ba9a004c5c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f3725fc_2067061d",
        "filename": "mojo/common/time_struct_traits.h",
        "patchSetId": 4
      },
      "lineNbr": 24,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-19T09:02:07Z",
      "side": 1,
      "message": "I\u0027m going to see if this makes is able to compile down to the same code as if we just passed an int64 and called FromInternalValue() directly. Hopefully it\u0027s not a big difference... it should be able to tell that deserialization of a base::TimeDelta can never fail and hopefully inline everything...",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 24,
        "endChar": 16
      },
      "revId": "7823760f4fabe7192a66d23e17164ba9a004c5c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}