{
  "comments": [
    {
      "key": {
        "uuid": "094b6c8e_c153ca51",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 40,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Renamed to \"IsFragmentContinuationFromLastLine\" for better clarity.\n\nAnd I guess we should probably move it to NGPhysicalFragment, and use a less hacky implementation?",
      "range": {
        "startLine": 40,
        "startChar": 5,
        "endLine": 40,
        "endChar": 42
      },
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ff1c823_1e9a5d01",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 40,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-22T03:27:49Z",
      "side": 1,
      "message": "+1\n\nHaving comments also helps whenever you create a new terminologies. I can imagine a few things from \"FragmentContinuation\" (continuation is used in the legacy.)",
      "parentUuid": "094b6c8e_c153ca51",
      "range": {
        "startLine": 40,
        "startChar": 5,
        "endLine": 40,
        "endChar": 42
      },
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7bc4df90_bdbaefaa",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 58,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Renamed to \"FragmentContinuesOnNextLine\" for better clarity.\n\nAnd I guess we should probably move it to NGPhysicalFragment, and use a less hacky implementation?",
      "range": {
        "startLine": 58,
        "startChar": 5,
        "endLine": 58,
        "endChar": 41
      },
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ecc0425_5eb08793",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 72,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "I think you can know if we have a next line or not from current_line-\u003eBreakToken(), can you try that?",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce49c4b8_665525ee",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 72,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Done. That make the implementation much less hacky!",
      "parentUuid": "1ecc0425_5eb08793",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c576d25_fe649648",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 77,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "Is there a better naming? These days I wonder, \"anonymous\" is too widely used in several different meaning that we should be more specific what it means in each context.\n\nAlso I prefer adding this to NGPhyscicalTextFragment, unless you\u0027re strong.",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84d99597_21126227",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 77,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Renamed to IsGeneratedText. Or do you have a better name for \"is (possibly indirectly) from a DOM text node\"?\n\nAdded a TODO to move it to NGPhysicalTextFragment.",
      "parentUuid": "2c576d25_fe649648",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edc31457_747d4ef7",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 77,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-22T03:27:49Z",
      "side": 1,
      "message": "Ah...for what does this return true? Is this for when a Text node produced multiple fragments in first-letter? I still don\u0027t understand the intention, so comments/naming to clarify the intention of the function is helpful.",
      "parentUuid": "84d99597_21126227",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7c8634b_f8d8ad72",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 94,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "Is it intentional to use \"\u003e\" to compare with EndOffset(), which is exclusive? If so, can add comments why?",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "814f3ef6_e98599fb",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 94,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Yes. Comments added.",
      "parentUuid": "a7c8634b_f8d8ad72",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c82780a_394e54f2",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 155,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "nit: s/\u003d// ?",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cdc22c37_c35e1dd8",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 155,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9c82780a_394e54f2",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7e500b44_2867fd53",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 214,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "Why do we need to collect all line boxes, compute all of them, and pick appropriate ones? What are the case where we might have more than one candidate? This looks like expensive for a long text, no?",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9aaf3bf7_3f9e5d91",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 214,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Well, with the current data structure, we have to iterate over all fragments in the context, regardless of what we do...\n\nRegarding the collection of line boxes, this is because we need to know if a fragment has continuation in the last/next line. For example, if we have text:\n\nXXX\nYYY\n\nwhere the line width is 3 and there is a soft wrap between the two lines. In this case, ComputeNGCaretPosition(3, kDownstream) should return \"|YYY\" instead of \"XXX|\". So when looking at fragment \"XXX\", although \"XXX|\" matches the offset, it doesn\u0027t match the affinity; as we see that it continues on the next line (YYY), we should check YYY instead.\n\nHowever, there are some cases where we can\u0027t find an exact match and have to pick from previously found candidates. One case is the \"soft wrap with space\". For example, consider text node \"XXX YYY\" laid out as:\n\nXXX\nYYY\n\nWhen resolving (4, kUpstream), the only fragment containing offset 4 is \"YYY\", which however doesn\u0027t match the affinity. Since there is no other possible caret position, we still return \"|YYY\".",
      "parentUuid": "7e500b44_2867fd53",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37238dc5_d55f9537",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 214,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-22T03:27:49Z",
      "side": 1,
      "message": "Maybe you wrote only easy example, but from what I understood from your example, we can:\n* Determine the answer if it\u0027s in the mid of a fragment.\n* Cannot determine only when it\u0027s at the edge, but if we got two edges, we know the answer.\n* The two fragments maybe apart in the visual order, but if we know their bidi level, we can optimize it further.\nso that doesn\u0027t explain we need to collect all line boxes?",
      "parentUuid": "9aaf3bf7_3f9e5d91",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f72b9a26_75f32445",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 229,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "I think this isn\u0027t correct when a line box contains another line box (inside of an inline block), no? Simpler, normal recursion might be easier to read.",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79329b61_3aca28b3",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 229,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "NGInlineFragmentTraversal doesn\u0027t enter block layout roots, so we should be fine here unless there can be nested line boxes in the same inline formatting context?",
      "parentUuid": "f72b9a26_75f32445",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3ce9949_5c211ede",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 229,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-22T03:27:49Z",
      "side": 1,
      "message": "Oh, I didn\u0027t know that, thx.",
      "parentUuid": "79329b61_3aca28b3",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "610c75d4_dab34ee8",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 262,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "I noticed \"IsInlineBlock\" isn\u0027t very well designed, I think you\u0027re using it here for atomic inlines (img etc.) correct? If it\u0027s really an inline block, do you need to look into its descendants, or is this function handles inline block always as an atomic unit?",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b096266c_4bbfede5",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 262,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "Yes, I\u0027m using it to find atomic inlines. Should I use some other way for it?\n\nWe don\u0027t go into its descendants, as they are already in a different context. We only need to check if either of the two caret position by the box sides is the caret position we are looking for.",
      "parentUuid": "610c75d4_dab34ee8",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "861211c3_19d6fff7",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.cc",
        "patchSetId": 21
      },
      "lineNbr": 262,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-22T03:27:49Z",
      "side": 1,
      "message": "No...there\u0027s other usage for this to determine atomic inlines, so we should probably just rename. I\u0027ll put in my backlog ;)",
      "parentUuid": "b096266c_4bbfede5",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19f2ec0e_5635e30a",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.h",
        "patchSetId": 21
      },
      "lineNbr": 48,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-21T06:59:01Z",
      "side": 1,
      "message": "Is this a transient object? If so, nice to annotate STACK_ALLOCATED() or some appropriate ones. https://chromium.googlesource.com/chromium/src/+/master/third_party/WebKit/Source/platform/heap/BlinkGCAPIReference.md\n\nIf this isn\u0027t a transient and maybe stored somewhere, probably better to make this scoped_refptr, unless you\u0027re very sure this doesn\u0027t live longer than the fragment?",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99a82f0f_773826e2",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.h",
        "patchSetId": 21
      },
      "lineNbr": 48,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-12-21T22:05:24Z",
      "side": 1,
      "message": "It is transient, but we can only use DISALLOW_NEW_EXCEPT_PLACEMENT_NEW here because we may store it in a (transient) vector. There can still be memory leak if someone stores the vector on heap.\n\nIn fact, the same loophole already exists in NGInlineFragmentIterator, which returns a vector of fragment pointers.\n\nMaybe we should change all of them to use scoped_refptr?",
      "parentUuid": "19f2ec0e_5635e30a",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20559442_4bc1e683",
        "filename": "third_party/WebKit/Source/core/layout/ng/inline/ng_caret_rect.h",
        "patchSetId": 21
      },
      "lineNbr": 48,
      "author": {
        "id": 1128431
      },
      "writtenOn": "2017-12-22T03:27:49Z",
      "side": 1,
      "message": "up to you, as long as it\u0027s transient and you\u0027re sure you hold a ref somewhere else while the object is alive. I think iterator is quite clear that the ref is kept in the original tree, so I\u0027m not too concerned about it, but I\u0027m also fine if you prefer.",
      "parentUuid": "99a82f0f_773826e2",
      "revId": "391b3a26157b2f2bdf78782c218c8e4887b2b406",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}