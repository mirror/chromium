{
  "comments": [
    {
      "key": {
        "uuid": "a926bf2e_464a9ee5",
        "filename": "components/cronet/ios/test/cronet_http_test.mm",
        "patchSetId": 8
      },
      "lineNbr": 31,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Instead of using \"static\", it would be better to declare these constants in an anonymous namespace.",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 31,
        "endChar": 51
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3530db1f_e5983984",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 45,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "The documentation of UploadDataStream::ReadInternal() says: \"Must not return any error, other than ERR_IO_PENDING.\"; however, the Upload() method returns ERR_FAILED. For that reason, the errors should be handled differently. Maybe notify the handler (delegate) about the error?",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "492c0160_961ef5fa",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 77,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Is it correct to set |pending_stream_data_| to false here unconditionally? What will happen if |pending_read_buffer_| is smaller than the number of bytes available in the NSInputStream? There will still be unread bytes left in the stream.",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a9edbbb_522801a9",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 81,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "A similar observation. If |pending_read_buffer_| is smaller than the length of the pending data and |is_final_chunk_| is set, the UploadDataStream will treat the chunk of data as final and will never call ReadInternal() to read the remaining data.",
      "range": {
        "startLine": 81,
        "startChar": 4,
        "endLine": 81,
        "endChar": 22
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c5ae62f_ee21e67c",
        "filename": "ios/net/chunked_data_stream_uploader.h",
        "patchSetId": 8
      },
      "lineNbr": 49,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "I would suggest moving the explanation why it is a weak pointer to the place where the weak pointer is declared.",
      "range": {
        "startLine": 48,
        "startChar": 50,
        "endLine": 49,
        "endChar": 49
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53f6635e_03533aa5",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 298,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Please add a log message that prints [[stream streamError] description], i.e. something similar to \"case NSStreamEventErrorOccurred:\"?",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99c30c38_921fc3be",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 743,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Since the \u0027if\u0027 clause always returns, the \u0027else\u0027 body can be moved outside, i.e.\n\n    if (net_request_-\u003eextra_request_headers().HasHeader(\n            HttpRequestHeaders::kContentLength)) {\n      // The request will be started when the stream is fully read.\n      return;\n    }\n    // The request doesn\u0027t have content-length header. Use ChunkedDataStreamUploader.\n    std::unique_ptr\u003cChunkedDataStreamUploader\u003e uploader(\n        new ChunkedDataStreamUploader(this));\n    chunked_uploader_ \u003d uploader-\u003eGetWeakPtr();\n    net_request_-\u003eset_upload(std::move(uploader));",
      "range": {
        "startLine": 743,
        "startChar": 6,
        "endLine": 743,
        "endChar": 10
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc320fc3_a0c0452e",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 745,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Use std::make_unique",
      "range": {
        "startLine": 744,
        "startChar": 0,
        "endLine": 745,
        "endChar": 47
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}