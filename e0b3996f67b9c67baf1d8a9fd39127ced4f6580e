{
  "comments": [
    {
      "key": {
        "uuid": "a926bf2e_464a9ee5",
        "filename": "components/cronet/ios/test/cronet_http_test.mm",
        "patchSetId": 8
      },
      "lineNbr": 31,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Instead of using \"static\", it would be better to declare these constants in an anonymous namespace.",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 31,
        "endChar": 51
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af190fbf_0d27377c",
        "filename": "components/cronet/ios/test/cronet_http_test.mm",
        "patchSetId": 8
      },
      "lineNbr": 31,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a926bf2e_464a9ee5",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 31,
        "endChar": 51
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3530db1f_e5983984",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 45,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "The documentation of UploadDataStream::ReadInternal() says: \"Must not return any error, other than ERR_IO_PENDING.\"; however, the Upload() method returns ERR_FAILED. For that reason, the errors should be handled differently. Maybe notify the handler (delegate) about the error?",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74bd03e1_7d50bead",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 45,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Sorry, I just read the code where the result\u003c0 is handled, and did not notice the document. Seems that returning failure is okay, but it is still being investigated(TODO in UploadDataStream::Read). I will follow the rule for now.",
      "parentUuid": "3530db1f_e5983984",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "492c0160_961ef5fa",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 77,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Is it correct to set |pending_stream_data_| to false here unconditionally? What will happen if |pending_read_buffer_| is smaller than the number of bytes available in the NSInputStream? There will still be unread bytes left in the stream.",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "127999ac_6815e5f5",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 77,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Yes. You give me the similar comments last time, and I checked this situation. According to my test, the NSInputStream will trigger another NSStreamEventHasBytesAvailable if the bytes in the stream is not read out. Besides, the NSInputStream will not trigger NSStreamEventEndEncountered until all bytes in the stream are read out.\n\nI add TEST_F(HttpTest, PostRequestWithLargeBodyStream) to cover the situation you mentioned. In the case, 100k bytes are written once into the stream, and I see many times of NSStreamEventHasBytesAvailable is triggered if I add some debug logs.\n\nTherefore, I think it is okay to use this simple way.",
      "parentUuid": "492c0160_961ef5fa",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a9edbbb_522801a9",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 81,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "A similar observation. If |pending_read_buffer_| is smaller than the length of the pending data and |is_final_chunk_| is set, the UploadDataStream will treat the chunk of data as final and will never call ReadInternal() to read the remaining data.",
      "range": {
        "startLine": 81,
        "startChar": 4,
        "endLine": 81,
        "endChar": 22
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5701c74_0562a6ce",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 81,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Ditto.",
      "parentUuid": "2a9edbbb_522801a9",
      "range": {
        "startLine": 81,
        "startChar": 4,
        "endLine": 81,
        "endChar": 22
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "459259b0_1cc1238c",
        "filename": "ios/net/chunked_data_stream_uploader.cc",
        "patchSetId": 8
      },
      "lineNbr": 81,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-02-01T23:20:05Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a5701c74_0562a6ce",
      "range": {
        "startLine": 81,
        "startChar": 4,
        "endLine": 81,
        "endChar": 22
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1c5ae62f_ee21e67c",
        "filename": "ios/net/chunked_data_stream_uploader.h",
        "patchSetId": 8
      },
      "lineNbr": 49,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "I would suggest moving the explanation why it is a weak pointer to the place where the weak pointer is declared.",
      "range": {
        "startLine": 48,
        "startChar": 50,
        "endLine": 49,
        "endChar": 49
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bcedba16_61a81e8a",
        "filename": "ios/net/chunked_data_stream_uploader.h",
        "patchSetId": 8
      },
      "lineNbr": 49,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1c5ae62f_ee21e67c",
      "range": {
        "startLine": 48,
        "startChar": 50,
        "endLine": 49,
        "endChar": 49
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "53f6635e_03533aa5",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 298,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Please add a log message that prints [[stream streamError] description], i.e. something similar to \"case NSStreamEventErrorOccurred:\"?",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f73bff8a_9fb4b90c",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 298,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "53f6635e_03533aa5",
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "99c30c38_921fc3be",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 743,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Since the \u0027if\u0027 clause always returns, the \u0027else\u0027 body can be moved outside, i.e.\n\n    if (net_request_-\u003eextra_request_headers().HasHeader(\n            HttpRequestHeaders::kContentLength)) {\n      // The request will be started when the stream is fully read.\n      return;\n    }\n    // The request doesn\u0027t have content-length header. Use ChunkedDataStreamUploader.\n    std::unique_ptr\u003cChunkedDataStreamUploader\u003e uploader(\n        new ChunkedDataStreamUploader(this));\n    chunked_uploader_ \u003d uploader-\u003eGetWeakPtr();\n    net_request_-\u003eset_upload(std::move(uploader));",
      "range": {
        "startLine": 743,
        "startChar": 6,
        "endLine": 743,
        "endChar": 10
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "352c496a_7cad8725",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 743,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "99c30c38_921fc3be",
      "range": {
        "startLine": 743,
        "startChar": 6,
        "endLine": 743,
        "endChar": 10
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc320fc3_a0c0452e",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 745,
      "author": {
        "id": 1143554
      },
      "writtenOn": "2018-01-31T23:25:34Z",
      "side": 1,
      "message": "Use std::make_unique",
      "range": {
        "startLine": 744,
        "startChar": 0,
        "endLine": 745,
        "endChar": 47
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f31c00f_5221ed1b",
        "filename": "ios/net/crn_http_protocol_handler.mm",
        "patchSetId": 8
      },
      "lineNbr": 745,
      "author": {
        "id": 1255203
      },
      "writtenOn": "2018-02-01T07:02:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fc320fc3_a0c0452e",
      "range": {
        "startLine": 744,
        "startChar": 0,
        "endLine": 745,
        "endChar": 47
      },
      "revId": "e0b3996f67b9c67baf1d8a9fd39127ced4f6580e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}