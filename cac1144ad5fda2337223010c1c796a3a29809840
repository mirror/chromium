{
  "comments": [
    {
      "key": {
        "uuid": "4b7c4b0c_af1c6b60",
        "filename": "components/omnibox/browser/shortcuts_backend.cc",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2017-06-29T20:16:46Z",
      "side": 1,
      "message": "If we use SKIP_ON_SHUTDOWN here, will we still properly close and clean up the DB during shutdown?",
      "revId": "cac1144ad5fda2337223010c1c796a3a29809840",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96023ff6_ad486b44",
        "filename": "components/omnibox/browser/shortcuts_backend.cc",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1000805
      },
      "writtenOn": "2017-06-30T09:11:58Z",
      "side": 1,
      "message": "Not sure.  It looks like we use the db_runner_ to do the final release on the database object.  The database object has no code in its destructor, but does have various by-value members like a sql::Connection and a sql::MetaTable.  If this is SKIP_ON_SHUTDOWN, does that mean these objects could possibly never be freed?  Does that in turn mean we could have database corruption?\n\nSurely this question has come up before when converting file/database writes to the task scheduler.  Adding robliao@ as one of the relevant task_scheduler OWNERS to give pointers.",
      "parentUuid": "4b7c4b0c_af1c6b60",
      "revId": "cac1144ad5fda2337223010c1c796a3a29809840",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f8cbac8_6a05be09",
        "filename": "components/omnibox/browser/shortcuts_backend.cc",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-06-30T16:43:31Z",
      "side": 1,
      "message": "The DB thread today has traits of \n{base::MayBlock(), base::WithBaseSyncPrimitives(), base::TaskPriority::USER_VISIBLE, base::TaskShutdownBehavior::BLOCK_SHUTDOWN}.\n\nThe task scheduler does not guarantee that all in-flight tasks will be cleaned up at shutdown, so if it is critical that destructors run prior to that point, this should be BLOCK_SHUTDOWN.\n\nSKIP_ON_SHUTDOWN only blocks shutdown if the task has started execution.\n\nTaking a quick look at sql::Connection, it looks like it indeed closes the database as part of its destructor, but the main impact is that any pending transaction is effectively rolled back. If the underlying DB is transactional, I would expect this to behave fine (as it needs to be robust to crashes in either case).\n\nMy first inclination is that SKIP_ON_SHUTDOWN is likely fine since the DB\u0027s need to be robust on crash or sudden termination. (We do use transactions, right?)",
      "parentUuid": "96023ff6_ad486b44",
      "revId": "cac1144ad5fda2337223010c1c796a3a29809840",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd4da000_c3ae1148",
        "filename": "components/omnibox/browser/shortcuts_backend.cc",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1000805
      },
      "writtenOn": "2017-06-30T19:22:30Z",
      "side": 1,
      "message": "We should be using transactions anywhere we\u0027re doing multiple writes as part of a single update.  If we don\u0027t, as you mention, that\u0027s already a bug.\n\nIf the shutdown behavior of the task scheduler is that SKIP_ON_SHUTDOWN will throw away unstarted tasks but allow already-started ones to block shutdown (rather than just nuking the thread they\u0027re on mid-task), then we may be OK.  My biggest worry is things like stale locks.  As you note, if we can have these after a crash we already have a problem, but I\u0027d rather not escalate that to an \"every time Chrome exits\" problem, and the right fix for it would be somewhere other than the layer I\u0027m changing.\n\nIt looks from reading ~Connection() and the chain of calls it makes like we\u0027re OK here.  I\u0027m going to proceed.",
      "parentUuid": "3f8cbac8_6a05be09",
      "revId": "cac1144ad5fda2337223010c1c796a3a29809840",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}