{
  "comments": [
    {
      "key": {
        "uuid": "7d1f468d_428e6609",
        "filename": "third_party/zlib/0003-arm-inffast.patch",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-09-21T00:56:18Z",
      "side": 1,
      "message": "s/Rosie/Hosie/",
      "revId": "0397489124ce7e6aced020f8b85f5034c7d5f49b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3779fc23_7a9cb562",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 4
      },
      "lineNbr": 230,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-09-17T23:06:37Z",
      "side": 1,
      "message": "I don\u0027t know if it\u0027s the cause of the Cronet bug, but I\u0027m working on a similar optimization, just not ARM specific. I found a bug in my code recently, and there might be a similar one in yours.\n\nThis code gets called from the inflate_fast function. Starting from the zlib-the-library\u0027s public API, there are two paths to get to inflate_fast. One is via the inflate function, in inflate.c. Two is via the inflateBack function, in infback.c. The former is used for \u0027wrapped\u0027 wire formats like gzip and zlib-the-format (RFCs 1950 and 1952). The latter is used for \u0027raw\u0027 flate (RFC 1951). Zlib-the-library users like libpng and HTTP stacks usually go through the former. Zip libraries usually go through the latter. Chromium might only care about (and unit test for) PNG, HTTP, etc. but if you want to push your patch upstream, you will need to care about ZIP too.\n\nFor inflate.c, the library malloc\u0027s the history buffer, so it is clearly separate from the (user supplied) output buffer. However, infback.c takes a buffer (a pointer and a length) as API arguments, and the history buffer *is* the output buffer (a ring buffer). There are two implications.\n\nFirst, I\u0027m not sure if you can use Z_RESTRICT here.\n\nSecond, sometimes you are copying e.g. 16 bytes even when the length-distance pair gives a shorter length. This overwrite is generally fine if the output and history buffers are separate, but if they are the same, the overwrite can affect history and hence lead to incorrect output if the distance is sufficiently large.\n\nTo repeat, I haven\u0027t studied this chunkcopy.h that closely, so I\u0027m not confident that I\u0027ve diagnosed a problem here, but I did find that problem in my similar code, so perhaps this comment helps give at least something to think about while we\u0027re waiting for a solid repro.",
      "revId": "0397489124ce7e6aced020f8b85f5034c7d5f49b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea966ac6_8bed4894",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 4
      },
      "lineNbr": 230,
      "author": {
        "id": 1240200
      },
      "writtenOn": "2017-09-19T20:31:56Z",
      "side": 1,
      "message": "My first thought is that PDF may be another thing to consider; though git grep doesn\u0027t show that.  Similarly, git grep doesn\u0027t show any reference to inflateBack within chromium source, so I guess that can\u0027t be the source of the Cronet bug?\n\nIndeed this implementation does look vulnerable to such a bug when used in infback.c, and to another bug as well: in inflate.c the window allocation is extended by a few bytes so that unaligned reads have the freedom to spill off the end of the window without extra tests to avoid that illegal read.  Since a pre-allocated window is provided to infback.c, and the size is not based on a query from the library, there\u0027s no way to allocate that same wiggle room, so calls from infback.c may result in illegal reads.\n\nAs it stands this implementation only risks window damage within N (16?) bytes of the _start_ of a copy.  If the copy is longer than N then exactly the correct number of bytes is overwritten.  Depending on the order of loads and stores this might still result in a corrupt copy, but that can be mitigated by deferring the first store until after the second store (or simply the end of the loop).  But I have no mitigation for the short copy case.\n\nUnfortunately most copies are short (try https://github.com/madler/infgen to analyse specific files), which means that the single-iteration wide load/store is the case that most benefits from optimisation.  To reduce it to a more careful loop is a big compromise.\n\n\nI think the simplest solution is two separate inflate_fast implementations for the different cases, accommodating infback.c usage demands too much compromise.",
      "parentUuid": "3779fc23_7a9cb562",
      "revId": "0397489124ce7e6aced020f8b85f5034c7d5f49b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67742fcb_9faf0568",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 4
      },
      "lineNbr": 230,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-09-21T00:56:18Z",
      "side": 1,
      "message": "\u003e Similarly, git grep doesn\u0027t show any reference to inflateBack within chromium source, so I guess that can\u0027t be the source of the Cronet bug?\n\nYeah, it might not be the source of the Cronet bug (I don\u0027t have any additional insight into that bug), but it (using restrict here, and allowing inflateBack to call contrib\u0027s version of inflate_fast) still looks like a bug to me as is.\n\nIf using restrict (and related assumptions about the history and output buffer being unaliased) is necessary for the performance gain, is it possible to Assert that the pointers are actually restrict\u0027ed? I\u0027m not sure if that\u0027s even possible if the restrict\u0027ion allows the compiler to optimize the assertion to be a no-op.\n\n\n\u003e in inflate.c the window allocation is extended by a few bytes\n\nOh, that change wasn\u0027t obvious to me when reading this CL, but when it gets un-rolled-back, I think it needs calling out (in addition to whatever bug fixes build on this CL as is). The CL description, directly and in the .patch file, doesn\u0027t mention it.\n\nThere are two flavors of inflate.c: the top level file and the one in contrib. The latter is a copy/paste of the former, plus a few lines of edits, but it\u0027s not easy to see the diff between the two, even when looking in 0003-arm-inffast.patch.\n\nIn my crrev.com/c/601694, I added a link to https://chromium-review.googlesource.com/c/chromium/src/+/601694/14/third_party/zlib/contrib/inffast64/README.txt that pointed to such a diff. There are other ways to structure it.\n\nBack to this CL. For example, on closer inspection, the contrib version of inflate.c has added a new INFLATE_CLEAR_UNUSED_UNDEFINED macro, to quieten some analysis tools over this extra allocation, but that\u0027s really not obvious from the +1571 \"added\" lines of code in https://chromium-review.googlesource.com/c/chromium/src/+/641575/4/third_party/zlib/contrib/arm/inflate.c\n\nOn eyeballing the new INFLATE_CLEAR_UNUSED_UNDEFINED-guarded code, it looks fine, and that macro defaults to undefined, but again, it\u0027s new code that\u0027s hard to notice, and it was probably worth calling out to reviewers, especially as anything malloc and memset related can be dangerous.\n\nSeparate, but related: inffast.c (both the top level and contrib flavors, and note that it\u0027s inffast.c, not inflate.c) also has a comment about inflate_fast\u0027s preconditions (\"Entry assumptions\"). It\u0027d be nice if the contrib version also mentioned this additional precondition (that the window allocation is extended by at least CHUNKCOPY_CHUNK_SIZE bytes of slack). Again, even better if it\u0027s obvious for reviewers what preconditions in the contrib version are additional to the top level vanilla version.\n\n\n\u003e Unfortunately most copies are short... which means that the single-iteration wide load/store is the case that most benefits from optimisation.  To reduce it to a more careful loop is a big compromise.\n\nIt is admittedly a big compromise. One argument for compromise, though, is that zlib is old enough and well-used enough that Hyrum\u0027s law (http://www.hyrumslaw.com/) possibly applies. Something to think about, perhaps, while we wait for more information on the Cronet bug...",
      "parentUuid": "ea966ac6_8bed4894",
      "revId": "0397489124ce7e6aced020f8b85f5034c7d5f49b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}