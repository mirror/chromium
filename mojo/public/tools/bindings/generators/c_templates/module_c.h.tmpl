// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
{%- if variant -%}
{%-   set variant_path = "%s-%s"|format(module.path, variant) -%}
{%- else -%}
{%-   set variant_path = module.path -%}
{%- endif -%}

{%- set header_guard = "%s_H_"|format(
        variant_path|upper|replace("/","_")|replace(".","_")|
            replace("-", "_")) %}

#ifndef {{header_guard}}
#define {{header_guard}}

#ifdef __cplusplus
extern "C" {
#endif


#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

///////////////////////////// MEF TEST
{# %- import "interface_macros.tmpl" as interface_macros #}


{%- macro declare_c_params(prefix, parameters) %}
{%-   for param in parameters -%}
{{param.kind|c_wrapper_type}} {{prefix}}{{param.name}}
{%- if not loop.last %}, {% endif %}
{%-   endfor %}
{%- endmacro %}

typedef const char* CharString;

// Interfaces
{%  for interface in interfaces %}
typedef struct {{interface.name}} {{interface.name}};
typedef struct {{interface.name}}* {{interface.name}}Ptr;
{%- endfor %}

// Structs
{%- for struct in structs %}
typedef struct {{struct.name}} {{struct.name}};
typedef struct {{struct.name}}* {{struct.name}}Ptr;
{%- endfor %}

// Enums
{%-   for enum in all_enums %}
{%-   set enum_name = enum|get_name_for_kind(flatten_nested_kind=False) %}

typedef enum {{enum_name}} {
{%-   for field in enum.fields %}
{%-     if field.value %}
  {{field.name}} = {{field.value|expression_to_text}},
{%-     else %}
  {{field.name}},
{%-     endif %}
{%-   endfor %}
} {{enum_name}};
{%-   endfor %}

{#--- Interface Stubs -#}
{%  for interface in interfaces %}

// {{interface.name}} methods.
{%- for method in interface.methods %}
{%-  if method.response_parameters and method.sync %}
{%-   for param in method.response_parameters %}
{%-  if param.kind|is_array_kind %}
void* /* {{param.kind|c_wrapper_type}} */
{%-  else %}
{{param.kind|c_wrapper_type}}
{%- endif %}
{%-   endfor -%}
{%-  else %}
void
{%- endif %}
 {{interface.name}}_{{method.name}}({{interface.name}}Ptr self
{%-   if method.parameters %}, {{declare_c_params("", method.parameters)}}
{%-   endif %});
{%- endfor %}
{%- endfor %}

{%- for struct in structs %}

// {{struct.name}} setters.
{%- for packed_field in struct.packed.packed_fields_in_ordinal_order %}
{%-  set kind = packed_field.field.kind %}
{%-  if kind|is_array_kind %}
void {{struct.name}}_add_{{packed_field.field.name}}({{struct.name}}Ptr self, {{kind.kind|c_wrapper_type}} {{packed_field.field.name}});
{%-  elif kind|is_map_kind %}
void {{struct.name}}_add_{{packed_field.field.name}}({{struct.name}}Ptr self, {{kind.key_kind|c_wrapper_type}} key, {{kind.value_kind|c_wrapper_type}} value);
{%-  else %}
void {{struct.name}}_set_{{packed_field.field.name}}({{struct.name}}Ptr self, {{packed_field.field.kind|c_wrapper_type}} {{packed_field.field.name}});
{%- endif %}

{%- endfor %}
// {{struct.name}} getters.
{%- for packed_field in struct.packed.packed_fields_in_ordinal_order %}
{%-  set kind = packed_field.field.kind %}
{%-  if kind|is_array_kind %}
{{kind.kind|c_wrapper_type}} {{struct.name}}_get_{{packed_field.field.name}}_atIndex({{struct.name}}Ptr self, int32_t index);
{%-  elif kind|is_map_kind %}
{{kind.value_kind|c_wrapper_type}} {{struct.name}}_get_{{packed_field.field.name}}_atKey({{struct.name}}Ptr self, {{kind.key_kind|c_wrapper_type}} key);
{%-  else %}
{{packed_field.field.kind|c_wrapper_type}} {{struct.name}}_get_{{packed_field.field.name}}({{struct.name}}Ptr self);
{%- endif %}
{%- endfor %}
{%- endfor %}

#ifdef __cplusplus
}
#endif

#endif  // {{header_guard}}
