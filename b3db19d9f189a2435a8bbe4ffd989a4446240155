{
  "comments": [
    {
      "key": {
        "uuid": "ef47ff77_43275164",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/webrtc/RTCPeerConnection-setRemoteDescription-tracks.https-expected.txt",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-01-31T12:16:14Z",
      "side": 1,
      "message": "removeTrack() twice is still \"safe\" (does not crash), but the second removeTrack() does not work because the sender has already been removed. Previously it was a NO-OP instead of throwing this exception because of an edge-case bug I happened to fix in this CL (which probably does not affect anything except this error message).\n\nThe error message is misleading, the sender was created by this PC it just is not found anymore. I don\u0027t want to add to the error message \"or has already been removed\" because that changes already shipped error messages to accommodate for an special case. When we are spec-compliant senders will never be removed and this error message will be correct.\n\nI can add \"if sender.pc \u003d\u003d this\" logic to distinguish between the two cases before landing this CL though.",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82003c9c_da690f67",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-AddRemoveTrack.html",
        "patchSetId": 3
      },
      "lineNbr": 123,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-01-31T12:16:14Z",
      "side": 1,
      "message": "FYI: This is an observable difference between having a separate local_streams_ and implementing legacy on top of non-legacy. This is a very obscure edge case that only shows up if you mix legacy and non-legacy APIs and trying to add it both with and without the stream. This is not worthy of an intent or even discuss-webrtc announcement.",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "881abf89_069135bf",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-legacy-stream-APIs-expected.txt",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-01-31T12:16:14Z",
      "side": 1,
      "message": "FYI: This will be fixed by the follow-up CL implementing addStream/removeStream on top of addTrack/removeTrack.",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da084254_0c8bd5a7",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-legacy-stream-APIs-expected.txt",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-01-31T12:16:14Z",
      "side": 1,
      "message": "FYI: This would have failed before this CL too. It will pass once we get rid of local_streams_ in a follow-up CL. https://crbug.com/806875",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4665352e_e84d54f2",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-legacy-stream-APIs-expected.txt",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-01-31T12:16:14Z",
      "side": 1,
      "message": "FYI: This is what the result looks like when running on master with only the test added:\n\nThis is a testharness.js-based test.\nPASS addStream() adds to local streams and senders.\nFAIL addTrack() adds to local streams and senders. assert_array_equals: lengths differ, expected 1 got 0\nPASS addTrack() fails after addStream().\nPASS addStream() after addTrack() adds the remaining track.\nPASS Adding a track to an addStream()-stream adds it to the PC.\nPASS Removing a track from an addStream()-stream removes it from the PC.\nPASS The PC stops observing the stream after removeStream().\nPASS removeStream() after addStream() removes from local streams and senders.\nFAIL removeStream() after addTrack() removes from local streams and senders. assert_array_equals: lengths differ, expected 1 got 0\nPASS removeStream() after removeTrack() removes remaining tracks.\nFAIL removeTrack() after addStream() removes from local streams and senders. assert_array_equals: lengths differ, expected 0 got 1\nFAIL removeTrack() after addTrack() removes from local streams and senders. assert_array_equals: lengths differ, expected 1 got 0\nPASS createDTMFSender() with addStream()-track.\nFAIL createDTMFSender() with addTrack()-track. promise_test: Unhandled rejection with value: object \"SyntaxError: Failed to execute \u0027createDTMFSender\u0027 on \u0027RTCPeerConnection\u0027: No local stream is available for the track provided.\"\nHarness: the test ran to completion.\n\nThe difference is that adding or removing tracks with streams using addTrack/removeTrack updates the set of local streams. Prior to this CL getLocalStreams() was only affected by addStream/removeStream. This is worthy of a PSA in discuss-webrtc.",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3ad4e878_c01afbf7",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-legacy-stream-APIs.html",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 1002823
      },
      "writtenOn": "2018-01-31T20:00:51Z",
      "side": 1,
      "message": "this looks odd. addTrack is called synchronously everywhere else.",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8bca6d9_a23b750a",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-legacy-stream-APIs.html",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-02-01T10:59:39Z",
      "side": 1,
      "message": "Oops, done.",
      "parentUuid": "3ad4e878_c01afbf7",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c51e09a6_676d4071",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-legacy-stream-APIs.html",
        "patchSetId": 3
      },
      "lineNbr": 105,
      "author": {
        "id": 1002823
      },
      "writtenOn": "2018-01-31T20:00:51Z",
      "side": 1,
      "message": "grammar issue with this error message",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "76c0ac2b_f6a8363d",
        "filename": "third_party/WebKit/LayoutTests/fast/peerconnection/RTCPeerConnection-legacy-stream-APIs.html",
        "patchSetId": 3
      },
      "lineNbr": 105,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-02-01T10:59:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c51e09a6_676d4071",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "257cd0bb_dcef398f",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1425,
      "author": {
        "id": 1002823
      },
      "writtenOn": "2018-01-31T20:00:51Z",
      "side": 1,
      "message": "This looks strange. The only time the last section will be executed more than once is when there are multiple senders in web_rtp_senders with the same id. Can this ever happen?\nThis also looks through rtp_senders_ once per element in web_rtp_senders - which makes the algorithm quadratic in number of senders. Doesn\u0027t really matter, given the likely number of senders, but it looks ugly.",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69fcb07d_6d45a711",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1425,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-02-01T10:59:39Z",
      "side": 1,
      "message": "rtp_senders_ is a map, so find() is O(1). This is O(web_rtp_senders.size()).\n\nAnd if you add a stream with two tracks, (up to) two senders will be created - we have to loop through all lower layer senders to find out which ones don\u0027t have a corresponding blink sender.",
      "parentUuid": "257cd0bb_dcef398f",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8caf4845_9aa720f7",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1430,
      "author": {
        "id": 1002823
      },
      "writtenOn": "2018-01-31T20:00:51Z",
      "side": 1,
      "message": "What happens here if a sender has been created using AddTransceiver?",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b46531e_5144932a",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1430,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-02-01T10:59:39Z",
      "side": 1,
      "message": "All APIs are responsible for keeping the rtp_senders_ up-to-date, including addTransceiver. The only time the rtp_senders_ is not up-to-date is between lower layer AddStream() and friends and calling this method. When this method is used properly, any senders created must belong to the stream, so the DCHECK is appropriate.\n\nAdded DCHECK(stream-\u003egetTracks().Contains(track)) too.\n\nThis will go away in the follow-up CL that use AddTrack which returns the new sender.",
      "parentUuid": "8caf4845_9aa720f7",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f4df0e8_2e2621e2",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1430,
      "author": {
        "id": 1002823
      },
      "writtenOn": "2018-02-01T11:56:44Z",
      "side": 1,
      "message": "My worry is AddTrack(), because it will create a sender, but the sender will *not* have a track. So track (if \"no track\" is represented by null) will be null, and the DCHECK will fail.\nThe same applies to the situation after sender.replaceTrack(null).",
      "parentUuid": "8b46531e_5144932a",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "38b0a0e4_9c5456f1",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1445,
      "author": {
        "id": 1002823
      },
      "writtenOn": "2018-01-31T20:00:51Z",
      "side": 1,
      "message": "This is another square-runtime algorithm. It looks ugly. Improve?",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fdefa52_0efa08bc",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1445,
      "author": {
        "id": 1126249
      },
      "writtenOn": "2018-02-01T10:59:39Z",
      "side": 1,
      "message": "The expected number of senders are so small that the square-runtime would most likely be faster, but I improved this by using std::sets just in case and for readability. I don\u0027t dare to remove-while-iterating because I see no way of getting an iterator valid-after-removal when using HeapHashMap and erase, so I still use a temporary set of unused sender IDs. Comment added.\n\nIn any case, this will be removed in the follow-up CL.",
      "parentUuid": "38b0a0e4_9c5456f1",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e8f0a000_90923d68",
        "filename": "third_party/WebKit/Source/modules/peerconnection/RTCPeerConnection.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1445,
      "author": {
        "id": 1002823
      },
      "writtenOn": "2018-02-01T11:56:44Z",
      "side": 1,
      "message": "Thanks, I found this code easier to read!",
      "parentUuid": "4fdefa52_0efa08bc",
      "revId": "b3db19d9f189a2435a8bbe4ffd989a4446240155",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}