{
  "comments": [
    {
      "key": {
        "uuid": "71732cb1_9c2fa707",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 17,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Identifiers beginning with __ are reserved to the implementation. I\u0027d make this into a function with an ordinary name, or perhaps better, factor the bodies of SetMemoryRead{Write,Only} into a helper function and inline it into that.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "392806a8_a623e0f7",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 21,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Do these need to be weak? In the other file you declare a section named protected_memory with length 0. So I think the section (and these symbols) should always exist.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e52c5cf_fd9d65b6",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Could be simpler to do:\n\nstatic Lock lock;\nreturn \u0026lock;",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6fe5360_32e75fe5",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T17:11:10Z",
      "side": 1,
      "message": "It\u0027s not allowed because it would register an exit time destructor.",
      "parentUuid": "1e52c5cf_fd9d65b6",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1a57235_de22f736",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "If you make the protected memory system different from the CFI system, you hopefully don\u0027t even need this flag.\n\n\nPrevious version of the comment for reference:\n\nCan you flip this to ..._ENABLED? Having #ifndef ...DISABLED starts to get impossible to read.\n\nFor the rest of the name, I feel like this is a CFI feature rather than a protected memory feature, so should be named accordingly.\n\nIf the definition of this is platform-specific, I would prefer this to use the BUILDFLAG system to define this flag in a header. The syntax around that makes it more difficult to screw up (it will error-out on typos). Base already defines a \"debugging_flags\" header, maybe we should add a general \"base_features\" one.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f99ae44_623e238c",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "Might it be better to call this \"AssertMemoryReadOnly\". Then you can have the DCHECK internal to it and not have to worry about people accidentally calling it from non-debug code.\n\nIf you\u0027re worried about call overhead, we can wrap it in a DCHECK_IS_ON block and define the non-on-dcheck arm to an empty inline function.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2548137_3297c4f8",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 57,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Do you mean \"always set back to read-only\"?",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ab1d883_2fa476ca",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 57,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T17:11:10Z",
      "side": 1,
      "message": "No, I meant to describe the situation where an attacker has (1) arbitrary RW and (2) can invoke some code that causes protected memory to be set RW and then RO. If \u0027writers\u0027 is stored in writable memory, then the attacker could set writers to some value like 100, then invoke the code that sets protected memory RW and RO and afterwards the protected memory section won\u0027t be set back RO. This would defeat protected memory (at least for the pages holding variables that the attacker can toggle RO/RW.)\n\nI\u0027ll make the description clearer to explain why writers needs to also be stored in the protected memory section.",
      "parentUuid": "b2548137_3297c4f8",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "705a8e64_f0cc9623",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 57,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-13T18:28:09Z",
      "side": 1,
      "message": "Thanks, I see what you are saying. My comment resulted from misunderstanding your parenthetical to pertain to the verb \"placed\" rather than \"overwritten\", so perhaps that could be less ambiguous.",
      "parentUuid": "5ab1d883_2fa476ca",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a4573d6_9d08f20d",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Identifiers beginning with __ are reserved to the implementation. I\u0027d move this into a namespace named \"internal\".\n\nAlso, I wonder what you think about changing the API so that instead of using macro wrappers, we make ProtectedCall part of the API, and use a dynamic check to make sure that the function pointer is protected. Something like:\n\nauto ProtectedCall(const Func \u0026f, Args\u0026\u0026... args) {\n  CHECK(\u0026f \u003e\u003d ProtectedMemoryStart() \u0026\u0026 \u0026f \u003c\u003d ProtectedMemoryEnd());\n  return f(std::forward\u003cArgs\u003e(args)...);\n}",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a5cf048_a2d013b2",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "A number of things like this function use two underscores at the beginning. Is this some built-in Clang-CFI thing? If it is, can you explain this explicitly in a comment for each one? If not, we shouldn\u0027t be using the compiler-reserved prefix on our symbols.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99e70479_b0373d74",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T17:11:10Z",
      "side": 1,
      "message": "Peter: So the problem is this won\u0027t work well with the follow-up ProtectedArray implementation. ProtectedArray stores a pointer to an array in the protected memory section, the array itself can\u0027t be stored there to avoid static initializers/initializers running on RO mem. There could be a separate implementation for ProtectedArray(Member|Fn)Call that does use macros while this one doesn\u0027t, but that seems less consistent. What do you think the best approach here is?",
      "parentUuid": "4a4573d6_9d08f20d",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f03b52b_148f2f5d",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-13T18:28:09Z",
      "side": 1,
      "message": "I see. After thinking about it for a while, I came up with this approach:\n\n1) define a ProtectedPtr template class, which would be a sort of smart pointer with an operator() that allows you to call the ProtectedPtr if it contains a function pointer. This operator() would replace the Protected*Call functions. Indexing into a ProtectedArray would return a ProtectedPtr, and ProtectedMemory would be implicitly convertible to ProtectedPtr.\n2) define a macro ProtectedMember that takes a ProtectedPtr to a struct and returns a ProtectedPtr to a given member of that struct. The macro definition would look like this:\n\n#define ProtectedMember(obj, mem) ProtectedPtr::internal_from_ptr(ProtectedPtr::internal_to_ptr(obj)-\u003emem)\n\nThis way, you only need one macro, and calls would look relatively natural. WDYT?",
      "parentUuid": "99e70479_b0373d74",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5969fb01_9a355eea",
        "filename": "build/config/sanitizers/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 361,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "This should use the BUILDFLAG system rather than setting defines (unless this is built in to the compiler). See //build/buildflag_header.gni",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "279ce987_1656e264",
        "filename": "build/config/sanitizers/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 384,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "Same here.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}