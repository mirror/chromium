{
  "comments": [
    {
      "key": {
        "uuid": "71732cb1_9c2fa707",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 17,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Identifiers beginning with __ are reserved to the implementation. I\u0027d make this into a function with an ordinary name, or perhaps better, factor the bodies of SetMemoryRead{Write,Only} into a helper function and inline it into that.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bd4a03f_399ccbd9",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 17,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "71732cb1_9c2fa707",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "392806a8_a623e0f7",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 21,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Do these need to be weak? In the other file you declare a section named protected_memory with length 0. So I think the section (and these symbols) should always exist.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4aa7f779_d2b29fd5",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 21,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "392806a8_a623e0f7",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1e52c5cf_fd9d65b6",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Could be simpler to do:\n\nstatic Lock lock;\nreturn \u0026lock;",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6fe5360_32e75fe5",
        "filename": "base/memory/protected_memory.cc",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T17:11:10Z",
      "side": 1,
      "message": "It\u0027s not allowed because it would register an exit time destructor.",
      "parentUuid": "1e52c5cf_fd9d65b6",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1a57235_de22f736",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "If you make the protected memory system different from the CFI system, you hopefully don\u0027t even need this flag.\n\n\nPrevious version of the comment for reference:\n\nCan you flip this to ..._ENABLED? Having #ifndef ...DISABLED starts to get impossible to read.\n\nFor the rest of the name, I feel like this is a CFI feature rather than a protected memory feature, so should be named accordingly.\n\nIf the definition of this is platform-specific, I would prefer this to use the BUILDFLAG system to define this flag in a header. The syntax around that makes it more difficult to screw up (it will error-out on typos). Base already defines a \"debugging_flags\" header, maybe we should add a general \"base_features\" one.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45369c0e_d2133cc8",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 32,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "The two are still intertwined such that I want to check that ProtectedMemory is implemented if cfi-icall is enabled, but I have moved the error to the CFI-specific code.",
      "parentUuid": "d1a57235_de22f736",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f99ae44_623e238c",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "Might it be better to call this \"AssertMemoryReadOnly\". Then you can have the DCHECK internal to it and not have to worry about people accidentally calling it from non-debug code.\n\nIf you\u0027re worried about call overhead, we can wrap it in a DCHECK_IS_ON block and define the non-on-dcheck arm to an empty inline function.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "093c39cf_71ad89d8",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5f99ae44_623e238c",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b2548137_3297c4f8",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 57,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Do you mean \"always set back to read-only\"?",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ab1d883_2fa476ca",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 57,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T17:11:10Z",
      "side": 1,
      "message": "No, I meant to describe the situation where an attacker has (1) arbitrary RW and (2) can invoke some code that causes protected memory to be set RW and then RO. If \u0027writers\u0027 is stored in writable memory, then the attacker could set writers to some value like 100, then invoke the code that sets protected memory RW and RO and afterwards the protected memory section won\u0027t be set back RO. This would defeat protected memory (at least for the pages holding variables that the attacker can toggle RO/RW.)\n\nI\u0027ll make the description clearer to explain why writers needs to also be stored in the protected memory section.",
      "parentUuid": "b2548137_3297c4f8",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "705a8e64_f0cc9623",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 57,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-13T18:28:09Z",
      "side": 1,
      "message": "Thanks, I see what you are saying. My comment resulted from misunderstanding your parenthetical to pertain to the verb \"placed\" rather than \"overwritten\", so perhaps that could be less ambiguous.",
      "parentUuid": "5ab1d883_2fa476ca",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9183d8a_eb32b374",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 57,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "705a8e64_f0cc9623",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4a4573d6_9d08f20d",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-09T23:44:57Z",
      "side": 1,
      "message": "Identifiers beginning with __ are reserved to the implementation. I\u0027d move this into a namespace named \"internal\".\n\nAlso, I wonder what you think about changing the API so that instead of using macro wrappers, we make ProtectedCall part of the API, and use a dynamic check to make sure that the function pointer is protected. Something like:\n\nauto ProtectedCall(const Func \u0026f, Args\u0026\u0026... args) {\n  CHECK(\u0026f \u003e\u003d ProtectedMemoryStart() \u0026\u0026 \u0026f \u003c\u003d ProtectedMemoryEnd());\n  return f(std::forward\u003cArgs\u003e(args)...);\n}",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a5cf048_a2d013b2",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "A number of things like this function use two underscores at the beginning. Is this some built-in Clang-CFI thing? If it is, can you explain this explicitly in a comment for each one? If not, we shouldn\u0027t be using the compiler-reserved prefix on our symbols.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99e70479_b0373d74",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T17:11:10Z",
      "side": 1,
      "message": "Peter: So the problem is this won\u0027t work well with the follow-up ProtectedArray implementation. ProtectedArray stores a pointer to an array in the protected memory section, the array itself can\u0027t be stored there to avoid static initializers/initializers running on RO mem. There could be a separate implementation for ProtectedArray(Member|Fn)Call that does use macros while this one doesn\u0027t, but that seems less consistent. What do you think the best approach here is?",
      "parentUuid": "4a4573d6_9d08f20d",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f03b52b_148f2f5d",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-13T18:28:09Z",
      "side": 1,
      "message": "I see. After thinking about it for a while, I came up with this approach:\n\n1) define a ProtectedPtr template class, which would be a sort of smart pointer with an operator() that allows you to call the ProtectedPtr if it contains a function pointer. This operator() would replace the Protected*Call functions. Indexing into a ProtectedArray would return a ProtectedPtr, and ProtectedMemory would be implicitly convertible to ProtectedPtr.\n2) define a macro ProtectedMember that takes a ProtectedPtr to a struct and returns a ProtectedPtr to a given member of that struct. The macro definition would look like this:\n\n#define ProtectedMember(obj, mem) ProtectedPtr::internal_from_ptr(ProtectedPtr::internal_to_ptr(obj)-\u003emem)\n\nThis way, you only need one macro, and calls would look relatively natural. WDYT?",
      "parentUuid": "99e70479_b0373d74",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3a697ca_b00d9825",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T19:46:10Z",
      "side": 1,
      "message": "If we implement it this way we would allow users to store ProtectedPtrs in long-lived structures. Since the pointers are stored in mutable memory an attacker could overwrite them. For the ProtectedMemory case we could CHECK() that the pointer to the fn ptr resides in ProtectedMemory. However, for ProtectedArray we would also need to store a array_pointer that points to the array and CHECK() that array_pointer is in ProtectedMemory and that ptr_to_fn_ptr is in the array_pointer bounds. The problem is by adding this additional level of indirection any pointer in protected memory could potentially be used to craft \u0027fake\u0027 Arrays with attacker-controlled entries.\n\nIf the issue is having function calls look natural, we could do what you\u0027re saying but have the macros construct a ProtectedPtr object only used for that single function call. In that case, we still have several macros, but the calls look natural. This also has the benefit of ProtectedPtr being a CFI-specific wrapper separate from ProtectedMemory/ProtectedArray implementations.",
      "parentUuid": "9f03b52b_148f2f5d",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc140543_fb3526ff",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-13T20:05:46Z",
      "side": 1,
      "message": "\u003e If we implement it this way we would allow users to store ProtectedPtrs in long-lived structures. Since the pointers are stored in mutable memory an attacker could overwrite them.\n\nYeah, that\u0027s one downside. I suppose that one solution would be to move ProtectedPtr into an internal namespace. Then it would be an error for code to mention ProtectedPtr outside of the macro and the Protected{Memory,Array} implementation, effectively preventing you from storing it. (You could get around that with tricks like creative use of auto, but we probably don\u0027t need to be 100% perfect here.)\n\n\u003e If the issue is having function calls look natural, we could do what you\u0027re saying but have the macros construct a ProtectedPtr object only used for that single function call. In that case, we still have several macros, but the calls look natural.\n\nCan you give an example of what you mean?",
      "parentUuid": "c3a697ca_b00d9825",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "266ba31a_d3c65be2",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-13T21:35:08Z",
      "side": 1,
      "message": "I was thinking something like\n\n #define ProtectedMemoryMemberCall(mem, member) \\\n            /* static_assert on mem type here */   \\\n            ProtectedPtr::Create(mem-\u003emember).Call\n ProtectedMemoryMemberCall(memory, member)(...)\n\nThe invocation of Call on the newly constructed object means that callers can not accidentally assign ProtectedPtrs with auto thinking they\u0027re referencing a function pointer, like\n\n auto NotAFnPtr \u003d ProtectedMember(...); // Actually a ProtectedPtr.\n // Long attacker controlled delay\n NotAFnPtr(...)",
      "parentUuid": "dc140543_fb3526ff",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c5c2424a_d58c8e71",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1125980
      },
      "writtenOn": "2017-10-13T22:03:24Z",
      "side": 1,
      "message": "My instinct would be to say that if ProtectedMember were properly documented, that would be unlikely to happen. Having several macros means more to memorise when using the protected memory interface. But I think I\u0027d be fine with starting with something like that and seeing if the multiple macros turns out to be a problem in practice.",
      "parentUuid": "266ba31a_d3c65be2",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16d40553_8be6bcb2",
        "filename": "base/memory/protected_memory.h",
        "patchSetId": 2
      },
      "lineNbr": 140,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "I did some digging and found that I could eliminate the macros entirely by using pointer-to-member. Let me know what you think about the current iteration, it\u0027s design is slightly modified to accommodate that change.",
      "parentUuid": "c5c2424a_d58c8e71",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5969fb01_9a355eea",
        "filename": "build/config/sanitizers/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 361,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "This should use the BUILDFLAG system rather than setting defines (unless this is built in to the compiler). See //build/buildflag_header.gni",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "058d6e53_d8656813",
        "filename": "build/config/sanitizers/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 361,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5969fb01_9a355eea",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "279ce987_1656e264",
        "filename": "build/config/sanitizers/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 384,
      "author": {
        "id": 1002691
      },
      "writtenOn": "2017-10-09T23:55:39Z",
      "side": 1,
      "message": "Same here.",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c4de33b_7b96e77c",
        "filename": "build/config/sanitizers/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 384,
      "author": {
        "id": 1238767
      },
      "writtenOn": "2017-10-16T22:16:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "279ce987_1656e264",
      "revId": "c295dd6c0e008d6e9c73b9ac6d3c0e7f7d1a131e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}