{
  "comments": [
    {
      "key": {
        "uuid": "26748439_94c52672",
        "filename": "content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc",
        "patchSetId": 7
      },
      "lineNbr": 243,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T20:07:30Z",
      "side": 1,
      "message": "This looks racy. The GPUInfo in GpuDataManager is updated asynchronously after the GPU process is successfully created and has sent its initialization data - including the GPUInfo.\n\nBy the looks of it, this function is simply posted from the IO thread after the GpuJpegDecodeAccelerator interface is requested (but before it has been sucessfully created), so we don\u0027t know that we have received a valid GPUInfo. The previous code guaranteed we had it - since we only return a channel after we have received the GPUInfo.",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e9fbf0f_1ec441da",
        "filename": "content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc",
        "patchSetId": 7
      },
      "lineNbr": 243,
      "author": {
        "id": 1120018
      },
      "writtenOn": "2017-06-12T21:15:20Z",
      "side": 1,
      "message": "AFAIK, GpuJpegDecodeAccelerator gets created lazily and only when we request for a connection in ConnectToGpuJpegDecodeAcceleratorOnIOThread. Please correct me if I am wrong.\nSince, we can no longer use a channel, please suggest if there\u0027s a better way of getting a valid GPUInfo. Thank you.",
      "parentUuid": "26748439_94c52672",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e82c11f5_c32550e7",
        "filename": "content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc",
        "patchSetId": 7
      },
      "lineNbr": 243,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T21:38:37Z",
      "side": 1,
      "message": "I think you\u0027d need to add an API on GpuProcessHost (or, possibly GpuDataManager) to call you back (possibly immediately) once you have a known valid GPUInfo.",
      "parentUuid": "0e9fbf0f_1ec441da",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8040336f_824009aa",
        "filename": "content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc",
        "patchSetId": 7
      },
      "lineNbr": 243,
      "author": {
        "id": 1120018
      },
      "writtenOn": "2017-06-12T22:52:11Z",
      "side": 1,
      "message": "Can we use GpuDataManagerObserver for this purpose?\nOne question. Don\u0027t you think GPUInfo in GpuDataManager(GDM) must have been already updated by the time VideoCaptureGpuJpegDecoder(VCGJD) gets created?\nAnd lets say even if we add an API on GPH or GDM, VCGJD will not receive the callback, if GPUInfo has been updated before VCGJD was created.",
      "parentUuid": "e82c11f5_c32550e7",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "92d2b028_663f8c36",
        "filename": "content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc",
        "patchSetId": 7
      },
      "lineNbr": 243,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T23:24:56Z",
      "side": 1,
      "message": "\u003e Can we use GpuDataManagerObserver for this purpose?\n\nNot really - GpuDataManagerObserver can tell you if GPUInfo changes (e.g. if we lose the GPU process and fallback to software), but it won\u0027t tell you if we already received the initial one.\n\n\u003e One question. Don\u0027t you think GPUInfo in GpuDataManager(GDM) must have been already updated by the time VideoCaptureGpuJpegDecoder(VCGJD) gets created?\n\nIt\u0027s not clear to me what ensures that would be the case.\n\n\u003e And lets say even if we add an API on GPH or GDM, VCGJD will not receive the callback, if GPUInfo has been updated before VCGJD was created.\n\nWell, for example on GpuProcessHost, I think you would want to do something where if DidInitialize (or DidFailInitialize) has already been called (and so you know the GPUInfo is set), you would call the callback right away, otherwise you would call the callback after DidInitialize/DidFailInitialize is called.",
      "parentUuid": "8040336f_824009aa",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2d3271b_2ccba455",
        "filename": "content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc",
        "patchSetId": 7
      },
      "lineNbr": 246,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T20:07:30Z",
      "side": 1,
      "message": "nit: you\u0027re not using the BrowserGpuChannelHostFactory any more, I suggest using BrowserThread::GetTaskRunnerForThread(BrowserThread::IO) instead, which is a more accurate description of what you\u0027re doing, and therefore reducing coupling.",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6f65ab2_4b30ee10",
        "filename": "content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.h",
        "patchSetId": 7
      },
      "lineNbr": 35,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2017-06-12T19:35:09Z",
      "side": 1,
      "message": "nit: s/succeed/succeeds/",
      "range": {
        "startLine": 35,
        "startChar": 61,
        "endLine": 35,
        "endChar": 68
      },
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c32f8f28_9292c2d8",
        "filename": "media/gpu/ipc/client/gpu_jpeg_decode_accelerator_host.cc",
        "patchSetId": 7
      },
      "lineNbr": 22,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2017-06-12T19:35:09Z",
      "side": 1,
      "message": "We might need to set_connection_error_handler()\nsimilar to e.g. [1], to act upon the \"server\" side\ndisappearing from under our feet.\n\n[1] https://cs.chromium.org/chromium/src/content/browser/renderer_host/media/service_launched_video_capture_device.cc?dr\u003dCSs\u0026l\u003d15",
      "range": {
        "startLine": 22,
        "startChar": 2,
        "endLine": 22,
        "endChar": 15
      },
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63b9afbb_abc61856",
        "filename": "media/gpu/ipc/client/gpu_jpeg_decode_accelerator_host.cc",
        "patchSetId": 7
      },
      "lineNbr": 22,
      "author": {
        "id": 1120018
      },
      "writtenOn": "2017-06-12T21:15:20Z",
      "side": 1,
      "message": "Sure. This can be done. Thanks.",
      "parentUuid": "c32f8f28_9292c2d8",
      "range": {
        "startLine": 22,
        "startChar": 2,
        "endLine": 22,
        "endChar": 15
      },
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbac6cf1_167de5b5",
        "filename": "media/gpu/ipc/client/gpu_jpeg_decode_accelerator_host.cc",
        "patchSetId": 7
      },
      "lineNbr": 108,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T20:07:30Z",
      "side": 1,
      "message": "This thread hopping is very odd, and I think contrary to what the original design wanted. In the original design, the message was received on the IO thread on purpose, to avoid issues when the client thread is blocked. In this version, the message is first received on the client thread, then posted to the IO thread. Why? Is it that the concern about the client thread being gone is no longer valid (in which case why post to the IO thread at all?), or should we receive the message from the IO thread in the first place?",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ab03970_ae4f48ba",
        "filename": "media/gpu/ipc/client/gpu_jpeg_decode_accelerator_host.cc",
        "patchSetId": 7
      },
      "lineNbr": 108,
      "author": {
        "id": 1120018
      },
      "writtenOn": "2017-06-12T21:15:20Z",
      "side": 1,
      "message": "client_ here expects its callbacks to be called on IO thread. Please see https://cs.chromium.org/chromium/src/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.h?l\u003d63.\nTherefore, I had to add this change.",
      "parentUuid": "cbac6cf1_167de5b5",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9a8a819_15c46645",
        "filename": "media/gpu/ipc/client/gpu_jpeg_decode_accelerator_host.cc",
        "patchSetId": 7
      },
      "lineNbr": 108,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T21:38:37Z",
      "side": 1,
      "message": "client_ expects to be called on the IO thread *because* we wanted to avoid the client thread. If we don\u0027t want to avoid it any more for some reason, we should remove the complexity associated with having to hop threads and guaranteeing thread safety. Alternatively, and especially if the concerns about avoiding the client thread are still valid, we can bind the interface on the IO thread to avoid the IO-\u003eclient-\u003eIO hops.",
      "parentUuid": "4ab03970_ae4f48ba",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "917f5874_3362b891",
        "filename": "media/gpu/ipc/client/gpu_jpeg_decode_accelerator_host.cc",
        "patchSetId": 7
      },
      "lineNbr": 108,
      "author": {
        "id": 1120018
      },
      "writtenOn": "2017-06-12T22:52:11Z",
      "side": 1,
      "message": "Oh, I see. Sorry, I wasn\u0027t aware of the history behind this.\nIn that case, we can create GJDA interface on the IO thread itself.\nSomething like https://chromium-review.googlesource.com/c/525672/2/content/gpu/gpu_child_thread.cc",
      "parentUuid": "d9a8a819_15c46645",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "723c871a_1ae7f534",
        "filename": "media/gpu/ipc/service/gpu_jpeg_decode_accelerator.cc",
        "patchSetId": 7
      },
      "lineNbr": 154,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2017-06-12T19:35:09Z",
      "side": 1,
      "message": "Hmm instead of having to do base::ResetAndReturn() every\ntime, we {c,sh}ould define |notify_decode_status_cb_| to\nbe a base::OnceCallback [1] using a BindOnce in l.202, and \nthen use std::move(notify_decode_status_cb_).Run() which\nis the currently established idiom.\n\nThat way is more evident (and it\u0027s enforce both at runtime\nand compile time) that this is a callback meant to be run\nonce.\n\n[1] https://chromium.googlesource.com/chromium/src/+/f9a943815c55bf468a284b474a0617c5c0e2f01d/docs/callback.md",
      "range": {
        "startLine": 154,
        "startChar": 2,
        "endLine": 154,
        "endChar": 22
      },
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7bb9103f_ac764103",
        "filename": "media/gpu/ipc/service/gpu_jpeg_decode_accelerator.cc",
        "patchSetId": 7
      },
      "lineNbr": 154,
      "author": {
        "id": 1120018
      },
      "writtenOn": "2017-06-12T21:15:20Z",
      "side": 1,
      "message": "sgtm. thanks for the suggestion.",
      "parentUuid": "723c871a_1ae7f534",
      "range": {
        "startLine": 154,
        "startChar": 2,
        "endLine": 154,
        "endChar": 22
      },
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9226e702_0c2a74a4",
        "filename": "media/gpu/ipc/service/gpu_jpeg_decode_accelerator.cc",
        "patchSetId": 7
      },
      "lineNbr": 205,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T20:07:30Z",
      "side": 1,
      "message": "Again, the task posting is odd. It\u0027s definitely true that the GPU main thread can be busy for a long time, so I don\u0027t understand why you would want to hop to that thread first, and then to the IO thread.",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c297db07_b8059103",
        "filename": "media/gpu/ipc/service/gpu_jpeg_decode_accelerator.cc",
        "patchSetId": 7
      },
      "lineNbr": 205,
      "author": {
        "id": 1120018
      },
      "writtenOn": "2017-06-12T21:15:20Z",
      "side": 1,
      "message": "This too for the same reason. accelerator_ i.e. underlying platform decoder(JpegDecodeAccelerator) expects its Decode(..) call to be made on IO thread.\nPlease see https://cs.chromium.org/chromium/src/media/gpu/vaapi_jpeg_decode_accelerator.cc?l\u003d288",
      "parentUuid": "9226e702_0c2a74a4",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6bc4602d_3e921a09",
        "filename": "media/gpu/ipc/service/gpu_jpeg_decode_accelerator.cc",
        "patchSetId": 7
      },
      "lineNbr": 205,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T21:38:37Z",
      "side": 1,
      "message": "But that\u0027s the same thing. The VJDA was made to support being called on the IO thread *because* we want to avoid the main thread, which can block.",
      "parentUuid": "c297db07_b8059103",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a40c6cb_e336bc6c",
        "filename": "media/gpu/ipc/service/gpu_jpeg_decode_accelerator.cc",
        "patchSetId": 7
      },
      "lineNbr": 208,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-12T20:07:30Z",
      "side": 1,
      "message": "weak_ptr_factory_ is reset on the main thread, so it\u0027s invalid to dereference it on the IO thread (where the callback is run).",
      "revId": "42deae259e6c18900962f0c449848c15cfa3198d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}