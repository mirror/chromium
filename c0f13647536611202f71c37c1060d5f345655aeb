{
  "comments": [
    {
      "key": {
        "uuid": "df0d3b60_e5ae9512",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "Does the ordering of map items matter to the recipient of a CBOR-encoded blob, or is there a well-defined ordering specified in the CBOR RFC? (I haven\u0027t read it yet.) This historically has been a security pain-point in JSON-using applications.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b761369a_5c017977",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 50,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "The RFC seems to say that anything bigger than a uint64_t will be a BigNum. Do I have that right? If so, it might help to document here that you are adhering to the spec in that way.\n\n(This is a good thing about CBOR relative to JSON, it would seem, which lexically allows all sorts of integers and floats, but smooshes them into float64s regardless of how well that works.)",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "858104a6_a17787d0",
        "filename": "content/browser/webauth/cbor/cbor_writer.h",
        "patchSetId": 21
      },
      "lineNbr": 57,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "Perhaps it\u0027s just me, but the function signature suggests appending. To communicate that it essentially converts a |CBORValue| to a |std::vector\u003cuint8_t\u003e|, I\u0027d declare it as\n\n  static std::vector\u003cuint8_t\u003e Write(const CBORValue\u0026 node);\n\nWith that signature, you don\u0027t even need a disambiguating comment.\n\nJust a preference nit; up to you.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf7af54f_0732a04e",
        "filename": "content/browser/webauth/cbor/cbor_writer_unittest.cc",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "I trust/hope it is not possible to construct any byte strings that an RFC-compliant CBOR parser would find ambiguous? The existence of https://tools.ietf.org/html/rfc7049#section-3.10 and https://tools.ietf.org/html/rfc7049#section-3.9 suggests there is a risk of ambiguity?\n\n\"This encoder emits only canonical CBOR\" or the like sounds like a security guarantee we might want to document and test. Or if not, to document that fact.\n\nAlso, what about non-minimal or invalid UTF-8 strings? Section https://tools.ietf.org/html/rfc7049#section-3.2 seems to disclaim a guarantee; perhaps we should document it too.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}