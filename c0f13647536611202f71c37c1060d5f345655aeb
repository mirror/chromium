{
  "comments": [
    {
      "key": {
        "uuid": "df0d3b60_e5ae9512",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "Does the ordering of map items matter to the recipient of a CBOR-encoded blob, or is there a well-defined ordering specified in the CBOR RFC? (I haven\u0027t read it yet.) This historically has been a security pain-point in JSON-using applications.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e2ccb54_96a9135c",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "CBOR doesn\u0027t define any ordering for maps (section 3.7 of https://tools.ietf.org/html/rfc7049). There is an idea of \"canonical\" CBOR (section 3.9 of https://tools.ietf.org/html/rfc7049), but based on some of the restrictions of canonical CBOR I\u0027m not sure that\u0027s what we actually want.",
      "parentUuid": "df0d3b60_e5ae9512",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ff084da_b2db334a",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-09-13T18:08:26Z",
      "side": 1,
      "message": "We\u0027re trending toward requiring canonical CBOR at agl\u0027s encouragement (https://github.com/fido-alliance/fido-2-specs/pull/294), but it\u0027s not quite merged yet. That ordering is by length and then lexicographic, rather than just lexicographic, which is dumb, but oh well. It\u0027d be straightforward to order this flat_map in CBOR order, since it takes a Compare argument.",
      "parentUuid": "3e2ccb54_96a9135c",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b761369a_5c017977",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 50,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "The RFC seems to say that anything bigger than a uint64_t will be a BigNum. Do I have that right? If so, it might help to document here that you are adhering to the spec in that way.\n\n(This is a good thing about CBOR relative to JSON, it would seem, which lexically allows all sorts of integers and floats, but smooshes them into float64s regardless of how well that works.)",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e3fcb96_0ffd1389",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 50,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "Yep, that\u0027s right.",
      "parentUuid": "b761369a_5c017977",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f1e54a13_f827ebec",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 50,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-09-13T18:08:26Z",
      "side": 1,
      "message": "Yeah, there are integers-up-to-64-bits, floats-up-to-64-bits, big integers, and big binary and decimal floats, all with their own distinct representations.",
      "parentUuid": "4e3fcb96_0ffd1389",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "858104a6_a17787d0",
        "filename": "content/browser/webauth/cbor/cbor_writer.h",
        "patchSetId": 21
      },
      "lineNbr": 57,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "Perhaps it\u0027s just me, but the function signature suggests appending. To communicate that it essentially converts a |CBORValue| to a |std::vector\u003cuint8_t\u003e|, I\u0027d declare it as\n\n  static std::vector\u003cuint8_t\u003e Write(const CBORValue\u0026 node);\n\nWith that signature, you don\u0027t even need a disambiguating comment.\n\nJust a preference nit; up to you.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f994be67_938d4593",
        "filename": "content/browser/webauth/cbor/cbor_writer.h",
        "patchSetId": 21
      },
      "lineNbr": 57,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "Ah, I was just following the JSONWriter convention to show it\u0027s to be used the same way. I guess I\u0027m ambivalent about it... will probably leave as-is unless someone cares more.",
      "parentUuid": "858104a6_a17787d0",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf7af54f_0732a04e",
        "filename": "content/browser/webauth/cbor/cbor_writer_unittest.cc",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "I trust/hope it is not possible to construct any byte strings that an RFC-compliant CBOR parser would find ambiguous? The existence of https://tools.ietf.org/html/rfc7049#section-3.10 and https://tools.ietf.org/html/rfc7049#section-3.9 suggests there is a risk of ambiguity?\n\n\"This encoder emits only canonical CBOR\" or the like sounds like a security guarantee we might want to document and test. Or if not, to document that fact.\n\nAlso, what about non-minimal or invalid UTF-8 strings? Section https://tools.ietf.org/html/rfc7049#section-3.2 seems to disclaim a guarantee; perhaps we should document it too.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1830957d_75665b14",
        "filename": "content/browser/webauth/cbor/cbor_writer_unittest.cc",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "It does seem like it might be possible to have ambiguous data, but the burden of validation lies largely on the decoder.\n\nI\u0027m not entirely sure what the needs of other components will be for CBOR and whether they would be met by canonical CBOR or not. Jeffrey Yasskin might have some comments about that. But I can add a statement that this currently is not canonical and only guarantees well-formed values.",
      "parentUuid": "bf7af54f_0732a04e",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "063d8999_6d484f3b",
        "filename": "content/browser/webauth/cbor/cbor_writer_unittest.cc",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-09-13T18:08:26Z",
      "side": 1,
      "message": "Like with JSON, repeated map keys are invalid, and different decoders might treat them differently. A decoder that enforces canonical CBOR has an easier time detecting and rejecting repeated keys.\n\nDo we want the encoder to guarantee that things it emits as utf-8 strings are valid utf-8?\n\nWhen we extend this to a decoder (likely for web packaging), we will want to detect and reject invalid utf-8, but there\u0027s nothing for Kim to do about that now.\n\nI can only think of one situation where we might want to emit non-canonical CBOR: if the CBORbis RFC changes the required map ordering, then we\u0027d need to select between the two versions of canonical CBOR. I think it\u0027s fine for now for this encoder to guarantee it emits canonical CBOR.",
      "parentUuid": "1830957d_75665b14",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}