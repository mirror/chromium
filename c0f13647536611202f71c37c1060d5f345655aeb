{
  "comments": [
    {
      "key": {
        "uuid": "df0d3b60_e5ae9512",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "Does the ordering of map items matter to the recipient of a CBOR-encoded blob, or is there a well-defined ordering specified in the CBOR RFC? (I haven\u0027t read it yet.) This historically has been a security pain-point in JSON-using applications.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e2ccb54_96a9135c",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "CBOR doesn\u0027t define any ordering for maps (section 3.7 of https://tools.ietf.org/html/rfc7049). There is an idea of \"canonical\" CBOR (section 3.9 of https://tools.ietf.org/html/rfc7049), but based on some of the restrictions of canonical CBOR I\u0027m not sure that\u0027s what we actually want.",
      "parentUuid": "df0d3b60_e5ae9512",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b761369a_5c017977",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 50,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "The RFC seems to say that anything bigger than a uint64_t will be a BigNum. Do I have that right? If so, it might help to document here that you are adhering to the spec in that way.\n\n(This is a good thing about CBOR relative to JSON, it would seem, which lexically allows all sorts of integers and floats, but smooshes them into float64s regardless of how well that works.)",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e3fcb96_0ffd1389",
        "filename": "content/browser/webauth/cbor/cbor_values.h",
        "patchSetId": 21
      },
      "lineNbr": 50,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "Yep, that\u0027s right.",
      "parentUuid": "b761369a_5c017977",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "858104a6_a17787d0",
        "filename": "content/browser/webauth/cbor/cbor_writer.h",
        "patchSetId": 21
      },
      "lineNbr": 57,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "Perhaps it\u0027s just me, but the function signature suggests appending. To communicate that it essentially converts a |CBORValue| to a |std::vector\u003cuint8_t\u003e|, I\u0027d declare it as\n\n  static std::vector\u003cuint8_t\u003e Write(const CBORValue\u0026 node);\n\nWith that signature, you don\u0027t even need a disambiguating comment.\n\nJust a preference nit; up to you.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f994be67_938d4593",
        "filename": "content/browser/webauth/cbor/cbor_writer.h",
        "patchSetId": 21
      },
      "lineNbr": 57,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "Ah, I was just following the JSONWriter convention to show it\u0027s to be used the same way. I guess I\u0027m ambivalent about it... will probably leave as-is unless someone cares more.",
      "parentUuid": "858104a6_a17787d0",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf7af54f_0732a04e",
        "filename": "content/browser/webauth/cbor/cbor_writer_unittest.cc",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-09-13T00:25:56Z",
      "side": 1,
      "message": "I trust/hope it is not possible to construct any byte strings that an RFC-compliant CBOR parser would find ambiguous? The existence of https://tools.ietf.org/html/rfc7049#section-3.10 and https://tools.ietf.org/html/rfc7049#section-3.9 suggests there is a risk of ambiguity?\n\n\"This encoder emits only canonical CBOR\" or the like sounds like a security guarantee we might want to document and test. Or if not, to document that fact.\n\nAlso, what about non-minimal or invalid UTF-8 strings? Section https://tools.ietf.org/html/rfc7049#section-3.2 seems to disclaim a guarantee; perhaps we should document it too.",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1830957d_75665b14",
        "filename": "content/browser/webauth/cbor/cbor_writer_unittest.cc",
        "patchSetId": 21
      },
      "lineNbr": 31,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-09-13T17:00:31Z",
      "side": 1,
      "message": "It does seem like it might be possible to have ambiguous data, but the burden of validation lies largely on the decoder.\n\nI\u0027m not entirely sure what the needs of other components will be for CBOR and whether they would be met by canonical CBOR or not. Jeffrey Yasskin might have some comments about that. But I can add a statement that this currently is not canonical and only guarantees well-formed values.",
      "parentUuid": "bf7af54f_0732a04e",
      "revId": "c0f13647536611202f71c37c1060d5f345655aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}