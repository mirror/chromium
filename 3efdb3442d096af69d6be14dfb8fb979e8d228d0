{
  "comments": [
    {
      "key": {
        "uuid": "29d71e73_be63234f",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T09:51:14Z",
      "side": 1,
      "message": "is this something that exo code should be doing? either way, looks like a fix that should separate from the rest of this CL",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6e58c4a_800cdb06",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T10:46:26Z",
      "side": 1,
      "message": "I don\u0027t think it should be done by exo. It\u0027s not only exo which uses frame sinks. I\u0027m extracting to a separate CL right now.",
      "parentUuid": "29d71e73_be63234f",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90a2a65e_be392f7d",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T11:04:46Z",
      "side": 1,
      "message": "Extracted to:\nhttps://chromium-review.googlesource.com/c/chromium/src/+/647347",
      "parentUuid": "a6e58c4a_800cdb06",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df8f0ff3_68708616",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T11:28:17Z",
      "side": 1,
      "message": "I don\u0027t mean for exo specifically but in general. Shouldn\u0027t the new surface ids be allocated by the client as a result of the bounds changing instead of here?",
      "parentUuid": "90a2a65e_be392f7d",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8eed308c_46ff58ca",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-04T03:31:03Z",
      "side": 1,
      "message": "Window state may change without bounds changing, though it\u0027s a rare edge case. Window manager (here ash) may want to arbitrarily create copies of layers for animations in any moment. We could add a callback to ask the client to call aura::Window::AllocateLocalSurfaceId, but on the other hand I\u0027m not very sure if it\u0027s necessary for the client to know that we\u0027re doing a layer copy and involve it in the process. It\u0027s an implementation detail of the window manager, and wm can take care of reallocating the surface on it\u0027s own.\n\nAnyways, the new version of https://chromium-review.googlesource.com/c/chromium/src/+/647347 simplifies this logic slightly by asking the layer owner (here aura::window) to allocate a new surface id. Let\u0027s continue the discussion there if you have further questions on this part of the CL.",
      "parentUuid": "df8f0ff3_68708616",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e94125e_21f85519",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 5
      },
      "lineNbr": 765,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-01T15:59:31Z",
      "side": 1,
      "message": "Shouldn\u0027t we fix this first? Then, we can simply use the pending frame \u0026 current frame for cross fade, which doesn\u0027t require these logic?",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9dc93864_6e76e0b2",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 5
      },
      "lineNbr": 765,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-04T03:31:03Z",
      "side": 1,
      "message": "Well, I don\u0027t think the order of CLs matters that much. It\u0027s easier to verify fixing b/65271032 if this landed first. And the workaround for broken synchronization is just one line.",
      "parentUuid": "0e94125e_21f85519",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0393b0df_6a2610c7",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 5
      },
      "lineNbr": 765,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-04T08:25:13Z",
      "side": 1,
      "message": "I believe if they\u0027re synchronized, we can simply crossfade between current and pending.",
      "parentUuid": "9dc93864_6e76e0b2",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "924d5da9_c7b91674",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 5
      },
      "lineNbr": 765,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-04T08:35:35Z",
      "side": 1,
      "message": "That\u0027s correct. Yet we still want to disable crossfading if invoked from aura (alt+). That\u0027s why we need the next_Frame_is_good_for_crossfade_. I\u0027ll remove this if though as we just landed the ARC fix for the synchronization.",
      "parentUuid": "0393b0df_6a2610c7",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7a51803_fd767960",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 5
      },
      "lineNbr": 765,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-04T10:03:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "924d5da9_c7b91674",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "710da49f_d5aed81d",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 5
      },
      "lineNbr": 778,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-04T08:25:13Z",
      "side": 1,
      "message": "we need to handle normal \u003c-\u003e fullscreen",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed624a89_6d511b42",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 5
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-04T08:35:35Z",
      "side": 1,
      "message": "We only animate fullscreen -\u003e normal in ash, but not normal -\u003e fullscreen. Not sure if it\u0027s on purpose. So I left fullscreen animation for a separate CL.",
      "parentUuid": "710da49f_d5aed81d",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1362aa18_679b5821",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T09:51:14Z",
      "side": 1,
      "message": "hm, can we make this work using standard configure event flow instead (using a synchronous round-trip if needed)? I really like us to cut down on arc specific logic that we have to maintain in exo/chrome and move towards a model where more code is shared with regular clients and upstream interfaces clearly define expected behavior.",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa36cedd_6033b331",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T10:46:26Z",
      "side": 1,
      "message": "Are we going to abandon the zcr_remote_surface_v1_interface protocol? It gives as a guarantee that window state changes are part of commits, which is very helpful and imho neat.\n\nAs for using configure, I\u0027m not sure if it\u0027s that helpful here. Per documentation \"client must make an ack_configure request *sometime before* the commit request\". So, when we have a surface commit we can either be committing a surface for the new or old window state. And we want to fire the animation just before we get the new frame. What I want to say is I\u0027m skeptical if the standard Wayland protocol gives as any mechanism to do a reliable crossfade animation without heuristics.",
      "parentUuid": "1362aa18_679b5821",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7085ced5_7e26d7b7",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T11:23:28Z",
      "side": 1,
      "message": "All right, I read the documentation again, and the configure from xdg-shell is actually synchronized. So yeah, it should work.\n\nHowever, we don\u0027t have it implemented on Android side yet. And it may be a lot of work. So the question is whether we want this CL first, and move to the standard protocol later, or we don\u0027t want it at all?",
      "parentUuid": "aa36cedd_6033b331",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba4c667e_1698fd9d",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T11:28:17Z",
      "side": 1,
      "message": "the standard wayland protocol has excellent support for this in the form of acks. it will also handle compositor driven state changes correctly. e.g. what if you press Alt-+ to maximize the window.\n\nI\u0027d like to abandon remote-shell eventually. It\u0027s not going to happen in a day but the more we rely on it the harder it will be.",
      "parentUuid": "aa36cedd_6033b331",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27582e6e_24ca7afd",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T11:37:10Z",
      "side": 1,
      "message": "Let\u0027s do it right from the start. I think it would be relatively easy to implement on the Android side by using a round-trip (wl_display_roundtrip). That\u0027s of course not ideal performance wise but it would be a good start. Example from client side:\n\nMaximizeWindow() {\n  shell_set_maximized();\n  wl_display_round_trip(); // will result in a configure event with maximize state and a serial\n  configure_ack(serial_from_above);\n  commit();\n}",
      "parentUuid": "ba4c667e_1698fd9d",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d653119_0de6a236",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-01T15:59:31Z",
      "side": 1,
      "message": "Note that alt-+ may not result in state change in Android, and Android still have the final decision that should happen. (we can reduce such chance by sending more info to server, but we can\u0027t eliminate 100%).\n\nAlso, if you\u0027re planning to remove remote shell, please coordinate with skuhne@ and also android team. Our current (future) upstream plan is to rely on Android to implement window state change, and I want to make sure it won\u0027t cause a problem in the future.",
      "parentUuid": "27582e6e_24ca7afd",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33099d14_f32a89f0",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-04T03:31:03Z",
      "side": 1,
      "message": "David, do you suggest to use zcr configure event with zcr maximize/restore? We use zcr protocol for ARC surfaces at this moment.\n\nThe zcr protocol is client driven for window state changes and zcr maximize/restore events are called *after* the client changes the window state. The zcr configure event is not used for window states.\n\nWe could make zcr work with configure events for window state changes, but it\u0027s a large effort including major refactoring on Android side. It\u0027s tracked here crbug.com/699746.\n\nIf we can go with this CL, we can deliver animations to users right now easily and quickly. If your concern is about supporting other clients, then I can add support for animations to other protocols which use configuration for window states. Also, when crbug.com/699746 is fixed, we\u0027d use zcr configure for animations too. And in the long term ideally migrate to xdg entirely.",
      "parentUuid": "6d653119_0de6a236",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8082a55_8d4d7430",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-06T11:47:23Z",
      "side": 1,
      "message": "Not sure exactly what \"Android to implement window state change\" means but a good process is to just submit updates to the new aura-shell protocol that provide what\u0027s needed and unless they are large they can be discussed and evaluated as part of the review process.\n\n@tomasz, remote-shell configure events is what you\u0027d need to use today but in the future when we move to xdg-shell we can instead use the configure event that is part of that interface.",
      "parentUuid": "33099d14_f32a89f0",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b823e777_d10db18b",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-06T23:09:02Z",
      "side": 1,
      "message": "On ARC++, the state change is initiated by Android, not chrome.\nThe maximize() from chrome is just a request, not really event in ARC++ case,\nbecause it may or may not maximize.  It may result in a confirmation dialog.\nWe don\u0027t really know the size the application will use.\n\nThe current implementation has to be updated to just send a request \n(which should fix the bug like this crbug.com/36724503).\n\n\nI understand that\u0027s standard wayland model, but this isn\u0027t regular wayland client, and I believe we agreed to implement this way first?\n\nWe have everything we need here. Why we need configure? I understand this case can be implemented using configure, but it sounds more complicated than necessary.",
      "parentUuid": "c8082a55_8d4d7430",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f49b433c_147b677f",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-08T14:42:04Z",
      "side": 1,
      "message": "Sounds like we need a more explicit mode in Chrome/Exo where clients gets a say in state changes. XDG-shell has things like \"can_resize\" etc. but I guess we need something more advanced like \"ask_for_resize\". aura-shell protocol would be a good place to introduce this.\n\nMy general concern is that special cases for ARC++ keeps piling up. Some are small hacks and some a significant WM design changes. It\u0027s hard to evaluate what the maintenance burden of these will be in the long run and it\u0027s not easy to understand them as it\u0027s mostly implicit based on the current arc++ needs.\n\nStandard upstream wayland protocol has been thoroughly reviewed by WM experts, is well documented and well tested. That makes me very comfortable to implement and support it as I know we\u0027re not digging ourselves into a hole where we need to maintain APIs with race conditions and hard to diagnose bugs.\n\nThe more of upstream we can use the better. Not just because protocol is reviewed by experts and tested but also because it will benefit our support for non-arc++ clients. This is the reason I always recommend using upstream protocol first.\n\nThat said, I\u0027m not set on any specific protocol for Arc++. I\u0027m open too all suggestions here. Client controlled state changes, absolute positioning etc. might all be fine but it\u0027s hard to evaluate without a proper design review. aura-shell protocol is supposed to fix this as we can add explicit interfaces for arc++\u0027s needs and they will both be documented and reviewed properly as part of being added to the protocol.",
      "parentUuid": "b823e777_d10db18b",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbd43729_0c277e24",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-13T04:55:56Z",
      "side": 1,
      "message": "I agree that remote-shell is not ideal, and standard protocols are the way to go in long term. We can either use what we have or block this CL on major refactoring. Let me try to justify why I believe we shouldn\u0027t block.\n\nLet\u0027s see what we have in this CL.\n\n1. Adding pending window state. This is not specific to ARC, as other protocols like xdg need that too.\n\n2. Applying pending window state in OnSurfaceCommit with an animation. Again, not specific to ARC. Other protocols need the same.\n\n3. Two new methods - MaximizeWithCommit and RestoreWithCommit. Again, not specific to ARC. Other protocols will need to call these too. We may rename them, but we\u0027ll still need to mark the states as pending instead of applying immediately.\n\nSo, IIUC we\u0027re not adding any ARC only specific code. While we\u0027re starting from remote_shell protocol, the logic will stay when we hook up other protocols or switch away from remote-shell, or add window state changes to remote-shell\u0027s configure.",
      "parentUuid": "f49b433c_147b677f",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "483d6a32_23afd8a4",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-14T02:49:58Z",
      "side": 1,
      "message": "I think there\u0027s some confusion about how this works for xdg clients. There\u0027s no pending window state as chrome controls the window state. There\u0027s only pending contents to match the state. Let\u0027s do a VC tomorrow to discuss what is the best way to solve this. I\u0027ll be in NYC and early morning is fine for me.",
      "parentUuid": "cbd43729_0c277e24",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d949d85f_66f2066e",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-14T03:37:31Z",
      "side": 1,
      "message": "IIUC xdg\u0027s set_maximized asks the server to maximize, and it\u0027s up to the server whether to maximize immediately without waiting for the new frame, or whether to maximize after AckConfigure. So, if we want to wait, then we will have a pending window state. Such state can be kept in pending_configs_, but it\u0027s semantically the same as pending_window_state_, just named differently. Am I missing something?",
      "parentUuid": "483d6a32_23afd8a4",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27330198_36de28ad",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-14T03:43:59Z",
      "side": 1,
      "message": "Or, do you want to maximize immediately on xdg\u0027s set_maximized? This would cause visual artifacts (window frame not matching the buffer size, broken overview, alt-tab screen) until we get a buffer for the new window state.",
      "parentUuid": "d949d85f_66f2066e",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4759e0f8_6271630c",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-14T21:03:54Z",
      "side": 1,
      "message": "Can you invite me too?\n\nRegarding dave\u0027s earlier comments, things like can_resize, can_maximize (which I was going to add anyway to give better UX feedback) etc won\u0027t really solve the issue because Android can change their decision any time, so these are just informational and can become stale. If next moment you check can_reize, ARC++ app may become not resizeable on Android side. Android app may even switch from maximized to normal state, without asking chrome.\n\nI understand that this may not match xdg model, but we building ARC++. Like or not, Android does part of WM and not just simple client. I do agree that it\u0027s better to let server/chrome controls the state, but we need to work with Android team to give window control to us. Plus, upstreaming Android\nchange is way more difficult and trickier.\n\nUntil that happens, if we have to optimize for one, we need to optimize for ARC++, not for xdg. At the end of the day, it is us who have to make sure ChromeOS and Android works well together, not wayland folks.",
      "parentUuid": "27330198_36de28ad",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}