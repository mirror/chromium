{
  "comments": [
    {
      "key": {
        "uuid": "29d71e73_be63234f",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T09:51:14Z",
      "side": 1,
      "message": "is this something that exo code should be doing? either way, looks like a fix that should separate from the rest of this CL",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6e58c4a_800cdb06",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T10:46:26Z",
      "side": 1,
      "message": "I don\u0027t think it should be done by exo. It\u0027s not only exo which uses frame sinks. I\u0027m extracting to a separate CL right now.",
      "parentUuid": "29d71e73_be63234f",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90a2a65e_be392f7d",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T11:04:46Z",
      "side": 1,
      "message": "Extracted to:\nhttps://chromium-review.googlesource.com/c/chromium/src/+/647347",
      "parentUuid": "a6e58c4a_800cdb06",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df8f0ff3_68708616",
        "filename": "ash/wm/window_state.cc",
        "patchSetId": 5
      },
      "lineNbr": 500,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T11:28:17Z",
      "side": 1,
      "message": "I don\u0027t mean for exo specifically but in general. Shouldn\u0027t the new surface ids be allocated by the client as a result of the bounds changing instead of here?",
      "parentUuid": "90a2a65e_be392f7d",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1362aa18_679b5821",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T09:51:14Z",
      "side": 1,
      "message": "hm, can we make this work using standard configure event flow instead (using a synchronous round-trip if needed)? I really like us to cut down on arc specific logic that we have to maintain in exo/chrome and move towards a model where more code is shared with regular clients and upstream interfaces clearly define expected behavior.",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa36cedd_6033b331",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T10:46:26Z",
      "side": 1,
      "message": "Are we going to abandon the zcr_remote_surface_v1_interface protocol? It gives as a guarantee that window state changes are part of commits, which is very helpful and imho neat.\n\nAs for using configure, I\u0027m not sure if it\u0027s that helpful here. Per documentation \"client must make an ack_configure request *sometime before* the commit request\". So, when we have a surface commit we can either be committing a surface for the new or old window state. And we want to fire the animation just before we get the new frame. What I want to say is I\u0027m skeptical if the standard Wayland protocol gives as any mechanism to do a reliable crossfade animation without heuristics.",
      "parentUuid": "1362aa18_679b5821",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7085ced5_7e26d7b7",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-01T11:23:28Z",
      "side": 1,
      "message": "All right, I read the documentation again, and the configure from xdg-shell is actually synchronized. So yeah, it should work.\n\nHowever, we don\u0027t have it implemented on Android side yet. And it may be a lot of work. So the question is whether we want this CL first, and move to the standard protocol later, or we don\u0027t want it at all?",
      "parentUuid": "aa36cedd_6033b331",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba4c667e_1698fd9d",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T11:28:17Z",
      "side": 1,
      "message": "the standard wayland protocol has excellent support for this in the form of acks. it will also handle compositor driven state changes correctly. e.g. what if you press Alt-+ to maximize the window.\n\nI\u0027d like to abandon remote-shell eventually. It\u0027s not going to happen in a day but the more we rely on it the harder it will be.",
      "parentUuid": "aa36cedd_6033b331",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27582e6e_24ca7afd",
        "filename": "components/exo/shell_surface.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-09-01T11:37:10Z",
      "side": 1,
      "message": "Let\u0027s do it right from the start. I think it would be relatively easy to implement on the Android side by using a round-trip (wl_display_roundtrip). That\u0027s of course not ideal performance wise but it would be a good start. Example from client side:\n\nMaximizeWindow() {\n  shell_set_maximized();\n  wl_display_round_trip(); // will result in a configure event with maximize state and a serial\n  configure_ack(serial_from_above);\n  commit();\n}",
      "parentUuid": "ba4c667e_1698fd9d",
      "revId": "3efdb3442d096af69d6be14dfb8fb979e8d228d0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}