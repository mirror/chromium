{
  "comments": [
    {
      "key": {
        "uuid": "3c4783a2_8f6222c0",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-14T02:59:57Z",
      "side": 1,
      "message": "The trouble stems from this function where we need any old instance to have closed all its file handles. What if instead the net library exposed a function with a completion callback to destroy any files on disk, that function would have to figure it out internally how to close handles prior to deleting files.\n\nint DestroyCacheBackend(...,path, completion_callback);\n\nSo nothing about task runners needs to be provided or exposed. The destroy function is what we\u0027re tyring to compose at this level, let\u0027s just make the disk_cache lib provide that function entirely. Wdyt?",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c82e2b03_3653b44a",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-14T14:22:42Z",
      "side": 1,
      "message": "Definitely worth thinking of --- I am not immediately certain how to implement it given the backend object is already destroyed by this point.\n\nHmm, and I am not sure that all FDs actually are guaranteed closed in the current code base --- mostly with the simple backend:\n1) Simple backend doesn\u0027t quite sequence everything on the task runner anyway, so the Close calls from AppCacheDiskCache::Disable() might not actually complete by the time you delete the directory. (What would happen on Unix would be just writing files to an unlink\u0027d dir, not sure about Windows; though, I think Windows + simple backend would only be ServiceWorker)\n2) If you call disk_cache::Entry::Close() on all entries, and destroy the backend object, the ops are still pending, and are expected to call the callback. How that\u0027s implemented differs\n--- Simple backend actually executes the ops. Block does a combination of blocking the I/O thread potentially waiting on disk (!!!) and aborting ops.\n\nNot sure if the code can even hit that, needs more knowledge than I can get by local \nexamination...",
      "parentUuid": "3c4783a2_8f6222c0",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3c3d425_ef107ebd",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-14T15:09:24Z",
      "side": 1,
      "message": "So one option for this would be to require a separate Create variant that fills in some sort of CleanupContext or such object, guaranteed, even if backend creation has failed; this can also potentially be used to keep track of outstanding closes/other ops to sequence after them independent of backend object\u0027s lifetime.",
      "parentUuid": "c82e2b03_3653b44a",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6253ad53_d361ac38",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-14T18:52:06Z",
      "side": 1,
      "message": "A lite weight variant of the cleanup context idea could be for disk_cache::CreateCacheBackend to provide the task runner it creates as an out argument. Have that value returned immediately w/o having to wait for OnCreateBackendComplete. Thats a pretty clean way of exposing the runner, a very small change to one function signature, instead of taking a runner as input, it produces the runner as output. The potential issue you raised about guaranteeing things are closed might be a separate problem, but the task at hand is mostly about inverting responsibility for who creates the runner.",
      "parentUuid": "a3c3d425_ef107ebd",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37a76045_13421da6",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-14T19:15:10Z",
      "side": 1,
      "message": "Hmm, that\u0027s certainly implementable easily, though I am not sure it avoids all of the flakery of the current CL --- is \"DeleteAndStartOver will never be called before InitWith*Backend\" a true property? OTOH, I am not sure I can fix the close thing w/o a context object.",
      "parentUuid": "6253ad53_d361ac38",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32af1cc2_3823ab63",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-14T19:38:46Z",
      "side": 1,
      "message": "Regarding flackery, seems like a lateral move, the change described would behave just like tip-of-tree does? Is that not right? I think DeleteAndStartOver probably can get called prior to Init being called, but in that case, the disk_cache certainly doesn\u0027t have any files open.",
      "parentUuid": "37a76045_13421da6",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}