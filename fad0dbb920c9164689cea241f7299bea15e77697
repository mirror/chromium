{
  "comments": [
    {
      "key": {
        "uuid": "3c4783a2_8f6222c0",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-14T02:59:57Z",
      "side": 1,
      "message": "The trouble stems from this function where we need any old instance to have closed all its file handles. What if instead the net library exposed a function with a completion callback to destroy any files on disk, that function would have to figure it out internally how to close handles prior to deleting files.\n\nint DestroyCacheBackend(...,path, completion_callback);\n\nSo nothing about task runners needs to be provided or exposed. The destroy function is what we\u0027re tyring to compose at this level, let\u0027s just make the disk_cache lib provide that function entirely. Wdyt?",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c82e2b03_3653b44a",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-14T14:22:42Z",
      "side": 1,
      "message": "Definitely worth thinking of --- I am not immediately certain how to implement it given the backend object is already destroyed by this point.\n\nHmm, and I am not sure that all FDs actually are guaranteed closed in the current code base --- mostly with the simple backend:\n1) Simple backend doesn\u0027t quite sequence everything on the task runner anyway, so the Close calls from AppCacheDiskCache::Disable() might not actually complete by the time you delete the directory. (What would happen on Unix would be just writing files to an unlink\u0027d dir, not sure about Windows; though, I think Windows + simple backend would only be ServiceWorker)\n2) If you call disk_cache::Entry::Close() on all entries, and destroy the backend object, the ops are still pending, and are expected to call the callback. How that\u0027s implemented differs\n--- Simple backend actually executes the ops. Block does a combination of blocking the I/O thread potentially waiting on disk (!!!) and aborting ops.\n\nNot sure if the code can even hit that, needs more knowledge than I can get by local \nexamination...",
      "parentUuid": "3c4783a2_8f6222c0",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3c3d425_ef107ebd",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-14T15:09:24Z",
      "side": 1,
      "message": "So one option for this would be to require a separate Create variant that fills in some sort of CleanupContext or such object, guaranteed, even if backend creation has failed; this can also potentially be used to keep track of outstanding closes/other ops to sequence after them independent of backend object\u0027s lifetime.",
      "parentUuid": "c82e2b03_3653b44a",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6253ad53_d361ac38",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-14T18:52:06Z",
      "side": 1,
      "message": "A lite weight variant of the cleanup context idea could be for disk_cache::CreateCacheBackend to provide the task runner it creates as an out argument. Have that value returned immediately w/o having to wait for OnCreateBackendComplete. Thats a pretty clean way of exposing the runner, a very small change to one function signature, instead of taking a runner as input, it produces the runner as output. The potential issue you raised about guaranteeing things are closed might be a separate problem, but the task at hand is mostly about inverting responsibility for who creates the runner.",
      "parentUuid": "a3c3d425_ef107ebd",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37a76045_13421da6",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-14T19:15:10Z",
      "side": 1,
      "message": "Hmm, that\u0027s certainly implementable easily, though I am not sure it avoids all of the flakery of the current CL --- is \"DeleteAndStartOver will never be called before InitWith*Backend\" a true property? OTOH, I am not sure I can fix the close thing w/o a context object.",
      "parentUuid": "6253ad53_d361ac38",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32af1cc2_3823ab63",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-14T19:38:46Z",
      "side": 1,
      "message": "Regarding flackery, seems like a lateral move, the change described would behave just like tip-of-tree does? Is that not right? I think DeleteAndStartOver probably can get called prior to Init being called, but in that case, the disk_cache certainly doesn\u0027t have any files open.",
      "parentUuid": "37a76045_13421da6",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f43fe42c_8484017b",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-14T19:51:33Z",
      "side": 1,
      "message": "I meant more in terms of code brittleness...\n\nAnyway, I was thinking along the lines of:\nclass CleanupContext {\n public:\n  typedef OnceCallback\u003cvoid(scoped_refptr\u003cbase::SequencedTaskRunner\u003e)\u003e PostCleanupCallback;\n\n  // The provide callback will be executed, and handed a task runner,\n  // when it\u0027s safe to queue an op to that task runner to delete the cache\u0027s\n  // directory without any interference from its operations or open files.\n  void ExecuteWhenCleanupComplete(PostCleanupCallback callback)\n}\n\n... with the understanding that the Execute... call would correspond to the last call to disk_cache::CreateCacheBackend (maybe it can even work without one), and that there should only be one for each. \n\nA simpler take would make the object non-reusable while the Execute... is pending.",
      "parentUuid": "32af1cc2_3823ab63",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0f59d28e_5e65a651",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-14T21:17:32Z",
      "side": 1,
      "message": "I definitely agree in principal with having the disk_cache lib provide the functionality of letting callers know what its done.\n\nAnother slightly different (simpler) api idea could be to provide the postcleanupcallback as an input to the disk_cache::CreateCacheBackend function. We don\u0027t need a queue.",
      "parentUuid": "f43fe42c_8484017b",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ddcdf066_a39d7ad9",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 1940,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-19T14:21:42Z",
      "side": 1,
      "message": "So to update you on this: I really like this refinement since it removes some artificial and very awkward memory management my sketch had (though at cost of potentially invoking callbacks at funny times); but in testing it seems like I need to better understand the requirements at CacheStorageCache level.\n\nOne issue that may be relevant here, too: is a cache backend ever re-created for the same path without doing the DeleteAndRestart dance? That likely needs the same sort of sequencing.  (The CL currently does that automatically, but the approach it has may be too dangerous for clients that aren\u0027t as disciplined at closing everything out).",
      "parentUuid": "0f59d28e_5e65a651",
      "range": {
        "startLine": 1940,
        "startChar": 18,
        "endLine": 1940,
        "endChar": 24
      },
      "revId": "fad0dbb920c9164689cea241f7299bea15e77697",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}