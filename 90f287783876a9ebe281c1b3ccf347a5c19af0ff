{
  "comments": [
    {
      "key": {
        "uuid": "7d340711_647b9d2f",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 98,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "Pass these by value too. (See comment for SendFrame() in header file.)",
      "range": {
        "startLine": 98,
        "startChar": 31,
        "endLine": 98,
        "endChar": 40
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4158305_875b5470",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 98,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7d340711_647b9d2f",
      "range": {
        "startLine": 98,
        "startChar": 31,
        "endLine": 98,
        "endChar": 40
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0041a17d_de42ace1",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 175,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "s/block main/block the main/",
      "range": {
        "startLine": 175,
        "startChar": 62,
        "endLine": 175,
        "endChar": 72
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c28556dd_c2b4b539",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 175,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0041a17d_de42ace1",
      "range": {
        "startLine": 175,
        "startChar": 62,
        "endLine": 175,
        "endChar": 72
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ca598eb_1bbd03d5",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 258,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "This should be moved up to the top of this method since you\u0027re reading pixels that were rendered before this method was called. (Some significant time may elapse during image-\u003ereadPixels(), for example.)",
      "range": {
        "startLine": 258,
        "startChar": 0,
        "endLine": 258,
        "endChar": 59
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1837ce2a_1368dc93",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 258,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "Done. Also, applied similar logic to async calls.",
      "parentUuid": "1ca598eb_1bbd03d5",
      "range": {
        "startLine": 258,
        "startChar": 0,
        "endLine": 258,
        "endChar": 59
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b0cf627_5e664bec",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 302,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "For the other code paths, you just set base::TimeDelta() here. Seems that the VideoFrame::timestamp should be consistent, regardless of code paths used.\n\nI\u0027d suggest setting it at the common endpoint, in SendFrame().\n\nAlso, the VideoFrame timestamps are relative media stream timestamps. Meaning, the first frame usually has a TimeDelta of zero, and the following frames have relatively increasing deltas from there. Often, for real-time capture cases, folks will map TimeTicks to the video frame TimeDeltas by saving the first frame\u0027s TimeTicks value:\n\n  // in header file:\n  base::Optional\u003cbase::TimeTicks\u003e first_frame_ticks_;\n\n  // in SendFrame() in .cc file:\n  if (!first_frame_ticks_)\n    first_frame_ticks_ \u003d this_frame_ticks;\n  video_frame-\u003eset_timestamp(this_frame_ticks - *first_frame_ticks_);",
      "range": {
        "startLine": 302,
        "startChar": 6,
        "endLine": 302,
        "endChar": 35
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a15129a8_a570ced2",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 302,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "Done. \n\nThe difference in code paths was due to this: The other code paths (l.273 and 240) are both |temp_argb_frame|. Timestamp doesn\u0027t matter as they are temp containers that aren\u0027t sent over to webrtc. However, this and l.376 are |output_frame| that is actually sent over.",
      "parentUuid": "6b0cf627_5e664bec",
      "range": {
        "startLine": 302,
        "startChar": 6,
        "endLine": 302,
        "endChar": 35
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "034e5ce2_c94fa02e",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 317,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "This should be cached. It\u0027s actually rather expensive to create and tear-down this for every frame (because, internally, it caches intermediate textures, framebuffers, and other GL objects). However, I leave it up to you whether you want to do that in this CL or a future one.\n\nThe issue with caching is that you have to know to delete the ReadbackYUVInterface whenever the context is lost because it internally caches a raw pointer to the GLHelper. (A bit brittle, I know. This is old code refactored and moved around by a bunch of different people over the years, which led to its current state.) You\u0027ll probably need to add an observer to |context_provider| to notify this class when the context is lost (or the GLHelper is destroyed) so you can delete the ReadbackYUVInterface.\n\nAlternatively, and perhaps a much simpler solution might be to just fix the ReadbackYUVInterface class so that it internally holds a WeakPtr to the GLHelper instead of a raw pointer. Then, add a ReadbackYUVInterface::IsValid() method like:\n\n  bool ReadbackYUVInterface::IsValid() const {\n    return !!weak_gl_helper_pointer_;\n  }\n\nThen, here, you can just do something simple like:\n\n  if (!yuv_reader_ || !yuv_reader_-\u003eIsValid()) {\n    ...recreate a new one from the new GLHelper...\n  } else {\n    // Use the existing one. Good to go!\n  }",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 317,
        "endChar": 74
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85eb8ff0_e8b37fd5",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 317,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "I see the issue and was actually waiting for your input. Let\u0027s tackle the problem in this CL if we can. \nI don\u0027t think this class should cache |yuv_reader_|. Currently, this class does not know about context. It relies on blink::WebGraphicsContext3DProvider* to be tied to a context and hold a GLHelper. If there are different GLHelpers passed between two images, we wouldn\u0027t have a way to track AFAICT. \nWhat about making GLHelper hand out lazily created instances of ReadbackYUVInterface, like GetReadbackSupport() on demand. That way we know that current instance is tied to that GLHelper for sure. I made the small changes for GetReadbackPipelineYUV(), WDYT?",
      "parentUuid": "034e5ce2_c94fa02e",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 317,
        "endChar": 74
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a8613db_ec184637",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 317,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-09T05:05:45Z",
      "side": 1,
      "message": "This is fine, assuming this is the only code that uses the GLHelper-owned instance. I\u0027m not sure there\u0027s a good way in the code structure to enforce that. Maybe blink::WebGraphicsContext3DProvider should own ReadbackYUVInterface instead of GLHelper?\n\nThere is one possible (but not-very-likely) danger here, if someone else starts using the shared ReadbackYUVInterface for some other feature and they call SetScaler() while your Canvas capturer is running. So, for safety, you might want to add a DCHECK(!yuv_reader-\u003escaler()) before the call to ReadbackYUV(). Or, maybe put the DCHECK in the getter method that returns the YUVReadbackInterface?\n\nAlso, there might be a performance penalty if ReadbackYUV() is being called repeatedly with different image sizes (e.g., because 2 different Canvas captures are running). This is because, internally, ReadbackYUV() will resize the cached textures; which pretty much defeats the caching.\n\nAs we\u0027ve worked through all the issues with GLHelper in this (and the last) code review, a design idea is forming in my mind: We could avoid a lot of the mess if ContextProvider had an API for letting clients make CopyOutputRequests on arbitrary textures. Then, we wouldn\u0027t need GLHelper at all, and no more worrying about context loses or sharing objects. :)",
      "parentUuid": "85eb8ff0_e8b37fd5",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 317,
        "endChar": 74
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d83e0ce_dfb2aadb",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 341,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "For more accuracy, I suggest calling TimeTicks::Now() in ReadARGBPixelsAsync(), and then pass the value as an argument to this callback.",
      "range": {
        "startLine": 341,
        "startChar": 0,
        "endLine": 341,
        "endChar": 59
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17014593_86d2ccfa",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 341,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7d83e0ce_dfb2aadb",
      "range": {
        "startLine": 341,
        "startChar": 0,
        "endLine": 341,
        "endChar": 59
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "78013844_4023b4da",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 361,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "Time accuracy issue here too. (Now() is much later than the actual frame timestamp...Possibly dozens of milliseconds for the GPU readback cases.)",
      "range": {
        "startLine": 361,
        "startChar": 23,
        "endLine": 361,
        "endChar": 45
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe3e685a_a6d11c00",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 361,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "78013844_4023b4da",
      "range": {
        "startLine": 361,
        "startChar": 23,
        "endLine": 361,
        "endChar": 45
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9bdc27ab_05dc61d1",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 440,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-11-08T03:23:50Z",
      "side": 1,
      "message": "std::move(video_frame) here, once you change the args to this method.",
      "range": {
        "startLine": 440,
        "startChar": 57,
        "endLine": 440,
        "endChar": 68
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df020ddd_c42981c2",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 8
      },
      "lineNbr": 440,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-09T01:19:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9bdc27ab_05dc61d1",
      "range": {
        "startLine": 440,
        "startChar": 57,
        "endLine": 440,
        "endChar": 68
      },
      "revId": "90f287783876a9ebe281c1b3ccf347a5c19af0ff",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}