{
  "comments": [
    {
      "key": {
        "uuid": "1bbcac92_38ee49c7",
        "filename": "media/gpu/android/media_codec_video_decoder.cc",
        "patchSetId": 2
      },
      "lineNbr": 294,
      "author": {
        "id": 1130490
      },
      "writtenOn": "2017-09-08T14:41:50Z",
      "side": 0,
      "message": "i don\u0027t think that this case is properly handled.  to do so, we\u0027d need to cancel overlay callbacks in TransitionToTargetSurface().  i think that would do it.  need another weak factory, i guess.\n\notherwise, we could switch from overlay 1 to ST, then to overlay 2, and get a destroyed callback on overlay 1 while it\u0027s sitting waiting to be released, maybe in shared state or something.  as written, we\u0027d switch away from overlay 2.\n\nactually, i don\u0027t remember how shared state works in MCVD.  does anything keep the surface bundle tied to the CodecImage?  as in, if we transition away from an overlay, but there are VideoFrames that are backed by it, what happens?\n\nin AVDA, assuming it\u0027s not in response to a SurfaceDestroyed, then the surface bundle stays around until none of the CodecImages need it anymore.   this prevents unbacking the frame early.  leaving fullscreen while paused no longer goes to a black video frame, if i remember, for example.\n\nfor SurfaceDestroyed, i think that we go through and un-back them all immediately.",
      "revId": "448db961b97d3b0eca418ca5130df4134b224aae",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a70505ab_9b9ae870",
        "filename": "media/gpu/android/media_codec_video_decoder.cc",
        "patchSetId": 2
      },
      "lineNbr": 294,
      "author": {
        "id": 1119171
      },
      "writtenOn": "2017-09-11T07:49:43Z",
      "side": 0,
      "message": "I\u0027m sure you\u0027re right but I don\u0027t quite follow your example. After we\u0027ve transitioned, overlay_bundle-\u003eoverlay \u003d\u003d overlay2. So when we receive OnSurfaceDestroyed(overlay1) we won\u0027t do anything. TargetSurface() will still be overlay2.\n\nMCVDs CodecImages don\u0027t hold a ref to the overlay. Is this a new behavior for AndroidOverlay in AVDA? I think we can easily add that. We don\u0027t even have to clear the ref from the CodecImages on SurfaceDestroyed() I don\u0027t think. Because they don\u0027t do anything with the overlay except hold onto it to keep it alive.",
      "parentUuid": "1bbcac92_38ee49c7",
      "revId": "448db961b97d3b0eca418ca5130df4134b224aae",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de150864_878c88be",
        "filename": "media/gpu/android/media_codec_video_decoder.cc",
        "patchSetId": 2
      },
      "lineNbr": 294,
      "author": {
        "id": 1130490
      },
      "writtenOn": "2017-09-11T14:14:37Z",
      "side": 0,
      "message": "\u003e So when we receive OnSurfaceDestroyed(overlay1) we won\u0027t do anything. \n\noh, yeah, you\u0027re right.  probably worth a comment, since it\u0027s not obvious that we might be called with |overlay| \u003d\u003d some old overlay, in any case.\n\n\u003e MCVDs CodecImages don\u0027t hold a ref to the overlay.\n\nAVDACodecImage \u003d\u003e shared state \u003d\u003e current surfacebundle.  they use it to position the overlay in SOP, and to keep a ref to it.\n\nin response to onSurfaceDestroyed, i think we would still need to clear them from images, though.  while there\u0027s no deadlock issues anymore, we still want to release the overlay so that the overlay thread in the browser isn\u0027t blocked indefinitely waiting for us to finish up.  plus, i\u0027m not sure that android will wait forever if the OSD was caused by low resources on the device.\n\nmaybe i should add an explicit \u0027destroy\u0027 call to AndroidOverlay that MCVD could call after setSurface() in OSD, so that cleanup is still fast.  then the images can retain the overlay mojo client object if they like.  crbug.com/763930 .\n\nwe\u0027ll also need the timeout in the browser\u0027s actually-from-android OSD for the \"no setSurface\" case, since that sends the bundle through the allocator thread during teardown,  there\u0027s no guarantee that it\u0027ll complete.  hrm, AVDA probably needs that in M62.  crbug.com/763929 .",
      "parentUuid": "a70505ab_9b9ae870",
      "revId": "448db961b97d3b0eca418ca5130df4134b224aae",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40eab8c0_7e32ca9e",
        "filename": "media/gpu/android/media_codec_video_decoder.cc",
        "patchSetId": 2
      },
      "lineNbr": 294,
      "author": {
        "id": 1130490
      },
      "writtenOn": "2017-09-11T15:02:15Z",
      "side": 0,
      "message": "\u003e e\u0027ll also need the timeout in the browser\u0027s actually-from-android OSD\n\u003e for the \"no setSurface\" case\n\nwait -- why did i just explain your own code to you?  :)\n\nsorry!  i\u0027ll go add the CodecAllocator timeout to AndroidOverlay now.",
      "parentUuid": "de150864_878c88be",
      "revId": "448db961b97d3b0eca418ca5130df4134b224aae",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ef83b94_e992add1",
        "filename": "media/gpu/avda_codec_allocator.cc",
        "patchSetId": 2
      },
      "lineNbr": 312,
      "author": {
        "id": 1130490
      },
      "writtenOn": "2017-09-08T14:41:50Z",
      "side": 0,
      "message": "the purpose of this comment was to prevent \"hey! nobody\u0027s using |surface_bundle|, so let\u0027s not pass it around!\" in the future.  i think some sort of comment to that effect is a good idea.  maybe it should be more direct than it was.",
      "revId": "448db961b97d3b0eca418ca5130df4134b224aae",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}