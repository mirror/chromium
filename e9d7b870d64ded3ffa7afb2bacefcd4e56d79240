{
  "comments": [
    {
      "key": {
        "uuid": "f1f0c5a0_85ee2933",
        "filename": "chrome/browser/extensions/install_verifier_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1223356
      },
      "writtenOn": "2017-12-14T04:24:35Z",
      "side": 1,
      "message": "If you decide to follow the parametrized test comment below, it would be easier to test a single thing per method (IsFromStore or MustRemainDisabled) instead of two things at once.\n\nI suggest 4 parametrized tests:\nTestIsFromStore\nTestIsNotFromStore\nTestMustRemainDisabled\nTestCanRemainEnabled\n\nEach of the test uses the matching \u003clocation, update_url\u003e pairs.",
      "range": {
        "startLine": 56,
        "startChar": 65,
        "endLine": 56,
        "endChar": 66
      },
      "revId": "e9d7b870d64ded3ffa7afb2bacefcd4e56d79240",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4ba62b4_8cdc12f6",
        "filename": "chrome/browser/extensions/install_verifier_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 75,
      "author": {
        "id": 1223356
      },
      "writtenOn": "2017-12-14T04:24:35Z",
      "side": 1,
      "message": "This screams parametrized test. \nMaybe it\u0027s worth splitting this into two parametrized tests (TestIsFromStoreAndMustRemainDisabled vs TestIsFromStoreAndCanRemainEnabled) which call a common method (something like \"void VerifyMustRemainDisabled(const Extension* extension, boolean expect_remains_disabled)\") with different values of expect_remains_disabled.\n\nExample parametrized test: https://cs.chromium.org/chromium/src/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_browsertest_win.cc?l\u003d785\u0026rcl\u003da4ee7012ac4d2103ed1a891d61c618b18828b973",
      "range": {
        "startLine": 75,
        "startChar": 20,
        "endLine": 75,
        "endChar": 0
      },
      "revId": "e9d7b870d64ded3ffa7afb2bacefcd4e56d79240",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5dddbc0_e5461c4a",
        "filename": "chrome/browser/extensions/install_verifier_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 75,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-12-14T14:33:05Z",
      "side": 1,
      "message": "Hmm... parameterized tests are great for some things (they\u0027ve saved me so much time when writing tests that are meant to pass with/without experiments!), but I actually think that a parameterized test greatly reduces readability here.  With a parameterized test, it\u0027s something like:\n\nCreateExtension() {\n  ExtensionBuilder extension_builder(\"extension\");\n  extension_builder.SetLocation(GetParam().first);\n  if (GetParam().second) {\n    extension_builder.MergeManifest(\n        DictionaryBuilder()\n            .Set(\"update_url\", GetParam().second-\u003espec())\n            .Build());\n  }\n  return extension_builder.Build();\n}\n\nTEST_P(..., IsFromStore) {\n  CreateExtension();\n  EXPECT_TRUE(InstallVerifier::IsFromStore());\n}\n\nTEST_P(..., NotFromStore) {\n  CreateExtension();\n  EXPECT_FALSE(InstallVerifier::IsFromStore());\n}\n\n...\n\nINSTANTIATE_TEST_CASE_P(InternalFromStore,\n                        InstallVerifierTest,\n                        ::testing::Values(std::make_pair(INTERNAL, GURL(kStoreUrl)));\nINSTANTIATE_TEST_CASE_P(InternalNotFromStore,\n                        InstallVerifierTest,\n                        ::testing::Values(std::make_pair(INTERNAL, GURL(kNonStoreUrl)));\n\n....\n\nAnd then we have to instantiate each of the test cases (you suggested four) four times each (to account for various combinations of location/update url), leading to 16 opaque (IMO) instantiations that make the assumptions hard to reason about.\n\nI find the \"test_case\" version here much more readable, because it puts all the code proximal to the location of the assumptions, and doesn\u0027t require the reader to understand the entire test file (helper functions, the test, the test instantiations) to then grok the assertions the test is verifying.  Additionally, it\u0027s much easier (IMO) to spot omitted or missing values.\n\nUnless you feel strongly about this, I\u0027d really prefer to keep it this way.\n\n(Istiaque, if you have preferences one way or the other, let us know!)",
      "parentUuid": "f4ba62b4_8cdc12f6",
      "range": {
        "startLine": 75,
        "startChar": 20,
        "endLine": 75,
        "endChar": 0
      },
      "revId": "e9d7b870d64ded3ffa7afb2bacefcd4e56d79240",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c4df57f_5048bf37",
        "filename": "chrome/browser/extensions/install_verifier_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 75,
      "author": {
        "id": 1223356
      },
      "writtenOn": "2017-12-14T15:05:22Z",
      "side": 1,
      "message": "\u003e And then we have to instantiate each of the test cases (you suggested four) four times each (to account for various combinations of location/update url), leading to 16 opaque (IMO) instantiations that make the assumptions hard to reason about.\n\nI think there\u0027s a way to instantiate the four test cases only once. ::testing::Values(INTERNAL, UNPACKED, EXTERNAL_POLICY_DOWNLOAD) implicitly creates 3 instantiation of the test. The instantiate statements would look like this:\n\nINSTANTIATE_TEST_CASE_P(TestIsFromStore,\n                        InstallVerifierIsFromStoreTest,\n                        ::testing::Combine(\n                          ::testing::Values(INTERNAL, UNPACKED, EXTERNAL_POLICY_DOWNLOAD),\n                          ::testing::Values(GURL(kStoreUrl))));\n\n\nINSTANTIATE_TEST_CASE_P(TestIsNotFromStore,\n                        InstallVerifierIsNotFromStoreTest,\n                        ::testing::Combine(\n                          ::testing::Values(INTERNAL, UNPACKED, EXTERNAL_POLICY_DOWNLOAD),\n                          ::testing::Values(GURL(kNonStoreUrl), base::nullopt)));\n\n\nINSTANTIATE_TEST_CASE_P(TestShouldRemainDisabled,\n                        InstallVerifierMustRemainDisabledTest,\n                        ::testing::Combine(\n                          ::testing::Values(INTERNAL),\n                          ::testing::Values(GURL(kNonStoreUrl), base::nullopt)));\n\n\nINSTANTIATE_TEST_CASE_P(TestCanRemainEnabledNotInternal,\n                        InstallVerifierCanRemainEnabledTest,\n                        ::testing::Combine(\n                          ::testing::Values(UNPACKED, EXTERNAL_POLICY_DOWNLOAD),\n                          ::testing::Values(GURL(kStoreUrl), GURL(kNonStoreUrl), base::nullopt)));\n\nINSTANTIATE_TEST_CASE_P(TestCanRemainEnabledInternal,\n                        InstallVerifierCanRemainEnabledTest,\n                        ::testing::Combine(\n                          ::testing::Values(INTERNAL),\n                          ::testing::Values(GURL(kStoreUrl)));\n\nIt\u0027s indeed quite difficult to spot omitted or missing values. Feel free to keep your existing implementation of the tests.",
      "parentUuid": "e5dddbc0_e5461c4a",
      "range": {
        "startLine": 75,
        "startChar": 20,
        "endLine": 75,
        "endChar": 0
      },
      "revId": "e9d7b870d64ded3ffa7afb2bacefcd4e56d79240",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}