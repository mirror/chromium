{
  "comments": [
    {
      "key": {
        "uuid": "1aab16f4_ef11f57b",
        "filename": "gpu/command_buffer/service/preemption_flag.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-06-27T00:40:31Z",
      "side": 1,
      "message": "I think Set/Reset should be memory_order_release, and IsSet should be memory_order_acquire.\n\nBasically on the IO thread we add a bunch of tasks to a list under lock, and set the flag. On the main thread, we test the flag and if set we (may) look at the list of tasks, under lock as well, and expect the tasks to be there. Without the memory order, the main thread could see the flag set but no task in the list.\n\nThat said, the data race is fairly harmless (as much as one can be), we\u0027ll always see a self-consistent task list (because of the lock), and worst case  we may preempt a channel spuriously and resume it without executing preempting tasks. The next time we look at the flag it should be set consistently thanks to the locks.\n\nStill, I don\u0027t see a reason not to use proper memory order. IsSet (which is called often) was already using acquire, so there shouldn\u0027t be any regression there. Set and Reset are seldom called, and the cost of the memory order should be dwarfed by the cost of the posted tasks to execute them anyway.",
      "revId": "2933cfe5b266cb371203c632c3288a19c1056e2b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "226e6e83_c00d08f7",
        "filename": "gpu/command_buffer/service/preemption_flag.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-06-27T17:15:03Z",
      "side": 1,
      "message": "\u003e I think Set/Reset should be memory_order_release, and IsSet should be memory_order_acquire.\n\u003e \n\u003e Basically on the IO thread we add a bunch of tasks to a list under lock, and set the flag. On the main thread, we test the flag and if set we (may) look at the list of tasks, under lock as well, and expect the tasks to be there. Without the memory order, the main thread could see the flag set but no task in the list.\n\u003e \n\u003e That said, the data race is fairly harmless (as much as one can be), we\u0027ll always see a self-consistent task list (because of the lock), and worst case  we may preempt a channel spuriously and resume it without executing preempting tasks. The next time we look at the flag it should be set consistently thanks to the locks.\n\nRight. I don\u0027t believe it\u0027s actually a data race, but it may be surprising.\n\n\u003e Still, I don\u0027t see a reason not to use proper memory order. IsSet (which is called often) was already using acquire, so there shouldn\u0027t be any regression there. Set and Reset are seldom called, and the cost of the memory order should be dwarfed by the cost of the posted tasks to execute them anyway.\n\nHappy to agree. I\u0027d mostly defaulted to preserving the previous memory order semantics, but agree that acq/rel is more intuitive here and unlikely to have an adverse performance impact. (And having that discussion is why you\u0027re an excellent reviewer for this CL. :D)",
      "parentUuid": "1aab16f4_ef11f57b",
      "revId": "2933cfe5b266cb371203c632c3288a19c1056e2b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}