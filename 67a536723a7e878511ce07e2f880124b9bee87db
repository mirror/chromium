{
  "comments": [
    {
      "key": {
        "uuid": "bec79897_96cd7671",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1145120
      },
      "writtenOn": "2017-08-11T17:58:16Z",
      "side": 1,
      "message": "Sorry, I can\u0027t understand how this works. sDeduplicationCache contains weak refs to the bitmap while sBitmapCache contains the actual bitmap. What happens when the weak ref is collected? Can you explain this a bit?\nThanks.",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d95c2cce_c4ac2755",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-08-14T10:31:57Z",
      "side": 1,
      "message": "Yes, sorry, I had written more Javadoc locally, and then managed to accidentally revert it :-(\n\nsBitmapCache contains strong references to the bitmaps, so they will never be garbage collected while they\u0027re still in the bitmap cache. The weak references in sDeduplicationCache however don\u0027t keep a bitmap from being garbage collected... _assuming there are no strong references to it_. So as soon as a bitmap is evicted from the bitmap cache (and it\u0027s not used somewhere else, like in the UI), the bitmap is eligible for garbage collection even if there is still a WeakReference to it in the deduplication cache. If it does get garbage collected, that WeakReference is nulled out so we know to remove it next time we compact the cache. This means we can use the deduplication cache to make sure we never have two (reachable) copies of the same bitmap in memory. See also https://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html#package_description (which calls this canonicalization).",
      "parentUuid": "bec79897_96cd7671",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b827846_6e5cfe26",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1145120
      },
      "writtenOn": "2017-08-15T18:04:55Z",
      "side": 1,
      "message": "Thanks. Still I don\u0027t understand this, so a few more questions :). \nWhy do we need the deduplication cache?\nUnder memory pressure, you call evictAll(), which should clear the cache. Shouldn\u0027t that be sufficient to release all the memory occupied by the bitmaps (unless the bitmap is being used by some page at this moment)?",
      "parentUuid": "d95c2cce_c4ac2755",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "167f3e9e_71926119",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-08-15T18:49:05Z",
      "side": 1,
      "message": "Yes, under memory pressure we will drop all bitmaps, but the deduplication cache reduces the memory footprint even before that, which in turns helps avoid memory pressure in the first place :) Basically, having identical copies of the same bitmap in memory is completely unnecessary, so this lets us avoid this, to reduce memory usage without affecting performance or user-visible impact (like dropping the LRU cache).",
      "parentUuid": "7b827846_6e5cfe26",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "695b1863_03fe95d3",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Is the purpose of sBitmapCache, then, to hold on to bitmaps that aren\u0027t actively being used but may be used again soon e.g. while scrolling through a RecyclerView?\n\nWhen this class was only used by downloads, we could destroy the entire cache as soon as downloads was closed. Now that this is being used for Suggestions as well, do we still have a mechanism for clearing out all of the cached bitmaps for a destroyed surface?",
      "parentUuid": "167f3e9e_71926119",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6cb4a097_d84c1734",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:13:25Z",
      "side": 1,
      "message": "Also, with regard to duplicate bitmaps in memory... The current sBitmapCache doesn\u0027t protect against duplicates? Is there an easy example of when we would end up with duplicate bitmaps in memory currently?",
      "parentUuid": "695b1863_03fe95d3",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b7bdd53_548799d0",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Iterating through the entire deduplicate cache each time a bitmap is retrieved seems a bit gratuitous. Perhaps we could compact after a thumbnail retrieval if there are no more requests to process?",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "343ac651_a4c6a0ce",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Should we compact the deduplicate cache here too?",
      "range": {
        "startLine": 202,
        "startChar": 32,
        "endLine": 202,
        "endChar": 0
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}