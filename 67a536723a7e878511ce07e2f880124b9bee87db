{
  "comments": [
    {
      "key": {
        "uuid": "bec79897_96cd7671",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1145120
      },
      "writtenOn": "2017-08-11T17:58:16Z",
      "side": 1,
      "message": "Sorry, I can\u0027t understand how this works. sDeduplicationCache contains weak refs to the bitmap while sBitmapCache contains the actual bitmap. What happens when the weak ref is collected? Can you explain this a bit?\nThanks.",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d95c2cce_c4ac2755",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-08-14T10:31:57Z",
      "side": 1,
      "message": "Yes, sorry, I had written more Javadoc locally, and then managed to accidentally revert it :-(\n\nsBitmapCache contains strong references to the bitmaps, so they will never be garbage collected while they\u0027re still in the bitmap cache. The weak references in sDeduplicationCache however don\u0027t keep a bitmap from being garbage collected... _assuming there are no strong references to it_. So as soon as a bitmap is evicted from the bitmap cache (and it\u0027s not used somewhere else, like in the UI), the bitmap is eligible for garbage collection even if there is still a WeakReference to it in the deduplication cache. If it does get garbage collected, that WeakReference is nulled out so we know to remove it next time we compact the cache. This means we can use the deduplication cache to make sure we never have two (reachable) copies of the same bitmap in memory. See also https://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html#package_description (which calls this canonicalization).",
      "parentUuid": "bec79897_96cd7671",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b827846_6e5cfe26",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1145120
      },
      "writtenOn": "2017-08-15T18:04:55Z",
      "side": 1,
      "message": "Thanks. Still I don\u0027t understand this, so a few more questions :). \nWhy do we need the deduplication cache?\nUnder memory pressure, you call evictAll(), which should clear the cache. Shouldn\u0027t that be sufficient to release all the memory occupied by the bitmaps (unless the bitmap is being used by some page at this moment)?",
      "parentUuid": "d95c2cce_c4ac2755",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "167f3e9e_71926119",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-08-15T18:49:05Z",
      "side": 1,
      "message": "Yes, under memory pressure we will drop all bitmaps, but the deduplication cache reduces the memory footprint even before that, which in turns helps avoid memory pressure in the first place :) Basically, having identical copies of the same bitmap in memory is completely unnecessary, so this lets us avoid this, to reduce memory usage without affecting performance or user-visible impact (like dropping the LRU cache).",
      "parentUuid": "7b827846_6e5cfe26",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "695b1863_03fe95d3",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Is the purpose of sBitmapCache, then, to hold on to bitmaps that aren\u0027t actively being used but may be used again soon e.g. while scrolling through a RecyclerView?\n\nWhen this class was only used by downloads, we could destroy the entire cache as soon as downloads was closed. Now that this is being used for Suggestions as well, do we still have a mechanism for clearing out all of the cached bitmaps for a destroyed surface?",
      "parentUuid": "167f3e9e_71926119",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6cb4a097_d84c1734",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:13:25Z",
      "side": 1,
      "message": "Also, with regard to duplicate bitmaps in memory... The current sBitmapCache doesn\u0027t protect against duplicates? Is there an easy example of when we would end up with duplicate bitmaps in memory currently?",
      "parentUuid": "695b1863_03fe95d3",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ef00c5d_1cfd256e",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-06T14:42:26Z",
      "side": 1,
      "message": "\u003e Is the purpose of sBitmapCache, then, to hold on to bitmaps that aren\u0027t actively being used but may be used again soon e.g. while scrolling through a RecyclerView?\n\nYes, exactly.\n\n\u003e When this class was only used by downloads, we could destroy the entire cache as soon as downloads was closed. Now that this is being used for Suggestions as well, do we still have a mechanism for clearing out all of the cached bitmaps for a destroyed surface?\n\nHm, good point. On trunk we don\u0027t actually clear the cache when destroying the object, because it\u0027s static (only the requests, handler and native pointer are members), but with the deduplication cache we can actually have a LRU cache per instance, because we\u0027re not going to end up with duplicate bitmaps anyway :) It does make dropping the cache under memory pressure a bit more complicated though, because then _that_ is not static anymore. I\u0027m passing in a DiscardableReferencePool now, and draining it in ChromeApplication.\n\n\u003e Also, with regard to duplicate bitmaps in memory... The current sBitmapCache doesn\u0027t protect against duplicates? Is there an easy example of when we would end up with duplicate bitmaps in memory currently?\n\n1) Client A requests a bitmap, bitmap is returned to client and added to cache.\n2) GC happens. Because the LruCache is only referenced by a WeakReference, it gets garbage-collected and the WeakReference is cleared. The bitmap itself is not garbage-collected, because client A still has a strong reference to it.\n3) Client B requests the same bitmap. The WeakReference is empty, so a new empty LruCache is constructed, a new bitmap is fetched and returned to the client, and added to the cache.",
      "parentUuid": "6cb4a097_d84c1734",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2cc20ce_19c655ed",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-06T20:11:32Z",
      "side": 1,
      "message": "In the duplication example, while I agree this is technically possible, particularly in multi-window where a user may have two instances running of downloads running (for example), I doubt this occurs (often) in the wild. Typically Client A will be suggestions and Client B will be downloads and they won\u0027t be requesting the same bitmaps, right?",
      "parentUuid": "6ef00c5d_1cfd256e",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b7bdd53_548799d0",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Iterating through the entire deduplicate cache each time a bitmap is retrieved seems a bit gratuitous. Perhaps we could compact after a thumbnail retrieval if there are no more requests to process?",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b02dbda_879f01e5",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-06T14:42:26Z",
      "side": 1,
      "message": "OK, I\u0027ve moved this to processNextRequest() into an IdleHandler, to give the garbage collection a chance to run.",
      "parentUuid": "7b7bdd53_548799d0",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89b02bdf_dfd5f369",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-06T20:11:32Z",
      "side": 1,
      "message": "Can we remove compactDeduplicationCache here, then, or is it still needed?",
      "parentUuid": "5b02dbda_879f01e5",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "343ac651_a4c6a0ce",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Should we compact the deduplicate cache here too?",
      "range": {
        "startLine": 202,
        "startChar": 32,
        "endLine": 202,
        "endChar": 0
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a376dd7d_1d54c8ab",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-06T14:42:26Z",
      "side": 1,
      "message": "I\u0027m not sure that would be that helpful â€“ if we call this method because of a memory pressure signal, usually garbage collection will happen _after_ the signal has been handled (to collect objects that have been dropped). I also don\u0027t think the empty WeakReferences in the non-compacted cache will take up significant memory compared to the Bitmaps, so I\u0027m tempted to work on the principle that the main advantage of compaction is not to save memory, but to keep performance of the data structure from degrading.",
      "parentUuid": "343ac651_a4c6a0ce",
      "range": {
        "startLine": 202,
        "startChar": 32,
        "endLine": 202,
        "endChar": 0
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eae16455_03ef6808",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-06T20:11:32Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a376dd7d_1d54c8ab",
      "range": {
        "startLine": 202,
        "startChar": 32,
        "endLine": 202,
        "endChar": 0
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}