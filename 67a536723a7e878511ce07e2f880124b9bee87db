{
  "comments": [
    {
      "key": {
        "uuid": "bec79897_96cd7671",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1145120
      },
      "writtenOn": "2017-08-11T17:58:16Z",
      "side": 1,
      "message": "Sorry, I can\u0027t understand how this works. sDeduplicationCache contains weak refs to the bitmap while sBitmapCache contains the actual bitmap. What happens when the weak ref is collected? Can you explain this a bit?\nThanks.",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d95c2cce_c4ac2755",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-08-14T10:31:57Z",
      "side": 1,
      "message": "Yes, sorry, I had written more Javadoc locally, and then managed to accidentally revert it :-(\n\nsBitmapCache contains strong references to the bitmaps, so they will never be garbage collected while they\u0027re still in the bitmap cache. The weak references in sDeduplicationCache however don\u0027t keep a bitmap from being garbage collected... _assuming there are no strong references to it_. So as soon as a bitmap is evicted from the bitmap cache (and it\u0027s not used somewhere else, like in the UI), the bitmap is eligible for garbage collection even if there is still a WeakReference to it in the deduplication cache. If it does get garbage collected, that WeakReference is nulled out so we know to remove it next time we compact the cache. This means we can use the deduplication cache to make sure we never have two (reachable) copies of the same bitmap in memory. See also https://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html#package_description (which calls this canonicalization).",
      "parentUuid": "bec79897_96cd7671",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b827846_6e5cfe26",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1145120
      },
      "writtenOn": "2017-08-15T18:04:55Z",
      "side": 1,
      "message": "Thanks. Still I don\u0027t understand this, so a few more questions :). \nWhy do we need the deduplication cache?\nUnder memory pressure, you call evictAll(), which should clear the cache. Shouldn\u0027t that be sufficient to release all the memory occupied by the bitmaps (unless the bitmap is being used by some page at this moment)?",
      "parentUuid": "d95c2cce_c4ac2755",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "167f3e9e_71926119",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-08-15T18:49:05Z",
      "side": 1,
      "message": "Yes, under memory pressure we will drop all bitmaps, but the deduplication cache reduces the memory footprint even before that, which in turns helps avoid memory pressure in the first place :) Basically, having identical copies of the same bitmap in memory is completely unnecessary, so this lets us avoid this, to reduce memory usage without affecting performance or user-visible impact (like dropping the LRU cache).",
      "parentUuid": "7b827846_6e5cfe26",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "695b1863_03fe95d3",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Is the purpose of sBitmapCache, then, to hold on to bitmaps that aren\u0027t actively being used but may be used again soon e.g. while scrolling through a RecyclerView?\n\nWhen this class was only used by downloads, we could destroy the entire cache as soon as downloads was closed. Now that this is being used for Suggestions as well, do we still have a mechanism for clearing out all of the cached bitmaps for a destroyed surface?",
      "parentUuid": "167f3e9e_71926119",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6cb4a097_d84c1734",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:13:25Z",
      "side": 1,
      "message": "Also, with regard to duplicate bitmaps in memory... The current sBitmapCache doesn\u0027t protect against duplicates? Is there an easy example of when we would end up with duplicate bitmaps in memory currently?",
      "parentUuid": "695b1863_03fe95d3",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ef00c5d_1cfd256e",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-06T14:42:26Z",
      "side": 1,
      "message": "\u003e Is the purpose of sBitmapCache, then, to hold on to bitmaps that aren\u0027t actively being used but may be used again soon e.g. while scrolling through a RecyclerView?\n\nYes, exactly.\n\n\u003e When this class was only used by downloads, we could destroy the entire cache as soon as downloads was closed. Now that this is being used for Suggestions as well, do we still have a mechanism for clearing out all of the cached bitmaps for a destroyed surface?\n\nHm, good point. On trunk we don\u0027t actually clear the cache when destroying the object, because it\u0027s static (only the requests, handler and native pointer are members), but with the deduplication cache we can actually have a LRU cache per instance, because we\u0027re not going to end up with duplicate bitmaps anyway :) It does make dropping the cache under memory pressure a bit more complicated though, because then _that_ is not static anymore. I\u0027m passing in a DiscardableReferencePool now, and draining it in ChromeApplication.\n\n\u003e Also, with regard to duplicate bitmaps in memory... The current sBitmapCache doesn\u0027t protect against duplicates? Is there an easy example of when we would end up with duplicate bitmaps in memory currently?\n\n1) Client A requests a bitmap, bitmap is returned to client and added to cache.\n2) GC happens. Because the LruCache is only referenced by a WeakReference, it gets garbage-collected and the WeakReference is cleared. The bitmap itself is not garbage-collected, because client A still has a strong reference to it.\n3) Client B requests the same bitmap. The WeakReference is empty, so a new empty LruCache is constructed, a new bitmap is fetched and returned to the client, and added to the cache.",
      "parentUuid": "6cb4a097_d84c1734",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2cc20ce_19c655ed",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-06T20:11:32Z",
      "side": 1,
      "message": "In the duplication example, while I agree this is technically possible, particularly in multi-window where a user may have two instances running of downloads running (for example), I doubt this occurs (often) in the wild. Typically Client A will be suggestions and Client B will be downloads and they won\u0027t be requesting the same bitmaps, right?",
      "parentUuid": "6ef00c5d_1cfd256e",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dec8f9ba_4d6193ba",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-07T12:28:06Z",
      "side": 1,
      "message": "Article suggestions don\u0027t go through this at all, because their thumbnails are stored in a database and/or fetched from the network. Download suggestions (which only exist pre-CH) would request the same bitmaps iff the thumbnails are shown at the same size as downloads.\n\nI\u0027m a bit wary about making assumptions about the likelihood of situations like these though -- I\u0027ve been bitten too much in the past by assuming something that isn\u0027t likely is not going to happen, or is not likely enough to worry about. Deduplication keeps the number of bitmaps the same or reduces them, with negligible overhead, so I think using it is a win over not using it.",
      "parentUuid": "d2cc20ce_19c655ed",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f30209fc_45345251",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-07T15:33:27Z",
      "side": 1,
      "message": "I agree that we should devise good caching strategy and that avoiding duplicate bitmaps is a win. We are introducing code complexity, so I want to understand the magnitude of the potential positive impacts.\n\nEach client having it\u0027s own LRU Cache that can be destroyed when its ThumbnailProviderImpl is destroyed (or that can be drained separately) is great, so I\u0027m happy to see that coupled with this change.\n\nIf article suggestions don\u0027t go through ThumbnailProviderImpl at all, then this won\u0027t have an impact on the memory for SuggestionsBottomSheetContent?",
      "parentUuid": "dec8f9ba_4d6193ba",
      "range": {
        "startLine": 53,
        "startChar": 1,
        "endLine": 53,
        "endChar": 2
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b7bdd53_548799d0",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Iterating through the entire deduplicate cache each time a bitmap is retrieved seems a bit gratuitous. Perhaps we could compact after a thumbnail retrieval if there are no more requests to process?",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b02dbda_879f01e5",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-06T14:42:26Z",
      "side": 1,
      "message": "OK, I\u0027ve moved this to processNextRequest() into an IdleHandler, to give the garbage collection a chance to run.",
      "parentUuid": "7b7bdd53_548799d0",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89b02bdf_dfd5f369",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-06T20:11:32Z",
      "side": 1,
      "message": "Can we remove compactDeduplicationCache here, then, or is it still needed?",
      "parentUuid": "5b02dbda_879f01e5",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5228398c_f7b6705c",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-07T12:28:06Z",
      "side": 1,
      "message": "Duh... removed.",
      "parentUuid": "89b02bdf_dfd5f369",
      "range": {
        "startLine": 171,
        "startChar": 16,
        "endLine": 171,
        "endChar": 44
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "343ac651_a4c6a0ce",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-05T16:01:32Z",
      "side": 1,
      "message": "Should we compact the deduplicate cache here too?",
      "range": {
        "startLine": 202,
        "startChar": 32,
        "endLine": 202,
        "endChar": 0
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a376dd7d_1d54c8ab",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-09-06T14:42:26Z",
      "side": 1,
      "message": "I\u0027m not sure that would be that helpful – if we call this method because of a memory pressure signal, usually garbage collection will happen _after_ the signal has been handled (to collect objects that have been dropped). I also don\u0027t think the empty WeakReferences in the non-compacted cache will take up significant memory compared to the Bitmaps, so I\u0027m tempted to work on the principle that the main advantage of compaction is not to save memory, but to keep performance of the data structure from degrading.",
      "parentUuid": "343ac651_a4c6a0ce",
      "range": {
        "startLine": 202,
        "startChar": 32,
        "endLine": 202,
        "endChar": 0
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eae16455_03ef6808",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/download/ui/ThumbnailProviderImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1122966
      },
      "writtenOn": "2017-09-06T20:11:32Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a376dd7d_1d54c8ab",
      "range": {
        "startLine": 202,
        "startChar": 32,
        "endLine": 202,
        "endChar": 0
      },
      "revId": "67a536723a7e878511ce07e2f880124b9bee87db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}