{
  "comments": [
    {
      "key": {
        "uuid": "112a7b90_9a2e4667",
        "filename": "cc/trees/layer_tree_host_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 1645,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-06T01:28:44Z",
      "side": 1,
      "message": "Does this need to be a flat_set? I think client tokens are all distinct (even more strongly so if you use source_frame_numbers, see comment in proxy_main.cc), so a std::vector would suffice.",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a1cc369_9207acab",
        "filename": "cc/trees/layer_tree_host_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 1662,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-06T01:28:44Z",
      "side": 1,
      "message": "Would this really happen though? We set a different presentation_token every time, so the only reason this would happen is if DidPresentCompositorFrame is called out-of-order relative to presentation_tokens.\n\nI don\u0027t think this can happen, but if it did, I think the logic here would be insufficient, because we would send the wrong time for frames that received their corresponding DidPresentCompositorFrame late.",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43968bff_8f6df498",
        "filename": "cc/trees/layer_tree_host_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 1667,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-06T01:28:44Z",
      "side": 1,
      "message": "nit: because you iterate over in_flight_presentation_time_tokens_ in key order on the first for loop (l.1646), I think you can keep the iter around, and just do in_flight_presentation_time_tokens_.erase(in_flight_presentation_time_tokens_.begin(), iter) here. It also means that you don\u0027t need to_remove any more.",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17d7810f_719ba80c",
        "filename": "cc/trees/layer_tree_host_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 1763,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-06T01:28:44Z",
      "side": 1,
      "message": "nit: make that a CHECK. The code doesn\u0027t strictly ensure this can\u0027t happen (e.g. chrome running for 3 years submitting frames at 60fps will wrap this), and we don\u0027t handle wrapping, so it\u0027s probably better to just terminate.",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "542e54f4_52eec556",
        "filename": "cc/trees/layer_tree_host_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 1763,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2017-12-06T23:26:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "17d7810f_719ba80c",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a76a2f1f_5c2a7e48",
        "filename": "cc/trees/layer_tree_host_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 1774,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-06T01:28:44Z",
      "side": 1,
      "message": "nit: ditto.",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0779a4ac_d9b46f76",
        "filename": "cc/trees/proxy_main.cc",
        "patchSetId": 4
      },
      "lineNbr": 394,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-06T01:28:44Z",
      "side": 1,
      "message": "Rather than posting a task, could this be done as part of the commit?\n1- avoids out-of-order callbacks. As is, you might get a callback for a frame that didn\u0027t commit yet, so it gives you misleading information\n2- may simplify the token management a bit because you can coalesce. In LayerTreeHost you\u0027d keep a list of callbacks per source_frame_number_, so you have at most 1 \"source\" token per frame, so you don\u0027t need a map of sets in LTHI\n3- saves task overhead.\n\nThe idea would be to just keep a \"bool request_presentation_time\" in LayerTreeImpl that would be set in LayerTreeHost::FinishCommitOnImplThread if there are any callbacks in LTH, and then LayerTreeHostImpl::MakeCompositorFrameMetadata can look at the active tree\u0027s request_presentation_time and if set, generate a presentation token and map it to the active tree\u0027s source_frame_number.\n\nThen on the way back, you can send the list of source_frame_number in DidPresentCompositorFrame, and look up the list of callbacks from there.\n\nProbably less code too overall.",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc9fc614_5b3b3b56",
        "filename": "cc/trees/proxy_main.cc",
        "patchSetId": 4
      },
      "lineNbr": 394,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2017-12-06T23:26:57Z",
      "side": 1,
      "message": "Ok, I think I got this. Take another look?",
      "parentUuid": "0779a4ac_d9b46f76",
      "revId": "4eeab50e29c57da871f64ec40c6e79b30d054d9c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}