{
  "comments": [
    {
      "key": {
        "uuid": "8424dbdc_5591c455",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "why? they take no memory/space, and we don\u0027t care about improving ASLR for profiling runs. Do you want to guard against regressions in compiler post-inlining logic this way?\n\nI don\u0027t mind doing it, just asking for the motivation, and attempting to reduce TODOs.",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 45,
        "endChar": 74
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13db3dcd_37698452",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "1000 * 1000",
      "range": {
        "startLine": 48,
        "startChar": 32,
        "endLine": 48,
        "endChar": 35
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bb15297_a1e33c1b",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "parse failed. Looks too clever, I think this would be clearer as a toplevel description of the datastructures: \"concurrent bitset and a concurrent append-only list of offsets\"?",
      "range": {
        "startLine": 50,
        "startChar": 54,
        "endLine": 51,
        "endChar": 45
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5adb6cd_3f43d7a3",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "commenting when not having read in full: not sure why something would be lost. Something can be written from other threads while we are disabling, but we start dumping after full memory barrier (even: on the same thread that was disabling the dumps), hence everything that happened before we started disabling will definitely be included into the dump.",
      "range": {
        "startLine": 68,
        "startChar": 53,
        "endLine": 68,
        "endChar": 57
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d055e13_937a162e",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "s/s/d/",
      "range": {
        "startLine": 90,
        "startChar": 41,
        "endLine": 90,
        "endChar": 42
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbe82eb9_f2be66e8",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "Disable+LOG is smart, thanks!",
      "range": {
        "startLine": 97,
        "startChar": 4,
        "endLine": 97,
        "endChar": 14
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f35dbab6_752bf529",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "a line below also depends on sizeof(int), so maybe just compile_assert(sizeof(int) \u003d\u003d 4) and then use 4?",
      "range": {
        "startLine": 102,
        "startChar": 26,
        "endLine": 102,
        "endChar": 37
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14497aba_9d9fe182",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "This makes non-atomic memory writes, then full barrier (non-C++-standard-kind). Hm.\n\nWhile this probably works on all platforms, it tests the boundaries of the memory model definitions :) It does not depend much on base::subtle subtleties, but puts them in sight, which makes for a more nervous reading.\n\nCan we just make g_ordered_offsets atomic, and avoid the barrier entirely? We allow loosing things, and effectively we will not loose much more, the base::File is slow, after all.",
      "range": {
        "startLine": 127,
        "startChar": 2,
        "endLine": 127,
        "endChar": 52
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09f009eb_be34444a",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "curious: are there many zeroes in practice?",
      "range": {
        "startLine": 145,
        "startChar": 74,
        "endLine": 146,
        "endChar": 29
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9971f350_092f7a5f",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 167,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "I am wondering whether it would be useful to prefix the pid with nanoseconds since epoch (of dump time or process creation time). With such timestamp we would know that the browser is the one that started first. With only having pid this is more flaky. Occasionally pid counter overflows. While writing this I realized .. we can actually use the process name here (available in flags).\n\nNot in this change. Should I add it to the todo list?",
      "range": {
        "startLine": 167,
        "startChar": 10,
        "endLine": 167,
        "endChar": 18
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ef1cda4_2dba7a63",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "please move the comment to the definition of RecordAddress()",
      "range": {
        "startLine": 188,
        "startChar": 2,
        "endLine": 189,
        "endChar": 27
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bf15325_3c2062fc",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 190,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "no need to create a separate local var here",
      "range": {
        "startLine": 190,
        "startChar": 8,
        "endLine": 190,
        "endChar": 22
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8ba709f_b7c16d2b",
        "filename": "tools/cygprofile/lightweight_cygprofile.cc",
        "patchSetId": 1
      },
      "lineNbr": 203,
      "author": {
        "id": 1000429
      },
      "writtenOn": "2017-11-21T18:56:58Z",
      "side": 1,
      "message": "nit: why are the hooks in anonymous namespace? Good to know that it works this way, but moving them out would be cleaner.",
      "range": {
        "startLine": 203,
        "startChar": 3,
        "endLine": 203,
        "endChar": 15
      },
      "revId": "a1132015ca15b24bd773f3ad06cad7dbae175308",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}