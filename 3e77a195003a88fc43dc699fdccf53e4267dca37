{
  "comments": [
    {
      "key": {
        "uuid": "a8e9ea60_771b8ffc",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 165,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-16T14:52:54Z",
      "side": 1,
      "message": "If thread A calls GetOrCreateLazyPointer() while thread B is creating the instance, and thread B decides to store nullptr, shouldn\u0027t thread A get the chance to create the instance instead of returning nullptr?\n\nIt\u0027s probably not very important to fix this \"race\", but it would be interesting to document it.",
      "range": {
        "startLine": 158,
        "startChar": 2,
        "endLine": 165,
        "endChar": 3
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ece48aa_3614905e",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 165,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-16T15:49:28Z",
      "side": 1,
      "message": "Yeah, doesn\u0027t matter. It\u0027s up to the caller to synchronize between when it does and doesn\u0027t \"desire to create an instance at this time\". In practice this is only for StaticMemorySingletonTraits and only matters for StaticMemorySingletonTraits::ResurrectForTesting().",
      "parentUuid": "a8e9ea60_771b8ffc",
      "range": {
        "startLine": 158,
        "startChar": 2,
        "endLine": 165,
        "endChar": 3
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e11d7654_1a66c25c",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 165,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-17T12:58:48Z",
      "side": 1,
      "message": "Since wez@ also mentioned this @ https://chromium-review.googlesource.com/c/chromium/src/+/868013/3/base/lazy_instance_internal.h#41, I tweaked the comment.",
      "parentUuid": "1ece48aa_3614905e",
      "range": {
        "startLine": 158,
        "startChar": 2,
        "endLine": 165,
        "endChar": 3
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ee650a9_a0dc1343",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 195,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-16T14:52:54Z",
      "side": 1,
      "message": "ThreadRestrictions::AssertSingletonAllowed() is a no-op on non-DCHECK builds, so I would remove this #if.\n\nhttps://cs.chromium.org/chromium/src/base/threading/thread_restrictions.h?l\u003d381\u0026rcl\u003d4d9273e282eae42eae0c5cf035490e0d53c4daa2",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 195,
        "endChar": 18
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d92b31ca_0a01cc8a",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 195,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-16T15:49:28Z",
      "side": 1,
      "message": "But Traits::kAllowedToAccessOnNonjoinableThread is DCHECK_IS_ON() only so... tidied up things some more in this regard.",
      "parentUuid": "2ee650a9_a0dc1343",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 195,
        "endChar": 18
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f3ea9300_5d568b3e",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-16T14:52:54Z",
      "side": 1,
      "message": "Explain why. Shouldn\u0027t static_cast\u003cType*\u003e(void*) work fine for any Type?\n\nhttps://stackoverflow.com/questions/310451/should-i-use-static-cast-or-reinterpret-cast-when-casting-a-void-to-whatever",
      "range": {
        "startLine": 200,
        "startChar": 11,
        "endLine": 200,
        "endChar": 27
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbd0c1ea_3960d6f2",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-16T15:49:28Z",
      "side": 1,
      "message": "Yes, but singleton.h used to reinterpret_cast and lazy_instance.h was static_cast\u0027ing. Wanted to do the same in both and settled on reinterpret_cast but I guess static_cast is kind of technically better (if the pointer is virtual). Done.",
      "parentUuid": "f3ea9300_5d568b3e",
      "range": {
        "startLine": 200,
        "startChar": 11,
        "endLine": 200,
        "endChar": 27
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "603b350e_1084ec44",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-16T14:52:54Z",
      "side": 1,
      "message": "Maybe create lazy_instance_internal.h, to avoid including the definition of LazyInstance?",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 31
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a7d605e_55d034c9",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-16T15:49:28Z",
      "side": 1,
      "message": "Done. Not sure I like including _internal.h file from other files but I couldn\u0027t think of a better layout",
      "parentUuid": "603b350e_1084ec44",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 31
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d0e33a1_8dc04717",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-17T12:58:48Z",
      "side": 1,
      "message": "Renamed to lazy_instance_helpers.h, better?",
      "parentUuid": "6a7d605e_55d034c9",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 31
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4621a445_08d0b9e5",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-16T14:52:54Z",
      "side": 1,
      "message": "Should we recommend using CR_DEFINE_STATIC_LOCAL() instead of base::Singleton for leaky cases? https://cs.chromium.org/chromium/src/base/macros.h?l\u003d73\u0026rcl\u003d6323cb4cb8f47aa505567914adf9a05548ddadb8",
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2d3c08e_c1ad3320",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-16T15:49:28Z",
      "side": 1,
      "message": "Hmm, mayyyyyybe idk... but it\u0027s orthogonal to this CL isn\u0027t it?",
      "parentUuid": "4621a445_08d0b9e5",
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8073f01b_96d0f324",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-16T23:45:56Z",
      "side": 1,
      "message": "Agree it\u0027s somewhat orthogonal, though note that it\u0027s not quite equivalent to Singleton\u003cT\u003e... though Singleton is kind of evil anyway.\n\nIf we\u0027re going to go down this route though, we should consider getting rid of CR_DEFINE_STATIC_LOCAL in favor of something like base::NoDestructor\u003cT\u003e with a forwarding constructor: this removes the heap indirection introduced by CR_DEFINE_STATIC_LOCAL while still guaranteeing that global destructors aren\u0027t generated.",
      "parentUuid": "c2d3c08e_c1ad3320",
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d7f625d0_8c3bb8fd",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 111,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-16T14:52:54Z",
      "side": 1,
      "message": "if (p)",
      "range": {
        "startLine": 111,
        "startChar": 4,
        "endLine": 111,
        "endChar": 21
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52b62cdb_393e0f22",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 111,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-16T15:49:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d7f625d0_8c3bb8fd",
      "range": {
        "startLine": 111,
        "startChar": 4,
        "endLine": 111,
        "endChar": 21
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a892eea9_c0c284f8",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-16T14:52:54Z",
      "side": 1,
      "message": "not needed, since AssertSingletonAllowed() is a no-op in non-DCHECK builds",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 228,
        "endChar": 18
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77c902f3_acd9ee2c",
        "filename": "base/memory/singleton.h",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-16T15:49:28Z",
      "side": 1,
      "message": "Ack (see other reply)",
      "parentUuid": "a892eea9_c0c284f8",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 228,
        "endChar": 18
      },
      "revId": "3e77a195003a88fc43dc699fdccf53e4267dca37",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}