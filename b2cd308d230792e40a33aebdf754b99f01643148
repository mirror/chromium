{
  "comments": [
    {
      "key": {
        "uuid": "33bb295f_d268a67e",
        "filename": "content/common/throttling_url_loader_unittest.cc",
        "patchSetId": 9
      },
      "lineNbr": 29,
      "author": {
        "id": 1001472
      },
      "writtenOn": "2018-01-17T12:50:08Z",
      "side": 1,
      "message": "Do you plan to use thiw WeakWrapper one even after other production callsites are migrating from it, or should we just remove WeakWrapper implementation after that?  (In the latter case we probably want to use the non-weak wrapper one here?)",
      "revId": "b2cd308d230792e40a33aebdf754b99f01643148",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ee69039_61002cf9",
        "filename": "content/common/throttling_url_loader_unittest.cc",
        "patchSetId": 9
      },
      "lineNbr": 29,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2018-01-17T17:59:48Z",
      "side": 1,
      "message": "My original plan was to keep this WeakWrapper even after the conversion. It could be useful. For example, imagine:\n- class Foo implements mojom::URLLoaderFactory.\n- Foo creates a WeakWrapper, initializes it with |this| and retains a reference.\n- Foo gives out scoped_refptr\u003cSharedURLLoaderFacotry\u003e.\n- When Foo is destructed, it can call Detach() on the WeakWrapper ref it retains.\n\nThe benefit of the pattern above is that there is no mojo call cost to use the returned scoped_refptr\u003cSharedURLLoaderFactory\u003e. (At the same time, it is very easy to support using the factory on multiple threads, as long as Foo implements mojom::URLLoaderFactory::Clone() properly.)\n\nWDYT? Thanks!\n(I will land this CL as-is, but happy to continue the discussion and make necessary changes if needed. There will be multiple follow-up CLs anyway.)",
      "parentUuid": "33bb295f_d268a67e",
      "revId": "b2cd308d230792e40a33aebdf754b99f01643148",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19df1e74_0cf59540",
        "filename": "content/public/common/shared_url_loader_factory.h",
        "patchSetId": 9
      },
      "lineNbr": 50,
      "author": {
        "id": 1002532
      },
      "writtenOn": "2018-01-17T01:27:52Z",
      "side": 1,
      "message": "nit: why is this in a separate struct instead of passing below, in case we keep adding more options? if so, did you consider default parameters instead (for easier typing at callsites)?",
      "revId": "b2cd308d230792e40a33aebdf754b99f01643148",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0bdd607a_889eee0d",
        "filename": "content/public/common/shared_url_loader_factory.h",
        "patchSetId": 9
      },
      "lineNbr": 50,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2018-01-17T04:46:23Z",
      "side": 1,
      "message": "Yes, I imagine we may add more options in the future (although I don\u0027t have examples in mind for now). CreateLoaderAndStart() already has quite some parameters, having a separate Constaints struct seems more clear to readers. \n\nI have already used default parameter for Constraints (line 65). The majority of callers don\u0027t need to worry about it at all.\n\nWDYT? Thanks!",
      "parentUuid": "19df1e74_0cf59540",
      "revId": "b2cd308d230792e40a33aebdf754b99f01643148",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}