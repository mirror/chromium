{
  "comments": [
    {
      "key": {
        "uuid": "21725291_65619b66",
        "filename": "third_party/WebKit/Source/platform/memory_profiler/SamplingNativeHeapProfiler.cpp",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 1002871
      },
      "writtenOn": "2018-01-25T16:19:59Z",
      "side": 1,
      "message": "Hmm honestly all this logic is very hard to reason about.\nI personally find challenging having to deal with \u003e1 atomic variable.\nMy humble suggestion would be to use a mutex here, or you might end up having to debug this code for quite long time.\nAlso consider that a mutex, when not hit, is really an atomic increment + decrement, and here you have accumulated way more atomic ops than that, so it might even just be more performant.\n\nDon\u0027t get me wrong, I am not saying this is wrong. I am just saying that I can\u0027t tell what\u0027s going to happen in all the possible linearizations, and the fact itself that you had to put a MemoryBarrier() above might be a red flag.\n\nI\u0027d say either find a way to do all this with one atomic variable, or put a mutex and live happy :)",
      "range": {
        "startLine": 250,
        "startChar": 1,
        "endLine": 264,
        "endChar": 73
      },
      "revId": "674e77288098a9c335299c7fbcbbd10c344961ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa0ad287_b1d609eb",
        "filename": "third_party/WebKit/Source/platform/memory_profiler/SamplingNativeHeapProfiler.cpp",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 1115861
      },
      "writtenOn": "2018-01-30T01:07:20Z",
      "side": 1,
      "message": "That is exactly the purpose of this patch. I\u0027m replacing two variables g_threshold and g_cumulative_counter that had to be kept in sync with just one g_bytes_left which is counted towards zero.\n\nIt is not that I\u0027m afraid of using mutexes ;-).\nI just need to make sure the lock-free part which runs independent of mutex state is kept in the valid state.\n\nI have to use MemoryBarrier because there\u0027s no Barrier_AtomicExchange function.",
      "parentUuid": "21725291_65619b66",
      "range": {
        "startLine": 250,
        "startChar": 1,
        "endLine": 264,
        "endChar": 73
      },
      "revId": "674e77288098a9c335299c7fbcbbd10c344961ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3cba535_c6ef8f81",
        "filename": "third_party/WebKit/Source/platform/memory_profiler/SamplingNativeHeapProfiler.cpp",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 1002871
      },
      "writtenOn": "2018-01-30T01:19:18Z",
      "side": 1,
      "message": "\u003e That is exactly the purpose of this patch. I\u0027m replacing two variables g_threshold and g_cumulative_counter that had to be kept in sync with just one g_bytes_left which is counted towards zero.\n\u003e \n\u003e It is not that I\u0027m afraid of using mutexes ;-).\n\u003e I just need to make sure the lock-free part which runs independent of mutex state is kept in the valid state.\n\nWell why not just using one instead of trying making this lockfree? You have more atomics than what would require for a mutex.\n\n\n\u003e I have to use MemoryBarrier because there\u0027s no Barrier_AtomicExchange function.\nAre you sure you don\u0027t really need a *_CompareAndSwap there? Do you really intend to exchange without checking the previous value? (asking because the logic itself you intend to achieve is not fully clear)",
      "parentUuid": "aa0ad287_b1d609eb",
      "range": {
        "startLine": 250,
        "startChar": 1,
        "endLine": 264,
        "endChar": 73
      },
      "revId": "674e77288098a9c335299c7fbcbbd10c344961ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5822f45_6eb304d1",
        "filename": "third_party/WebKit/Source/platform/memory_profiler/SamplingNativeHeapProfiler.cpp",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 1115861
      },
      "writtenOn": "2018-01-30T17:00:43Z",
      "side": 1,
      "message": "\u003e Well why not just using one instead of trying making this lockfree? You have more atomics than what would require for a mutex.\n\nI really want to make the part that is executed when we don\u0027t record a sample (above line 249) as fast as possible. Namely I\u0027d like to avoid mutex in this part as lots of allocations are running in parallel. It currently requires just a single NoBarrier_AtomicIncrement which is pretty good.\n\nAs for the bottom part (lines below 249) it is already being run by a single thread, so no mutex really required there.\n\n\u003e Are you sure you don\u0027t really need a *_CompareAndSwap there? Do you really intend to exchange without checking the previous value? (asking because the logic itself you intend to achieve is not fully clear)\n\nI\u0027m not checking the value, because I just grab all the accumulated amount at line 263 with AtomicExchange.\n\nThere is another approach to collect a sample that I considered. It makes use of CompareAndSwap, but it seems to be less \"precise\" than this one.\n\nThat approach would basically do (assuming size !\u003d 0):\n1: bytes_left \u003d AtomicIncrement(\u0026g_bytes_left, -size);\n2: if (bytes_left \u003e 0) return;\n3: if (CompareAndSwap(\u0026g_bytes_left, bytes_left, next_interval) !\u003d bytes_left) return;\n\nHere as soon the the bytes_left reaches zero, all the threads will run to the line 3. Then the threads will be leaving at line 3 if other threads keep coming and changing g_bytes_left at line 1. So basically this approach makes the last thread win.\n\nThe current approach does the opposite. It allows the thread that in fact crossed the zero level to record the sample. In a situation when there are threads allocate e.g. 100KB and 1KB, it is very likely that the one allocating 100 KB chunk is in fact crossed the line, and I want it to record the stack.\nAs a bonus my current approach uses just a single operation on the fast path, while CAS one would need two. :-)",
      "parentUuid": "b3cba535_c6ef8f81",
      "range": {
        "startLine": 250,
        "startChar": 1,
        "endLine": 264,
        "endChar": 73
      },
      "revId": "674e77288098a9c335299c7fbcbbd10c344961ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}