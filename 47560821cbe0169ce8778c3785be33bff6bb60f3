{
  "comments": [
    {
      "key": {
        "uuid": "f7ef347e_948d0366",
        "filename": "components/history/core/browser/history_backend.cc",
        "patchSetId": 2
      },
      "lineNbr": 2313,
      "author": {
        "id": 1176654
      },
      "writtenOn": "2018-01-15T07:55:02Z",
      "side": 1,
      "message": "Can\u0027t this function return an incorrect value in the following scenarios:\nScenario #1: The user is using iOS or Android and the page only has a 16x16 favicon\nScenario #2: The favicon was added to the database via HistoryBackend::SetImportedFavicons()\n\nI suggest allowing setting on demand icons on a per-icon-type basis. Thus it would be allowable to set an on-demand icon if the page has no mapping of a specific icon type.\nIt would be possible to set an on demand icon of type kTouchIcon if there is an icon of type kFavicon mapped to the page URL but no icon of type kTouchIcon mapped to the page URL.\nIt would not be allowable to set an an on demand icon of type kTouchIcon if there is an icon of type kTouchIcon mapped to the page URL.\n\nNote that the icon types kTouchIcon, kTouchPrecomposedIcon and kWebManifestIcon are equivalent from the database\u0027s point of view",
      "revId": "47560821cbe0169ce8778c3785be33bff6bb60f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4047e02c_14c79b70",
        "filename": "components/history/core/browser/history_backend.cc",
        "patchSetId": 2
      },
      "lineNbr": 2313,
      "author": {
        "id": 1161814
      },
      "writtenOn": "2018-01-24T12:57:03Z",
      "side": 1,
      "message": "I am fine with your proposal; I am just surprised that it is more permissive than my proposal. My proposal aims at storing icons as kTouchIcon and checks that there are no icons of this type. On top of that it checks additional properties (only icons of kFavicon of at most of size 16x16).\n\nIn my opinion, your proposal leaves more room for favicon wars (between on-demand and on-visit icons). Say a site has only 32x32 favicon (of type kFavicon) and we desire for a larger icon we would repetitively download an on-demand icon (when displaying the NTP) and delete it again (when visiting the site). My proposal leaves only room for such wars for 16x16 favicon icons.\n\nI agree that my function does not deliver what it promises by its name. Maybe this can be circumvented by \n#1 Renaming to FaviconsForPageURLLookLikeFromSync\n#2 Checking for \"!\u003d 16\" instead of \"\u003e 16\" on line 2326\n\nWhat I conceptually like that the function name refers to sync. If we ever stop syncing favicons, it is more clear that this check is obsolete and can be returned by \"false\".\n\nNevertheless, if this is unacceptable for you, I am also fine for your proposal.",
      "parentUuid": "f7ef347e_948d0366",
      "revId": "47560821cbe0169ce8778c3785be33bff6bb60f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f73815b7_105afe89",
        "filename": "components/history/core/browser/history_backend.cc",
        "patchSetId": 2
      },
      "lineNbr": 2313,
      "author": {
        "id": 1176654
      },
      "writtenOn": "2018-01-25T05:59:49Z",
      "side": 1,
      "message": "I thought some more about \"favicon wars\". I had not thought about this previously. One way of mitigating \"favicon wars\" is by checking whether the existing icon in the database is expired prior to calling LargeIconService::GetLargeIconOrFallbackStyleFromGoogleServerSkippingLocalCache()\n\nCurrently, HistoryBackend::MergeFavicon() does not always set the merged in icon as expired. We can change this.\n\nWe should definitely make HistoryBackend::SetOnDemandFavicons() fail if there are any touch icons mapped to the URL.\nI am unsure whether we should make HistoryBackend::SetOnDemandFavicons() fail if there is favicon of type kFavicon but which is unexpired. My gut instinct is no. The caller of LargeIconService::GetLargeIconOrFallbackStyleFromGoogleServerSkippingLocalCache() is responsible for doing this check. The caller is the one who suffers by doing needless downloads (sky@ will likely have an opinion on this point)\n\nI would rather not have special handling for 16x16 icons because it makes the behavior of HistoryBackend::SetOnDemandFavicons() subtle and harder to understand. (and in my opinion makes the API less clean)\n\nI hope that this comment is helpful",
      "parentUuid": "4047e02c_14c79b70",
      "revId": "47560821cbe0169ce8778c3785be33bff6bb60f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d048d09c_7703ec8d",
        "filename": "components/history/core/browser/history_backend.cc",
        "patchSetId": 2
      },
      "lineNbr": 2313,
      "author": {
        "id": 1161814
      },
      "writtenOn": "2018-01-25T07:47:47Z",
      "side": 1,
      "message": "Ah, that\u0027s interesting! Thanks! Do you propose that we differentiate favicons from sync as being expired?\n\nThis sounds reasonable as a general rule that we allow storing on-demand favicon if there is no direct conflict (for kTouchIcon) and all other icons are expired.\n\nIsn\u0027t there any other potential problem? Can we consistently store synced favicons as expired (even if there are many other icons stored for the page)? Wouldn\u0027t it force favicons to be refetched on every visit to such a page?\n\nAnother solution would be to mark it expired only if there is no other icon stored. How would this behave for sites that previously had an icon (which is stored in sync) but have no icon now. Wouldn\u0027t there be a icon war between no icon and the synced icon?\n\nIf we do not resolve it in a few more rounds, I propose to have an ad-hoc favicon gvc next Tuesday.",
      "parentUuid": "f73815b7_105afe89",
      "revId": "47560821cbe0169ce8778c3785be33bff6bb60f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f7fef83_dbaf1e9e",
        "filename": "components/history/core/browser/history_backend.cc",
        "patchSetId": 2
      },
      "lineNbr": 2313,
      "author": {
        "id": 1176654
      },
      "writtenOn": "2018-01-25T16:23:21Z",
      "side": 1,
      "message": "I am not suggesting differentiating icons from sync as \"expired icons\".\n- HistoryBackend::MergeFavicon() has non-sync callers.\n- An icon might be expired because the user has not visited the page for a long time \n  FaviconRawBitmapResult has a field indicating whether an icon is expired but it does not\n  have a field with the last_updated value from the database (and it should not have it) \n\nI do think that checking whether the favicon data is expired prior to calling LargeIconService::GetLargeIconOrFallbackStyleFromGoogleServerSkippingLocalCache() is a way for the client of LargeIconService to:\n- guess whether the user has navigated to the page\n- throttle GetLargeIconOrFallbackStyleFromGoogleServerSkippingLocalCache() downloads to at\n  most once every 7 days (kFaviconRefetchDays)\n\nFor the sake of clarity:\nIn MergeFavicon() I am suggesting expiring icons from sync\nIn this case:\nline 1675\nthumbnail_db_-\u003eAddFaviconBitmap(favicon_id, bitmap_data,\n                                FaviconBitmapType::ON_VISIT,\n                                base::Time::Now(), pixel_size);\nBut not this case:\nline 1637\nif (IsFaviconBitmapDataEqual(bitmap_id_sizes[i].bitmap_id, bitmap_data))\n\nI am happy to have a GVC next Tuesday if you think that it would speed things up :)",
      "parentUuid": "d048d09c_7703ec8d",
      "revId": "47560821cbe0169ce8778c3785be33bff6bb60f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06bcc0ff_98d77a85",
        "filename": "components/history/core/browser/history_backend.cc",
        "patchSetId": 2
      },
      "lineNbr": 2313,
      "author": {
        "id": 1161814
      },
      "writtenOn": "2018-01-31T18:23:53Z",
      "side": 1,
      "message": "I\u0027ve updated the implementation based on our gvc.",
      "parentUuid": "5f7fef83_dbaf1e9e",
      "revId": "47560821cbe0169ce8778c3785be33bff6bb60f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}