{
  "comments": [
    {
      "key": {
        "uuid": "d208fe13_a45df8ce",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 7,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "I\u0027m not sure how I feel about this narrative in general. My understanding is that for historical reasons, we failed to apply the SOP to certain resources. But that is not because of a resource vs. document distinction; it is related to history. For example, we properly apply the SOP to fonts, module scripts, and text tracks, since those were added to the platform relatively recently. Even though I\u0027d say they are resources.\n\nI\u0027d encourage removing the document vs. resource framing and just concentrate on allowed-for-legacy-reasons vs. not. Or maybe just under-consideration-for-blocking vs. not.",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df21304d_e6ebbff8",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 20,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "This doesn\u0027t work in modern browsers, as JSON arrays do not use the Array constructor.",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99241e9a_59253098",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 20,
      "author": {
        "id": 1002169
      },
      "writtenOn": "2018-02-05T20:40:13Z",
      "side": 1,
      "message": "I agree with Domenic\u0027s statement.\n\nIt would be accurate to say that XSDB is a defense-in-depth against undiscovered XSSI attack vectors (the Array ctor business, long-fixed, being the first such known attack). However, XSDB also winds up needing to interact with and build upon the other defenses against XSSI -- the other defenses being parser-breaking prefixes (which is an ad-hoc collection convention for turning \u003cscript\u003e inclusion into error), and the nosniff header (which causes \u003cscript\u003e inclusion to fail when accompanied with a json mime type).\n\nIt is accurate to say that XSDB can provide a defense against XSSI vectors even when the site doesn\u0027t employ one of the other defenses. On the other hand, XSDB treats the presence of the other defenses as a signal that blocking is appropriate.",
      "parentUuid": "df21304d_e6ebbff8",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf292b76_cfc090bc",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 20,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "I\u0027ve added clarification that the array constructor attack vector has been mitigated (and added a link to slides outlining other potential attack vectors that Nick has shared with me).\n\nMore broadly - are there possibly other motivating factors for XSDB?  (other than XSSI and Spectre)",
      "parentUuid": "99241e9a_59253098",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c3cfa0e_846852f2",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 35,
      "author": {
        "id": 1264433
      },
      "writtenOn": "2018-02-05T17:04:48Z",
      "side": 1,
      "message": "This is likely too nitpicky, but from a web developer\u0027s point of view it\u0027s fairly difficult to think of JSON resources as \"documents\". In my mind a document maps more closely to how it\u0027s defined in the DOM spec https://www.w3.org/TR/html52/dom.html#documents and HTML (https://www.w3.org/TR/html52/infrastructure.html#infrastructure-terminology), i.e. it\u0027s renderable, has a DOM, etc., none of which is true for JSON.\n\nHowever, I\u0027m not sure how to resolve this and keep your document vs. resource narrative intact, so perhaps you should just ignore this and go with the terminology you already have.",
      "range": {
        "startLine": 35,
        "startChar": 40,
        "endLine": 35,
        "endChar": 50
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c26788b3_ae781439",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 35,
      "author": {
        "id": 1002169
      },
      "writtenOn": "2018-02-05T20:40:13Z",
      "side": 1,
      "message": "I think this is a really valuable point. Our team has been using \"document blocking\" with this meaning for a really long time, and so the outside perspective of how this comes across is helpful.\n\nThe universe of cross-origin resources that are blockable by an XSDB type filter, are precisely those which don\u0027t need to be allowed through by some potential opaque consumer in the renderer. By \u0027opaque\u0027 I mean a consumer that doesn\u0027t allow the bits of the response to become known to the page origin.\n\nSupporting out-of-process iframes is what allowed HTML to move into the set of blockable resource types. As a thought exercise -- if we implemented out-of-process \u003cimg\u003e tags, we could do the same thing for cross-origin images (this is not an insane performance architecture, but it has crazy implications for canvas).\n\nNon-empty JSON objects are in the set of blockable resource types because there\u0027s no HTML element that produces anything other than an error when pointed at a JSON object. Other JSON cases are similar, except that the \u003cscript\u003e tag will accept them, but ought to produce no observable side effects.\n\nThe blockability of XML is derived similarly to JSON, without the Javascript polyglot ambiguities.\n\n ---\n\nSo really, what we\u0027re trying to classify is whether a particular resource is \u0027potentially digestible by some context\u0027 or \u0027indigestible by all contexts\u0027.\n\nMaybe we rebrand this as \"Cross-site resource protection\"?",
      "parentUuid": "2c3cfa0e_846852f2",
      "range": {
        "startLine": 35,
        "startChar": 40,
        "endLine": 35,
        "endChar": 50
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0a06d5ce_11016161",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 35,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Let\u0027s talk about this more before proceeding (I\u0027d like to make this sweeping change only once :-).  Maybe s/document/XSDB-protected-response/ and s/resource/XSDB-ignored-response/ ?",
      "parentUuid": "c26788b3_ae781439",
      "range": {
        "startLine": 35,
        "startChar": 40,
        "endLine": 35,
        "endChar": 50
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5a836e0_2a99eae0",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-02T21:10:57Z",
      "side": 1,
      "message": "Domenic, I can see how you might be unhappy with the current wording.  FWIW, an earlier patchset said simply \"Avoid breaking existing websites (e.g. by unintentionally blocking *resources* they depend on).\".\n\nAt any rate, IMHO getting the rest of the document right (how XSDB should work, which MIME types it should pay attention to, how it is or is not compatible with existing website) is more important than wordsmithing the goals.  I think we are all on the same page - we do not want to break existing websites (although the actual impact of XSDB has not been quantified yet and each of us might have different thresholds for acceptable level of breakage).",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 50,
        "endChar": 43
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91b6726a_f6e94bba",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "I would phrase this as \"XSDB should cause minimal web-compatibility breakages\" instead of being \"effectively transparent\".",
      "parentUuid": "f5a836e0_2a99eae0",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 50,
        "endChar": 43
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a668e624_cc3eac7a",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "91b6726a_f6e94bba",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 50,
        "endChar": 43
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6c1893c3_903ed8c6",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 63,
      "author": {
        "id": 1264433
      },
      "writtenOn": "2018-02-05T17:04:48Z",
      "side": 1,
      "message": "Yes, this seems like a good idea, especially for resources that were already blocked by XSDB.\n\nWithout blocking headers, one risk is for endpoints which 302 redirect to (unauthenticated) capability URLs. For example, if example.org/myimage returns a 302 with Location: images.example.org/abc123...789xyz.png then the attacker could gain access to the secret URL and obtain the data.\n\nOne question is if Fetch safelisting would prevent exposing \"Location\" but if my reading of https://fetch.spec.whatwg.org/#cors-safelisted-request-header is correct this should be the case by default (if there is no Access-Control-Expose-Headers).",
      "range": {
        "startLine": 62,
        "startChar": 25,
        "endLine": 63,
        "endChar": 67
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "541d744f_7a579508",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 63,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "\u003e Yes, this seems like a good idea, especially for resources that were already blocked by XSDB.\n\u003e \nAck.\n\n\u003e Without blocking headers, one risk is for endpoints which 302 redirect to (unauthenticated) capability URLs. For example, if example.org/myimage returns a 302 with Location: images.example.org/abc123...789xyz.png then the attacker could gain access to the secret URL and obtain the data.\n\nI think XSDB and the renderer only see the final HTTP response (e.g. after all the redirects have already been handled - in other words AFAIK the renderer doesn\u0027t see intermediate redirect hops).\n\n\u003e \n\u003e One question is if Fetch safelisting would prevent exposing \"Location\" but if my reading of https://fetch.spec.whatwg.org/#cors-safelisted-request-header is correct this should be the case by default (if there is no Access-Control-Expose-Headers).\n\nFirst - an appology - I should have linked to safelisted *response* headers (not *request* headers).\n\nAnd yes - Location is not safelisted and would be stripped if XSDB followed https://fetch.spec.whatwg.org/#cors-safelisted-response-header-name",
      "parentUuid": "6c1893c3_903ed8c6",
      "range": {
        "startLine": 62,
        "startChar": 25,
        "endLine": 63,
        "endChar": 67
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d20e5796_32ef732d",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 125,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "This section in particular seems really bad from trying to define document vs. resource in ways that don\u0027t quite match the typical definition. I\u0027d strongly suggest changing it to potentially-XSDB-blockable vs. ignored blocked by XSDB.",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bab45118_6ad8575f",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1002169
      },
      "writtenOn": "2018-02-05T20:40:13Z",
      "side": 1,
      "message": "In an important sense, the same-origin policy is always in effect, so we should word this more carefully.\n\nThe thing with \u003cimg\u003e, \u003cscript\u003e, etc is that they support opaquely loading cross-origin resources in a way that isn\u0027t expected to reveal the resource body to the page\u0027s origin.",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dfe7b740_21eb0d77",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Done (changed to more closely match the wording used on https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy, in the \"Cross-origin network access\" section, in the second paragraph/list).",
      "parentUuid": "bab45118_6ad8575f",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4b361ad_eb0e23b7",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 134,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "Probably should include other JavaScript MIME types. https://html.spec.whatwg.org/#javascript-mime-type (we should probably move that list to MIME Sniffing so it\u0027s centralized with the others).",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ccaab7ea_a14b798a",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 134,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b4b361ad_eb0e23b7",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4a6649b6_466386b4",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 157,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "We have https://html.spec.whatwg.org/#json-mime-type already (should also be centralized to MIME Sniffing); interesting that you have something more permissive here. The spec basically uses this to determine whether to display the result as a plain text file currently, so it\u0027s not that important (and may not match browsers exactly).",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2354d66_303ad82e",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 157,
      "author": {
        "id": 1002169
      },
      "writtenOn": "2018-02-05T20:40:13Z",
      "side": 1,
      "message": "Our list here may be somewhat archaic or arbitrary -- it\u0027s really just carried over from our prototype, which rapidly had the dust blown off of it over the past few months. It would not be a bad idea to unify with the spec\u0027s definition.",
      "parentUuid": "4a6649b6_466386b4",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b23a025_66aface7",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 157,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Done (replaced enumeration of mime types with a reference to the spec you\u0027ve pointed out).\n\nThe `application/json+*` and `text/json+*` come from https://crbug.com/799155, where I learned from xtof@, that some public Google APIs appear to use json+protobuf in responses:\n    Content-Type: application/json+protobuf; charset\u003dUTF-8\nFWIW, I\u0027ve also opened https://github.com/whatwg/html/issues/3454 to cover application/json+protobuf by https://html.spec.whatwg.org/#json-mime-type.\n\nI don\u0027t know what is the origin of other MIME types on the list (e.g. `test/x-json`)",
      "parentUuid": "4a6649b6_466386b4",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "67fcb5ba_9aec7020",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 163,
      "author": {
        "id": 1264433
      },
      "writtenOn": "2018-02-05T17:04:48Z",
      "side": 1,
      "message": "Nit: all-caps here and below.",
      "range": {
        "startLine": 163,
        "startChar": 17,
        "endLine": 163,
        "endChar": 21
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6198f8bb_cbfd5a3c",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 163,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "67fcb5ba_9aec7020",
      "range": {
        "startLine": 163,
        "startChar": 17,
        "endLine": 163,
        "endChar": 21
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4ba7115_5fa1c352",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 166,
      "author": {
        "id": 1002169
      },
      "writtenOn": "2018-02-05T20:40:13Z",
      "side": 1,
      "message": "This description doesn\u0027t match the current implementation -- so is it a proposed tightening of enforcement?\n\nThere are two ways we could implement an the XSDB filter: either by trying to recognize all the patterns that need to be let through, or by trying to recognize patterns that are okay to block. Our implementation currently takes the second approach. Doing the first way seems like it might require a really big registry (e.g. every image format, awareness of video text tracks, etc etc ...)?",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7062e43f_35ea4940",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 166,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "\u003e This description doesn\u0027t match the current implementation -- so is it a proposed tightening of enforcement?\n\nYes - that\u0027s a proposal that we didn\u0027t commit to yet.  Let\u0027s talk about it tomorrow?\n\nI think that the list of documents requiring protection might grow in the future (e.g. when a new format for sharing data becomes popular) and we wouldn\u0027t want to be forced to update XSDB spec and implementation whenever this happens (e.g. when application/new-pdf or application/new-zip or application/new-json becomes popular).  OTOH, the list of MIME types of resources that don\u0027t need XSDB protection is indeed long, but I think it is unlikely that this list will grow (e.g. assuming that [for example] new video format will have `video/*` MIME type and not something like `application/x-my-new-video-format`).\n\u003e \n\u003e There are two ways we could implement an the XSDB filter: either by trying to recognize all the patterns that need to be let through, or by trying to recognize patterns that are okay to block. Our implementation currently takes the second approach. Doing the first way seems like it might require a really big registry\n\nIt\u0027s big, but I think it is still doable?\n\n\u003e (e.g. every image format\n\nimage/* should be sufficient?  https://mimesniff.spec.whatwg.org/#image-type seems to agree.\n\n\u003e awareness of video text tracks, etc etc ...)?\n\nGood point - I did list text/vtt in https://crbug.com/802836, but forgot to list it in the explainer.",
      "parentUuid": "b4ba7115_5fa1c352",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e1ee2b9_23ee6759",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 168,
      "author": {
        "id": 1264433
      },
      "writtenOn": "2018-02-05T17:04:48Z",
      "side": 1,
      "message": "My guess is that it is indeed too aggressive. Basically, I\u0027d expect that there are many resources without a Content-Type or with an arbitrary incorrect C-T value which are loaded cross-origin. I\u0027m speculating, but I think this could cause a fair amount of breakage.",
      "range": {
        "startLine": 168,
        "startChar": 25,
        "endLine": 168,
        "endChar": 79
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02849dc1_8e374d22",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 168,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Thanks for the feedback.\n\nI think it might be worthwhile to separate 1) what the initial XSDB implementation in Chrome should do (this might need to be conservative / risk-averse) and 2) what the right long-term thing is / what should the spec ask for (I think the spec should allow blocking of types like application/pdf and/or application/zip even if the initial XSDB implementation won\u0027t protect them).\n\nI\u0027ve tried to reword this in the explainer, but I am sure we\u0027ll continue discussing this (here or in https://crbug.com/802836).",
      "parentUuid": "6e1ee2b9_23ee6759",
      "range": {
        "startLine": 168,
        "startChar": 25,
        "endLine": 168,
        "endChar": 79
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7105b844_c600a5fd",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "They would be ignored in text/css resources, so this is an interesting observable breaking change to write tests for.",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "689072e7_cd730ae3",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1002169
      },
      "writtenOn": "2018-02-05T20:40:13Z",
      "side": 1,
      "message": "Excellent point. The policy might actually need to think about text/css.",
      "parentUuid": "7105b844_c600a5fd",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b2b305d_e666a368",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Domenic - thanks for raising this point - the CSS parsing is indeed not very strict.  Could you please help identify an example CSS that parses fine despite presence of a JSON parser breaker at the beginning of the file?  FWIW, I\u0027ve tried the following:\n\n    while (1);\n    h1 { color: green; }\n\nand\n\n    )]}\u0027\n    h1 { color: green; }\n\nand\n\n    {}\u0026\u0026\n    h1 { color: green; }\n\nand none of them worked when included as follows from html:\n\n    \u003c!DOCTYPE html\u003e\n    \u003chtml\u003e\n      \u003chead\u003e\n        \u003clink rel\u003d\"stylesheet\" type\u003d\"text/css\" href\u003d\"theme.css\"\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003ch1\u003eHeader example\u003c/h1\u003e\n        \u003cp\u003eParagraph body\u003c/p\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n\nwhile the following stylesheet worked fine (the header turned green):\n\n    h1 { color: green; }\n\n\nIf we can identify an example of a text/css response that would be broken by XSDB, then we should open a bug to track this issue (not sure how to fix it though - limit JSON parser recognition to some MIME types only?  that would greatly reduce the utility of sniffing for JSON parser breaker though...).",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "752d5657_9a20c751",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T23:20:08Z",
      "side": 1,
      "message": "Artur helped me find an example (thanks!):\n    ```css\n    )]}\u0027\n    {}\n    h1 { color: red; }\n    ```\n\nI\u0027ve added the text/css exception to the explainer.\n\n\nOTOH, I am not sure if an exception for `text/css` is sufficient / if it is okay to sniff for JSON parser breaker in other cases.  For example, Nick points out that while the spec is very strict about the expected content type, the implementation in Blink also allows an empty/missing content type [2].  Maybe requiring the Content-Type to be non-empty, non-css is the kind of requirement XSDB should check before sniffing for JSON parser breakers?\n\n[1] https://html.spec.whatwg.org/#link-type-stylesheet says \"Once a resource has been obtained, if its Content-Type metadata is text/css, then run these steps [...]\".  Implicitly, if the content type is anything else, do nothing.\n\n[2] https://cs.chromium.org/chromium/src/third_party/WebKit/Source/core/css/StyleElement.cpp?type\u003dcs\u0026sq\u003dpackage:chromium\u0026l\u003d156",
      "parentUuid": "5b2b305d_e666a368",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a069c2c3_3b2a7d9b",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 189,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "Personally I find this section\u0027s approach of defining a criteria via a set of paragraphs somewhat hard to reason about. I\u0027d encourage defining it as an algorithm that determines whether something is potentially-XSDB-blockable (returns true or false).\n\nFor an explainer though, it\u0027s fine.",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99bb4947_886a5923",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 189,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "\u003e Personally I find this section\u0027s approach of defining a criteria via a set of paragraphs somewhat hard to reason about. I\u0027d encourage defining it as an algorithm that determines whether something is potentially-XSDB-blockable (returns true or false).\n\nFair feedback.\n\u003e \n\u003e For an explainer though, it\u0027s fine.\n\nRight - trying to spec/capture exact algorithm will probably slow us down + bias us toward a particular algorithm.  Let\u0027s wait until the explainer settles down a bit and major known issues are addressed and *then* try to put things into spec-like wording (disclaimer: I\u0027ve never worked on a spec, so I will probably need help with putting together a description of the algorithm [using the right spec structure, spec words, etc.]).",
      "parentUuid": "a069c2c3_3b2a7d9b",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d73d858a_b93ac6df",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "s/web visible/the service worker\u0027s; it may still be web-visible once it exits the service worker.\n\ns/an empty body/a non-accessible body/",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3d5bd2b_b4288228",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d73d858a_b93ac6df",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "be10b73c_03394cc2",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 276,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "What about a HTML document loaded into a \u003clink rel\u003d\"stylesheet\"\u003e element, which can apply itself to the page? E.g. this HTML document can also be used as a CSS stylesheet, whose third line will apply to the page that includes it.\n\n\u003c!DOCTYPE html\u003e\n\u003cstyle\u003e h2 {}\nh1 { color: blue; }\n\u003c/style\u003e",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1cfe09fb_c8fad760",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 276,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "Great point.  Thanks for bringing this up.  I\u0027ve added a html/css example here.",
      "parentUuid": "be10b73c_03394cc2",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0aea956d_cb6f3361",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 282,
      "author": {
        "id": 1264433
      },
      "writtenOn": "2018-02-05T17:04:48Z",
      "side": 1,
      "message": "I wonder if this could be abused as a cross-origin information leak. For example, if evil.com loads victim.com/resource as a \u003cscript\u003e, then it will be able to infer if XSDB kicked in based on the absence of a JS error. Since XSDB kicks in based on the C-T, the attacker might be able to distinguish between response with a MIME type that triggers XSDB (document) vs. one with a MIME ignored by XSDB (resource) even if the actual responses both trigger JS parsing errors (and thus would be indistinguishable without XSDB).\n\nOne plausible example is a URL which returns resources which the attacker cannot directly observe cross-origin, but which, under certain conditions (e.g. depending on whether the user is logged in), shows an HTML error page. It\u0027s not a very compelling scenario, but might be worth thinking about more and/or documenting somewhere.",
      "range": {
        "startLine": 281,
        "startChar": 18,
        "endLine": 282,
        "endChar": 56
      },
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6c55756_b35c23d0",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 354,
      "author": {
        "id": 1197619
      },
      "writtenOn": "2018-02-05T19:25:22Z",
      "side": 1,
      "message": "Are these meant to be RFC 2119 should/may? Or are they more colloqual \"will / will not\"?",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9aa6cb7f_c936586a",
        "filename": "content/browser/loader/cross_site_document_blocking_explainer.md",
        "patchSetId": 6
      },
      "lineNbr": 354,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2018-02-05T22:34:46Z",
      "side": 1,
      "message": "These are meant to be RFC 2119 should/may.  Perhaps it is too early to go there (i.e. it seems that we are still discovering new issues / corner cases when discussing the explainer).",
      "parentUuid": "e6c55756_b35c23d0",
      "revId": "609dfeda95a92b432f6868977bfa1042ce0ca263",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}