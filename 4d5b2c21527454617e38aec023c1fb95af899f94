{
  "comments": [
    {
      "key": {
        "uuid": "c258dd56_6fbd77dd",
        "filename": "chrome/browser/resources/print_preview/native_layer.js",
        "patchSetId": 7
      },
      "lineNbr": 168,
      "author": {
        "id": 1115893
      },
      "writtenOn": "2017-09-28T18:47:34Z",
      "side": 1,
      "message": "Is there anyway that the C++ could infer the |type| from the |destinationId| such that we only have to pass destination ID here? Or would that make things more complicated?",
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2f7411e_dfd0fd32",
        "filename": "chrome/browser/resources/print_preview/native_layer.js",
        "patchSetId": 7
      },
      "lineNbr": 168,
      "author": {
        "id": 1182404
      },
      "writtenOn": "2017-09-28T19:08:28Z",
      "side": 1,
      "message": "C++ currently doesn\u0027t store any lists of printers, so we would need to add that in the handler to avoid re-fetching all the printers each time. The other problem is that I do not think anything stops 2 printers of different types from having the same destination ID. In the map of destinations, we use DestinationStore.getKey_() to obtain unique identifiers for each destination, and the key contains both the id and the origin. It should be possible to send this key to C++ and then parse the id and origin from the string and convert the origin to PrinterType there, but I am not sure if that is any better than just sending the type and id directly.",
      "parentUuid": "c258dd56_6fbd77dd",
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a310d5d_ecf9b685",
        "filename": "chrome/browser/ui/webui/print_preview/extension_printer_handler.cc",
        "patchSetId": 7
      },
      "lineNbr": 312,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-28T21:13:05Z",
      "side": 1,
      "message": "If you use SetPath(), then you can skip calling base::DictionaryValue::From().",
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "428a5e44_0d71aefa",
        "filename": "chrome/browser/ui/webui/print_preview/extension_printer_handler.cc",
        "patchSetId": 7
      },
      "lineNbr": 312,
      "author": {
        "id": 1182404
      },
      "writtenOn": "2017-09-28T22:38:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a310d5d_ecf9b685",
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4bd01b78_68bbf427",
        "filename": "chrome/browser/ui/webui/print_preview/extension_printer_handler_unittest.cc",
        "patchSetId": 7
      },
      "lineNbr": 220,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-28T21:13:05Z",
      "side": 1,
      "message": "Should this be FindPathOfType() ? Then if it\u0027s the wrong type, we just set the out value to nullptr. As is, line 223 will Clone it, and then fail the check in DictionaryValue::From().",
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a7e531b_681e9c27",
        "filename": "chrome/browser/ui/webui/print_preview/extension_printer_handler_unittest.cc",
        "patchSetId": 7
      },
      "lineNbr": 220,
      "author": {
        "id": 1182404
      },
      "writtenOn": "2017-09-28T22:38:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4bd01b78_68bbf427",
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd01e753_94b6fe08",
        "filename": "chrome/browser/ui/webui/print_preview/printer_handler.h",
        "patchSetId": 7
      },
      "lineNbr": 48,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-28T21:13:05Z",
      "side": 1,
      "message": "So no kSettingCapabilties key implies failure? Can there be a kSettingCapabilties key, but the dictionary value is empty?",
      "range": {
        "startLine": 48,
        "startChar": 18,
        "endLine": 48,
        "endChar": 24
      },
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "463dcfc4_1fe20700",
        "filename": "chrome/browser/ui/webui/print_preview/printer_handler.h",
        "patchSetId": 7
      },
      "lineNbr": 48,
      "author": {
        "id": 1182404
      },
      "writtenOn": "2017-09-28T22:38:32Z",
      "side": 1,
      "message": "No key implies failure. An empty dictionary shouldn\u0027t cause any issues in JS, just gives the printer empty capabilities - see e.g. the DPI ticket item here, which checks dest.capabilities \u0026\u0026 dest.capabilities.printer: https://cs.chromium.org/chromium/src/chrome/browser/resources/print_preview/data/ticket_items/dpi.js?l\u003d54\n\nIt does seem odd to report a successful fetch with an empty dictionary but the existing behavior has always allowed that for local printers. I changed the DCHECK that kSettingsCapability exists to be part of the if statement that determines the callback result.",
      "parentUuid": "fd01e753_94b6fe08",
      "range": {
        "startLine": 48,
        "startChar": 18,
        "endLine": 48,
        "endChar": 24
      },
      "revId": "4d5b2c21527454617e38aec023c1fb95af899f94",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}