{
  "comments": [
    {
      "key": {
        "uuid": "209cddc6_ebf80465",
        "filename": "third_party/WebKit/Source/bindings/core/v8/V8Initializer.cpp",
        "patchSetId": 5
      },
      "lineNbr": 409,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-06-19T22:55:10Z",
      "side": 1,
      "message": "Is this API set in stone? I\u0027m worried about bugs that might happen if the caller passes in different |length| or |mode| parameters than those the |data| was born with. If possible, those details should be tied to |data| in a manner opaque to callers.",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e32e9f80_9514a69e",
        "filename": "third_party/WebKit/Source/bindings/core/v8/V8Initializer.cpp",
        "patchSetId": 5
      },
      "lineNbr": 409,
      "author": {
        "id": 1144619
      },
      "writtenOn": "2017-06-20T21:37:22Z",
      "side": 1,
      "message": "This is meant to be a pretty low level API, and V8 and Blink both have infrastructure in place to keep track of the length as array buffers move between the V8 and Blink garbage collectors.\n\nI considered a couple of options. One was to allocate an extra page at the beginning where I could store the length, allocation mode and maybe a magic number. This struck me as hokey and fragile to do at this level, but maybe it\u0027s not. I\u0027m pretty sure some malloc implementations do something similar.\n\nAlternatively, the ArrayBufferAllocator could keep a hash table mapping allocations to the rest of the data. This seemed like more overhead than it was worth to me though.",
      "parentUuid": "209cddc6_ebf80465",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "667b7794_3d217a53",
        "filename": "third_party/WebKit/Source/bindings/core/v8/V8Initializer.cpp",
        "patchSetId": 5
      },
      "lineNbr": 422,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-06-19T22:55:10Z",
      "side": 1,
      "message": "Maybe this should/could be subsumed into the Allocate* functions? Is that possible?\n\nWhat does it mean to set |length| greater than or less than the original length of |data|?",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "706390d3_030bb3c3",
        "filename": "third_party/WebKit/Source/bindings/core/v8/V8Initializer.cpp",
        "patchSetId": 5
      },
      "lineNbr": 422,
      "author": {
        "id": 1144619
      },
      "writtenOn": "2017-06-20T21:37:22Z",
      "side": 1,
      "message": "These need to be separate. The interval covered by `data` and `length` needs to be contained by the original allocation, but they can be smaller. The way Wasm uses this API is that it first reserves a large amount of memory and then makes a portion of it accessible. Wasm programs can request to grow the memory, and this is done by calling SetProtection to make more of the memory accessible. Currently, Wasm allocates 8GB, since this is the largest address that can be generated by a Wasm load or store instruction, and then makes the actual memory size accessible (\u003c2GB). I would eventually like to make this be 16GB and then make the range from 8 to 10GB accessible, with the first 8GB protecting from accidental sign extensions.",
      "parentUuid": "667b7794_3d217a53",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2ab7964_8ca171d3",
        "filename": "third_party/WebKit/Source/bindings/tests/results/core/V8ArrayBuffer.cpp",
        "patchSetId": 5
      },
      "lineNbr": 82,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-06-19T22:55:10Z",
      "side": 1,
      "message": "This seems to duplicate the previous file. Is there any way to avoid that?",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4228db8_17a24577",
        "filename": "third_party/WebKit/Source/bindings/tests/results/core/V8ArrayBuffer.cpp",
        "patchSetId": 5
      },
      "lineNbr": 82,
      "author": {
        "id": 1144619
      },
      "writtenOn": "2017-06-20T21:37:22Z",
      "side": 1,
      "message": "This file is generated from the previous file, which is why it is duplicated.",
      "parentUuid": "e2ab7964_8ca171d3",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31690d3b_b03fd417",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-06-19T22:55:10Z",
      "side": 1,
      "message": "It\u0027s best to TODO(crbug.com/foo).",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f98cbbf_1e727c0e",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.cpp",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1144619
      },
      "writtenOn": "2017-06-20T21:37:22Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "31690d3b_b03fd417",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5dc6be67_f273066d",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.h",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-06-19T22:55:10Z",
      "side": 1,
      "message": "OK, my earlier comments might be off-base, as long as this class remains the only caller of the new lower-level APIs, and as long as it gets everything right.",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a22a807a_271d1530",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.h",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1144619
      },
      "writtenOn": "2017-06-20T21:37:22Z",
      "side": 1,
      "message": "Are you referring to the comments about keeping the length with the data? There are two ways to allocate and track array buffers, but both go through the ArrayBuffer allocator. V8 tracks the data and allocation pointers as part of its ArrayBuffer structure, which is freed by the garbage collector. Alternatively, a buffer can be externalized, which means V8 relinquishes ownership and instead the machinery in this file takes over. This handoff happens in the previous file, V8ArrayBuffer.cpp.",
      "parentUuid": "5dc6be67_f273066d",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb9f5b8a_43a34335",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.h",
        "patchSetId": 5
      },
      "lineNbr": 96,
      "author": {
        "id": 1001040
      },
      "writtenOn": "2017-06-19T22:55:10Z",
      "side": 1,
      "message": "This should maybe be a CHECK? It seems like a crucial correctness guarantee? Maybe I\u0027m wrong.",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "866adf5e_940da269",
        "filename": "third_party/WebKit/Source/platform/wtf/typed_arrays/ArrayBufferContents.h",
        "patchSetId": 5
      },
      "lineNbr": 96,
      "author": {
        "id": 1144619
      },
      "writtenOn": "2017-06-20T21:37:22Z",
      "side": 1,
      "message": "The more I think about it, I think it would be better to have one DCHECK that guards both branches.\n\nThe only thing that\u0027s absolutely required is that allocation_base_ \u003c\u003d data_ \u003c\u003d data_ + data_length_ \u003c\u003d allocation_base_ + allocation_length_. When we\u0027re using the kReservation mode, we end up cases there data_ and allocation_base_ are different. For kNormal, so far the two ranges are always equal, but the contract doesn\u0027t require it. Basically, allocation_base_ to allocation_base_ + allocation_length_ is the part that the memory manager cares about, while data_ to data_ + data_length_ is contains the data that the rest of the system cares about.\n\nAs far as CHECK vs DCHECK, I I think of DCHECK as being for things that indicate a programmer error, in this case that the rest of the code failed to ensure the invariants that we expect here, while CHECK is for things that are possible in production, such as if these bytes had been run off the network. Thus, I\u0027d be inclined to choose DCHECK here, but I\u0027d be happy to change it to CHECK if you prefer.\n\nI went ahead and changed the DCHECK to enforce the bounds that are actually required, and also duplicated them in the constructor because that seems like the more logical place for them.",
      "parentUuid": "bb9f5b8a_43a34335",
      "revId": "d437c26d3a849cbf0532f3e738b5063fe82d4c0a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}