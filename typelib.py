# Attempts to dump .tlb files such as generated by the midl.exe tool.

# I looked at the output of oleview.exe on google_update.tlb and at
# google_update.tlb's contents.

""".tlb viewer.

Run like:
typelib.py third_party/win_build_output/midl/google_update/x64/google_update_idl.tlb
"""

import sys
import struct

tlb = open(sys.argv[1]).read()

assert tlb[0:4] == 'MSFT'

# 0x150 stores 0x1760, which seems to be the start of some string table.
# In general, the first 0x1f0 or so bytes seem to be 4-byte offsets into the
# file.
strtaboff = struct.unpack('<I', tlb[0x150:0x154])
print '%x' % strtaboff
print

# It looks like there are 15 offset/len/-1/15 tuples at 0xe0.
# But for ia2_api_all.tlb, the offset is 0xc8 instead.
# ...looks like the number at 0x20 is some count that's smaller for ia2.
# (0x1d == 29 vs 0x23 == 35. 0xe0 - 0xc8 == 24, 35 - 29 is 6, which neatly
# divides the 24 bytes. So the number at 0x20 is number of 4 byte somethings.
# 0xe0 - 35*4 == 0xc8 - 29*4 == 84, so the ints probably start at 84/0x54?)
# This theory mostly works out, except some offsets are 0xffff (== not present,
# always have len of 0).

for i in range(15):
  off, len, minusone, fifteen = \
      struct.unpack('<IIII', tlb[0xe0 + i*16: 0xe0 + i*16 + 16])
  print '%x %x => %x' % (off, len, off+len)

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221549(v=vs.85).aspx
