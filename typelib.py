# Attempts to dump .tlb files such as generated by the midl.exe tool.
# This dumper can process all .tlb files checked in at
# third_party/win_build_output. It doesn't look at all input bytes, but
# it produces reasonably complete output, compared to what oleview.exe
# prints.
# Missing:
# * some complex types (typedef'd types; on parameters, struct fields)
# * importlib()s
# * some metadata flags (odl, propget, dual, oleautomation, id(), propput,
#    public, nonextensible)
# * interface base classes
# * calling conventions (_stdcall vs not)
""".tlb viewer.

Run like:
typelib.py third_party/win_build_output/midl/google_update/x64/google_update_idl.tlb
"""

import sys
import struct

def hexdump(dat, o, l):
  for i in range(o, o + l, 16):
    s = dat[i:min(i + 16, o + l)]
    hexstr = ' '.join(['%02x' % ord(c) for c in s])
    textstr = ''.join([c if 0x20 <= ord(c) <= 0x7e else '.' for c in s])
    print '%-48s %s' % (hexstr, textstr)


def getguid(p):
  guidoff, guidlen = entries[5]
  assert 0 <= p
  assert p + 24 <= guidlen
  g0, g1, g2, g3, g4, n0, n1 = struct.unpack_from('<IHHH6sii', tlb, guidoff + p)
  g4 = ''.join(['%02X' % ord(g) for g in g4])
  # Hm, n1 might be a "next" pointer (into the GUID section again) like in
  # section 13 -- so that the GUID section can contain lists of GUIDs. -1 means
  # end-of-list.
  return '%08X-%04X-%04X-%04X-%s' % (g0, g1, g2, g3, g4), n0, n1


def gettystr(p):
  strtaboff, strtablen = entries[7]
  assert 0 <= p
  assert p + 12 <= strtablen, '%x %x' % (p + 12, strtablen)
  u0, u1, n, u2, u3 = struct.unpack_from('<IIBBH', tlb, strtaboff+p)
  return tlb[strtaboff+p+12:strtaboff+p+12+n], u0, u1, u2, u3


def getstr(p):
  strtaboff, strtablen = entries[8]
  assert 0 <= p
  assert p + 2 <= strtablen
  n, = struct.unpack_from('<H', tlb, strtaboff+p)
  return tlb[strtaboff+p+2:strtaboff+p+2+n]


def getcust(p):
  # If top byte is 0x8c, the lower bytes contain value inline.  Else, it
  # references custom data (section 12).
  if p & 0x8c000000:
    return p & ~0x8c000000
  custoff, custlen = entries[11]
  assert 0 <= p
  assert p + 2 <= custlen
  kind, = struct.unpack_from('<H', tlb, custoff+p)
  assert kind in [3, 8, 0x13], kind
  if kind == 3:  # signed
    return struct.unpack_from('<i', tlb, custoff+p+2)[0]
  if kind == 0x13:  # unsigned
    return struct.unpack_from('<I', tlb, custoff+p+2)[0]
  if kind == 8:  # text
    n, = struct.unpack_from('<I', tlb, custoff+p+2)
    return tlb[custoff+p+6:custoff+p+6+n]


def getcustlist(p):
  custoff, custlen = entries[12]
  assert 0 <= p
  assert p + 12 <= custlen
  l = []
  while p != 0xffffffff:
    guidoff, dataoff, p = struct.unpack_from('<III', tlb, custoff + p)
    l.append((getguid(guidoff)[0], getcust(dataoff)))
  return l


def paramtypestr(paramty, paramtyflags):
  types = {
    0x2: 'short',
    0x3: 'long',
    0x4: 'float',
    0x5: 'double',
    0x6: 'CURRENCY',
    0x7: 'DATE',
    0x8: 'BSTR',
    0x9: 'IDispatch',
    0xa: 'SCODE',
    0xb: 'VARIANT_BOOL',
    0xc: 'VARIANT',
    0xd: 'IUnknown',
    0x10: 'char',
    0x11: 'unsigned char',
    0x12: 'unsigned short',
    0x13: 'unsigned long',
    0x14: 'hyper',
    0x15: 'unsigned hyper',
    0x16: 'int',
    0x17: 'unsigned int',
    0x18: 'void',
    0x19: 'HRESULT',
    0x1f: 'LPWSTR',
    0x50: 'SAFEARRAY',
    0x90: 'HBITMAP',
    0xc0: 'HGLOBAL',
  }
  if paramtyflags & 0x8000:
    assert paramty in types, '%x' % paramty
    return types[paramty]
  ptroff, ptrlen = entries[9]
  assert 0 <= paramty
  assert paramty + 8 <= ptrlen
  t1, t2, t3, t4 = struct.unpack_from('<HHHH', tlb, ptroff+paramty)
  assert t1 in [0x1a, 0x1c, 0x1d], '%x' % t1
  if t1 == 0x1a:  # Pointer.
    return paramtypestr(t3, t4) + '*'
  if t1 == 0x1c:  # Array.
    arroff, arrlen = entries[10]
    infooff = (t4 << 16) + t3
    assert 0 <= infooff
    assert infooff + 8 <= arrlen
    ndim, = struct.unpack_from('<H', tlb, arroff + infooff + 4)
    s = ['[%d]' % struct.unpack_from('<H', tlb, arroff + infooff + (i + 1)*8)[0]
         for i in range(ndim)]
    return paramtypestr(*struct.unpack_from('<HH', tlb, arroff + infooff)) + \
           ''.join(s)
  #if t1 == 0x1d and t2 == 3:  # Custom type.
  if t1 == 0x1d:  # Custom type.
    # XXX this almost works, except if using an HWND* param while also
    # saying `importlib("oleacc.dll")` -- in that case, we end up with an
    # incorrect reference here.
    return 'customXXX'
    infooff = (t4 << 16) + t3
    #print '%x %x %x %x' % (t1, t2, t3, t4)
    #print '%x %d' % (infooff, infooff)
    #assert False
    assert infooff % 100 == 0, infooff
    intoff, intlen = entries[0]
    assert 0 <= infooff
    assert infooff + 100 <= intlen
    infooff += intoff
    kind = ord(tlb[infooff])
    typeoff, = struct.unpack_from('<I', tlb, infooff + 0x34)
    if kind == 0x20:
      return 'enum ' + gettystr(typeoff)[0]
    if kind == 0x21:
      return 'struct ' + gettystr(typeoff)[0]
    if kind == 0x27:
      return 'union ' + gettystr(typeoff)[0]
    return gettystr(typeoff)[0]
  #if t1 == 0x1d:  # XXX what?
  #return 'XXX'


tlb = open(sys.argv[1], 'rb').read()

assert tlb[0:4] == 'MSFT'
# oleview.exe refuses to open files that don't start with this.
assert tlb[4:8] == '\x02\x00\x01\x00'

# TLB files start with a 0x54 byte header.
# I changed header contents (xxd, change, xxd -r) and opened the modified tlb
# files in oleview.exe to discover the meaning of some of these fields.
# I also ran small test.idl files through midl.exe and looked at its output
# when various inputs were present or absent.
# ODL syntax for .idl input:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221254(v=vs.85).aspx
# 0-3: 'MSFT' always
# 4-7: 0200 0100 always
# 8-0xb: offset of file GUID (into GUID section)
# 0xc-0xf: 0904 0000 always (?) (0904 looks like the US english language code
#                                in res files -- yup, controlled by lcid() attr)
# 0x10: ? (always 0?)
# 0x14: 4100 0000 for 32-bit files, 4300 0000 for 64-bit files -- some bit mask?
# 0x18: 2xuint16 version
# 0x1c: ? (4 for ia2, 0 else)
# 0x20: uint32 number of types (interface, coclass) in tlb file
# 0x24: helpstring(), offset into strtab
# 0x38: library name, offset into typetab
# 0x3c: always ffff ffff (?)
# 0x40: uint32 custoff, offset into 13th section, points to head of global
#       custom() list.
# 0x4c: always ffff ffff (?) (...not for google_update! 1 there)

guidoff, = struct.unpack_from('<I', tlb, 8)
v1, v2, _, nwords, stroff = struct.unpack_from('<HHIII', tlb, 0x18)
typeoff, _, custoff = struct.unpack_from('<III', tlb, 0x38)
diroff = 0x54 + 4*nwords

# After the header, there are nwords uint32.
# These just look like increasing offsets, each growing by 100 bytes.
for i in range(nwords):
  word, = struct.unpack_from('<I', tlb, 0x54 + 4*i)
  assert word == 100 * i
  #print '%d' % word
#print

# After that, there are 15 section headers that just contain (offset, length)
# pairs.  Each section header has fixed semantics (1st one always points to
# type descriptions, etc).

entries = []
names = [''] * 15
names[0] = 'types'

names[2] = 'importlibs'

names[4] = 'guids hash (??)'
names[5] = 'guids'
names[6] = 'typetab hash (??)'
names[7] = 'typetab'
names[8] = 'strtab'
names[9] = 'complex types'
names[10] = 'array types'
names[11] = 'custom'
names[12] = 'custom+guid'
names[13] = 'empty'
names[14] = 'empty'
for i in range(15):
  off, ln, minusone, fifteen = \
      struct.unpack_from('<IIII', tlb, diroff + i*16)
  assert minusone == 0xffffffff
  assert fifteen == 0xf
  print '%x %x => %x (%s)' % (off, ln, off+ln, names[i])
  entries.append((off, ln))
print

# Print library header.
print '['
print '  uuid(%s),' % getguid(guidoff)[0]
print '  version(%d.%d),' % (v1, v2)
if stroff != 0xffffffff:
  print '  helpstring("%s"),' % getstr(stroff)
if custoff != 0xffffffff:
  for g, v in getcustlist(custoff):
    print '  custom(%s, %s),' % (g, str(v))
print ']'
print 'library %s' % gettystr(typeoff)[0]
print

# Looks like the first section has "nwords" many entries, each 100 bytes long
# (i.e. indexed by the numbers in front of the section table, but those are
# just multiple of 100)
print 'Entry 1: Interfaces'
assert entries[0][1] == nwords * 100
intoff = entries[0][0]
for i in range(nwords):
  # First byte: 0x25 coclass, 0x23 interface
  # @+4: offset to method data (?) -- after all the sections in the section dict
  # @+0x18: uint16 n_methods
  # @+0x1a: uint16 n_fields
  # @+0x2c: offset into guid table (?)
  # @+0x34: offset into typetab table (name)
  # @+0x3c: offset into strtab table (help text)
  # @+0x48: uint32 custoff, offset into 13th section, points to head of a
  #         custom() list.
  infooff = intoff + i * 100
  #hexdump(tlb, infooff, 100)
  guidoff, _, typeoff, _, stroff = struct.unpack_from(
      '<IIIII', tlb, infooff + 0x2c)
  custoff, = struct.unpack_from('<I', tlb, infooff + 0x48)
  if guidoff != 0xffffffff:
    guid, n0, n1 = getguid(guidoff)
  if stroff != 0xffffffff:
    s = getstr(stroff)
  print '[',
  if guidoff != 0xffffffff:
    print 'uuid(%s),' % guid,
  if stroff != 0xffffffff:
    print 'helpstring("%s")' % s,
  if custoff != 0xffffffff:
    print ', '.join('custom(%s, %s)' % (g, str(v))
                    for g, v in getcustlist(custoff)),
  print ']'
  kind = ord(tlb[infooff])
  assert kind in [0x20, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x34], '%x' % kind
  is_struct = kind == 0x21
  is_union = kind == 0x27
  print { 0x20: 'typedef enum',  # ??
          0x21: 'typdef struct', # ??
          0x23: 'interface',
          0x24: 'dispinterface',
          0x25: 'coclass',
          0x26: 'typedef uint64',  # ??
          0x27: 'typedef union',  # ??
          0x34: 'interface',  # with superclass (?)
        }[kind],
  ts, t0, t1, t2, t3 = gettystr(typeoff)
  print '%s {' % ts
  n_meth, n_field = struct.unpack_from('<HH', tlb, infooff + 0x18)
  methoff, = struct.unpack_from('<I', tlb, infooff + 4)
  # Method and field data:
  # uint32 offset to past method data (where id table, param name table are)
  # n_methods + n_fields: uint16 len, that much data
  # n_methods + n_fields: uint32 (just 1, 2, 3, ...?)
  #            for fields, it looks like (uint16, uint16) pairs with first elt
  #            going 1, 2, 3, .. while 2nd is always 0x4000
  # n_methods + n_fields offsets into typetab method names
  # n_methods + n_fields uint32 offset to parameter dtor for i'th method
  methnameoff = methoff + 4
  helps = []
  params = []
  values = []
  rettypes = []
  lastargname = 0
  for i in range(n_meth + n_field):
    size, ind, rettype, rettypeflag = struct.unpack_from(
        '<HHHH', tlb, methnameoff)
    # In here (@+0 is size), for meths (i < n_meth):
    # @+2: uint16 index
    assert ind == i
    # @+4: uint16 type
    # @+6: uint16 type flag
    #      if flag & 0x8000, then type is inline type, else it's offset into
    #      complex type section (section 10)
    rettypes.append((rettype, rettypeflag))
    # @+0x14: num params
    # @+0x1c: help string, strtab offset (if present)
    # For fields:
    # @+0x10: initial value (at least for enums).
    #         For structs, this seems to be the offset of the field.
    if i < n_meth:
      n_params, = struct.unpack_from('<H', tlb, methnameoff + 0x14)
      value = None
    else:
      n_params = 0
      value, = struct.unpack_from('<I', tlb, methnameoff + 0x10)
      if is_struct:
        value = 'offset %x' % value
      elif is_union:
        value = None
      else:
        value = getcust(value)
    values.append(value)
    header_size = size - 12*n_params

    if header_size >= 0x1c:
      helpstr, = struct.unpack_from('<I', tlb, methnameoff + 0x1c)
      helps.append(getstr(helpstr))
    else:
      helps.append('')

    # A parameter descriptor is 3x uint32 large, starts at meth+0x20
    # middle one is ref to name. The other two are type and flags probably?
    thisparams = []
    for j in range(n_params):
      argtype, argtyflags, argname, argflags = struct.unpack_from(
          '<HHII', tlb, methnameoff + header_size + j*12)
      if argname == 0xffffffff:
        argname = lastargname  # weird special case
      thisparams.append((argtype, argtyflags, gettystr(argname)[0], argflags))
      lastargname = argname
    params.append(thisparams)

    methnameoff += size
  methnameoff += 4 * (n_meth + n_field)
  for i in range(n_meth + n_field):
    name, = struct.unpack_from('<I', tlb, methnameoff + 4*i)
    s, u0, u1, u2, u3 = gettystr(name)
    if i >= n_meth:
      rettype = paramtypestr(*rettypes[i])
      print '  %s %s' % (rettype, s),
      if values[i]:
        print '=', values[i],
      print
      continue
    assert not values[i]
    rettype = paramtypestr(*rettypes[i])
    if helps[i]:
      print '  [helpstring("%s")]' % helps[i]
    funout = '  %s %s(' % (rettype, s)
    argout = []
    for argtype, argtyflags, argname, argflags in params[i]:
      #print 'arg %x %x' % (argtype, argtyflags)
      argtystr = paramtypestr(argtype, argtyflags)
      flagv = []
      bits = { 1: 'in', 2: 'out', 8: 'retval', 16: 'optional' }
      for b in bits:
        if argflags & b:
          flagv.append(bits[b])
          argflags = argflags & ~b
      assert argflags == 0, argflags
      argout.append('[%s] %s %s %x %x' % (
          ', '.join(flagv), argtystr, argname, argtype, argtyflags))
    print funout + (',\n' + ' ' * len(funout)).join(argout) + ')'
  print '}'
  print
print

# 3th seems to be importlibs somehow
# first 4 bytes look like GUID offset
# 2nd 4 are 0
# 3rd 4 are 1 or 2 (why?)
# then 2 byte that are NOT string length
# then lib name
# then padding
print 'Entry 3: importlib()s'
impoff, implen = entries[2]
off = 0
while off  < implen:
  guidoff, n0, n1, l0 = struct.unpack_from('<IIIH', tlb, impoff + off)
  l = l0 >> 2
  s = tlb[impoff+off+14:impoff+off+14+l]
  print '%s %x %x %x %s' % (getguid(guidoff)[0], n0, n1, l0 & 3, s)
  off += 14 + l
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
print
assert off == implen

# 5th seems to always have length 0x80. It contains offsets into guids
# (entry 6), and -1 entries. Maybe the n1 in guids is also a "next" offset
# (also into guids), and the field here in 5th points to list heads -- maybe
# this contains a hash table (with lists in hash buckets) for the guids?

# 6th seems to store offset to GUIDs
print 'Entry 6: GUIDs'
guidoff, guidlen = entries[5]
# One entry: 16 byte GUID, two signed ints (-2 or -1)
assert guidlen % 24 == 0
for i in range(0, guidlen, 24):
  print '%04x: %s %d %d' % ((i,) + getguid(i))
print

# 7th seems to always have length 0x200. It contains offsets into typetab
# (entry 8), and -1 entries. Maybe the u1 in typetab is also a "next" offset
# (also into typetab), and the field here in 7th points to list heads -- maybe
# this contains a hash table (with lists in hash buckets) for the typetab?

# 8th of the 15 entries stores 0x1760, which seems to be the start of some
# string table. The strings here seem to be prefixed by 12 bytes of metadata
# (type data?)
# Looks like:
# uint32 ?, uint32 ?, u8 strlen, u8 ?, u16 ?, strdata, padding
print 'Entry 8: Typetab (?)'
strtaboff, strtablen = entries[7]
off = 0
i = 0
while off < strtablen:
  s, u0, u1, u2, u3 = gettystr(off)
  print 'str %d (@%x):' % (i, off), s,
  print '; %x %x %x %x' % (u0, u1, u2, u3)
  off += len(s) + 12
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 9th seems to be a "regular" strtab, with just u16len followed by str.
strtaboff, strtablen = entries[8]
print 'Entry 9: Strtab'
off = 0
i = 0
while off < strtablen:
  n, = struct.unpack_from('<H', tlb, offset=strtaboff+off)
  print 'str %d (@%x):' % (i, off), tlb[strtaboff+off+2:strtaboff+off+2+n]
  off += n + 2
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 10th seems to contain 8 bytes of data for each pointer type used in the
# idl file, so it probably contains pointer types somehow.
# Looks like the 2nd uint32 is the pointee type.  Tye first uint32 always starts
# with 0x1a00 and ends in 0x4, but the 3rd byte can be 0x10, 03, 02, 0, ...
# Looks like the 3rd byte roughly is the pointed-to type too?
# `char**` causes two entries in this table.
# Parameters that have the type of an enum also cause entries here.
# For enums, the first 4 byte are just 1d 00 03 00, and the 2nd seem to be
# the offset of the enum definition in section 1.
ptroff, ptrlen = entries[9]
print 'Entry 10: complex types'
hexdump(tlb, ptroff, ptrlen)
print

# 11th is only non-empty if the .idl files contains arrays (`int a[10]`), so
# it contains array type descriptors.
# Looks like 16 bytes per array type.
# First uint16: array base type.
# 2nd uint16: array base type flags (?).
# 3rd uint16: number of array dimensions.
# 4th uint16: ??
# Then, for each array dimension 8 bytes which stores array size along dimension
# and seems to be 0 else.
arroff, arrlen = entries[10]
print 'Entry 11: array types'
hexdump(tlb, arroff, arrlen)
print

# 12th seems to be custom's info (midl.exe version string and some)
# Looks like this is just another chunk of data. Each packet is uint16 type.
# Type 0x8 is "text" or "raw", and is uint32 len followed by that many data
# bytes. Type 0x13 is followed by uint32 data bytes. Each packet is followed
# by padding to 4 byte boundary. Type 0x3 is also (signed) int32.
custoff, custlen = entries[11]
print 'Entry 12: custom (len %d)' % custlen
hexdump(tlb, custoff, custlen)
print

# 13th seems to link up GUIDs to custom data. Tuples of:
# uint32 guid, uint32 custom off, uint32 next
# (next points to the next 3-tuple in this section, for list of custom()s,
# with the final elt in the list having 0xffffffff)
print 'Entry 13: custom+guid'
custoff, custlen = entries[12]
for i in range(0, custlen, 12):
  guidoff, dataoff, nextel = struct.unpack_from('<III', tlb, custoff + i)
  print 'off %x: guid(%s) value(%s), next %x' % (
      i, getguid(guidoff)[0], str(getcust(dataoff)), nextel)

# This describes an interface that seems to query .tlb files:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221549(v=vs.85).aspx
