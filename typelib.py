# Attempts to dump .tlb files such as generated by the midl.exe tool.

# I looked at the output of oleview.exe on google_update.tlb and at
# google_update.tlb's contents.

""".tlb viewer.

Run like:
typelib.py third_party/win_build_output/midl/google_update/x64/google_update_idl.tlb
"""

import sys
import struct

def hexdump(dat, o, l):
  for i in range(o, o + l, 16):
    s = dat[i:min(i + 16, o + l)]
    hexstr = ' '.join(['%02x' % ord(c) for c in s])
    textstr = ''.join([c if 0x20 <= ord(c) <= 0x7e else '.' for c in s])
    print '%-48s %s' % (hexstr, textstr)


def getguid(p):
  guidoff, guidlen = entries[5]
  assert 0 <= p
  assert p + 24 <= guidlen
  g0, g1, g2, g3, g4, n0, n1 = struct.unpack_from('<IHHH6sii', tlb, guidoff + p)
  g4 = ''.join(['%02X' % ord(g) for g in g4])
  return '%08X-%04X-%04X-%04X-%s' % (g0, g1, g2, g3, g4), n0, n1


def gettystr(p):
  strtaboff, strtablen = entries[7]
  assert 0 <= p
  assert p + 12 <= strtablen
  u0, u1, n, u2, u3 = struct.unpack_from('<IIBBH', tlb, strtaboff+p)
  return tlb[strtaboff+p+12:strtaboff+p+12+n], u0, u1, u2, u3


def getstr(p):
  strtaboff, strtablen = entries[8]
  assert 0 <= p
  assert p + 2 <= strtablen
  n, = struct.unpack_from('<H', tlb, strtaboff+p)
  return tlb[strtaboff+p+2:strtaboff+p+2+n]


tlb = open(sys.argv[1], 'rb').read()

assert tlb[0:4] == 'MSFT'

# It looks like there are 15 offset/len/-1/15 tuples at 0xe0.
# But for ia2_api_all.tlb, the offset is 0xc8 instead.
# ...looks like the number at 0x20 is some count that's smaller for ia2.
# (0x1d == 29 vs 0x23 == 35. 0xe0 - 0xc8 == 24, 35 - 29 is 6, which neatly
# divides the 24 bytes. So the number at 0x20 is number of 4 byte somethings.
# 0xe0 - 35*4 == 0xc8 - 29*4 == 84, so the ints probably start at 84/0x54?)
# This theory mostly works out, except some offsets are 0xffff (== not present,
# always have len of 0).
# This suggests the fixed file header is 84/0x54 bytes long.
# 0-3: 'MSFT' always
# 0x18: 2xuint16 version (?) (at least ia2_api_all has 0100 0300 there, and
#       oleview.exe says that file is version 1.3)
# 0x20: uint32 nwords, number of types (interface, coclass) in tlb file
# 0x50: uint32 custoff, offset into 13th section, points to head of global
#       custom() list.
# Also somewhere: GUID offset, helpstring offset (XXX change numbers, open in
# oleview.exe, see which one changes things)

nwords, = struct.unpack_from('<I', tlb, 0x20)
#print nwords
#print hex(0x54 + 4*nwords)
diroff = 0x54 + 4*nwords

# These just look like increasing offsets, each growing by 100 bytes.
for i in range(nwords):
  word, = struct.unpack_from('<I', tlb, 0x54 + 4*i)
  assert word == 100 * i
  #print '%d' % word
#print

entries = []
names = [''] * 15
names[0] = 'types'
names[2] = 'importlibs'
names[5] = 'guids'
names[7] = 'typetab'
names[8] = 'strtab'
names[10] = 'empty'
names[11] = 'custom'
names[12] = 'custom+guid'
names[13] = 'empty'
names[14] = 'empty'
for i in range(15):
  off, ln, minusone, fifteen = \
      struct.unpack_from('<IIII', tlb, diroff + i*16)
  assert minusone == 0xffffffff
  assert fifteen == 0xf
  print '%x %x => %x (%s)' % (off, ln, off+ln, names[i])
  entries.append((off, ln))
print

# Looks like the first section has "nwords" many entries, each 100 bytes long
# (i.e. indexed by the numbers in front of the section table, but those are
# just multiple of 100)
# For chromoting_lib.tlb, nwords is 3 and oleview shows 3 interfaces, so
# maybe this section is type descriptors.
# chromoting_lib.tlb has:
# 1. [ uuid(6741FD0A-6A8A-5838-A35E-8088697E2088), (uuid 5)
#      helpstring("RdpDesktopSession Class") ] (str 1)
#    coclass RdpDesktopSession {} (typestr 1)
# 2. [ odl,
#      uuid(6A7699F0-EE43-43E7-AA30-A6738F9BD470), (uuid 6)
#      helpstring("IRdpDesktopSession Interface"), (str 2)
#      nonextensible ]
#    interface IRdpDesktopSession : IUnknown  (typestr 2){}
# 3. [ odl,
#      uuid(B59B96DA-83CB-40EE-9B91-C377400FC3E3), (uuid 8)
#      helpstring("IRdpDesktopSessionEventHandler Interface"), (str 3)
#      nonextensible ]
#    interface IRdpDesktopSessionEventHandler : IUnknown {} (typestr 3)
print 'Entry 1: Interfaces'
assert entries[0][1] == nwords * 100
intoff = entries[0][0]
for i in range(nwords):
  # First byte: 0x25 coclass, 0x23 interface
  # @+0x14: n_methods
  # @+0x2c: offset into guid table (?)
  # @+0x34: offset into typetab table (name)
  # @+0x3c: offset into strtab table (help text)
  infooff = intoff + i * 100
  hexdump(tlb, infooff, 100)
  guidoff, _, typeoff, _, stroff = struct.unpack_from(
      '<IIIII', tlb, infooff + 0x2c)
  if guidoff != 0xffffffff:
    guid, n0, n1 = getguid(guidoff)
  if stroff != 0xffffffff:
    s = getstr(stroff)
  print '[',
  if guidoff != 0xffffffff:
    print 'uuid(%s),' % guid,
  if stroff != 0xffffffff:
    print 'helpstring("%s")' % s,
  print ']'
  assert ord(tlb[infooff]) in [0x20, 0x21, 0x23, 0x25, 0x26, 0x34]
  print { 0x20: 'typedef enum',  # ??
          0x21: 'typdef struct', # ??
          0x23: 'interface',
          0x26: 'typedef uint64',  # ??
          0x34: 'interface',  # with superclass (?)
          0x25: 'coclass' }[ord(tlb[infooff])],
  ts, t0, t1, t2, t3 = gettystr(typeoff)
  print ts
print

# 3th seems to be importlibs somehow
# first 4 bytes look like GUID offset
# 2nd 4 are 0
# 3rd 4 are 1 or 2 (why?)
# then 2 byte that are NOT string length
# then lib name
# then padding

# 6th seems to store offset to GUIDs
print 'Entry 6: GUIDs'
guidoff, guidlen = entries[5]
# One entry: 16 byte GUID, two signed ints (-2 or -1)
assert guidlen % 24 == 0
for i in range(0, guidlen, 24):
  print '%04x: %s %d %d' % ((i,) + getguid(i))
print

# 8th of the 15 entries stores 0x1760, which seems to be the start of some
# string table. The strings here seem to be prefixed by 12 bytes of metadata
# (type data?)
# Looks like:
# uint32 ?, uint32 ?, u8 strlen, u8 ?, u16 ?, strdata, padding
print 'Entry 8: Typetab (?)'
strtaboff, strtablen = entries[7]
off = 0
i = 0
while off < strtablen:
  s, u0, u1, u2, u3 = gettystr(off)
  print 'str %d (@%x):' % (i, off), s,
  print '; %x %x %x %x' % (u0, u1, u2, u3)
  off += len(s) + 12
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 9th seems to be a "regular" strtab, with just u16len followed by str.
strtaboff, strtablen = entries[8]
print 'Entry 9: Strtab'
off = 0
i = 0
while off < strtablen:
  n, = struct.unpack_from('<H', tlb, offset=strtaboff+off)
  print 'str %d (@%x):' % (i, off), tlb[strtaboff+off+2:strtaboff+off+2+n]
  off += n + 2
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 10th is some int field.

# 11th is empty (-1) for the files i looked at.

# 12th seems to be custom's info (midl.exe version string and some)
# Looks like this is just another chunk of data. Each packet is uint16 type.
# Type 0x8 is "text" or "raw", and is uint32 len followed by that many data
# bytes. Type 0x13 is followed by uint32 data bytes. Each packet is followed
# by padding to 4 byte boundary. Type 0x3 is also uint32? Or maybe 0x13 is
# signed and 0x3 is unsigned?
custoff, custlen = entries[11]
print 'Entry 12: custom (len %d)' % custlen
hexdump(tlb, custoff, custlen)
print

# 13th seems to link up GUIDs to custom data. Tuples of:
# uint32 guid, uint32 custom off, uint32 next
# (next points to the next 3-tuple in this section, for list of custom()s,
# with the final elt in the list having 0xffffffff)
custoff, custlen = entries[12]
for i in range(custoff, custoff+custlen, 12):
  guidoff, dataoff, nextel = struct.unpack_from('<III', tlb, i)
  # XXX: display data at dataoff
  # XXX: google_update_lib.idl suggests that if high bit of dataoff is set,
  # the data comes from a different section or something.
  # XXX: ia2_api_all.tlb has data in 12th section not referenced by this 13th,
  # so other things seem to reference into section 12 too.
  print '%s: %x %x' % (getguid(guidoff)[0], dataoff, nextel)

# This describes an interface that seems to query .tlb files:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221549(v=vs.85).aspx
