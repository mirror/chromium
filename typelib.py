# Attempts to dump .tlb files such as generated by the midl.exe tool.

# I looked at the output of oleview.exe on google_update.tlb and at
# google_update.tlb's contents.

""".tlb viewer.

Run like:
typelib.py third_party/win_build_output/midl/google_update/x64/google_update_idl.tlb
"""

import sys
import struct

tlb = open(sys.argv[1], 'rb').read()

assert tlb[0:4] == 'MSFT'

# It looks like there are 15 offset/len/-1/15 tuples at 0xe0.
# But for ia2_api_all.tlb, the offset is 0xc8 instead.
# ...looks like the number at 0x20 is some count that's smaller for ia2.
# (0x1d == 29 vs 0x23 == 35. 0xe0 - 0xc8 == 24, 35 - 29 is 6, which neatly
# divides the 24 bytes. So the number at 0x20 is number of 4 byte somethings.
# 0xe0 - 35*4 == 0xc8 - 29*4 == 84, so the ints probably start at 84/0x54?)
# This theory mostly works out, except some offsets are 0xffff (== not present,
# always have len of 0).
# This suggests the fixed file header is 84/0x54 bytes long.

nwords, = struct.unpack_from('<I', tlb, 0x20)
#print nwords
#print hex(0x54 + 4*nwords)
diroff = 0x54 + 4*nwords

# These just look like increasing offsets, each growing by 100 bytes.
for i in range(nwords):
  word, = struct.unpack_from('<I', tlb, 0x54 + 4*i)
  assert word == 100 * i
  print '%d' % word
print

entries = []
for i in range(15):
  off, ln, minusone, fifteen = \
      struct.unpack_from('<IIII', tlb, diroff + i*16)
  assert minusone == 0xffffffff
  assert fifteen == 0xf
  print '%x %x => %x' % (off, ln, off+ln)
  entries.append((off, ln))
print

# 6th seems to store offset to GUIDs
print 'Entry 6: GUIDs'
guidoff, guidlen = entries[5]
# One entry: 16 byte GUID, two signed ints (-2 or -1)
assert guidlen % 24 == 0
for i in range(0, guidlen, 24):
  g0, g1, g2, g3, g4, n0, n1 = struct.unpack_from('<IHHH6sii', tlb, guidoff + i)
  g4 = ''.join(['%02X' % ord(g) for g in g4])
  print '%08X-%04X-%04X-%04X-%s %d %d' % (g0, g1, g2, g3, g4, n0, n1)

# 8th of the 15 entries stores 0x1760, which seems to be the start of some
# string table. The strings here seem to be prefixed by 15 or so bytes of
# metadata (type data?)
strtaboff = entries[7][0]
print '%x' % strtaboff
print

# 9th seems to be a "regular" strtab, with just u16len followed by str.
strtaboff, strtablen = entries[8]
print 'Entry 9: Strtab'
off = 0
i = 0
while off < strtablen:
  n, = struct.unpack_from('<H', tlb, offset=strtaboff+off)
  print 'str %d:' % i, tlb[strtaboff+off+2:strtaboff+off+2+n]
  off += n + 2
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 10th is some int field.

# 11th is empty (-1) for the files i looked at.

# 12th seems to be creator's info (midl.exe version string and some)
creatoff, creatlen = entries[11]
print 'Entry 12: Creator info (len %d)' % creatlen
for i in range(creatoff, creatoff + creatlen, 16):
  s = tlb[i:min(i + 16, creatoff + creatlen)]
  print ' '.join(['%02x' % ord(c) for c in s]),
  print ' ' * (16 - len(s)) * 3,
  print ''.join([c if 0x20 <= ord(c) <= 0x7e else '.' for c in s])

# This describes an interface that seems to query .tlb files:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221549(v=vs.85).aspx
