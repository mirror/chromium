# Attempts to dump .tlb files such as generated by the midl.exe tool.
# This dumper can process all .tlb files checked in at
# third_party/win_build_output. It doesn't look at all input bytes, but
# it produces reasonably complete output, compared to what oleview.exe
# prints.
# Missing:
# * some metadata flags (propget, dual, id(), propput; on module dllname(""),
#   helpcontext(0x123); entry("") -- see stdole2.tlb)
# * defaultvalue()'s value
# * interface base classes
# * calling conventions (_stdcall vs not)
""".tlb viewer.

Run like:
typelib.py third_party/win_build_output/midl/google_update/x64/google_update_idl.tlb
"""

import sys
import struct

def hexdump(dat, o, l):
  for i in range(o, o + l, 16):
    s = dat[i:min(i + 16, o + l)]
    hexstr = ' '.join(['%02x' % ord(c) for c in s])
    textstr = ''.join([c if 0x20 <= ord(c) <= 0x7e else '.' for c in s])
    print '%-48s %s' % (hexstr, textstr)


def getguid_at(data, base, p):
  g0, g1, g2, g3, n0, n1 = struct.unpack_from('<IHH8siI', data, base + p)
  g3 = ''.join(['%02X' % ord(g) for g in g3])
  # Hm, n1 might be a "next" pointer (into the GUID section again) like in
  # section 13 -- so that the GUID section can contain lists of GUIDs. -1 means
  # end-of-list.
  # n0 can point to the offset of an interface for GUIDs on interfaces (in
  # section 1), or its lowest bit is set for foreign guid references (and rest
  # is multiple of 0x12 -- offset to somewhere, but not clear where).
  return '%08X-%04X-%04X-%s-%s' % (g0, g1, g2, g3[0:4], g3[4:]), n0, n1


def getguid(p):
  guidoff, guidlen = entries[5]
  assert 0 <= p
  assert p + 24 <= guidlen
  return getguid_at(tlb, guidoff, p)


def guidhash(guidstr):
  import operator, uuid
  words = struct.unpack('<8H', uuid.UUID(guidstr).bytes_le)
  return reduce(operator.xor, [w for w in words]) % (0x80 / 4)


# svaldez@google.com figured out the hash function, given a list of input
# strings and their hash values as computed by midl.exe, with the help
# of tctc@google.com and vtl@google.com (and some initial dumb guesses by
# me, see gerrit history for my sorry attempts).
def hash_tystr(s):
  s = s.upper().replace('W', 'V').replace('Y', 'U')
  h = 0xdeadbee
  for i, x in enumerate(s):
    h = (37*h + ord(x)) & 0xffffffff
  return (h % 0x1003F) & 0xffff


def gettystr(p):
  strtaboff, strtablen = entries[7]
  assert 0 <= p
  assert p + 12 <= strtablen, '%x %x' % (p + 12, strtablen)
  # 5 numbers:
  # 1st varies by type (4th number).
  #     For interfaces (type 0x38): offset into section 1, pointing to
  #                                 description of that type.
  #     For enum values (0x30): offset of enum type this belongs to.
  #     For other (type 0): If set, this is a method name, and this is the
  #                         offset of the first interface with a method of this
  #                         name.
  #   Else, often 0xffffffff.
  # 2nd is hash table next pointer, another offset into the 8th section.
  # 3rd is length of string following the 5 numbers
  # 4th seems type of thing named by string
  #     0x10: struct field (?)
  #     0x30: enum field (?)
  #     0x38: interface name.
  #        0: method, param, library name ("other string", basically).
  # 5th is the hash value of the string as computed by hash_tystr()
  to, nextelt, n, kind, strhash = struct.unpack_from('<IIBBH', tlb, strtaboff+p)
  s = tlb[strtaboff+p+12:strtaboff+p+12+n]
  assert kind in [0, 0x10, 0x30, 0x38], '0x%x' % kind
  if kind == 0x38 or (kind == 0 and to != 0xffffffff):
    assert to % 100 == 0
  assert hash_tystr(s) == strhash
  return s, to, nextelt, kind, strhash


def getstr(p):
  strtaboff, strtablen = entries[8]
  assert 0 <= p
  assert p + 2 <= strtablen
  n, = struct.unpack_from('<H', tlb, strtaboff+p)
  return tlb[strtaboff+p+2:strtaboff+p+2+n]


def getcust(p):
  # If top byte is 0x8c, the lower bytes contain value inline.  Else, it
  # references custom data (section 12).
  if p & 0x8c000000:
    return p & ~0x8c000000
  custoff, custlen = entries[11]
  assert 0 <= p
  assert p + 2 <= custlen
  kind, = struct.unpack_from('<H', tlb, custoff+p)
  assert kind in [3, 8, 0x13], kind
  if kind == 3:  # signed
    return struct.unpack_from('<i', tlb, custoff+p+2)[0]
  if kind == 0x13:  # unsigned
    return struct.unpack_from('<I', tlb, custoff+p+2)[0]
  if kind == 8:  # text
    n, = struct.unpack_from('<I', tlb, custoff+p+2)
    return tlb[custoff+p+6:custoff+p+6+n]


def getcustlist(p):
  custoff, custlen = entries[12]
  assert 0 <= p
  assert p + 12 <= custlen
  l = []
  while p != 0xffffffff:
    guidoff, dataoff, p = struct.unpack_from('<III', tlb, custoff + p)
    l.append((getguid(guidoff)[0], getcust(dataoff)))
  return l


def find_dll(name):
  """Looks up a dll named |name| using Windows's dll lookup rule."""
  import os
  dirs = os.environ['PATH'].split(os.pathsep)
  if sys.platform == 'win32':
    import win32api
    dirs = [os.getcwd(),
            win32api.GetSystemDirectory(),
            win32api.GetWindowsDirectory()] + dirs
  for d in dirs:
    candidate = os.path.join(d, name)
    if os.path.exists(candidate):
      return candidate


def extract_typelib_res(libpath):
  """Opens a PE executable, finds the first TYPELIB resource, and returns it."""
  try:
    import pefile
  except:
    import os
    sys.path.insert(0, os.path.join(os.path.dirname(__file__),
                                    'third_party', 'pefile'))
    import pefile
  pe = pefile.PE(libpath, fast_load=True)
  pe.parse_data_directories(directories=[
      pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_RESOURCE']])
  #print pe.dump_info()
  for resty in pe.DIRECTORY_ENTRY_RESOURCE.entries:
    if str(resty.name) != 'TYPELIB':
      continue
    for resid in resty.directory.entries:
      #print 'id', resid.id
      for reslang in resid.directory.entries:
        # Docs say to use first TYPELIB resource unless instructed otherwise.
        #print reslang.id, reslang.data.lang, reslang.data.sublang
        #print reslang.data.struct.OffsetToData, reslang.data.struct.Size
        return pe.get_memory_mapped_image()[
            reslang.data.struct.OffsetToData:
            reslang.data.struct.OffsetToData + reslang.data.struct.Size]
  assert False


def find_remote_type(liboff, typeindex=-1, byguid=''):
  impoff, implen = entries[2]
  assert liboff + 12 <= implen
  guidoff, n0, n1, l0 = struct.unpack_from('<IIIH', tlb, impoff + liboff)
  l = l0 >> 2
  s = tlb[impoff+liboff+14:impoff+liboff+14+l]
  # XXX: cache |s|'s data, this currently does PATH lookup and PE resource
  # parsing for every remote type lookup.
  libpath = find_dll(s)
  assert libpath
  libtlb = extract_typelib_res(libpath)
  assert libtlb
  libguidoff, = struct.unpack_from('<I', libtlb, 8)
  v1, v2, _, nwords, stroff = struct.unpack_from('<HHIII', libtlb, 0x18)
  typeoff, _, custoff = struct.unpack_from('<III', libtlb, 0x38)
  diroff = 0x54 + 4*nwords
  # assert guid in remote tlb matches local referenced library guid
  guidbaseoff = struct.unpack_from('<I', libtlb, diroff + 5*16)[0]
  assert getguid_at(libtlb, guidbaseoff, libguidoff)[0] == getguid(guidoff)[0]

  if byguid:
    assert typeindex == -1, 'only set typeindex or byguid, not both'
    # Be fancy and go to the guid hash table to get the guid offset, and then
    # go to the type from there instead of just doing a linear scan of guids.
    h = 4*guidhash(byguid)
    h += struct.unpack_from('<I', libtlb, diroff + 4*16)[0]
    hashoff, = struct.unpack_from('<I', libtlb, h)
    guid_s = ''
    while guid_s != byguid:
      assert hashoff != 0xffffffff
      guid_s, off, hashoff = getguid_at(libtlb, guidbaseoff, hashoff)
    assert off % 100 == 0
    typeoff = off
  else:
    assert typeindex != -1, 'must set typeindex if byguid not set'
    assert byguid == '', 'only set typeindex or byguid, not both'
    typeoff = 100*typeindex
    #print struct.unpack_from('<I', libtlb, 0x54+4*typeindex)[0], 100*typeindex
    assert struct.unpack_from(
        '<I', libtlb, 0x54+4*typeindex)[0] == 100*typeindex

  # Get name of type at typeoff
  typenamoff, = struct.unpack_from('<I', libtlb, diroff + 0*16)
  typenamoff += typeoff
  typenamoff, = struct.unpack_from('<I', libtlb, typenamoff + 0x34)
  strtaboff, = struct.unpack_from('<I', libtlb, diroff + 7*16)
  n, = struct.unpack_from('<B', libtlb, strtaboff+typenamoff+8)
  typename = libtlb[strtaboff+typenamoff+12:strtaboff+typenamoff+12+n]

  # Also get library name, to qualify type name.
  #n, = struct.unpack_from('<B', libtlb, strtaboff+typeoff+8)
  #libname = libtlb[strtaboff+typeoff+12:strtaboff+typeoff+12+n]
  #return '%s.%s' % (libname, typename)
  return '%s::%s' % (s, typename)


def customtypestr(infooff, include_interface=False):
  if infooff & 1 != 0:
    # If the lowest bit is set, then this is a reference to a type defined
    # in an imported tlb (e.g. GUID after `importlib("stdole2.tlb")`).
    # infooff is an offset into the 2nd section then, which has more info.
    infooff = infooff & ~1
    assert infooff % 12 == 0, infooff
    foroff, forlen = entries[1]
    assert 0 <= infooff
    assert infooff + 12 <= forlen
    # Looks like the 12 bytes are:
    # uint16 running index
    # uint16 unk (0x100, 0x600, 0 in practice)
    # => hm looks like if the lowest it of this is set, then the 4th int32
    # means something else, see e.g. iFont with stdole2.tlb imported.
    # Aha, then it's an offset into our local guid table with the guid
    # identifying the remote type!
    # int32 offset into section 3, importlibs
    # int32 type offset into library identified by previous number
    ind, unk, lib, typeind = struct.unpack_from('<HHII', tlb, foroff+infooff)
    if unk & 1:
      return find_remote_type(lib, byguid=getguid(typeind)[0])
    else:
      return find_remote_type(lib, typeind)
  assert infooff % 100 == 0, infooff
  intoff, intlen = entries[0]
  assert 0 <= infooff
  assert infooff + 100 <= intlen
  infooff += intoff
  kind = ord(tlb[infooff])
  typeoff, = struct.unpack_from('<I', tlb, infooff + 0x34)
  if kind == 0x20:
    return 'enum ' + gettystr(typeoff)[0]
  if kind == 0x21:
    return 'struct ' + gettystr(typeoff)[0]
  if kind == 0x27:
    return 'union ' + gettystr(typeoff)[0]
  if include_interface and kind == 0x23:
    return 'interface ' + gettystr(typeoff)[0]
  if include_interface and kind == 0x24:
    return 'dispinterface ' + gettystr(typeoff)[0]
  return gettystr(typeoff)[0]

def paramtypestr(paramty, paramtyflags):
  types = {
    0x2: 'short',
    0x3: 'long',
    0x4: 'float',
    0x5: 'double',
    0x6: 'CURRENCY',
    0x7: 'DATE',
    0x8: 'BSTR',
    0x9: 'IDispatch',
    0xa: 'SCODE',
    0xb: 'VARIANT_BOOL',
    0xc: 'VARIANT',
    0xd: 'IUnknown',
    0x10: 'char',
    0x11: 'unsigned char',
    0x12: 'unsigned short',
    0x13: 'unsigned long',
    0x14: 'hyper',
    0x15: 'unsigned hyper',
    0x16: 'int',
    0x17: 'unsigned int',
    0x18: 'void',
    0x19: 'HRESULT',
    0x1f: 'LPWSTR',
    0x50: 'SAFEARRAY',
    0x90: 'HBITMAP',
    0xc0: 'HGLOBAL',
  }
  if paramtyflags & 0x8000:
    assert paramty in types, '%x' % paramty
    return types[paramty]
  ptroff, ptrlen = entries[9]
  assert 0 <= paramty
  assert paramty + 8 <= ptrlen
  t1, t2, t3, t4 = struct.unpack_from('<HHHH', tlb, ptroff+paramty)
  assert t1 in [0x1a, 0x1c, 0x1d], '%x' % t1
  if t1 == 0x1a:  # Pointer.
    return paramtypestr(t3, t4) + '*'
  if t1 == 0x1c:  # Array.
    arroff, arrlen = entries[10]
    infooff = (t4 << 16) + t3
    assert 0 <= infooff
    assert infooff + 8 <= arrlen
    ndim, = struct.unpack_from('<H', tlb, arroff + infooff + 4)
    s = ['[%d]' % struct.unpack_from('<H', tlb, arroff + infooff + (i + 1)*8)[0]
         for i in range(ndim)]
    return paramtypestr(*struct.unpack_from('<HH', tlb, arroff + infooff)) + \
           ''.join(s)
  if t1 == 0x1d:  # Custom type.
    infooff = (t4 << 16) + t3
    return customtypestr(infooff)


tlb = open(sys.argv[1], 'rb').read()

assert tlb[0:4] == 'MSFT'
# oleview.exe refuses to open files that don't start with this.
assert tlb[4:8] == '\x02\x00\x01\x00'

# TLB files start with a 0x54 byte header.
# I changed header contents (xxd, change, xxd -r) and opened the modified tlb
# files in oleview.exe to discover the meaning of some of these fields.
# I also ran small test.idl files through midl.exe and looked at its output
# when various inputs were present or absent.
# ODL syntax for .idl input:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221254(v=vs.85).aspx
# 0-3: 'MSFT' always
# 4-7: 0200 0100 always
# 8-0xb: offset of file GUID (into GUID section)
# 0xc-0xf: 0904 0000 always (?) (0904 looks like the US english language code
#                                in res files -- yup, controlled by lcid() attr)
# 0x10: ? (always 0?)
# 0x14: 4100 0000 for 32-bit files, 4300 0000 for 64-bit files -- some bit mask?
# 0x18: 2xuint16 version
# 0x1c: ? (4 for ia2, 0 else)
# 0x20: uint32 number of types (interface, coclass) in tlb file
# 0x24: helpstring(), offset into strtab
# 0x38: library name, offset into typetab
# 0x3c: always ffff ffff (?)
# 0x40: uint32 custoff, offset into 13th section, points to head of global
#       custom() list.
# 0x4c: always ffff ffff (?) (...not for google_update! 1 there)

guidoff, = struct.unpack_from('<I', tlb, 8)
v1, v2, _, nwords, stroff = struct.unpack_from('<HHIII', tlb, 0x18)
typeoff, _, custoff = struct.unpack_from('<III', tlb, 0x38)
diroff = 0x54 + 4*nwords

# After the header, there are nwords uint32.
# These just look like increasing offsets, each growing by 100 bytes.
for i in range(nwords):
  word, = struct.unpack_from('<I', tlb, 0x54 + 4*i)
  assert word == 100 * i
  #print '%d' % word
#print

# After that, there are 15 section headers that just contain (offset, length)
# pairs.  Each section header has fixed semantics (1st one always points to
# type descriptions, etc).

entries = []
names = [''] * 15
names[0] = 'types'
names[1] = 'foreign types'
names[2] = 'importlibs'
names[3] = 'coclass interfaces'
names[4] = 'guids hash'
names[5] = 'guids'
names[6] = 'typetab hash'
names[7] = 'typetab'
names[8] = 'strtab'
names[9] = 'complex types'
names[10] = 'array types'
names[11] = 'custom'
names[12] = 'custom+guid'
names[13] = 'empty'
names[14] = 'empty'
for i in range(15):
  off, ln, minusone, fifteen = \
      struct.unpack_from('<IIII', tlb, diroff + i*16)
  assert minusone == 0xffffffff
  assert fifteen == 0xf
  print '%x %x => %x (%s)' % (off, ln, off+ln, names[i])
  entries.append((off, ln))
print

# Print library header.
print '['
print '  uuid(%s),' % getguid(guidoff)[0]
print '  version(%d.%d),' % (v1, v2)
if stroff != 0xffffffff:
  print '  helpstring("%s"),' % getstr(stroff)
if custoff != 0xffffffff:
  for g, v in getcustlist(custoff):
    print '  custom(%s, %s),' % (g, str(v))
print ']'
print 'library %s' % gettystr(typeoff)[0]
print

# Looks like the first section has "nwords" many entries, each 100 bytes long
# (i.e. indexed by the numbers in front of the section table, but those are
# just multiple of 100)
print 'Entry 1: Interfaces'
assert entries[0][1] == nwords * 100
intoff = entries[0][0]
for i in range(nwords):
  # First byte: 0x25 coclass, 0x23 interface
  # @+4: offset to method data -- after all the sections in the section dict
  # @+0x18: uint16 n_methods
  # @+0x1a: uint16 n_fields
  # @+0x2c: offset into guid table
  # @+0x30: flags. 0x10: restricted, 0x200: hidden
  # @+0x34: offset into typetab table (name)
  # @+0x3c: offset into strtab table (help text)
  # @+0x48: uint32 custoff, offset into 13th section, points to head of a
  #         custom() list.
  # @+0x54: type + flags for typedef (0x26).
  #         offset to list of interfaces in section 4 for coclass (0x25).
  #         Something else for interface (0x23) -- XXX figure out
  infooff = intoff + i * 100
  #hexdump(tlb, infooff, 100)
  guidoff, flags, typeoff, _, stroff = struct.unpack_from(
      '<IIIII', tlb, infooff + 0x2c)
  custoff, = struct.unpack_from('<I', tlb, infooff + 0x48)
  extradata, = struct.unpack_from('<I', tlb, infooff + 0x54)
  if guidoff != 0xffffffff:
    guid, n0, n1 = getguid(guidoff)
  if stroff != 0xffffffff:
    s = getstr(stroff)
  print '%d, %04x: [' % (i, i * 100),
  if guidoff != 0xffffffff:
    print 'uuid(%s),' % guid,
  if stroff != 0xffffffff:
    print 'helpstring("%s")' % s,
  if custoff != 0xffffffff:
    print ', '.join('custom(%s, %s)' % (g, str(v))
                    for g, v in getcustlist(custoff)),
  kind = ord(tlb[infooff])
  if kind == 0x25:
    assert flags & 2
    flags = flags & ~2  # apparently always set for coclass
  flagbits = {
    0x10: 'hidden,',
    0x40: 'dual,',
    0x80: 'nonextensible,',
    0x100: 'oleautomation,',
    0x200: 'restricted,',
    0x1000: 'object,',
    }
  for b in flagbits:
    if flags & b:
      print flagbits[b],
      flags = flags & ~b
  assert flags == 0, '%x' % flags
  print ']'
  assert kind in [0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x34], '%x' % kind
  is_struct = kind == 0x21
  no_value = kind in [0x24, 0x27]
  print { 0x20: 'enum',
          0x21: 'struct',
          0x22: 'module',
          0x23: 'interface',
          0x24: 'dispinterface',
          0x25: 'coclass',
          0x26: 'typedef',
          0x27: 'union',
          0x34: 'interface',  # with superclass (?)
        }[kind],
  if kind == 0x26:
    print paramtypestr(extradata & 0xffff, extradata >> 16),
  elif kind not in [0x22, 0x23, 0x25, 0x34]:
    assert extradata == 0xffffffff

  ts, t0, t1, t2, t3 = gettystr(typeoff)
  print '%s {' % ts

  if kind == 0x25:
    # For coclass, print implemented interfaces.
    while extradata != 0xffffffff:
      #hexdump(tlb, entries[3][0] + extradata, 16)
      tyoff, flags, u0, extradata = struct.unpack_from(
          '<IIII', tlb, entries[3][0] + extradata)
      bits = { 1: 'default', 3: 'source', 4: 'restricted' }
      flagv = []
      for b in bits:
        if flags & b:
          flagv.append(bits[b])
          flags = flags & ~b
      assert flags == 0, flags
      flags = '[%s] ' % ','.join(flagv) if flagv else ''
      print '  %s%s' % (flags, customtypestr(tyoff, True))

  n_meth, n_field = struct.unpack_from('<HH', tlb, infooff + 0x18)
  methoff, = struct.unpack_from('<I', tlb, infooff + 4)
  # Method and field data:
  # uint32 offset to past method data (where id table, param name table are)
  # n_methods + n_fields: uint16 len, that much data
  # n_methods + n_fields: uint32 (just 1, 2, 3, ...?)
  #            for fields, it looks like (uint16, uint16) pairs with first elt
  #            going 1, 2, 3, .. while 2nd is always 0x4000
  # n_methods + n_fields offsets into typetab method names
  # n_methods + n_fields uint32 offset to parameter descriptor for i'th method
  methnameoff = methoff + 4
  helps = []
  params = []
  values = []
  rettypes = []
  lastargname = 0
  for i in range(n_meth + n_field):
    # In here (@+0 is size), for meths (i < n_meth):
    # @+2: uint16 index
    # @+4: uint16 return type
    # @+6: uint16 return type flags
    #      if flag & 0x8000, then type is inline type, else it's offset into
    #      complex type section (section 10)
    # @+0x14: num params
    # @+0x1c: help string, strtab offset (if present)
    # For fields:
    # @+0x10: initial value (at least for enums).
    #         For structs, this seems to be the offset of the field.
    size, ind, rettype, rettypeflag = struct.unpack_from(
        '<HHHH', tlb, methnameoff)
    #hexdump(tlb, methnameoff, size)
    assert ind == i
    rettypes.append((rettype, rettypeflag))
    if i < n_meth:
      n_params, = struct.unpack_from('<H', tlb, methnameoff + 0x14)
      value = None
    else:
      n_params = 0
      value, = struct.unpack_from('<I', tlb, methnameoff + 0x10)
      if is_struct:
        value = 'offset %x' % value
      elif no_value:
        value = None
      else:
        value = getcust(value)
    values.append(value)
    header_size = size - 12*n_params

    if header_size >= 0x1c:
      helpstr, = struct.unpack_from('<I', tlb, methnameoff + 0x1c)
      helps.append(getstr(helpstr))
    else:
      helps.append('')

    # A parameter descriptor is 3x uint32 large, starts at meth+0x20
    # middle one is ref to name. The other two are type and flags probably?
    thisparams = []
    for j in range(n_params):
      argtype, argtyflags, argname, argflags = struct.unpack_from(
          '<HHII', tlb, methnameoff + header_size + j*12)
      if argname == 0xffffffff:
        argname = lastargname  # weird special case
      thisparams.append((argtype, argtyflags, gettystr(argname)[0], argflags))
      lastargname = argname
    params.append(thisparams)

    methnameoff += size
  #methnameoff += 4 * (n_meth + n_field)
  for i in range(n_meth + n_field):
    methid, = struct.unpack_from('<I', tlb, methnameoff + 4*i)
    name, = struct.unpack_from('<I', tlb, methnameoff + 4*(i + n_meth+n_field))
    s, u0, u1, u2, u3 = gettystr(name)
    if i >= n_meth:
      rettype = paramtypestr(*rettypes[i])
      print '  %s %s' % (rettype, s),
      if values[i]:
        print '=', values[i],
      print
      continue
    assert not values[i]
    rettype = paramtypestr(*rettypes[i])
    attribs = []
    if helps[i]:
      attribs.append('helpstring("%s")' % helps[i])
    # XXX: This isn't quite right; it prints id()s for ia2_api_all.idl while
    # oleview.exe doesn't print them there. Probably needs some bit on the
    # type descriptor set?
    #if methid != i + 1:
      #attribs.append('id(0x%x)' % methid)
    if attribs:
      print '  [%s]' % ', '.join(attribs)
    funout = '  %s %s(' % (rettype, s)
    argout = []
    for argtype, argtyflags, argname, argflags in params[i]:
      #print 'arg %x %x' % (argtype, argtyflags)
      argtystr = paramtypestr(argtype, argtyflags)
      flagv = []
      bits = {
          1: 'in', 2: 'out', 8: 'retval', 16: 'optional', 32: 'defaultvalue' }
      # XXX: for defaultvalue, print defaultvalue
      for b in bits:
        if argflags & b:
          flagv.append(bits[b])
          argflags = argflags & ~b
      assert argflags == 0, argflags
      argout.append('[%s] %s %s %x %x' % (
          ', '.join(flagv), argtystr, argname, argtype, argtyflags))
    print funout + (',\n' + ' ' * len(funout)).join(argout) + ')'
  print '}'
  print
print

# 2nd seems to be for types used from importlibs somehow: If I
# importlib("stdole2.tlb"), then each referenced to type "GUID" increases
# the size of this section by 12.
# Looks like the 12 bytes are:
# uint16 running index
# uint16 unk (0x100, 0x600, 0 in practice)
# int32 offset into section 3, importlibs
# int32 type offset into library identified by previous number
print 'Entry 2: foreign types'
foroff, forlen = entries[1]
hexdump(tlb, foroff, forlen)
print

# 3rd seems to be importlibs somehow
# first 4 bytes look like GUID offset
# 2nd 4 are 0
# 3rd 4 are 1 or 2 (why?)
# then 2 byte that are NOT string length
# then lib name
# then padding
print 'Entry 3: importlib()s'
impoff, implen = entries[2]
off = 0
while off  < implen:
  guidoff, n0, n1, l0 = struct.unpack_from('<IIIH', tlb, impoff + off)
  l = l0 >> 2
  s = tlb[impoff+off+14:impoff+off+14+l]
  print '%04x: %s %x %x %x %s' % (off, getguid(guidoff)[0], n0, n1, l0 & 3, s)
  off += 14 + l
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
print
assert off == implen

# 4th grows by 0x10 for each "interface" line in a coclass, so it stores
# information about which interfaces are implemented by coclasses.
# Each entry looks like 4 uint32_ts.
# 1st: offset into section 1, the interface.
# 2nd: bitmask. 1 for [default], 4 for [restricted], 3 for [source].
#               if no explicit [default], first interface gets default.
# 3rd: always 0xffffffff
# 4th: offset into this section, the next interface implemented by curr
#      coclass, or 0xffffffff for end of list.
print 'Entry 4: coclass interfaces'
coinfoff, coinflen = entries[3]
off = 0
while off  < coinflen:
  tyoff, flag, u0, n = struct.unpack_from('<IIII', tlb, coinfoff + off)
  if tyoff & 1:
    # If lowest bit is set, this is a remote type from section 2.
    assert (tyoff & ~1) % 12 == 0, tyoff
  else:
    assert tyoff % 100 == 0, '%x' % tyoff
  assert flag <= 7
  assert u0 == 0xffffffff
  assert n == 0xffffffff or n % 0x10 == 0
  print '%04x: %04x %x %x %x' % (off, tyoff, flag, u0, n)
  off += 16
print
assert off == coinflen


# 5th seems to always have length 0x80. It contains offsets into guids
# (entry 6). The n1 in guids is a "next" offset (also into guids), and the
# field here in 5th points to list heads -- this contains a hash table (with
# lists in hash buckets) for the guids.
# The hash function of a guid is just the xor of the guid bytes in LE
# interpreted as 8 uint16s all xored together, and then taken mod 0x20.
print 'Entry 5: GUID hashes'
hashoff, hashlen = entries[4]
assert hashlen == 0x80
for i in range(0, hashlen, 4):
  if i % 64 == 0 and i != 0:
    print
  p, = struct.unpack_from('<I', tlb, hashoff + i)
  if p == 0xffffffff:  # Not set
    print '....',
  else:
    print '%04x' % p,
    # Check that guidhash() is correct for this input file.
    guid = getguid(p)[0]
    h = guidhash(guid)
    if i/4 != h:
      print '\n should %x, is %x -- %s' %(i/4, h, guid)
    assert i/4 == h
print
print

# 6th seems to store offset to GUIDs
print 'Entry 6: GUIDs'
guidoff, guidlen = entries[5]
# One entry: 16 byte GUID, two signed ints (-2 or -1)
# The 1st int seems to point to the object using the GUID somehow.
# For GUIDs on types (interfaces etc), it's an offset into section 1 (the type
# section). For GUIDs on import libs, it stores something nonobvious.
# The 2nd int is an offset to the "next" GUID for the GUID hash table in the
# 5th section which uses chaining.
assert guidlen % 24 == 0
for i in range(0, guidlen, 24):
  print '%04x: %s %d 0x%04x' % ((i,) + getguid(i))
print


# 7th seems to always have length 0x200. It contains offsets into typetab
# (entry 8), and -1 entries. Maybe the u1 in typetab is also a "next" offset
# (also into typetab), and the field here in 7th points to list heads -- maybe
# this contains a hash table (with lists in hash buckets) for the typetab?
# A and a map to same hash (0x58). B is 0x59, C 0x5a, D 0x5b...
# a0 -> 0x6a, aa -> 0x7b, which is 17 apart, suggesting that hash is computed
# on toupper.
print 'Entry 7: typetab hashes'
hashoff, hashlen = entries[6]
assert hashlen == 0x200
for i in range(0, hashlen, 4):
  if i % 64 == 0 and i != 0:
    print
  p, = struct.unpack_from('<I', tlb, hashoff + i)
  if p == 0xffffffff:  # Not set
    print '....',
  else:
    print '%04x' % p,
    s, _, _, _, strhash = gettystr(p)
    assert i/4 == strhash%(0x200/4)
print
print

# 8th of the 15 entries stores 0x1760, which seems to be the start of some
# string table. The strings here are prefixed by 12 bytes of metadata.
# See comment in gettystr() for a description of the 5 numbers.
print 'Entry 8: Typetab'
strtaboff, strtablen = entries[7]
off = 0
i = 0
while off < strtablen:
  s, to, nextelt, kind, strhash = gettystr(off)
  print 'str %d (@%x):' % (i, off), s,
  print '; %x %x %x %x' % (to, nextelt, kind, strhash)
  off += len(s) + 12
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 9th seems to be a "regular" strtab, with just u16len followed by str.
strtaboff, strtablen = entries[8]
print 'Entry 9: Strtab'
off = 0
i = 0
while off < strtablen:
  n, = struct.unpack_from('<H', tlb, offset=strtaboff+off)
  print 'str %d (@%x):' % (i, off), tlb[strtaboff+off+2:strtaboff+off+2+n]
  off += n + 2
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 10th seems to contain 8 bytes of data for each pointer type used in the
# idl file, so it probably contains pointer types somehow.
# Looks like the 2nd uint32 is the pointee type.  Tye first uint32 always starts
# with 0x1a00 and ends in 0x4, but the 3rd byte can be 0x10, 03, 02, 0, ...
# Looks like the 3rd byte roughly is the pointed-to type too?
# `char**` causes two entries in this table.
# Parameters that have the type of an enum also cause entries here.
# For enums, the first 4 byte are just 1d 00 03 00, and the 2nd seem to be
# the offset of the enum definition in section 1.
ptroff, ptrlen = entries[9]
print 'Entry 10: complex types'
hexdump(tlb, ptroff, ptrlen)
print

# 11th is only non-empty if the .idl files contains arrays (`int a[10]`), so
# it contains array type descriptors.
# Looks like 16 bytes per array type.
# First uint16: array base type.
# 2nd uint16: array base type flags (?).
# 3rd uint16: number of array dimensions.
# 4th uint16: ??
# Then, for each array dimension 8 bytes which stores array size along dimension
# and seems to be 0 else.
arroff, arrlen = entries[10]
print 'Entry 11: array types'
hexdump(tlb, arroff, arrlen)
print

# 12th seems to be custom's info (midl.exe version string and some)
# Looks like this is just another chunk of data. Each packet is uint16 type.
# Type 0x8 is "text" or "raw", and is uint32 len followed by that many data
# bytes. Type 0x13 is followed by uint32 data bytes. Each packet is followed
# by padding to 4 byte boundary. Type 0x3 is also (signed) int32.
custoff, custlen = entries[11]
print 'Entry 12: custom (len %d)' % custlen
hexdump(tlb, custoff, custlen)
print

# 13th seems to link up GUIDs to custom data. Tuples of:
# uint32 guid, uint32 custom off, uint32 next
# (next points to the next 3-tuple in this section, for list of custom()s,
# with the final elt in the list having 0xffffffff)
print 'Entry 13: custom+guid'
custoff, custlen = entries[12]
for i in range(0, custlen, 12):
  guidoff, dataoff, nextel = struct.unpack_from('<III', tlb, custoff + i)
  print 'off %x: guid(%s) value(%s), next %x' % (
      i, getguid(guidoff)[0], str(getcust(dataoff)), nextel)

# This describes an interface that seems to query .tlb files:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221549(v=vs.85).aspx
