# Attempts to dump .tlb files such as generated by the midl.exe tool.
# This dumper can process all .tlb files checked in at
# third_party/win_build_output. It doesn't look at all input bytes, but
# it produces reasonably complete output, compared to what oleview.exe
# prints.
# Missing:
# * complex types (pointers, typedef'd types; on parameters, struct fields)
# * importlib()s
# * some metadata flags (odl, propget, dual, oleautomation, id(), propput,
#    public, nonextensible)
# * interface base classes
# * calling conventions (_stdcall vs not)
""".tlb viewer.

Run like:
typelib.py third_party/win_build_output/midl/google_update/x64/google_update_idl.tlb
"""

import sys
import struct

def hexdump(dat, o, l):
  for i in range(o, o + l, 16):
    s = dat[i:min(i + 16, o + l)]
    hexstr = ' '.join(['%02x' % ord(c) for c in s])
    textstr = ''.join([c if 0x20 <= ord(c) <= 0x7e else '.' for c in s])
    print '%-48s %s' % (hexstr, textstr)


def getguid(p):
  guidoff, guidlen = entries[5]
  assert 0 <= p
  assert p + 24 <= guidlen
  g0, g1, g2, g3, g4, n0, n1 = struct.unpack_from('<IHHH6sii', tlb, guidoff + p)
  g4 = ''.join(['%02X' % ord(g) for g in g4])
  # Hm, n1 might be a "next" pointer (into the GUID section again) like in
  # section 13 -- so that the GUID section can contain lists of GUIDs. -1 means
  # end-of-list.
  return '%08X-%04X-%04X-%04X-%s' % (g0, g1, g2, g3, g4), n0, n1


def gettystr(p):
  strtaboff, strtablen = entries[7]
  assert 0 <= p
  assert p + 12 <= strtablen
  u0, u1, n, u2, u3 = struct.unpack_from('<IIBBH', tlb, strtaboff+p)
  return tlb[strtaboff+p+12:strtaboff+p+12+n], u0, u1, u2, u3


def getstr(p):
  strtaboff, strtablen = entries[8]
  assert 0 <= p
  assert p + 2 <= strtablen
  n, = struct.unpack_from('<H', tlb, strtaboff+p)
  return tlb[strtaboff+p+2:strtaboff+p+2+n]


def getcust(p):
  # If top byte is 0x8c, the lower bytes contain value inline.  Else, it
  # references custom data (section 12).
  if p & 0x8c000000:
    return p & ~0x8c000000
  custoff, custlen = entries[11]
  assert 0 <= p
  assert p + 2 <= custlen
  kind, = struct.unpack_from('<H', tlb, custoff+p)
  assert kind in [3, 8, 0x13], kind
  if kind == 3:  # signed
    return struct.unpack_from('<i', tlb, custoff+p+2)[0]
  if kind == 0x13:  # unsigned
    return struct.unpack_from('<I', tlb, custoff+p+2)[0]
  if kind == 8:  # text
    n, = struct.unpack_from('<I', tlb, custoff+p+2)
    return tlb[custoff+p+6:custoff+p+6+n]


def getcustlist(p):
  custoff, custlen = entries[12]
  assert 0 <= p
  assert p + 12 <= custlen
  l = []
  while p != 0xffffffff:
    guidoff, dataoff, p = struct.unpack_from('<III', tlb, custoff + p)
    l.append((getguid(guidoff)[0], getcust(dataoff)))
  return l


tlb = open(sys.argv[1], 'rb').read()

assert tlb[0:4] == 'MSFT'
# oleview.exe refuses to open files that don't start with this.
assert tlb[4:8] == '\x02\x00\x01\x00'

# TLB files start with a 0x54 byte header.
# I changed header contents (xxd, change, xxd -r) and opened the modified tlb
# files in oleview.exe to discover the meaning of some of these fields.
# I also ran small test.idl files through midl.exe and looked at its output
# when various inputs were present or absent.
# ODL syntax for .idl input:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221254(v=vs.85).aspx
# 0-3: 'MSFT' always
# 4-7: 0200 0100 always
# 8-0xb: offset of file GUID (into GUID section)
# 0xc-0xf: 0904 0000 always (?) (0904 looks like the US english language code
#                                in res files -- yup, controlled by lcid() attr)
# 0x10: ? (always 0?)
# 0x14: 4100 0000 for 32-bit files, 4300 0000 for 64-bit files -- some bit mask?
# 0x18: 2xuint16 version
# 0x1c: ? (4 for ia2, 0 else)
# 0x20: uint32 number of types (interface, coclass) in tlb file
# 0x24: helpstring(), offset into strtab
# 0x38: library name, offset into typetab
# 0x3c: always ffff ffff (?)
# 0x40: uint32 custoff, offset into 13th section, points to head of global
#       custom() list.
# 0x4c: always ffff ffff (?) (...not for google_update! 1 there)

guidoff, = struct.unpack_from('<I', tlb, 8)
v1, v2, _, nwords, stroff = struct.unpack_from('<HHIII', tlb, 0x18)
typeoff, _, custoff = struct.unpack_from('<III', tlb, 0x38)
diroff = 0x54 + 4*nwords

# After the header, there are nwords uint32.
# These just look like increasing offsets, each growing by 100 bytes.
for i in range(nwords):
  word, = struct.unpack_from('<I', tlb, 0x54 + 4*i)
  assert word == 100 * i
  #print '%d' % word
#print

# After that, there are 15 section headers that just contain (offset, length)
# pairs.  Each section header has fixed semantics (1st one always points to
# type descriptions, etc).

entries = []
names = [''] * 15
names[0] = 'types'

names[2] = 'importlibs'

names[4] = 'guids hash (??)'
names[5] = 'guids'
names[6] = 'typetab hash (??)'
names[7] = 'typetab'
names[8] = 'strtab'
names[9] = 'complex types'
names[10] = 'empty'
names[11] = 'custom'
names[12] = 'custom+guid'
names[13] = 'empty'
names[14] = 'empty'
for i in range(15):
  off, ln, minusone, fifteen = \
      struct.unpack_from('<IIII', tlb, diroff + i*16)
  assert minusone == 0xffffffff
  assert fifteen == 0xf
  print '%x %x => %x (%s)' % (off, ln, off+ln, names[i])
  entries.append((off, ln))
print

# Print library header.
print '['
print '  uuid(%s),' % getguid(guidoff)[0]
print '  version(%d.%d),' % (v1, v2)
if stroff != 0xffffffff:
  print '  helpstring("%s"),' % getstr(stroff)
if custoff != 0xffffffff:
  for g, v in getcustlist(custoff):
    print '  custom(%s, %s),' % (g, str(v))
print ']'
print 'library %s' % gettystr(typeoff)[0]
print

# Looks like the first section has "nwords" many entries, each 100 bytes long
# (i.e. indexed by the numbers in front of the section table, but those are
# just multiple of 100)
print 'Entry 1: Interfaces'
assert entries[0][1] == nwords * 100
intoff = entries[0][0]
for i in range(nwords):
  # First byte: 0x25 coclass, 0x23 interface
  # @+4: offset to method data (?) -- after all the sections in the section dict
  # @+0x18: uint16 n_methods
  # @+0x1a: uint16 n_fields
  # @+0x2c: offset into guid table (?)
  # @+0x34: offset into typetab table (name)
  # @+0x3c: offset into strtab table (help text)
  # @+0x48: uint32 custoff, offset into 13th section, points to head of a
  #         custom() list.
  infooff = intoff + i * 100
  #hexdump(tlb, infooff, 100)
  guidoff, _, typeoff, _, stroff = struct.unpack_from(
      '<IIIII', tlb, infooff + 0x2c)
  custoff, = struct.unpack_from('<I', tlb, infooff + 0x48)
  if guidoff != 0xffffffff:
    guid, n0, n1 = getguid(guidoff)
  if stroff != 0xffffffff:
    s = getstr(stroff)
  print '[',
  if guidoff != 0xffffffff:
    print 'uuid(%s),' % guid,
  if stroff != 0xffffffff:
    print 'helpstring("%s")' % s,
  if custoff != 0xffffffff:
    print ', '.join('custom(%s, %s)' % (g, str(v))
                    for g, v in getcustlist(custoff)),
  print ']'
  kind = ord(tlb[infooff])
  assert kind in [0x20, 0x21, 0x23, 0x25, 0x26, 0x34], '%x' % kind
  is_struct = kind == 0x21
  print { 0x20: 'typedef enum',  # ??
          0x21: 'typdef struct', # ??
          0x23: 'interface',
          0x25: 'coclass',
          0x26: 'typedef uint64',  # ??
          0x34: 'interface',  # with superclass (?)
        }[kind],
  ts, t0, t1, t2, t3 = gettystr(typeoff)
  print '%s {' % ts
  n_meth, n_field = struct.unpack_from('<HH', tlb, infooff + 0x18)
  methoff, = struct.unpack_from('<I', tlb, infooff + 4)
  # Method and field data:
  # uint32 offset to past method data (where id table, param name table are)
  # n_methods + n_fields: uint16 len, that much data
  # n_methods + n_fields: uint32 (just 1, 2, 3, ...?)
  #            for fields, it looks like (uint16, uint16) pairs with first elt
  #            going 1, 2, 3, .. while 2nd is always 0x4000
  # n_methods + n_fields offsets into typetab method names
  # n_methods + n_fields uint32 offset to parameter dtor for i'th method
  methnameoff = methoff + 4
  helps = []
  params = []
  values = []
  rettypes = []
  lastargname = 0
  for i in range(n_meth + n_field):
    size, ind, rettype, rettypeflag = struct.unpack_from(
        '<HHHH', tlb, methnameoff)
    # In here (@+0 is size), for meths (i < n_meth):
    # @+2: uint16 index
    assert ind == i
    # @+4: uint16 type
    # @+6: uint16 type flag
    #      if flag & 0x8000, then type is inline type, else it's offset into
    #      complex type section (section 10)
    rettypes.append((rettype, rettypeflag))
    # @+0x14: num params
    # @+0x1c: help string, strtab offset (if present)
    # For fields:
    # @+0x10: initial value (at least for enums).
    #         For structs, this seems to be the offset of the field.
    if i < n_meth:
      n_params, = struct.unpack_from('<H', tlb, methnameoff + 0x14)
      value = None
    else:
      n_params = 0
      value, = struct.unpack_from('<I', tlb, methnameoff + 0x10)
      if is_struct:
        value = 'offset %x' % value
      else:
        value = getcust(value)
    values.append(value)
    header_size = size - 12*n_params

    if header_size >= 0x1c:
      helpstr, = struct.unpack_from('<I', tlb, methnameoff + 0x1c)
      helps.append(getstr(helpstr))
    else:
      helps.append('')

    # A parameter descriptor is 3x uint32 large, starts at meth+0x20
    # middle one is ref to name. The other two are type and flags probably?
    thisparams = []
    for j in range(n_params):
      argtype, argtyflags, argname, argflags = struct.unpack_from(
          '<HHII', tlb, methnameoff + header_size + j*12)
      if argname == 0xffffffff:
        argname = lastargname  # weird special case
      thisparams.append((argtype, argtyflags, gettystr(argname)[0], argflags))
      lastargname = argname
    params.append(thisparams)

    methnameoff += size
  methnameoff += 4 * (n_meth + n_field)
  for i in range(n_meth + n_field):
    name, = struct.unpack_from('<I', tlb, methnameoff + 4*i)
    s, u0, u1, u2, u3 = gettystr(name)
    if i >= n_meth:
      print '  %s' % s,
      if values[i]:
        print '=', values[i],
      print
      continue
    assert not values[i]
    types = {
      0x2: 'short',
      0x3: 'long',
      0x4: 'float',
      0x5: 'double',
      0x8: 'BSTR',
      0xb: 'VARIANT_BOOL',
      0xc: 'VARIANT',
      0x10: 'char',
      0x11: 'unsigned char',
      0x12: 'unsigned short',
      0x13: 'unsigned long',
      0x14: 'hyper',
      0x15: 'unsigned hyper',
      0x16: 'int',
      0x17: 'unsigned int',
      0x18: 'void',
      0x19: 'HRESULT',
      0x50: 'SAFEARRAY',
      0x90: 'HBITMAP',
      0xc0: 'HGLOBAL',
    }
    rettype = 'XXX'
    if rettypes[i][1] & 0x8000:
      assert rettypes[i][0] in types, '%x' % rettypes[i][0]
      rettype = types[rettypes[i][0]]
    if helps[i]:
      print '  [helpstring("%s")]' % helps[i]
    funout = '  %s %s(' % (rettype, s)
    argout = []
    for argtype, argtyflags, argname, argflags in params[i]:
      argtystr = 'XXX'
      if argtyflags & 0x8000:
        assert argtype in types
        argtystr = types[argtype]
      flagv = []
      bits = { 1: 'in', 2: 'out', 8: 'retval', 16: 'optional' }
      for b in bits:
        if argflags & b:
          flagv.append(bits[b])
          argflags = argflags & ~b
      assert argflags == 0, argflags
      argout.append('[%s] %s %s %x%x' % (
          ', '.join(flagv), argtystr, argname, argtype, argtyflags))
    print funout + (',\n' + ' ' * len(funout)).join(argout) + ')'
  print '}'
  print
print

# 3th seems to be importlibs somehow
# first 4 bytes look like GUID offset
# 2nd 4 are 0
# 3rd 4 are 1 or 2 (why?)
# then 2 byte that are NOT string length
# then lib name
# then padding

# 5th seems to always have length 0x80. It contains offsets into guids
# (entry 6), and -1 entries. Maybe the n1 in guids is also a "next" offset
# (also into guids), and the field here in 5th points to list heads -- maybe
# this contains a hash table (with lists in hash buckets) for the guids?

# 6th seems to store offset to GUIDs
print 'Entry 6: GUIDs'
guidoff, guidlen = entries[5]
# One entry: 16 byte GUID, two signed ints (-2 or -1)
assert guidlen % 24 == 0
for i in range(0, guidlen, 24):
  print '%04x: %s %d %d' % ((i,) + getguid(i))
print

# 7th seems to always have length 0x200. It contains offsets into typetab
# (entry 8), and -1 entries. Maybe the u1 in typetab is also a "next" offset
# (also into typetab), and the field here in 7th points to list heads -- maybe
# this contains a hash table (with lists in hash buckets) for the typetab?

# 8th of the 15 entries stores 0x1760, which seems to be the start of some
# string table. The strings here seem to be prefixed by 12 bytes of metadata
# (type data?)
# Looks like:
# uint32 ?, uint32 ?, u8 strlen, u8 ?, u16 ?, strdata, padding
print 'Entry 8: Typetab (?)'
strtaboff, strtablen = entries[7]
off = 0
i = 0
while off < strtablen:
  s, u0, u1, u2, u3 = gettystr(off)
  print 'str %d (@%x):' % (i, off), s,
  print '; %x %x %x %x' % (u0, u1, u2, u3)
  off += len(s) + 12
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 9th seems to be a "regular" strtab, with just u16len followed by str.
strtaboff, strtablen = entries[8]
print 'Entry 9: Strtab'
off = 0
i = 0
while off < strtablen:
  n, = struct.unpack_from('<H', tlb, offset=strtaboff+off)
  print 'str %d (@%x):' % (i, off), tlb[strtaboff+off+2:strtaboff+off+2+n]
  off += n + 2
  off += (4 - off % 4) % 4  # Pad to 4 byte boundary.
  i += 1
assert off == strtablen
print

# 10th seems to contain 8 bytes of data for each pointer type used in the
# idl file, so it probably contains pointer types somehow.
# Looks like the 2nd uint32 is the pointee type.  Tye first uint32 always starts
# with 0x1a00 and ends in 0x4, but the 3rd byte can be 0x10, 03, 02, 0, ...
# Looks like the 3rd byte roughly is the pointed-to type too?
# `char**` causes two entries in this table.
# Parameters that have the type of an enum also cause entries here.
# For enums, the first 4 byte are just 1d 00 03 00, and the 2nd seem to be
# the offset of the enum definition in section 1.
ptroff, ptrlen = entries[9]
print 'Entry 10: complex types'
hexdump(tlb, ptroff, ptrlen)
print

# 11th is empty (-1) for the files i looked at.

# 12th seems to be custom's info (midl.exe version string and some)
# Looks like this is just another chunk of data. Each packet is uint16 type.
# Type 0x8 is "text" or "raw", and is uint32 len followed by that many data
# bytes. Type 0x13 is followed by uint32 data bytes. Each packet is followed
# by padding to 4 byte boundary. Type 0x3 is also (signed) int32.
custoff, custlen = entries[11]
print 'Entry 12: custom (len %d)' % custlen
hexdump(tlb, custoff, custlen)
print

# 13th seems to link up GUIDs to custom data. Tuples of:
# uint32 guid, uint32 custom off, uint32 next
# (next points to the next 3-tuple in this section, for list of custom()s,
# with the final elt in the list having 0xffffffff)
print 'Entry 13: custom+guid'
custoff, custlen = entries[12]
for i in range(0, custlen, 12):
  guidoff, dataoff, nextel = struct.unpack_from('<III', tlb, custoff + i)
  print 'off %x: guid(%s) value(%s), next %x' % (
      i, getguid(guidoff)[0], str(getcust(dataoff)), nextel)

# This describes an interface that seems to query .tlb files:
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms221549(v=vs.85).aspx
