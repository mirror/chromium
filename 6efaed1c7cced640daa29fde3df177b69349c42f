{
  "comments": [
    {
      "key": {
        "uuid": "9f85619d_1196508e",
        "filename": "ui/accessibility/platform/ax_platform_node_auralinux.cc",
        "patchSetId": 3
      },
      "lineNbr": 664,
      "author": {
        "id": 1000678
      },
      "writtenOn": "2017-11-29T16:30:26Z",
      "side": 1,
      "message": "Are there any timing issues with these notifications? Is it ever\npossible that we\u0027ll get a callback inside this stack frame, like\nwe do on Windows when AT injects a DLL in-process?\n\nI\u0027m sure Linux ATK can\u0027t inject in-process, but I\u0027m more wondering\nif the ATK library ever makes calls back into the object in response\nto a notification, for example.\n\nThe potential concern is that this function may be called while we\u0027re\nin the middle of deleting a subtree, so there could be some dangling\npointers.\n\nIf we don\u0027t get any callbacks in this exact stack frame we\u0027re fine.\nIf we do, a short-term fix would be to retain the object a bit longer\nand notify in OnAtomicUpdateFinished(). Even better, I\u0027m hoping to\nadd a preprocessing step to identify all nodes that *will be* deleted\nbefore the tree changes, to make firing notifications like this\nmuch simpler.",
      "revId": "6efaed1c7cced640daa29fde3df177b69349c42f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "660a2a99_e52b2799",
        "filename": "ui/accessibility/platform/ax_platform_node_auralinux.cc",
        "patchSetId": 3
      },
      "lineNbr": 664,
      "author": {
        "id": 1250986
      },
      "writtenOn": "2017-11-29T20:24:26Z",
      "side": 1,
      "message": "This change basically tells ATK object listeners (in process, and out of process through AT-SPI) that the object is becoming invalid, so they should realize any access to it will be detached from the actual objects (basically all the method calls are going to return invalid information). We need this, because on ATK objects there is reference counting, and other objects may still keep a reference to it (i.e. because they are accessing the values).\n\nA solution could be just emiting the signal _just after_ the m_object has been set to nullptr, instead of before. In this case, any callback taht would happen would already be detached from the AX model, so there would be no possibility to interact with the backing object.\n\nIn WebKit the implementation is essentially the same. The only difference is quite interesting, as they do not have null checks everywhere. What they do is replacing the regular backing object (our AXPlatformNodeAuraLinux) with a fake one that returns generic values. That\u0027s an optimization that avoids needing to do checks everywhere for m_object validity.",
      "parentUuid": "9f85619d_1196508e",
      "revId": "6efaed1c7cced640daa29fde3df177b69349c42f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}