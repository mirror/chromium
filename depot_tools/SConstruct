# Copyright (c) 2006-2008 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os
import stat
import string
import subprocess
import sys
import tarfile
import zipfile


default_url = 'http://src.chromium.org/svn/trunk/depot_tools'

depot_tools_dir = ARGUMENTS.get('DEPOT_TOOLS_DIR', '')
if depot_tools_dir:
  depot_tools_dir_ = depot_tools_dir + '/'
else:
  depot_tools_dir_ = ''

download_url = ARGUMENTS.get('DOWNLOAD_URL')
if download_url is None:
  download_url = default_url
  if depot_tools_dir:
    download_url += '/' + depot_tools_dir

release_arches = [
    'linux',
    'mac',
    'win',
]


base_env = Environment(tools = [],
                       WRAPPER_DIR = '#$DEPOT_TOOLS_DIR/$RELEASE_ARCH',
                       RELEASE_DIR = '#$DEPOT_TOOLS_DIR/release/$RELEASE_ARCH',
                       DOWNLOAD_URL = download_url)


def DoSubstitute(target, source, env):
  target = str(target[0])
  source = str(source[0])
  try:
    mode = os.stat(target)[stat.ST_MODE]
  except EnvironmentError:
    mode = None
  try:
    os.unlink(target)
  except EnvironmentError:
    pass
  tfp = open(target, 'wb')
  sfp = open(source, 'rb')
  c = string.Template(sfp.read())
  tfp.write(c.safe_substitute(env.Dictionary()))
  if mode:
    os.chmod(target, mode)

DoSubstituteAction = Action(DoSubstitute,
                            'Substitute file: "$SOURCE" as "$TARGET"',
                            varlist=['DOWNLOAD_URL'])

base_env['BUILDERS']['DoSubstitute'] = Builder(action=DoSubstituteAction,
                                               source_factory=File,
                                               target_factory=File)



def Substitute(env, target, source):
  # Arrange for SCons to *not* remove the target file(s), so the
  # build step can examine and preserve permissions.
  env.Precious(target)
  return env.DoSubstitute(target, source)

base_env.AddMethod(Substitute)


def InstallSubstitutions(env, target, source):
  result = []
  dir = str(target)
  for s in source:
    t = env.Substitute(dir + '/' + os.path.split(s)[1], s)
    result.extend(t)
  return result

base_env.AddMethod(InstallSubstitutions)


def CopySubversionTree(env, target, source):
  target = str(env.Dir(target))
  source = str(env.Dir(source))
  for root, dirs, files in os.walk(source):
    subdir = root.replace(source, '')
    if subdir.startswith('/'):
      subdir = subdir[1:]
    if '.svn' in dirs:
      dirs.remove('.svn')
    for f in files:
      env.InstallAs(os.path.join(target, subdir, f),
                    os.path.join(source, subdir, f))

base_env.AddMethod(CopySubversionTree)


def FailForModifiedSubversionWorkingDirectory(source):
  svn = subprocess.Popen(['svn', 'status', source],
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE,
                         shell=(sys.platform=='win32'))
  stdout, stderr = svn.communicate()
  if stderr:
    sys.stdout.write("STDOUT ==========\n" + stdout)
    sys.stderr.write("STDERR ==========\n" + stderr)
    return True
  elif stdout:
    msg = 'WARNING: modified source tree %s:\n%s'
    sys.stdout.write(msg % (repr(source), stdout))
  return False

# TODO(sgk):  uses working directory .svn dirs, make it hermetic
def TarWrappers(target, source, env):
  source = str(source[0])
  if FailForModifiedSubversionWorkingDirectory(source):
    return 1
  tfp = tarfile.open(str(target[0]), 'w:gz')

  # TODO(sgk):  this was the original call to create the .tar.gz,
  # but it preserves on-disk owner and group.
  # tfp.add(source, 'depot_tools')

  # TODO(sgk):  Attempt to use the tarfile module to mimic
  # tar --owner --group
  # Only adds the first file in each directory.
  for root, dirs, files in os.walk(source):
    subdir = root.replace(source, '')
    if subdir.startswith('/'):
      subdir = subdir[1:]
    for p in dirs + files:
      rname = os.path.join(root, p)
      dtname = os.path.join('depot_tools', subdir, p)
      print "tfp.gettarinfo(%s, %s)" % (rname, dtname)
      try:
        fileobj = open(rname, 'rb')
      except:
        ti = tfp.gettarinfo(rname, dtname)
      else:
        ti = tfp.gettarinfo(rname, dtname, fileobj)
      ti.uid = 0
      ti.uname = 'root'
      ti.gid = 0
      ti.gname = 'root'
      tfp.addfile(ti)
  return None

# TODO(sgk):  just use tar itself, which makes us not cross-platform,
# but works as we want.
TarWrappers = "tar --owner 0 --group 0 -zcf $TARGET $SOURCE"

TarWrappersAction = Action(TarWrappers,
                          'TarWrappers file: "$SOURCE" as "$TARGET"')

base_env['BUILDERS']['TarWrappers'] = Builder(action=TarWrappersAction,
                                              source_factory=Dir,
                                              target_factory=File)

# TODO(sgk):  uses working directory .svn dirs, make it hermetic
def ZipWrappers(target, source, env):
  source = str(source[0])
  if FailForModifiedSubversionWorkingDirectory(source):
    return 1
  tfp = zipfile.ZipFile(str(target[0]), 'w', zipfile.ZIP_DEFLATED)
  for root, dirs, files in os.walk(source):
    subdir = root.replace(source, '')
    if subdir.startswith('/'):
      subdir = subdir[1:]
    for d in dirs:
      dname = os.path.join('depot_tools', subdir, d, '')
      zinfo = zipfile.ZipInfo(dname)
      zinfo.external_attr = 48 # directory
      tfp.writestr(zinfo, '')
    for f in files:
      tfp.write(os.path.join(root, f),
                os.path.join('depot_tools', subdir, f))
    if env['RELEASE_ARCH'] in ('linux', 'mac'):
      for zinfo in tfp.filelist:
        zinfo.create_system = 3 # UNIX
  return None

ZipWrappersAction = Action(ZipWrappers,
                          'ZipWrappers file: "$SOURCE" as "$TARGET"')

base_env['BUILDERS']['ZipWrappers'] = Builder(action=ZipWrappersAction,
                                              source_factory=Dir,
                                              target_factory=File)


env = base_env.Clone(DEPOT_TOOLS_DIR = depot_tools_dir,
                     DEPOT_TOOLS_DIR_ = depot_tools_dir_)

for release_arch in release_arches:
  env = env.Clone(RELEASE_ARCH = release_arch)
  Export('env')
  SConscript('src/wrappers/SConscript')
  SConscript('src/release/SConscript')
  if ARGUMENTS.get('DEPOT_TOOLS_DIR', '') == '1':
    if release_arch in ('linux', 'mac'):
      env.TarWrappers('${DEPOT_TOOLS_DIR_}depot_tools_${RELEASE_ARCH}.tar.gz',
                      '$WRAPPER_DIR')
    if release_arch in ('win',):
      env.ZipWrappers('${DEPOT_TOOLS_DIR_}depot_tools_${RELEASE_ARCH}.zip',
                      '$WRAPPER_DIR')


Help("""
usage: scons [OPTION [TARGET] ...

SCons configuration for packaging depot_tools.

  DOWNLOAD_URL=         Specify the URL that will get inserted in the
	                appropriate update scripts for depot_tools to
                        sync from.
  DEPOT_TOOLS_DIR=      Specify the directory into which to build/release
                        the scripts.  Default is ''.
  TAR=1                 Generates depot_tools_win.zip, depot_tools_mac.tar.gz or
                        depot_tools_linux.tar.gz
""")
