# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""changebranch - stuff for change branches

Classes:
ChangeBranch -- representation of a change branch

Functions:
ListChangeBranches -- generate changebranch names and dirents
Diff            -- diff a change branch

"""

import cStringIO
import os
import posixpath
import random
import re
import shutil
import subprocess
import sys

from errno import EEXIST

import svn.diff
import svn.ra
import svn.wc

from svn.core import SVN_DIRENT_CREATED_REV, SVN_DIRENT_KIND
from svn.core import SWIG_SVN_INVALID_REVNUM as SVN_INVALID_REVNUM
from svn.core import svn_node_dir, svn_node_file, svn_node_none, svn_node_unknown
from svn.core import svn_path_local_style
from svn.core import svn_prop_regular_kind, svn_property_kind

import gvn.commit
import gvn.errors
import gvn.platform
import gvn.repository
import gvn.svncmd
import gvn.util
import gvn.wc

try:
  import simplejson
except ImportError:
  from gvn.third_party import simplejson


def IsRegularProp(name):
  (kind, prefix_len) = svn.core.svn_property_kind(name)
  return kind == svn.core.svn_prop_regular_kind

def FilterRegularProps(properties):
  """Return copy of properties with special svn properties removed."""
  return dict((name, value) for (name, value) in properties.iteritems()
              if IsRegularProp(name))


_ADD_CODES =['A', 'R']

class State(object):
  """state of a changebranch snapshot

  Attributes:
  base_path, base_revision      -- path/revision snapshot is based on
  paths                         -- dict mapping unicode path to PathState
  """
  def __init__(self, base_path, base_revision):
    self.base_path = base_path
    self.base_revision = base_revision
    self.paths = {}


class PathState(object):
  """state of a path in a changebranch snapshot

  Note: kind is always svn_node_unknown for old-style changebranches,
  which are going away soon.

  Attributes:
  action                -- 'A'dd, 'D'elete, 'R'eplace, 'M'odify
  base_revision         -- revision of working copy item this represents
  snap_revision         -- revision of last snapshot
  copyfrom_path         -- path copied from or None
  copyfrom_revision     -- revision copied from or SVN_INVALID_REVNUM
  kind                  -- svn_node_kind_t
  """
  def __init__(self, action, base_revision, snap_revision,
               copyfrom_path, copyfrom_revision, kind):
    self.action = action
    self.base_revision = base_revision
    self.snap_revision = snap_revision
    self.copyfrom_path = copyfrom_path
    self.copyfrom_revision = copyfrom_revision
    self.kind = kind

  def __eq__(self, other):
    return (self.action == other.action
            and self.base_revision == other.base_revision
            and self.snap_revision == other.snap_revision
            and self.copyfrom_path == other.copyfrom_path
            and self.copyfrom_revision == other.copyfrom_revision
            and self.kind == other.kind)
  def __ne__(self, other):
    return not self == other


def _ParseStateKind(state_dict):
  """Parse path kind from State dict (helper for ParseState)."""
  if state_dict.get('kind') in [None, 'file']:
    return svn_node_file
  return svn_node_dir

def ParseState(state_utf8, snap_revision):
  """Parse state_utf8 at snap_revision.

  Arguments:
  state_utf8            -- utf8-encoded str from the repository state file
  snap_revision         -- revision of the snapshot being examined

  Raises:
  gvn.errors.ParseState
  """
  # Decode the UTF-8 text.
  try:
    decoded = state_utf8.decode('utf8')
  except UnicodeDecodeError, e:
    raise gvn.errors.ParseState(child=gvn.errors.Encoding(e))
  # Parse the dict from the decoded text.
  try:
    parsed = simplejson.loads(decoded)
  except ValueError, e:
    raise gvn.errors.ParseState(child=e)
  # Check the format.
  try:
    format = parsed['format']
  except KeyError:
    # no format => format 0
    format = 0
  if format != 0:
    # which is all we support
    raise gvn.errors.ParseState(message='unknown format %d' % (format,))
  # Get base path and revision.
  try:
    base_path = parsed['base']
  except KeyError:
    raise gvn.errors.ParseState(message='missing base path')
  try:
    base_revision = parsed['base_rev']
  except KeyError:
    raise gvn.errors.ParseState(message='missing base revision')

  change_state = State(base_path, base_revision)
  # Get path state.
  try:
    path_state = parsed['paths']
  except KeyError:
    raise gvn.errors.ParseState(message='missing paths')
  for (path, state) in path_state.iteritems():
    try:
      action = state['action']
    except KeyError:
      raise gvn.errors.ParseState(message="missing action for '%s'" % (path,))
    # base, snap, copyfrom_path/rev, and kind may be missing.
    change_state.paths[path] = PathState(action,
                                         state.get('base', base_revision),
                                         state.get('snap', snap_revision),
                                         state.get('copyfrom_path'),
                                         state.get('copyfrom_rev',
                                                   SVN_INVALID_REVNUM),
                                         _ParseStateKind(state))
  return change_state


class _WCBranch(gvn.wc.Edit):
  """Apply a change from a working copy to a change branch."""

  def __init__(self, *args, **kwargs):
    """Same as gvn.wc.Edit.__init__ plus source_revision.

    Additional arguments:
    source_revision -- revision of source branch copied to change branch
                       (required keyword argument)
    """

    self.source_revision = kwargs.pop('source_revision')
    gvn.wc.Edit.__init__(self, *args, **kwargs)

  def _GetAction(self):
    """gvn.wc.Edit._GetAction but treat conflicted as modified."""
    try:
      action = gvn.wc.Edit._GetAction(self)
    except KeyError, e:
      if e.args[0] != svn.wc.status_conflicted:
        raise
      action = self._Modified
    return action

  def _PostProcess(self, pool):
    state = gvn.wc.ChangeState(None, self.wc.AbsolutePath(self.wc_path),
                               None, self.status)
    self.wc.UpdateChangeState(self.wc_path, state)

  def _Modified(self, parent, path, editor, pool):
    if (self.source_revision is not None
        and self.status.entry.revision != self.source_revision):
      self.wc.Notify(self.wc_path, svn.wc.notify_commit_modified,
                     self.status.entry.kind, pool)
      # If wc_path's base revision is not the same as the
      # source_revision the overall change branch is based on, replace
      # this node in the change branch with a copy from wc_path's base
      # and base change on that.
      if not self.status.entry.repos.startswith('http'):
        # As long as we need the 2939 hack in _AddHelper, only for non-http.
        editor.delete_entry(path, self.status.entry.revision, parent, pool)
      return self._AddHelper(parent, path, editor,
                             self.status.entry.url,      # copyfrom
                             self.status.entry.revision, # copyfrom
                             pool)
    else:
      return gvn.wc.Edit._Modified(self, parent, path, editor, pool)

  # XXX workaround http://subversion.tigris.org/issues/show_bug.cgi?id=2939
  def _AddHelper(self, parent, path, editor,
                 copyfrom_url=None, copyfrom_rev=None, pool=None):
    self.DiagLog('')
    if self.status.entry.repos.startswith('http'):
      args = (path, self.status.entry.revision, parent, pool)
      gvn.DiagLog('delete_entry%s; ', args)
      editor.delete_entry(*args)
    result = gvn.wc.Edit._AddHelper(self, parent, path, editor,
                                    copyfrom_url, copyfrom_rev, pool)
    gvn.DiagLog('\n')
    return result


class PostfixTextDeltaManager(gvn.wc.PostfixTextDeltaManager):
  def PostProcess(self, wc_path, status, checksum):
    """Update gvn change state.

    No wc bump, as this isn't a commit to the working copy's URL.
    """

    state = gvn.wc.ChangeState(None, self.wc.AbsolutePath(wc_path),
                               checksum, status)
    self.wc.UpdateChangeState(wc_path, state)

  def HandleTmp(self, tmp):
    """Unlink tmp file, rather than ignoring it.

    For snapshots, we must remove this file, otherwise later submits try to
    use it as the new text base, resulting in corruption.
    """
    os.unlink(tmp)


# TODO(next-release): The new changebranch creation code fixes all these
# TODOs about self.revision.
class ChangeBranch(object):
  """Representation of a change branch."""

  def __init__(self, config, project, name, username=None, revision=None):
    """Initialize ChangeBranch, which may or may not exist in the repo.

    Arguments:
    config   -- gvn.config.Config
    project  -- gvn.project.Project
    name     -- name of change branch
    username -- username; defaults to config.username
    revision -- revision number of existing change branch

    """

    gvn.util.ValidateChangeName(name)
    self._name = name
    self._config = config
    self.project = project

    if username is None:
      self._username = self.project.repository.username
    else:
      self._username = username

    if revision is None:
      self._revision = revision
    else:
      # TODO(epg): We should fill this in on the fly.
      (self._revision,) = self.project.repository.GetRevisions(start=revision)

    self._description = None
    self._revisions = []

    # TODO(next-release): Remove; this is just to support old-style
    # changebranches during the transition; see also _GetChangedPathsHelper
    # and BranchPath methods.
    self._branch_name = 'branch'

  name = property(lambda self: self._name)
  username = property(lambda self: self._username)
  change_name_at_head = property(lambda self: '/'.join([self.username,
                                                        self.name]))
  change_name = property(lambda self: '@'.join(['/'.join([self.username,
                                                          self.name]),
                                                str(self.revision.number)]))

  def BranchPath(self, path=None):
    """Return root-relative path of (or within) the branch.

    If path is None return the branch path itself, otherwise return the
    root-relative path of path within the branch.
    """
    if path is None:
      path = self._branch_name
    else:
      path = self._branch_name + '/' + path
    return self.project.ChangeBranchPath(self.username, self.name, path)

  def StatePath(self):
    """Return root-relative path of the state file."""
    return self.project.ChangeBranchPath(self.username, self.name, 'state')

  def _GetRevision(self):
    if self._revision is None:
      dirent = self.project.repository.Stat(
                            self.project.ChangeBranchPath(self.username,
                                                           self.name),
                            self.project.repository.GetHead())
      self._revision = dirent.last_changed
    return self._revision
  revision = property(_GetRevision)

  def _GetDescription(self):
    if self._description is None:
      try:
        revision = self.revision
      except gvn.errors.RepoPath:
        return
      self._description = revision['svn:log'].decode('utf-8')
    return self._description
  description = property(_GetDescription)

  def _GetChangedPathsHelper(self):
    revision = self.revision

    cbp = self.project.ChangeBranchPath(self.username, self.name)

    # TODO(epg): Er, isn't this entirely redundant?  Just use self.revision...
    (revision,) = self.project.repository.GetRevisions([cbp],
                                                        start=revision.number,
                                                        end=1, limit=1)

    changes = []
    branch_name = None
    for i in sorted(revision.paths, key=lambda x: x.path):
      # When we start through here, we don't know the "top name"
      # ('trunk' for '//trunk', 'projects' for '//public/projects').
      if branch_name is None:
        (dirname, basename) = posixpath.split(i.path.lstrip('/'))
        if dirname == cbp:
          # Found the branch; save branch_name, path, and copyfrom.
          self._branch_name = branch_name = basename
          cbp = self.project.ChangeBranchPath(self.username, self.name,
                                               branch_name)
          source = i.copyfrom_path
          source_revision = i.copyfrom_revision
          continue
        # If we get here, we're looking at creation of directories
        # above the changebranch; skip those.
        continue
      try:
        relative_path = gvn.util.RelativePath(cbp, i.path.lstrip('/'))
      except gvn.errors.PathNotChild:
        # i is not in our changebranch
        continue
      changes.append(gvn.repository.ChangedPath(i.path, i.revision, i.action,
                                            i.copyfrom_path, i.copyfrom_revision,
                                            relative_path, source,
                                            source_revision))
    return (source, source_revision, changes)

  def _GetChangedPaths(self):
    # TODO(next-release): Preserving this crapitude for just one more...
    try:
      return self._GetChangedPathsHelper()[2]
    except gvn.errors.RepoPath:
      return []
  changed_paths = property(_GetChangedPaths, doc="""List of ChangedPaths.""")

  def _OldGetRepoState(self):
    (source, source_revision, changes) = self._GetChangedPathsHelper()
    state = State(source.lstrip('/'), source_revision)
    for cp in changes:
      relative_path = cp.relative_path.lstrip('/')
      if cp.copyfrom_path is None:
        copyfrom_path = None
      else:
        copyfrom_path = cp.copyfrom_path.lstrip('/')
      state.paths[relative_path] = PathState(cp.action, cp.old_revision,
                                             self.revision.number,
                                             copyfrom_path,
                                             cp.copyfrom_revision,
                                             svn_node_unknown)
    return state

  def _NewGetRepoState(self, pool):
    """Return State object parsed from repository state file.

    Will replace GetRepoState in next release.

    Raises:
    SubversionException.apr_err in gvn.errors.SVN_NOENT
    SubversionException.apr_err==???
    gvn.errors.ParseState
    """
    sio = cStringIO.StringIO()
    svn.ra.get_file(self.project.repository.ra,
                    self.StatePath(), self.revision.number,
                    sio, pool)
    return ParseState(sio.getvalue(), self.revision.number)

  def GetRepoState(self, pool):
    """Return State object from old or new style changebranch.

    First try _NewGetRepoState, but if the state file does not exist, try
    _OldGetRepoState.

    Will be replaced by _NewGetRepoState in next release.
    """
    try:
      return self._NewGetRepoState(pool)
    except svn.core.SubversionException, e:
      if e.apr_err not in gvn.errors.SVN_NOENT:
        raise
      # No state path; try old-style changebranch.
      return self._OldGetRepoState()

  def ChangedPathsRelative(self):
    """Return iterator returning relative paths of changed_paths."""
    return (x.relative_path for x in self.changed_paths)

  def Exists(self):
    try:
      # Contact the repository to find the last changed revision.
      self.revision
      return True
    except gvn.errors.RepoPath:
      # Changebranch does not exist.
      return False

  def _MissingDirectories(self, path, revision, pool):
    """Return list of directories to make in order to mkdir path.

    In an empty repository:
      _MissingDirectories(foo/bar/baz)  => [foo, foo/bar, foo/bar/baz]
    If foo/bar already exists:
      _MissingDirectories(foo)          => []
      _MissingDirectories(foo/bar)      => []
      _MissingDirectories(foo/bar/baz)  => [foo/bar/baz]

    Arguments:
    path                -- path relative to repository root
    revision            -- revision the transaction is based on
    pool                -- memory pool
    """
    if path == '':
      return []
    kind = svn.ra.check_path(self.project.repository.ra, path, revision, pool)
    if kind != svn_node_none:
      return []
    return (self._MissingDirectories(posixpath.dirname(path), revision, pool)
            + [path])

  def Branch(self, _wc, paths=None, description=None, pool=None):
    """Replace (or create) change branch with paths.

    paths may be either a dict mapping path to svn_wc_status2_t or a
    list of paths.  If it is a list, .Branch will open the deepest
    common path and discover the svn_wc_status2_t for each path
    itself; if a dict, .Branch assumes the wc is already open.

    Arguments:
    paths       -- list of paths to change; defaults to .changed_paths
    description -- svn:log for change; defaults to .description; default ''
    pool        -- memory pool

    """

    if _wc.name == '':
      raise gvn.errors.BranchFromRoot

    # Save the current changebranched paths so we can remove local
    # meta-data for paths being removed from the changebranch.
    orig_paths = set(self.ChangedPathsRelative())

    if paths is None:
      paths = orig_paths

    if not hasattr(paths, 'iterkeys'):
      # Treat it as a list.
      targets = paths
      _wc.Open(targets)
      paths = {}
      def status_cb(target, status):
        paths[_wc.RelativePath(target)] = status
      _wc.Status(targets, recursive=False, get_all=False, no_ignore=False,
                 show_children=False, callback=status_cb)

    if description is None:
      description = self.description
      if description is None:
        description = ''

    head = self.project.repository.GetHead(pool)

    changes_path = self.project.ChangeBranchPath()
    user_path = self.project.ChangeBranchPath(self.username)
    container_path = self.project.ChangeBranchPath(self.username, self.name)
    branch_path = self.project.ChangeBranchPath(self.username, self.name,
                                                 _wc.name)

    mkdirs = self._MissingDirectories(container_path, head, pool)
    delete_branch_path = (container_path not in mkdirs
                          and svn.ra.check_path(self.project.repository.ra,
                                                branch_path, head,
                                                pool) != svn_node_none)
    repo_paths = list(mkdirs)
    repo_paths.append(branch_path)
    for i in sorted(paths.iterkeys()):
      repo_paths.append(self.project.ChangeBranchPath(self.username,
                                                       self.name,
                                                       '/'.join([_wc.name,
                                                                 i])))

    source_revision = _wc.Entry(pool=pool).revision

    deltaman = PostfixTextDeltaManager(_wc)
    def action(path, pool):
      if path in mkdirs:
        return gvn.commit.Mkdir(head)
      elif path == branch_path:
        return gvn.commit.CopyDir(_wc.URL(), source_revision,
                                  replace=delete_branch_path,
                                  replace_revision=head)
      wc_path = path[len(branch_path)+1:]
      try:
        if _wc.change_state[wc_path].change_name != self.name:
          # ye olde stupid generic exception; we gotta fix that
          raise gvn.errors.ChangeBranch('%s already in %s' % (wc_path,
                                        _wc.change_state[wc_path].change_name))
      except KeyError:
        # not yet changebranched at all
        pass
      return _WCBranch(_wc, wc_path, paths[wc_path],
                       source_revision=source_revision,
                       file_baton_cb=deltaman.Add)
    try:
      try:
        commit_info = gvn.commit.Drive(self.project.repository,
                                       {'svn:log': description.encode('utf-8')},
                                       head, repo_paths, action,
                                       deltaman.Transmit)
      except svn.core.SubversionException, e:
        # Try to report decent error message for out of date parent.
        if e.apr_err == svn.core.SVN_ERR_FS_NOT_DIRECTORY:
          # local and svn use this
          m = re.match(r"Path '(.*)' not present$", e.args[0])
          if m is None:
            # Not a case we know about; let it out.
            raise
          parent = m.group(1)[len(branch_path)+1:]
          raise gvn.errors.OutOfDateParent(e, _wc.subpath, source_revision,
                                           parent)
        elif e.apr_err == svn.core.SVN_ERR_FS_NOT_FOUND:
          # neon (TODO(epg): and serf?) use this
          m = re.match(r"File not found: transaction '[^']+', path '(.*)'$",
                       e.args[0])
          if m is None:
            # Not a case we know about; let it out.
            raise
          # TODO(epg): neon has leading /; does serf?
          parent = posixpath.dirname(m.group(1)[len(branch_path)+2:])
          raise gvn.errors.OutOfDateParent(e, _wc.subpath, source_revision,
                                           parent)
        # Not a case we know about; let it out.
        raise
    except:
      _wc.ClearPendingChangeState()
      raise

    # Update local change state.
    for path in orig_paths.difference(paths):
      # User removed path from changebranch.
      _wc.DeleteChangeState(path)
    for i in paths:
      _wc.UpdateChangeState(i, change_name=self.name)
    _wc.Save()
    _wc.Close()

    self._description = description
    # TODO(epg): We just created this revision, so we can construct
    # the Revision object without having to svn log.
    (self._revision,) = self.project.repository.GetRevisions(start=commit_info.revision)

    if callable(_wc.notify_func):
      _wc.notify_func('Changed %s.\n' % (self.change_name,))
      if commit_info.post_commit_err is not None:
        _wc.notify_func('\nWarning: %s\n' % (commit_info.post_commit_err,))

  def Delete(self, _wc, description=None, pool=None):
    """Delete, leaving self invalid and paths associated with no change.

    Arguments:
    description -- svn:log for deletion; defaults to .description or ''
    pool        -- memory pool

    """

    # Save this for updating _wc.change_state .
    paths = list(self.ChangedPathsRelative())

    if description is None:
      description = 'Delete.\n'

    head = self.project.repository.GetHead(pool)
    container_path = self.project.ChangeBranchPath(self.username, self.name)

    def action(path, pool):
      return gvn.commit.Delete(self.revision.number)
    try:
      commit_info = gvn.commit.Drive(self.project.repository,
                                     {'svn:log': description.encode('utf-8')},
                                     head, [container_path], action, pool=pool)
    except:
      _wc.ClearPendingChangeState()
      raise

    # Update local change state.
    for i in paths:
      _wc.DeleteChangeState(i)
    _wc.Save()

    self._revision = self._description = None

    if callable(_wc.notify_func):
      _wc.notify_func('Deleted %s@%d.\n' % (self.change_name_at_head,
                                            commit_info.revision))
      if commit_info.post_commit_err is not None:
        _wc.notify_func('\nWarning: %s\n' % (commit_info.post_commit_err,))

  def Submit(self, _wc, description=None, revprops=None, pool=None):
    """Submit (and remove) change branch.

    Arguments:
    description -- svn:log for submit; defaults to .description or ''
    revprops    -- mapping of revprop names to values (default None)
    pool        -- memory pool

    """

    if description is None:
      description = self.description.encode('utf-8')
      if description is None:
        description = ''

    if revprops is None:
      revprops = {}
    revprops['svn:log'] = description
    revprops['gvn:change'] = self.change_name

    head = self.project.repository.GetHead(pool)

    if callable(_wc.notify_func):
      _wc.notify_func('Submitting %s\n' % (self.change_name,), pool)

    container_path = self.project.ChangeBranchPath(self.username, self.name)

    paths = []
    repo_paths = [container_path]
    for i in self.changed_paths:
      paths.append(i.relative_path)
      repo_paths.append(_wc.RepoPath(i.relative_path))

    _wc.Open(paths, write_lock=True)

    path_status = {}
    def status_cb(target, status):
      wc_path = _wc.RelativePath(target)
      # TODO(epg): Need to check for other kinds of status as well.
      # For example, if i have a changebranch in which i add new/ and
      # new/file and someone else commits new/ i can't submit (out of
      # date).  If i update and snapshot i'll be fine, but if i update
      # and forget to snapshot, status here is svn_wc_status_none for
      # new/ (because it's an Add on cb but unmodified in wc) which
      # causes _GetAction to have a KeyError.
      if gvn.wc.IsConflicted(status):
        raise gvn.errors.Conflict(wc_path)
      path_status[wc_path] = status
    _wc.Status(paths, recursive=False, get_all=False, no_ignore=False,
               show_children=False, callback=status_cb)

    deltaman = gvn.wc.PostfixTextDeltaManager(_wc)
    def action(path, editpool):
      if path == container_path:
        return gvn.commit.Delete(self.revision.number)
      wc_path = _wc.LocalPath(path)
      return gvn.wc.Edit(_wc, wc_path, path_status[wc_path],
                         file_baton_cb=deltaman.Add)
    try:
      commit_info = gvn.commit.Drive(self.project.repository,
                                     revprops,
                                     head, repo_paths, action,
                                     deltaman.Transmit, pool)
    except:
      _wc.ClearPendingChangeState()
      raise

    # TODO(epg): Any of these may fail independently: MarkSubmitted,
    # .gvnstate updating, wc bump, and anything else we add here.  But
    # we want to try them all, anyway, but let the callers see all
    # exceptions.  Collin agreed that a composite exception class,
    # containing a list of exception objects for caller to handle, is
    # a sane way to cover this.  For now, ignore MarkSubmitted errors.
    # Eventually, the post-commit processor will add missing
    # gvn:submitted properties.
    try:
      self.MarkSubmitted(commit_info.revision, pool)
    except:
      #import traceback; traceback.print_exc()
      pass

    # Update local change state.
    for i in paths:
      _wc.DeleteChangeState(i)
    _wc.Save()

    if callable(_wc.notify_func):
      _wc.notify_func('Submitted r%d.\n' % (commit_info.revision,), pool)
      if commit_info.post_commit_err is not None:
        _wc.notify_func('\nWarning: %s\n' % (commit_info.post_commit_err,))

    # TODO(epg): Huh?  Why are we clobbering these?
    self._revision = self._description = None

    _wc.ProcessCommittedQueue(commit_info, pool)
    _wc.Close()

    return commit_info.revision

  def Approve(self, pool):
    """Mark this change branch approved."""

    propname = ':'.join(['gvn:approve', self.project.repository.username])
    svn.ra.change_rev_prop(self.project.repository.ra,
                           self.revision.number, propname, '',
                           pool)

  def MarkSubmitted(self, revision, pool):
    """Mark this changebranch submitted in revision."""
    svn.ra.change_rev_prop(self.project.repository.ra,
                           self.revision.number, 'gvn:submitted',
                           str(revision), pool)

def ListChangeBranches(project, dirent_fields=0, user=None, pool=None):
  """Return a generator yielding (change_name, svn_dirent_t) tuples.

  Arguments:
  project               -- gvn.project.Project
  dirent_fields         -- see svn_ra_get_dir2; use SVN_DIRENT_CREATED_REV
                           and SVN_DIRENT_KIND even if not specified here
  user                  -- user whose changebranches to yield;
                           yield all if None (the default)
  pool                  -- memory pool

  Raises:
  gvn.errors.NoChangeBranchBase
  gvn.errors.NoUserChangeBranch
  svn.core.SubversionException
  """
  if user is None:
    try:
      (dirents, revision, properties) = svn.ra.get_dir2(project.repository.ra,
                                                    project.ChangeBranchPath(),
                                                        SVN_INVALID_REVNUM,
                                                        SVN_DIRENT_KIND,
                                                        pool)
    except svn.core.SubversionException, e:
      if e.apr_err in [svn.core.SVN_ERR_FS_NOT_FOUND,
                       svn.core.SVN_ERR_RA_DAV_PATH_NOT_FOUND]:
        raise gvn.errors.NoChangeBranchBase(project.ChangeBranchPath())
      raise
    users = (name for (name, dirent) in dirents.iteritems()
             if dirent.kind == svn_node_dir)
  else:
    users = [user]

  # No matter what the caller wanted, we need at least these two.
  dirent_fields |= SVN_DIRENT_CREATED_REV
  dirent_fields |= SVN_DIRENT_KIND

  iterpool = svn.core.Pool(pool)
  for user in users:
    iterpool.clear()
    try:
      (dirents, revision, properties) = svn.ra.get_dir2(
                                        project.repository.ra,
                                        project.ChangeBranchPath(user),
                                        SVN_INVALID_REVNUM,
                                        dirent_fields, pool)
    except svn.core.SubversionException, e:
      if e.apr_err in [svn.core.SVN_ERR_FS_NOT_FOUND,
                       svn.core.SVN_ERR_RA_DAV_PATH_NOT_FOUND]:
        raise gvn.errors.NoUserChangeBranch(project.ChangeBranchPath(user))
      raise
    for (name, dirent) in dirents.iteritems():
      if dirent.kind == svn_node_dir:
        yield ('%s/%s@%d' % (user, name, dirent.created_rev), dirent)
  iterpool.destroy()

def UniqueChangeName(project, username, base, pool):
  """Return a unique change name starting with base.

  If base is available, just return that, otherwise try appending
  numbers to it until finding a unique name.

  """

  try:
    changebranches = [change_name for (change_name, dirent) in
                      ListChangeBranches(project, user=username, pool=pool)]
  except gvn.errors.NoUserChangeBranch:
    return base
  if base not in changebranches:
    return base

  i = 1
  while True:
    name = base + str(i)
    if name not in changebranches:
      return name
    i += 1

def RandomBranchName(length=4):
  """Return a random branchname of length 'length'.

  Branchnames are only lowercase characters and numbers, excluding:
     lower case 'o' and the number 0 so as not to be confused
     lower case 'l' and the number 1 so as not to be confused

  Letters and numbers alternate beginning with a letter.

  Examples of a 4 character branchname:  'a2i3', 'w2b8', 'd5j4'.

  Uses of names returned by this method should be wrapped in
  UniqueChangeName() to ensure uniqueness.

  """

  branchname = []
  for i in xrange(0, length):
    if i % 2 == 0:
      branchname.append(random.choice('abcdefghijkmnpqrstuvwxyz'))
    else:
      branchname.append(random.choice('23456789'))

  return ''.join(branchname)

###########################################################################
# changebranch diffing

# first, the callbacks

class DiffCallbacks(object):
  """Base class for callbacks called by Diff functions."""
  cb = None
  repo_state = None

  def SetChangeState(self, cb, state):
    """Called with ChangeBranch and State objects before any other callback.

    Callback implementors should not need to implement this one, as this
    implementation saves them as the cb and state attributes.
    """
    self.cb = cb
    self.repo_state = state

  def Directory(self, path,
                left_properties, right_properties, pool):
    """Called for added or changed directories.

    Arguments:
    path                -- unicode path relative to the base path
    left_properties     -- properties for the left side
    right_properties    -- properties for the right side
    pool                -- scratch pool
    """
    pass

  def File(self, path, left_path, right_path,
           left_properties, right_properties, pool):
    """Called for added or changed files.

    Implementations may freely modify the two tmp files, but may not
    delete them.

    Arguments:
    path                -- unicode path relative to the base path
    left_path           -- name of local temporary file for the left side
    right_path          -- name of local temporary file for the right side
    left_properties     -- properties for the left side
    right_properties    -- properties for the right side
    pool                -- scratch pool
    """
    pass

  def Abort(self, pool):
    """Called if something goes wrong before finishing the diff.

    Arguments:
    pool                -- scratch pool
    """
    pass

  def Finish(self, pool):
    """Called when the diff is finished.

    Arguments:
    pool                -- scratch pool

    Returns:
    Whatever the implementor wants (this implementation returns None); Diff
    functions will return this.
    """
    return None


class SvnDiffCallbacks(DiffCallbacks):
  """DiffCallbacks implementation using svn's internal textual diff."""

  def __init__(self, options, out_file, encoding, pool, command=None):
    """Initialize from list, file-like, str, svn.core.Pool.

    It does not make much sense for a caller to pass anything but
    sys.stdout for out_file when specify a custom command, unless it
    really wants the property diffs and 'Index' headings to go to a
    different output stream from the diff command output.

    Arguments:
    options     -- list of option strings for svn.diff.file_options_parse
    out_file    -- file-like object to which to write the diff
    encoding    -- user's encoding
    pool        -- scratch memory pool; may be cleared after instantiation
    command     -- optional custom diff; passed to subprocess.call (with shell)
    """
    self.options = svn.diff.file_options_create()
    svn.diff.file_options_parse(self.options, options, pool)
    self.fp = out_file
    self.encoding = encoding
    self.command = command
    self.result = 0

  def _DiffProps(self, path, left_properties, right_properties, pool):
    prop_diffs = svn.core.svn_prop_diffs(right_properties, left_properties,
                                         pool)
    if len(prop_diffs) == 0:
      return
    self.fp.write('\n'
                  'Property changes on: %s\n'
                  '___________________________________________________________________\n'
                  % (path.encode(self.encoding),))
    for (name, value) in prop_diffs.iteritems():
      original = left_properties.get(name)
      # TODO(glasser): Use svn.diff.mem_string stuff here.
      if original is None:
        self.fp.write('Added: %s\n'
                      '   + %s\n'
                      % (name.encode(self.encoding), value))
      elif value is None:
        self.fp.write('Deleted: %s\n'
                      '   - %s\n'
                      % (name.encode(self.encoding), original))
      else:
        self.fp.write('Modified: %s\n'
                      '   - %s\n'
                      '   + %s\n'
                      % (name.encode(self.encoding),
                         original, value))

  def Directory(self, path,
                left_properties, right_properties,
                left_header, right_header, pool):
    # TODO(epg): Support --no-diff-deleted
    no_diff_deleted = True
    if (no_diff_deleted
        and self.repo_state is not None
        and self.repo_state.paths[path].action == 'D'):
      return
    self._DiffProps(path, left_properties, right_properties, pool)

  def File(self, path, left_path, right_path,
           left_properties, right_properties,
           left_header, right_header, pool):
    # TODO(epg): Support --no-diff-deleted
    no_diff_deleted = True
    if (no_diff_deleted
        and self.repo_state is not None
        and self.repo_state.paths[path].action == 'D'):
      maybe_deleted = ' (deleted)'
    else:
      maybe_deleted = ''
    self.fp.write('Index: %s%s\n'
                  '===================================================================\n'
                  % (path.encode(self.encoding), maybe_deleted))
    if (no_diff_deleted
        and self.repo_state is not None
        and self.repo_state.paths[path].action == 'D'):
      return

    if self.command is None:
      diff = svn.diff.file_diff_2(left_path, right_path,
                                  self.options, pool)
      relative_to_dir = None
      svn.diff.file_output_unified3(self.fp, diff,
                                    left_path, right_path,
                                    left_header, right_header,
                                    self.encoding, relative_to_dir,
                                    self.options.show_c_function, pool)
      # TODO(epg): Would be nice if svn.diff could tell us if anything
      # changed so we could set self.result here.
      #self.result = ...
    else:
      cmd = '%s %s %s' % (self.command, left_path, right_path)
      gvn.DiagLog('SvnDiffCallbacks.File => subprocess.call(%s, shell=True)\n',
                  cmd)
      self.fp.flush()
      result = subprocess.call(cmd, shell=True)
      if result != 0:
        self.result = result

    self._DiffProps(path, left_properties, right_properties, pool)

  def Finish(self, pool):
    return self.result


def _MaybeWriteProperties(properties, filename):
  """Serialize properties into the file filename, if any properties.

  Helper for TkDiffCallbacks.
  """
  if len(properties) == 0:
    return
  fp = open(filename, mode='ab')
  fp.write('\n\nProperties:\n')
  for (name, value) in sorted(properties.iteritems(), key=lambda x: x[0]):
    fp.write('%s: %s\n' % (name, value))
  fp.close()

class TkDiffCallbacks(DiffCallbacks):
  """DiffCallbacks implementation using tkdiff."""

  def __init__(self, tkdiff, encoding):
    """Initialize from str, str.

    Arguments:
    tkdiff      -- tkdiff command; passed to subprocess.call (without shell)
    encoding    -- user's encoding
    """
    self.tkdiff = tkdiff
    self.encoding = encoding
    self.pairs = []

  def Directory(self, path,
                left_properties, right_properties,
                left_header, right_header, pool):
    # TODO(epg): _MaybeWriteProperties in some parallel tree (so names match
    # up) for directory prop diffs.
    return

  def File(self, path, left_path, right_path,
           left_properties, right_properties,
           left_header, right_header, pool):
    self.pairs.append((left_path, right_path))
    if len(svn.core.svn_prop_diffs(right_properties, left_properties,
                                   pool)) == 0:
      return
    _MaybeWriteProperties(left_properties, left_path)
    _MaybeWriteProperties(right_properties, right_path)

  def Finish(self, pool):
    if len(self.pairs) == 0:
      # Nothing actually changed, so don't run tkdiff.
      return 0
    argv = [self.tkdiff]
    for (left, right) in self.pairs:
      argv.append(':')
      argv.append(left)
      argv.append(right)
    return subprocess.call(argv)

#################################################################
# now, the Diff functions

# first, DiffBaseToSnapshot

def _FindLeft(path, base_revision, repo_state, copied_directory_stack):
  """Return (root-relative path, revision, header) for the left side of a diff.

  In the simple, common case this is just

    (repo_state.base_path + path, base_revision)

  But if some parent directory of path was copied
  (i.e. copied_directory_stack is not empty), we need to find the
  left side under the path from which that copy was made.

  The returned header is suitable for to svn.diff.file_output_unified3 and
  similar functions.

  Arguments:
  path                          -- base-relative path
  base_revision                 -- what the caller thinks the base revision
                                   of path is
  repo_state                    -- State object
  copied_directory_stack        -- list of copied directories
                                   (see DiffBaseToSnapshot)
  """
  if len(copied_directory_stack) > 0:
    # Some parent directory was copied; find left side in there.
    (copied_dir, copyfrom_path, copyfrom_revision) = copied_directory_stack[-1]
    path_in_copied_dir = path[len(copied_dir) + 1:]
    left_path = '/'.join([copyfrom_path, path_in_copied_dir])
    left_revision = copyfrom_revision
  else:
    # Not under copied directory; use same path for left side.
    left_path = '/'.join([repo_state.base_path, path])
    left_revision = base_revision
  # Now make the header.
  if repo_state.paths[path].action in _ADD_CODES:
    left_header = path + '\t(added)'
  else:
    left_header = ('%s\t(^/%s@%d)'
                   % (left_path[len(repo_state.base_path) + 1:],
                      left_path, left_revision))
  return (left_path, left_revision, left_header)


def _RaGetDirOrFile(ra, path, revision, fp, dirent_fields, pool,
                    kind=svn_node_unknown):
  """Call get_file or get_dir for DiffBaseToSnapshot.

  This is for old-style changebranches, where we don't know whether path
  is a directory or file.  Arguments are a combination of svn.ra.get_file
  and svn.ra.get_dir2 arguments, plus the optional kind, which we know
  with new-style changebranches.
  """
  if kind == svn_node_file:
    result = svn.ra.get_file(ra, path, revision, fp, pool)
    return (kind, result)

  if kind == svn_node_dir:
    result = svn.ra.get_dir2(ra, path, revision, dirent_fields, pool)
    return (kind, result)

  gvn.DiagLog('_RaGetDirOrFile(%s@%d) => try get_file => ', path, revision)
  try:
    result = svn.ra.get_file(ra, path, revision, fp, pool)
    kind = svn_node_file
    gvn.DiagLog('is file')
  except svn.core.SubversionException, e:
    if e.apr_err not in [svn.core.SVN_ERR_FS_NOT_FILE,
                         # ra-neon screws us again; don't even ask
                         # about serf, which just wrote some HTML 301
                         # foo into fp!  see svn issue 3206
                         svn.core.SVN_ERR_RA_DAV_RELOCATED]:
      raise
    gvn.DiagLog('get_dir2 => ')
    result = svn.ra.get_dir2(ra, path, revision, dirent_fields, pool)
    kind = svn_node_dir
    gvn.DiagLog('is dir')
  gvn.DiagLog('\n')
  return (kind, result)


def DiffBaseToSnapshot(cb, callbacks, encoding, pool):
  """Diff the base of a snapshot to the snapshot itself.

  This is 'gvn review'; it shows the change being proposed.

  Arguments:
  cb            -- ChangeBranch object
  callbacks     -- DiffCallbacks implementation
  encoding      -- user's encoding
  pool          -- memory pool

  Returns:
  the return value of callbacks.Finish
  """
  copied_directory_stack = []
  tree = gvn.util.TmpTree()
  try:
    try:
      change_state = cb.GetRepoState(pool)
      callbacks.SetChangeState(cb, change_state)
      iterpool = svn.core.Pool(pool)
      for (path, state) in sorted(change_state.paths.iteritems(),
                                  key=lambda x: x[0]):
        iterpool.clear()
        # See if we just came out from under a copied directory.
        if len(copied_directory_stack) > 0:
          last_copied_dir = copied_directory_stack[-1][0]
          if not gvn.util.IsChild(path, last_copied_dir):
            # Yep, so pop it off the stack.
            copied_directory_stack.pop()

        kind = state.kind
        local_path = svn_path_local_style(path, iterpool).decode('utf8')
        local_path_encoded = local_path.encode(encoding)

        # Get left path/revision/header now, as we need them in a few
        # different blocks below.
        (left_path, left_revision, left_header) = _FindLeft(
          path, state.base_revision, change_state, copied_directory_stack)

        # This is more complicated than it could be in order to support
        # old-style changebranches (no repo state file), where we don't
        # know what kind of path we have.

        #################################################################
        # left side

        if kind != svn_node_dir:
          # Create tmp file, possibly incorrectly for old-style.
          fp = tree.MkFile(['left', local_path_encoded])
        else:
          fp = None

        if state.action in _ADD_CODES:
          if state.copyfrom_path is None:
            # This is an added dir or file, so no left-side properties.
            properties = {}
            if kind == svn_node_file and state.action == 'R':
              # This is a Replaced file that isn't copied; svn diffs
              # these as Modified files, so let's do the same.
              # TODO(next-release): Note that for old-style changebranches
              # we don't yet know kind, so we never get here.  That's OK,
              # this can be a teensy bit broken until we kick the old
              # style to the curb.  Don't forget to adjust testDiff in
              # test_changebranch.py
              svn.ra.get_file(cb.project.repository.ra,
                              left_path, left_revision,
                              fp, iterpool)
          else:
            # This is a copied dir or file, so get properties of copyfrom
            # for the left side.
            (kind, result) = _RaGetDirOrFile(cb.project.repository.ra,
                                             state.copyfrom_path.encode('utf8'),
                                             state.copyfrom_revision,
                                             fp, dirent_fields=0, kind=kind,
                                             pool=iterpool)
            # The properties come last in the result for both dir and file.
            properties = result[-1]
            # And push it onto the stack.
            copied_directory_stack.append((path, state.copyfrom_path,
                                           state.copyfrom_revision))

        else:
          # Modified or Deleted
          # TODO: Don't fetch if no_diff_deleted.
          (kind, result) = _RaGetDirOrFile(cb.project.repository.ra,
                                           left_path, left_revision,
                                           fp, dirent_fields=0, kind=kind,
                                           pool=iterpool)
          if kind == svn_node_file:
            (unused_rev, properties) = result
          else:
            (unused_dirents, unused_rev, properties) = result
        # Note whether we made a left tmp file; further down, we'll
        # delete bogus left and right files for directories in
        # old-style changebranches.
        if fp is None:
          made_left = False
        else:
          made_left = True
          fp.close()
        left_properties = FilterRegularProps(properties)

        #################################################################
        # right side

        # You might think we definitely know the kind of this path by now
        # even in the old style, but if this is an Add, we didn't do
        # anything for the left side, so we still don't know.

        branch_path = cb.BranchPath(path)
        if kind != svn_node_dir:
          # Create tmp file, possibly incorrectly for old-style.
          fp = tree.MkFile(['right', local_path_encoded])
        else:
          fp = None
        if state.action == 'D':
          properties = {}
        else:
          # Added or Modified
          branch_path_utf8 = branch_path.encode('utf8')
          (kind, result) = _RaGetDirOrFile(cb.project.repository.ra,
                                           branch_path_utf8, state.snap_revision,
                                           fp, dirent_fields=0, kind=kind,
                                           pool=iterpool)
          if kind == svn_node_file:
            (unused_rev, properties) = result
          else:
            (unused_dirents, unused_rev, properties) = result
        # Note whether we made a bogus tmp file; further down, we'll
        # delete bogus left and right files for directories in
        # old-style changebranches.
        if fp is None:
          made_right = False
        else:
          made_right = True
          fp.close()
        right_properties = FilterRegularProps(properties)

        # And here it is: if this was a directory, delete any files we
        # created incorrectly.
        if kind == svn_node_dir:
          if made_left:
            tree.RmFile(['left', local_path_encoded])
          if made_right:
            tree.RmFile(['right', local_path_encoded])

        #################################################################
        # Now diff the left and right sides.

        right_header = ('%s\t(^/%s@%d)'
                        % (path, branch_path,
                           state.snap_revision))
        if kind == svn_node_file:
          callbacks.File(path,
                         tree.Path(['left', local_path_encoded]),
                         tree.Path(['right', local_path_encoded]),
                         left_properties, right_properties,
                         left_header, right_header,
                         iterpool)
        else:
          callbacks.Directory(path,
                              left_properties, right_properties,
                              left_header, right_header, iterpool)
      iterpool.destroy()
    except:
      callbacks.Abort(pool)
      raise
    else:
      return callbacks.Finish(pool)
  finally:
    tree.Close()


def DiffSnapshotToWC(cb, wc, callbacks, encoding, pool):
  """Diff a snapshot to the working copy.

  This is used to show what the user has changed since last snapshot.

  Arguments:
  cb            -- ChangeBranch object
  callbacks     -- DiffCallbacks implementation
  encoding      -- user's encoding
  pool          -- memory pool

  Returns:
  the return value of callbacks.Finish
  """
  # TODO(next-release): This is easier in upcoming .gvnstate format.
  paths = dict((path, state) for (path, state) in wc.change_state.iteritems()
               if state.change_name == cb.name)
  wc.Open(paths)
  # TODO(next-release): Remove; this is only here to support old-style
  # changebranches; we need it to find the branch name (for BranchPath),
  # and we need the repo path state later on (since we won't have the snap
  # revision until the next release).
  change_state = cb.GetRepoState(pool)
  tree = gvn.util.TmpTree()
  try:
    try:
      # Shouldn't status callback receive a pool, like most callbacks?
      # Fine, we'll handle it ourselves.
      status_pool = svn.core.Pool(pool)
      def status_cb(target, status):
        status_pool.clear()
        path = wc.RelativePath(target)
        if not wc.NeedsSnapshot(path, status, status_pool):
          return

        branch_path = cb.BranchPath(path)
        branch_path_utf8 = branch_path.encode('utf8')
        # TODO(next-release): Get from wc state instead.
        snap_revision = change_state.paths[path].snap_revision

        left_header = ('%s\t(^/%s@%d)' % (path, branch_path,
                                          snap_revision))
        right_header = path + '\t(working copy)'

        if status.entry.kind == svn_node_dir:
          (unused_dirents, unused_rev,
           properties) = svn.ra.get_dir2(cb.project.repository.ra,
                                         branch_path_utf8,
                                         snap_revision,
                                         0, # dirent_fields
                                         status_pool)
          properties = FilterRegularProps(properties)
          (local_prop_diffs, local_props) = wc.GetPropDiffs(target, status_pool)
          gvn.util.ApplyPropDiffs(local_props, local_prop_diffs)
          callbacks.Directory(path, properties, local_props,
                              left_header, right_header, status_pool)
        else:
          local_path = svn_path_local_style(path, status_pool).decode('utf8')
          local_path_encoded = local_path.encode(encoding)

          fp = tree.MkFile(['left', local_path_encoded])
          (unused_rev, properties) = svn.ra.get_file(
            cb.project.repository.ra, branch_path_utf8,
            snap_revision, fp, status_pool)
          fp.close()
          properties = FilterRegularProps(properties)
          right_path = svn.wc.translated_file2(target.encode('utf8'),
                                               target.encode('utf8'),
                                               wc.AdmRetrieve(target,
                                                              status_pool),
                                               svn.wc.TRANSLATE_FROM_NF,
                                               pool)
          (local_prop_diffs, local_props) = wc.GetPropDiffs(target, status_pool)
          gvn.util.ApplyPropDiffs(local_props, local_prop_diffs)
          callbacks.File(path,
                         tree.Path(['left', local_path_encoded]), right_path,
                         properties, local_props,
                         left_header, right_header,
                         status_pool)
      wc.Status(paths.keys(),
                recursive=False, get_all=False, no_ignore=False,
                show_children=False, callback=status_cb)
      status_pool.destroy()
      wc.Close()
    except:
      callbacks.Abort(pool)
      raise
    else:
      return callbacks.Finish(pool)
  finally:
    tree.Close()


def DiffSnapshots():
  pass
  # Similar to DiffFromChange; the only way we can do this is by
  # fetching every file and comparing them.  In the common case, a
  # URL-URL diff would work, but when it doesn't, there's nothing we
  # can do in the report that will give us the behavior we need.

  # The way it would work in the common case is say:
  #    want diff between branch@20 -> branch@30
  #    report change state, telling it *what versions of branch@20 we have*
  # receive deltas telling us how to turn that into branch@30

  # That's no good:

  # r20
  # A /changes/epg/foo/branch from trunk@17
  # M /changes/epg/foo/branch/a
  # R /changes/epg/foo/branch/b from trunk@19
  # =>
  # epg/foo@20
  # M a
  # M b

  # r30
  # R /changes/epg/foo/branch from trunk@28
  # M /changes/epg/foo/branch/a
  # M /changes/epg/foo/branch/b
  # =>
  # epg/foo@30
  # M a
  # M b

  # But there are files other than a and b!  And they changed between
  # 17 and 28.  So, for example 'c': we'll receive a delta turning
  # trunk/c@17 into trunk/c@28 which is no good at all.  In large
  # trees, we could receive quite a lot of crap we don't want.
