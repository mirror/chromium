{
  "comments": [
    {
      "key": {
        "uuid": "62b56930_e43e0df1",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 1116024
      },
      "writtenOn": "2017-12-05T17:28:57Z",
      "side": 1,
      "message": "Nit: Need a comment on why 8192.  And I think the coding style prefers whole words so maybe \"max_webaudio_buffer_size\" instead.",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79823455_82af979c",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 1212154
      },
      "writtenOn": "2017-12-05T22:28:14Z",
      "side": 1,
      "message": "Oops, I had meant to add a comment here saying that maybe this value should even be passed into CreateAudioDevice() from AudioDestination since it could be kFIFOSize - kRenderQuantumFrames. I took 8192 pretty arbitrarily since it\u0027s less than that value (right now) and \u003e\u003d the largest platform-specific audio buffer size. Otherwise I can just add a comment for now, WDYT?",
      "parentUuid": "62b56930_e43e0df1",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e3f28aab_51afcd9a",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 1116024
      },
      "writtenOn": "2017-12-06T22:54:10Z",
      "side": 1,
      "message": "I think this comment from my abandoned CL explains the choice pretty well. At least for Android:\n\n  // UMA stats show that hardware buffer sizes range from a low of 96\n  // up to 87,360(!).  Set the minimum to 128, and a max of 8192.\n  // (The stats say 8192 includes 99.1% of all devices, as of\n  // 2017/11/29.)",
      "parentUuid": "79823455_82af979c",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8cdf9d21_74f87caa",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 1212154
      },
      "writtenOn": "2017-12-07T09:29:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e3f28aab_51afcd9a",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ab8ed50_fdcbae86",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1116024
      },
      "writtenOn": "2017-12-05T17:28:57Z",
      "side": 1,
      "message": "Although the original version did rounding, I wonder if ceiling might be more appropriate?  With rounding, you might end up with a latency less than specified. It seems to me that a lower latency than asked for is not a good idea.\n\nWDYT?",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "92e954e7_ad1bbb3b",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1212154
      },
      "writtenOn": "2017-12-05T22:28:14Z",
      "side": 1,
      "message": "The buffer size should be clamped to the output_buffer_size on the line below in any case but I\u0027m fine with using ceiling if you think that makes more sense here.",
      "parentUuid": "0ab8ed50_fdcbae86",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f768cab_246025b9",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1116024
      },
      "writtenOn": "2017-12-06T22:54:10Z",
      "side": 1,
      "message": "Chatted with Hongchan offline.  If the user requests latency x, we should provide a value greater than or equal to x, but clamped to some maximum of course.  Thus, if output_buffer_size is 240 (like on some Android devices), and the requested size is 300 (sample rate * hint), we would currently get rounded_buffer_size \u003d 240, which becomes the final size.  This is lower than requested.  If we take the ceiling, the rounded size is 480, so the latency is higher than requested.  But probably better in terms of glitching and power consumption. (Not so good for latency, but you\u0027re supposed to know what you\u0027re doing when you set a numeric latency value.)",
      "parentUuid": "92e954e7_ad1bbb3b",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5618ff7f_84e63689",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1212154
      },
      "writtenOn": "2017-12-07T09:29:17Z",
      "side": 1,
      "message": "That makes sense to me, though if we change it here to use ceiling we should probably also do the same in AudioLatency::GetExactBufferSize, otherwise it will cause strange behavior like this:\n\na \u003d new AudioContext({\u0027latencyHint\u0027: 3950/44100})\na.baseLatency*a.sampleRate (-\u003e 7680)\n\na \u003d new AudioContext({\u0027latencyHint\u0027: 4095/44100})\na.baseLatency*a.sampleRate (-\u003e 4096)\n\nThe first one is because 3950 is requested from the hardware, which uses rounding and sets the buffer size to 3840, then this new function uses ceiling and since 3840 \u003c 3950 it forces it up to the next multiple of the current hardware buffer size of 3840, so 7680.\n\nJust wanted to make sure that you mean for me to update it in AudioLatency as well. Thanks!",
      "parentUuid": "8f768cab_246025b9",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f816f740_14ed249b",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1116024
      },
      "writtenOn": "2017-12-07T15:58:28Z",
      "side": 1,
      "message": "Yeah, this is really complicated.  Since webaudio works on 128 frames chunks, ideally, we want requested size to be a multiple of that.  But if the HW calls back with sizes that aren\u0027t a multiple of 128, it gets complicated.  Let\u0027s say the HW size is 129 samples.  To satisfy the first request, we need to render twice, just to get 129 samples.  The CPU load is way higher than it needs to be because we basically do the work of two renders in the time allowed for one. And this lasts for a long time.\n\nMaybe this is ok for your example.  The HW size is already so large that there\u0027s no real expectation of low latency audio, so producing an even larger latency, while not great, isn\u0027t really horrible.\n\nSo, let\u0027s round up, and see what happens and watch the bug reports. (My guess is the latency hint is not used very often.  Hmm.  Need to check if we have stats for that....)",
      "parentUuid": "5618ff7f_84e63689",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04b0524f_0de7b0b8",
        "filename": "content/renderer/media/renderer_webaudiodevice_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1212154
      },
      "writtenOn": "2017-12-07T21:42:43Z",
      "side": 1,
      "message": "Ok sounds good! I\u0027ve modified both the calculation in this GetPreferredWebAudioBufferSize() function as well as in AudioLatency::GetExactBufferSize() to use ceil() rather than round(). While updating GetExactBufferSize() I also noticed that it was incorrectly using hardware_buffer_size rather than minimum_buffer_size, this was only working because round() was rounding to 0 and being clamped to the minimum_buffer_size.",
      "parentUuid": "f816f740_14ed249b",
      "revId": "48125d6a63af7223f5f8062ea4ae25e042c39be3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}