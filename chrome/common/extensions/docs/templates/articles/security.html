<h1>Stay Secure</h1>
<p>

  Extensions have access to special privileges within the browser,
  making them an appealing target to to attackers.
  Every user of a compromised extension is vulnerable to malicious
  and unwanted intrusion.
</p>
<p>
  Include these practices to keep an extension secure and protect users.
</p>
<h2 id="content_scripts">Use Content Scripts Carefully</h2>
<p>
  While <a href="/content_scripts">content scripts</a> live in an
  <a href="/content_scripts#execution-environment">isolated world</a>,
  they are not immune from attacks.
  Because content scripts are the only part of the extension that
  interacts with the webpage directly,
  hostile webpages will often exploit parts of the DOM the content script
  depends on.
  Sensitive work should, ideally, be performed in a dedicated process.
</p>
<h2 id="sanitize">Register and Sanitize Inputs</h2>
<p>
  Safeguard an extension from malicious scripts by
  limiting listeners to only what the extension is expecting,
  validating the senders of incomming data,
  and sanitizing all inputs.
</p>
<p>
  An extension should only register for
  <a href="/runtime#event-onMessageExternal"><code>
    runtime.onRequestExternal</code></a>,
  if it is expecting communication from an external website or extension.
  Always validate that the sender matches a trusted source.
</p>
<pre data-filename="background.js">
  // The ID of an external extension
  const kFriendlyExtensionId = "iamafriendlyextensionhereisdatas";

  chrome.runtime.onMessageExternal.addListener(
    function(request, sender, sendResponse) {
      if (sender.id == kFriendlyExtensionId)
        doSomething();
  });
</pre>
<p>
  Even messages via <a href="/runtime#event-onMessage">runtime.onMessage</a>
  event from the extension itself should be scrutinized to ensure
  the <a href="/runtime#type-MessageSender">MessageSender</a>
  is not from a compromised <a href="/content_scripts">content script</a>.
</p>
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    if (sender.id === chrome.runtime.id)
      console.log("this message is from myself.")
  });
</pre>
<p>
  Prevent an extension from excuting an attackers script by
  sanitizing user inputs and incomming data,
  even from the extension itself and approved sources.
  <a href="/security#avoid">Avoid executable APIs</a>.
</p>
<pre>
  function sanitizeInput(input) {
      return input.replace(/&/g, '&ampamp;').replace(/&lt;/g, '&amplt;').replace(/"/g, '&ampquot;');
  }
</pre>

<h2 id="https">Never use HTTP, Ever</h2>
<p>
  When requesting or sending data, avoid an HTTP connection.
  Assume that any HTTP connections will have eavesdroppers
  or contain modifications.
  HTTPS should always be prefered, as it has built-in security
  circumventing most
  <a href="https://www.owasp.org/index.php/Man-in-the-middle_attack">
    man-in-the-middle attacks</a>.
</p>

<h2 id="permissions">Request Minimal Permissions</h2>
<p>
  The Chrome browser limits an extension's access to privileges
  that have been explicitly requested in the <a href="/manifest">manifest</a>.
  Extensions should minimize their permissions
  by only registering APIs and websites they depend on.
  Arbitrary code should be kept to a minimum.
</p>
<p>
  Limiting an extensions privileges limits what a potential attacker can exploit.
</p>
<h3 id="xhr">Cross-Origin XMLHttpRequest</h3>
<p>
  An extension can only use <a href="/xhr">XMLHttpRequest</a>
  to get resources from iteself and
  from domains specified in the permissions.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Very Secure Extension",
    "version": "1.0",
    "description": "Example of a Secure Extension",
    <b>"permissions": [
      "https://developer.chrome.com/*",
      "https://*.google.com/"
    ],</b>
    "manifest_version": 2
  }
</pre>
<p>
  This extension requests access to anything on developer.chrome and
  subdomains of Google by listing <code>"https://developer.chrome.com/*"</code>
  and <code>"https://*google.com/"</code> in the permissions.
  If the extension were compromised,
  it would still only have permission to interact with
  websites that meet the <a href="/match_patterns">match pattern</a>.
  The attacker would not be able to access
  <code>"https://user_bank_info.com"</code> or
  interact with <code>"https://malicious_website.com"</code>.
</p>

<h2 id="avoid">Avoid Executable APIs</h2>
<p>
  API's that execute code should be replaced with safer alternatives.
</p>
<h3 id="document_write">document.write() and innerHTML</h3>
<p>
  While simpler to dynamically create HTML elements with
  <code>document.write()</code> and <code>innerHTML</code>,
  it leaves the extension, and webpages the extension depends on,
  open to attackers inserting malicious scripts.
  Instead, manually create DOM nodes
  and use <code>innerText</code> to insert dynamic content.
</p>
<pre data-filename="background.js">
  function constructDOM() {
    let newTitle = document.createElement('h1');
    newTitle.innerText = host;
    document.appendChild(newTitle);
  }
</pre>
<h3 id="eval">eval()</h3>
<p>
  Avoid using <code>eval()</code> whenever possible to prevent attacks,
  as <code>eval()</code> will execute any code passed into it,
  which may be malicious.
</p>
<pre data-filename="background.js">
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "http://api.example.com/data.json", true);
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
      // WARNING! Might be evaluating an evil script!
      var resp = eval("(" + xhr.responseText + ")");
      ...
    }
  }
  xhr.send();
</pre>
<p>
  Instead, prefer safer, and faster, methods such as
  <code>JSON.parse()</code>
</p>
<pre data-filename="background.js">
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://api.example.com/data.json", true);
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
      // JSON.parse does not evaluate the attacker's scripts.
      var resp = JSON.parse(xhr.responseText);
    }
  }
  xhr.send();
</pre>


<h2 id="manifest_fields">Limit Manifest Fields</h2>
<p>
  Including unecessary registrations in the manifest creates vulnrabilities
  and makes an extension more visable.
  Limit manifest fields to those the extension relies on
  and give specific field registration.
</p>
<h3 id="externally_connectable">Externally Connectable</h3>
<p>
  Use the <a href="/manifest/externally_connectable">
    <code>externally_connectable</code></a>
  field to declare which external extensions and webpages
  the extension will exchange information with.
  Restrict who the extension can externally connect with to trusted sources.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Super Safe Extension",
    "externally_connectable": {
      "ids": [
        "iamafriendlyextensionhereisdatas"
      ],
      "matches": [
      "https://developer.chrome.com/*",
      "https://*google.com/"
      ],
      "accepts_tls_channel_id": false
    },
    ...
  }
</pre>
<h3 id="web_accessible_resources">Web Accessible Resources</h3>
<p>
  Making resources accessible by the web, under the
  <a href="/manifest/web_accessible_resources">
    <code>web_accessible_resources</code></a>
  will make an extension detectable by websites and attackers.


</p>
<pre data-filename="manifest.json">
  {
  ...
  "web_accessible_resources": [
    "images/*.png",
    "style/secure_extension.css",
    "script/secure_extension.js"
  ],
  ...
}
</pre>
<p>
  The more web accessible resources available,
  the move avenues a potential attacker can exploit.
  Keep these files to a minimum.
</p>
<h2 id="content_security_policy">
  Include an Explicit Content Security Policy
</h2>
<p>
  Include a <a href="/contentSecurityPolicy">content security policy</a>
  for the extension in the manifest to prevent cross-site scripting attacks.
  If the extension only loads resources from itself register the following:
</p>
<pre data-filename="manifest.json">
  {
    "name": "Very Secure Extension",
    "version": "1.0",
    "description": "Example of a Secure Extension",
    <b>"content_security_policy": "default-src 'self'"</b>
    "manifest_version": 2
  }
</pre>
<p>
	If the extension needs to include scripts from specific hosts,
  they can be included:
</p>
<pre data-filename="manifest.json">
  {
    "name": "Very Secure Extension",
    "version": "1.0",
    "description": "Example of a Secure Extension",
    "content_security_policy": "default-src 'self' <b>https://extension.resource.com</b>"
    "manifest_version": 2
  }
</pre>

<h2 id="bundle">Package Resources</h2>
<p>
  Include as many resources as possible in the extension bundle,
  such as the min file of a library.
</p>
<pre data-file="popup.html">
  &lt;script src="resouces/javascript_library.min.js"&gt;&lt;script&gt;
</pre>
<p>
    This will eliminate the need to make requests outside the extension.
</p>
<pre data-filename="popup.html">
  &lt;script src="https://javascript.library.for.this.extension.min.js"&gt;&lt;/script&gt;
</pre>
<p>
  If an extension must fetch a remote script,
  always use HTTPS over HTTP and
  include the appropriate permissions.
</p>
<h2 id="group_publishing">Keep Groups Selective</h2>
<p>
  If using <a href="/publish#set-up-group-publishing">group publishing</a>,
  keep the group confined to trusted developers.
  Do not accept membership requests from unknown persons.
</p>
<h2 id="clear_commented_code">Write Clear and Commented Code</h2>
<p>
  Refrain from using unnecessary obfuscation or minification in code.
  It should be comprehensible enough to decipher basic processes.
  Include comments to explain functionality.
</p>
