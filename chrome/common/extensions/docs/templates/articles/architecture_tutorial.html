<h1>Extension Architecture</h1>

<p>
  Extension architecture is built upon its componenets,
  which can include background scripts, content scripts, an options page,
  UI elements and various logic files.
  An extension's architecture components will depend on its functionality
  and may not include every type.
</p>
<p>
  This tutorial will build an extension that demonstrates
  architecture by allowing the user change the background color of any page
  on <a href="https://developer.chrome.com/">https://developer.chrome.com/</a>.
  To start, create a new directory or download the files
  <a href="examples/tutorials/architecture_example/"
  download="architecture_example.zip">here</a>.
</p>

<h2 id="manifest">Manifest</h2>
<p>
  Extensions start with their <a href="/manifest">manifest</a>,
  housed within a manifest.json file:
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    "manifest_version": 2
  }
</pre>
<p>
  The directory holding the manifest file
  can be added as an extension in developer mode in its current state.
  Click on the Chrome menu and
  hover over "More Tools" then selected "Extensions",
  or navigate in the ominibox to
  <a href="chrome://extensions/">chrome://extensions/</a>.
  Check the box next to "Developer mode",
  then click the "Load unpacked extension..." button
  and select the directory the manifest file is stored in.
</p>
<img src="{{static}}/images/architecture_tutorial/load_extension.png"
  height="200"
  alt="Load Extension" />
<p>
  Ta-da!
  The extension has been successfuly installed.
  Because no icons were included in the manifest,
  a generic toolbar icon will be created for the extension.
</p>
<h2 id="background">Background Script</h2>
<p>
  Although the extension has been installed,
  it has no instruction.
  Add a <a href="/background_page.html">background script</a>
  by including a file titled <code>background.js</code>
  in the extension directory.
  Register the background script in the manifest so that the extension
  understands it is an active component and knows which file to refer to:
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    <b>"background": {
      "scripts": ["background.js"],
      "persistent": false
    },</b>
    "manifest_version": 2
  }
</pre>
<p>
  This extension will need information from a persistent variable.
  Setting a value in <a href="/storage">storage</a> under the
  <a href="/runtime#event-onInstalled"><code>runtime.onInstalled</code></a>
  listener event in the background script will give multiple components
  access to it.
</p>

<pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function() {
    chrome.storage.sync.set({color: "#3aa757"}, function(){
      console.log("The color is green.")
    })
  });
</pre>

<p>
  The <a href="/storage">storage</a> API must be
  registered under the <code>"permissions"</code> field in the manifest
  for the extension to call
  <a href="/storage#property-sync"><code>storage.sync</code></a>.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    <b>"permissions": ["storage"],</b>
    "background": {
      "scripts": ["background.js"],
      "persistent": false
    },
    "manifest_version": 2
  }
</pre>
<p>
  Navigate back to the extension management page and click the "Reload" link.
  A new field "Inspect views" becomes available
  with a blue link "background page".
</p>
<img src="{{static}}/images/architecture_tutorial/view_background.png"
  height="200"
  alt="Inspect Views" />
<p>
  Click the link to view the background scripts console log,
  "<code>The color is green.</code>"

<h2 id="user_interface">User Interface</h2>
<p>
  Extensions can have many forms of a
  <a href="/user_interface">user interface</a>,
  but this one will use a
  <a href="/user_interface#popup">popup</a>.
  Add a file titled <code>popup.html</code> to the directory.
  This extension uses two buttons,
  one to change the background color and a second to reset it:
</p>
<pre data-filename="popup.html">
  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;style&gt;
        button {
          height: 30px;
          width: 30px;
          outline: none;
        }
      &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
      <b>&lt;button id="displayNew"&gt;&lt;/button&gt;
      &lt;br&gt;
      &lt;button id="displayDefault"&gt;X&lt;/button&gt;</b>
      &lt;script src="popup.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</pre>
<p>
  The file needs to be designated as a popup in the manifest under
  <a href="/pageAction"><code>page_action</code></a>.
  This is also where the toolbar icons are declared.
  Download the images folder
  <a href="examples/tutorials/architecture_example/"
  download="architecture_icons.zip">
  here</a> and place it in the extensions directory.
  Register images under the
  <a href="/user_interface#icons"><code>icons</code></a> feild to display them
  on the extensions management page,
  permission warnings,
  and favicon.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    "permissions": ["storage"],
    "background": {
      "scripts": ["background.js"],
      "persistent": false
    },
    <b>"page_action": {
      "default_popup": "popup.html",
      "default_icon": {
        "16": "images/extension_architecture16.png",
        "32": "images/extension_architecture32.png",
        "48": "images/extension_architecture48.png",
        "128": "images/extension_architecture128.png"
      }
    },
    "icons": {
      "16": "images/extension_architecture16.png",
      "32": "images/extension_architecture32.png",
      "48": "images/extension_architecture48.png",
      "128": "images/extension_architecture128.png"
    },</b>
    "manifest_version": 2
  }
</pre>
<p>
  If the extension is reloaded at this stage, it will function the same.
  Because <code>page_action</code> is declared in the manifest,
  it is up to the extension to tell the browser when the user can interact
  with <code>popup.html</code>.
  This extension declares rules using the
  <a href="/declarativeContent"><code>declarativeContent</code></a>
  API within the
  <code>runtime.onInstalled</code> listener event in the background script,
</p>
<pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function() {
    chrome.storage.sync.set({color: "#3aa757"}, function(){
      console.log("The color is green.")
    });
    <b>chrome.declarativeContent.onPageChanged.removeRules(undefined, function() {
      chrome.declarativeContent.onPageChanged.addRules([
        {
          conditions: [
            new chrome.declarativeContent.PageStateMatcher({
              pageUrl: { hostEquals: 'developer.chrome.com' },
            })
          ],
          actions: [ new chrome.declarativeContent.ShowPageAction() ]
        }
      ]);
    });</b>
  });
</pre>
<p>
  The extension will need permission to access the
  <a href="/declarativeContent"><code>declarativeContent</code></a> API
  in its manifest.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
  ...
    "permissions": [<b>"declarativeContent"</b>, "storage"],
  ...
  }
</pre>
<img src="{{static}}/images/architecture_tutorial/popup_grey.png"
  align="right"
  style="margin-left:3px; margin-right:3px"
  alt="Popup" />
<p>
  The browser will now show a full-color page action icon in the browser
  toolbar when users navigate to a URL that contains
  <code>"developer.chrome.com"</code>.
  When the icon is full-color, users can click it to view popup.html.
</p>


<h3 id="functionality">Functionality</h3>
<p>
  Now that a popup is registered and clickable, functionality can be added.
  Start by creating a file called <code>popup.js</code>
  in the extension directory and adding the following code,
</p>
<pre data-filename="popup.js">
  let displayNew = document.getElementById('displayNew');
  chrome.storage.sync.get('color', function(data) {
    displayNew.style.backgroundColor = data.color;
    displayNew.setAttribute('value', data.color);
  })

  displayNew.onclick = function(element) {
    let color = element.target.value;
    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
      chrome.tabs.sendMessage(tabs[0].id, {color: color}, function(response) {
        console.log(response.done);
      });
    });
  }

  let displayDefault = document.getElementById('displayDefault');
  displayDefault.onclick = function(element) {
    chrome.storage.sync.get('pageColor', function(data) {
      chrome.tabs.query({active: true,
        currentWindow: true}, function(tabs) {
          chrome.tabs.sendMessage(tabs[0].id, {color: data.pageColor},
          function(response) {
            console.log(response.done);
        });
      })
    });
  }
</pre>
<p>
  The first block grabs the top button from
  <code>popup.html</code>, then requests the color value from storage.
  The color value is applied as the background of the button.
  Reload the extension and the button will now be green.
  Inspect the popup window and keep it open to view the logs.
</p>
<p>
  The last two blocks add click event listeners to the buttons.
  The first sends a <a href="/messaging">message</a>
  containing the color value of the button.
</p>
<p>
  The manifest will need the <a href="activeTab"><code>activeTab</code></a>
  permission to allow the extension temporary access to the
  <a href="/tabs"><code>tabs</code></a> API.
  This enables the extension to call
  <a href="/tabs#method-sendMessage"><code>tabs.sendMessage</code></a>.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
  ...
    "permissions": [<b>"activeTab"</b>, "declarativeContent", "storage"],
  ...
  }
</pre>
<p>
  The second button requests a value from storage,
  but this value does not exsist yet.
  The "pageColor" value is dependent on the
  <a href="/content_script">content script</a>
  as it is the only component of an extension that can read directly
  from the DOM of an active webpage.
</p>

<h2 id="content_script">Content Script</h2>
<p>
  Create a file called <code>content_script.js</code>
  and include it in the extension directory with the following code:
</p>
<pre data-filename="content_script.js">
  function findBackgroundColor() {
    let backgroundColor = document.head.style.backgroundColor
    console.log("Background color is " + backgroundColor);
    chrome.storage.sync.set({pageColor: backgroundColor});
  };

  findBackgroundColor();

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    document.body.style.backgroundColor = request.color;
    console.log("Changing background color to " + request.color);
    sendResponse({done: "background color is " + request.color});
  });
</pre>
<p>
  The content script finds the background color of the page and
  saves it in global storage,
  making it accessiable by <code>popup.js</code>.
  The content script also has a message listener,
  which catches the color sent from <code>popup.js</code>.
  It then executes a
  <a href="/content_script#programatic">programatic injection</a>
  that turns the page background to match the color -
  either the new color or reseting it,
  depending on the button clicked.
  Content script console logs can be viewed by inspecting the webpage.
</p>
<p>
  Where the content script runs is determined by
  <a href="/match_patterns">match patterns</a>.
  Because the extension should only be availabe for
  <a href="https://developer.chrome.com/">https://developer.chrome.com/</a>,
  the matches are limited when registering the content script in the manifest.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    "permissions": ["activeTab", "declarativeContent", "storage"],
    "page_action": {
      "default_popup": "popup.html"
    },
    "background": {
      "scripts": ["background.js"],
      "persistent": false
    },
    <b>"content_scripts": [
     {
       "matches": ["https://developer.chrome.com/*"],
       "js": ["content_script.js"]
     }
   ],</b>
    "manifest_version": 2
  }
</pre>
<p>
  The extension is now fully functional!
  Reload it and refresh this page to turn it green.
  However, some users may want to change the background to a different color.
</p>
<h2 id="options">Options</h2>
<p>
  The extension only allows users to change the background to green,
  but by intergrating an options page users can have more
  control over the extension functionality.
  Create a file in the directory called <code>options.html</code>
  and include the following code,
</p>
<pre data-filename="options.html">
  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;style&gt;
        button {
          height: 30px;
          width: 30px;
          outline: none;
          margin: 10px;
        }
      &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;div id="buttonDiv"&gt;
      &lt;/div&gt;
    &lt;/body&gt;
    &lt;script src="options.js"&gt;&lt;/script&gt;
  &lt;/html&gt;
</pre>
<p>
  Then register the options page in the manifest,
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    <b>"options_page": "options.html",</b>
    "permissions": ["activeTab", "storage", "declarativeContent"],
    "page_action": {
      "default_popup": "popup.html"
    },
    "background": {
      "scripts": ["background.js"],
      "persistent": false
    },
    "content_scripts": [
     {
       "matches": ["https://developer.chrome.com/*"],
       "js": ["content_script.js"],
       "run_at": "document_start"
     }
   ],
    "manifest_version": 2
  }
</pre>
<p>
  Reload the extension then select the new options link to view the page,
  although it will be blank.
</p>
<img src="{{static}}/images/architecture_tutorial/options.png"
  height="200"
  alt="Inspect Views" />
<p>
 Last step is to add the options logic.
 Create a file called <code>options.js</code> in the extension directory
 with the following code,
</p>
<pre data-filename="options.js">
  const kButtonColors = ['#3aa757', '#e8453c', '#f9bb2d', '#4688f1']
  function constructOptions(kButtonColors) {
    let page = document.getElementById('buttonDiv');
    for (let item of kButtonColors) {
     let button = document.createElement('button');
     button.style.backgroundColor = item;
     button.setAttribute('id', item);
     button.addEventListener('click', function() {
        console.log(button.id)
        chrome.storage.sync.set({color: button.id}, function(){
          console.log("color is " + button.id)
        })
     });
     page.appendChild(button)
    }
  }
  constructOptions(kButtonColors)
</pre>
<p>
  Four color options are provided then generated as buttons on
  the options page with onclick event listeners.
  When the user clicks a button,
  it updates the color value in the extension's global storage.
  Since all the extension pulls the color information from global storage
  no other values need to be updated.
</p>
