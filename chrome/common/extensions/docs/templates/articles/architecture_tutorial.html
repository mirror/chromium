<h1>Extension Architecture</h1>

<p>
  Extension architecture is built upon the manifest file
  and can include background scripts, content scripts, an options page,
  UI elements and various logic.
  An extensions architecture will depend on its functionality
  and may not need every element.
</p>
<p>
  This tutorial will build an extension that demonstrates
  architecture by allowing the user change the background color of any page
  on <a href="https://developer.chrome.com/">https://developer.chrome.com/</a>.
  <!-- TODO add file for download -->
  Create a new directory for the extension or download the files here.
</p>

<h2 id="manifest">Manifest</h2>
<p>
  Extensions start with their manifest, housed within a manifest.json file.
  The manifest only needs the following to get started.
    <!-- This Architecture Example extension will include a background script,
    content script, a popup, and an options page. -->
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    "manifest_version": 2
  }
</pre>
<p>
  The directory holding the manifest file
  can be added as an extension in developer mode as is.
  Click on the three-dot menu icon in the upper right-hand side of the browser,
  hover over "More Tools" then selected "Extensions",
  or navigate in the omini box to
  <a href="chrome://extensions/">chrome://extensions/</a>.
  Check the box next to "Developer mode",
  then click the "Load unpacked extension..." button.
</p>
<img src="{{static}}/images/architecture_tutorial/load_extension.png"
  height="200"
  alt="Load Extension" />
<p>
  Select the directory the manifest file is stored in.
  Ta-da!
  The extension has been successfuly installed.
  A generic tool bar icon will be created for the extension,
  since no images were included and specified in the manifest.
</p>
<h2 id="background">Background Script</h2>
<p>
  Now that the extension has been installed,
  it needs soemthing to do.
  Start by including the file <code>background.js</code>
  in the extension directory.
  This extension will need information from a global variable,
  therefore, a value is set in global storage under the
  <a href="/runtime#event-onInstalled"><code>runtime.onInstalled</code></a>
  listener event in the background script.
</p>

<pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function() {
    chrome.storage.sync.set({color: "#3aa757"}, function(){
      console.log("The color is green.")
    })
  });
</pre>

<p>
  The background script is then registered in the manifest.
  The manifest must also be granted the
  <a href="/storage">storage</a> permission to give the extension
  access to that API.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    <b>"permissions": ["storage"],
    "background": {
      "scripts": ["background.js"],
      "persistent": false
    },</b>
    "manifest_version": 2
  }
</pre>
<p>
  Navigate back to the extension management page and click the "Reload" link.
  Once the extension reloads, there will be a new field "Inspect views:"
  with a blue link "background page".
</p>
<img src="{{static}}/images/architecture_tutorial/view_background.png"
  height="200"
  alt="Inspect Views" />
<p>
  Click the link to view the background scripts console log,
  "<code>The color is green.</code>"

<h2 id="popup">Popup</h2>
<p>
  The extension now needs a way to interact with the user.
  The <code>popup.html</code> file will be this extensions first UI page.
</p>
<pre data-filename="popup.html">
  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;style&gt;
        button {
          height: 30px;
          width: 30px;
          outline: none;
        }
      &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
      <b>&lt;button id="displayColor"&gt;&lt;/button&gt;
      &lt;script src="popup.js"&gt;&lt;/script&gt;</b>
    &lt;/body&gt;
  &lt;/html&gt;
</pre>
<p>
  It contains a button and a script tag that links to our popup logic.
  This page will need to be registered in the manifest.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    "permissions": ["storage"],
    "background": {
      "scripts": ["background.js"],
      "persistent": false
    },
    <b>"page_action": {
      "default_popup": "popup.html"
    },</b>
    "manifest_version": 2
  }

</pre>
<p>
  If the extension is reloaded at this stage, it will appear the same.
  Because <code>page_action</code> is declared in the manifest,
  it is up to the extension to tell the browser when the user can interact
  with <code>popup.html</code>.
</p>

<h2 id="content_script">Content Script</h2>
<p>
  Create a file called <code>content_script.js</code>
  and include it in the extension directory.
  The content script will send a message to the background script when
  it is time to activate the page_action.
</p>
<pre data-filename="content_script.js">
  chrome.runtime.sendMessage({message: "page_action"}, function(response) {
    console.log(response.recieved);
  });
</pre>
<p>
  The background script will need to setup a listener for this message,
  then activate the page_action by calling
  <code> chrome.pageAction.show()</code>.
  Add the following code to the background script,
</p>
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(request, sender, sendResponse) {
      if (request.message == "page_action")
        chrome.pageAction.show(sender.tab.id)
        sendResponse({recieved: "page_action activated!"});
    });
</pre>
<p>
  Because the extension should only be availabe for
  <a href="https://developer.chrome.com/">https://developer.chrome.com/</a>,
  the matches are limited when registering the content script in the manifest
  and by granting the <code>activeTab</code> permission.
</p>
<pre data-filename="manifest.json">
  {
    "name": "Architecture Example",
    "version": "1.0",
    "description": "Shows Architecture of Extensions",
    "permissions": [<b>"activeTab"</b>, "storage"],
    "page_action": {
      "default_popup": "popup.html"
    },
    "background": {
      "scripts": ["background.js"],
      "persistent": false
    },
    <b>"content_scripts": [
     {
       "matches": ["https://developer.chrome.com/*"],
       "js": ["content_script.js"],
       "run_at": "document_start"
     }
   ],</b>
    "manifest_version": 2
  }
</pre>
<p>
  Once the extension has reloaded and the webpage navigates to a url
  matching
  <a href="https://developer.chrome.com/">https://developer.chrome.com/*</a>
  the extension will be enabled and the user will be able to view
  <code>popup.html</code>, although, it will still not do anything.
</p>

<h2 id="functionality">Functionality</h2>
<p>
  Now that the compoents of the extension can communicate with each other
  and displays a UI, the functionality can be added.
  Start by creating <code>popup.js</code> in the extension directory,
  then adding the following code,
</p>
<pre data-filename="popup.js">
  let display = document.getElementById('displayColor')
  chrome.storage.sync.get('color', function(data) {
    display.style.backgroundColor = data.color;
    display.setAttribute('value', data.color);
  })

  display.onclick = function(element) {
    let color = element.target.value
    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
      chrome.tabs.sendMessage(tabs[0].id, {color: color}, function(response) {
        console.log(response.done);
      });
    });
  }
</pre>
<p>
  In the first block, the script grabs the button element from
  <code>popup.html</code>, then grabs the color value from storage.
  It takes the color value and applies it to the background color
  of the button. Reload the extension and the button will now be green.
</p>
<p>
  The second code block add an onclick event listener.
  Because what good is a button if it is unclickable?
  This onlcick event sends a message to the content script
  where a new event handler must be registered.
  Add the following to <code>content_script.js</code>,
</p>
<pre data-filename="content_script.js">
  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    document.body.style.backgroundColor = request.color;
    sendResponse({done: "background color is " + request.color});
  });
</pre>
<p>
  This is now a working extension that actually does something!

</p>
<!-- TODO add options section - also, rewrite everything -->
