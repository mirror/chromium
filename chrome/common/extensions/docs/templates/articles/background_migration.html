<h1>Converting to Non-Persistent Background Scripts</h1>

<p>
Extension background scripts should have the persistent field set to false
by default.
Background scripts act as a listener and handler for events between
the Chrome browser and the extension.
Only under rare circumstances should an extension have a persistent background,
as they consume system resources
and can cause a strain on lower-powered devices.
<p>

<p>
Use the instructions below to convert a persistent background script to non-persistent.
</p>

<h2 id="persistence">Set Persistent to False</h2>

<p>
Add or update the "persistent" field to false:
</p>

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "scripts": ["background.js"],
    "persistent": false
  }</b>,
  ...
}</pre>

<p>
The same applies to a background page that relies on HTML:
</p>

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "page": "background.html",
    "persistent": false
  }</b>,
  ...
}</pre>

<h2 id="listeners">Migrate Event Listeners to Surface</h2>

<p>
Listeners must be at the top level scope
in order to activate the background page.
Listening events may need to be restructred to a synchronous pattern.
Logging listeners, as below, will not allow them to be invoked.
</p>

<pre data-filename="background.js">
  chrome.storage.local.get('runtimeEvents', function (events) {
    for (let event of events)
      chrome.runtime[event].addListener(listener);
  });
</pre>

<p>
Instead keep listeners available:
</p>

<pre data-filename="background.js">
  chrome.runtime.onStartup.addListener(function(){
    // run startup function
  })
</pre>

<h2 id="storage">Place Global Variables in Storage</h2>
<p>
Use the <a href="/storage">Storage API</a> to set and return global variables and states.
Use <code>local.set</code> to declare a global variable on the local machine:
</p>

<pre data-filename="background.js">
  chrome.storage.local.set({ 'variable': variableInformation });
</pre>

<p>
And <code>local.get</code> to grab the value of that variable.
</p>

<pre data-filename="background.js">
  chrome.storage.local.get(['variable'], function(variable){
      let variableAwesome = variable.variableInformation
      // do something with variableAwesome
  });
</pre>


<h2 id="timers">Transform Timers into Alarms</h2>
<p>
DOM-based timers are not honored in non-persistent background scripts.
If an extension relies <code>window.setTimeout()</code> or
<code>window.setInterval()</code>, such as below:
</p>

<pre data-filename="background.js">
  window.setInterval(function() {
      alert("Hello, world!");
    }, 3000);
</pre>

<p>
Use the <a href="alarms">alarms API</a> instead:
</p>

<pre data-filename="background.js">
  chrome.alarms.create({delayInMinutes: 3.0})
</pre>

<p>
Then add a listener:
</p>

<pre data-filename="background.js">
  chrome.alarms.onAlarm.addListener(function() {
    alert("Hello, world!")
  });
</pre>

<h2 id="backgroundFunctions">Update Calls for Background Script Functions</h2>

<p>
If using  <code>$(ref:extension.getBackgroundPage)</code>
to call a function from the background page, update to
<code>$(ref:runtime.getBackgroundPage)</code>.
The newer method activates the non-persistent script before returning it.
</p>
<pre data-filename="background.js">
  function backgroundFunction() {
    alert("Background, reporting for duty!")
  }
</pre>

<pre data-filename="popup.js">
  document.getElementById('target').addEventListener('click', function(){
    chrome.extension.getBackgroundPage().backgroundFunction();
  });
</pre>

<p>
This method won't work if the background script is inactive,
which is the default state for a non-persistent script.
The newer method includes a callback function
to ensure the background script has loaded.
</p>

<pre data-filename="popup.js">
  document.getElementById('target').addEventListener('click', function(){
    chrome.runtime.getBackgroundPage(function(backgroundPage){
      backgroundPage.backgroundFunction()
    })
  });
</pre>
</p>
