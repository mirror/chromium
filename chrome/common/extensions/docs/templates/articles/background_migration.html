<h1>Converting to Non-Persistent Background Scripts</h1>

<p>
Extension background scripts should have the persistent field set to false by default.
Background scripts act as a listener and handler for events between the Chrome browser
and your extension.
Only under rare functionality circumstances should an extension have a persistent background,
as they consume system resources and can cause a strain on lower-powered devices.
<p>

<p>
Use the instructions below to convert a persistent background script to non-persistent.
</p>

<h2 id="persistence">Set Persistence to False</h2>

<p>
Add  or update the "persistent" field to false, as shown below.
</p>

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "scripts": ["background.js"],
    "persistent": false
  }</b>,
  ...
}</pre>

<p>
You will do the same thing to a background page that relies on HTML:
</p>

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "page": "background.html",
    "persistent": false
  }</b>,
  ...
}</pre>

<h2 id="listeners">Migrate Event Listeners to Surface</h2>

<p>
Listeners must be at the top level scope in order to activate the background page.
You may need to restructure listening events to a synchronous pattern.
Logging your listeners, as below, will not allow them to be envoked.
</p>

<pre data-filename="background.js">
  chrome.storage.local.get('runtimeEvents', function (events) {
    for (let event of events)
      chrome.runtime[event].addListener(listener);
  });
</pre>

<p>
Instead you will need to keep listeners available:
</p>
<pre data-filename="background.js">
  chrome.runtime.onStartup.addListener(function(){
    // run startup function
  })
</pre>

<h2 id="storage">Place Global Variables in Storage</h2>
<p>
Use the <a href="/storage">Storage API</a> to set and return global variables and states.
  Use <code>local.set</code> to declare a global variable on the local machine:
  <pre data-filename="background.js">
    chrome.storage.local.set({ 'variable': variableInformation });
  </pre>

  And <code>local.get</code> to grab the value of that variable.
  <pre data-filename="background.js">
    chrome.storage.local.get(['variable'], function(variable){
        let variableAwesome = variable.variableInformation
        // do something with variableAwesome
    });
  </pre>
</p>

<h2 id="timers">Transform Timers into Alarms</h2>
<p>
DOM-based timers are not honored in non persistent background scripts.
If your extension uses <code>window.setTimeout()</code> or
<code>window.setInterval()</code>, such as below:
</p>

<pre data-filename="background.js">
  window.setInterval(function() {
      alert("Hello, world!");
    }, 3000);
</pre>

<p>
  You can switch to using the <a href="alarms">alarms API</a> instead:
</p>

<pre data-filename="background.js">
  chrome.alarms.create({delayInMinutes: 3.0})
</pre>

<p>
Then add a listener:
</p>

<pre data-filename="background.js">
  chrome.alarms.onAlarm.addListener(function() {
    alert("Hello, world!")
  });
</pre>

<h2 id="backgroundFunctions">Update Calls for Background Script Functions</h2>

<p>
If you need to call a function or variable from your background page,
update <code>$(ref:extension.getBackgroundPage)</code> to
<code>$(ref:runtime.getBackgroundPage)</code>.
The newer method will start the non persistent script before returning it.
</p>
<pre data-filename="background.js">
  function backgroundFunction() {
    alert("Background, reporting for duty!")
  }
</pre>

<pre data-filename="popup.js">
  document.getElementById('target').addEventListener('click', function(){
    chrome.extension.getBackgroundPage().backgroundFunction();
  });
</pre>

<p>
This method will not work if the background script is inactive,
which is the default state for a non persistent script.
The newer method includes a callback function
to ensure the background script has loaded.
</p>

<pre data-filename="popup.js">
  document.getElementById('target').addEventListener('click', function(){
    chrome.runtime.getBackgroundPage(function(backgroundPage){
      backgroundPage.backgroundFunction()
    })
  });
</pre>
</p>
