<h1>Event Management with Background Scripts</h1>

<p>
Extension functionality often relies on interaction with outside browser events,
such as receiving a <a href="extensions/samples#search:notifications">notification</a>,
<a href="extensions/samples#search:new%20tab">opening a new tab</a> or
<a href="extensions/samples#search:bookmarks">removing a bookmark</a>.
Create effective background scripts that stay dormant until these events are fired
and unload after they've responded.
</p>

<h2 id="manifest">Registering Background Scripts</h2>
<p>
Background scripts must be registered in the manifest
under the background section with the "persistence" field set to false:
</p>

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "scripts": ["background.js"],
    "persistent": false
  }</b>,
  ...
}
</pre>

<p>
You can register multiple background scripts for more modularized code.
</p>

<pre data-filename="manifest.json">
  {
     "name": "My extension",
     ...
     "background": {
       "scripts": [
       "backgroundContextMenus.js",
       "backgroundOmniBox.js",
       "backgroundOauth.js"
       ],
       "persistent": false
     },
     ...
   }
</pre>

<p>
If a background script relies on creating HTML elements dymanically with JavaScript,
it can be registered as a page:
</p>
<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "page": "background.html",
    "persistent": false
  }</b>,
  ...
}
</pre>

<p>
The background script can then be called in a script tag:
</p>
<pre data-filename="background.html">
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Water Popup&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      // call to background script
     &lt;script src="background.js">&lt;/script&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</pre>

<p id="persistentWarning" class="warning">
<strong>Background scripts and pages should only have persistent field set to true under the most dire of functionality circumstances.
Setting them to true will keep them active at all times,
reducing browser efficiency.</strong>
</p>

<p>
If you are currently using a persistent background page, please refer to
<a href="/background_migration">Background Migration Guide</a>
for instruction on how to switch to a non-persistent model.
</p>

<h2 id="listeners">Setting Up Listeners</h2>

<p>
Structure event listeners synchronously
so that the background script lays dormant until a top-level event is invoked.
This frees up memory and other system resources,
providing considerable performance advantages.
</p>

<p>
An effective background script includes something like this:
</p>

<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(function(message) {
    alert(message)
  });

  chrome.runtime.onMessageExternal.addListener(function(messageExternal) {
    alert(messageExternal)
  });
</pre>

<p>
The following would not work inside a background script:
</p>
<pre data-filename="notGoodBackground.js">
  const eventList = ['onMessage', 'onMessageExternal'];

  eventList.forEach(function(event) {
    chrome.runtime.event.addListener(function(message) {
      alert(message)
    });
  });
</pre>

<h2 id="initiation">Initializing your extension</h2>
<p>
Listen to the <code>$(ref:runtime.onInstalled)</code> event
to initialize your extension on installation.
Use this event to set a state or for one-time initialization,
such as a <a href="contextMenus">Context Menu</a>.
</p>

<pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function() {
    chrome.contextMenus.create({
      "id": "sampleContextMenu",
      "title": "Sample Context Menu",
      "contexts": ["selection"]
    });
  });
</pre>

<h2 id="filters">Filtering event listeners</h2>
<p>
Use API's that support <a href="events#filtered">event filters</a>
to restrict listeners to the cases you care about.
For example, if you listen to the
<code><a href="extensions/tabs#event-onUpdated">tabs.onUpdated</a></code> event,
try using the <code>$(ref:webNavigation.onCompleted)</code> event with filters instead,
as the tabs API does not support filters.
</p>

<pre data-filename="background.js">
  chrome.webNavigation.onCompleted.addListener(function() {
      alert("This is my favorite website!");
  }, {url: [{urlMatches : 'https://www.google.com/'}]})
</pre>


<h2 id="responding">Responding to Listeners</h2>

<p>
Background scripts respond to events in multiple ways.
<br>
You can include API calls inside listeners:
</p>
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(message, callback) {
     	if (message == “setAlarm”){
      chrome.alarms.create({delayInMinutes: 5})
      }
   });
</pre>

<p>
Make calls to outside JavaScript files:
</p>
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(message, callback) {
      if (message == “runLogic”){
        chrome.tabs.executeScript({
          file: 'logic.js'
        });
      }
   });
</pre>

<p>
And insert content scripts directly:
</p>
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(message, callback) {
      if (message == “changeColor”){
        chrome.tabs.executeScript({
          code: 'document.body.style.backgroundColor="orange"'
        });
      }
   });
</pre>

<h2 id="unloading">Unloading Background Scrips</h2>

<p>
Background scripts unload after a few seconds of inactivity.
If you need to do any last minute cleanup,
you can listen to the <code>$(ref:runtime.onSuspend)</code> event.
</p>

<pre data-filename="background.js">
  chrome.runtime.onSuspend.addListener(function() {
    console.log("Unloading.");
    chrome.browserAction.setBadgeText({text: ""});
  });
</pre>

<p>
Data should be persisted periodically
so that important information is not lost if your extension crashes without receiving
<code>onSuspend</code>
Use the <a href="/storage">Storage API</a> to assist with this:
</p>

<pre data-filename="background.js">
chrome.runtime.onInstalled.addListener(function() {
  chrome.storage.local.set({ 'variable': variableInformation });
})
</pre>

<p>
If your extension uses <a href="messaging">message passing</a>,
ensure all ports are closed.
The background script will not unload until all message ports have shut.
Listening to the $(ref:runtime.Port.onDisconnect) event will give insight to
when open ports are closing.
You can manually close them with $(ref:runtime.Port.disconnect).
</p>

<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(message, callback) {
      if(message == "hello"){
        sendResponse({greeting: "welcome!"})
      }
      else if (message == “goodbye”){
        chrome.runtime.Port.disconnect();
      }
   });
</pre>

<p>
The lifetime of a background script is observable by monitoring
when an entry for the extension appears and dissapears from Chrome's task manager.
</p>

<img src="{{static}}/images/taskManager"
     height="600"
     alt="Chrome with an extension's popup open.">

<p>
Open the task manager by clicking Chrome's menu icon,
the three dots in the upper right corner of the browser,
hovering over more tools and selecting "Task Manager".
</p>
