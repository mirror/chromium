<h1>Event Management with Background Scripts</h1>

<p>
Extension functionality often relies on interaction with outside browser events,
such as receiving a <a href="extensions/samples#search:notifications">notification</a>,
<a href="extensions/samples#search:new%20tab">opening a new tab</a> or
<a href="extensions/samples#search:bookmarks">removing a bookmark</a>.
Background scripts stay dormant until these events are fired,
react approripately,
then unload.
<!-- Background scripts hold the listeners for these events,
They stay dormant until a registered event is fired,
then execute the appropriate code,
and unload when their job is completed. -->
</p>

<h2 id="manifest">Registering Background Scripts</h2>
<p>
Background scripts must be registered in the manifest
under the background section with the "persistence" field set to false.

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "scripts": ["background.js"],
    "persistent": false
  }</b>,
  ...
}
</pre>
You can register multiple background scripts for more modularized code.
</p>

<p>
If a background script relies on creating HTML elements dymanically with JavaScript,
it can be registered as a page:

  <pre data-filename="manifest.json">
  {
    "name": "My extension",
    ...
    <b>"background": {
      "page": "background.html",
      "persistent": false
    }</b>,
    ...
  }
  </pre>
  The background script can then be called in a script tag:
  <pre data-filename="background.html">
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Water Popup&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        // call to background script
       &lt;script src="background.js">&lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  </pre>
</p>

<p>
Background scripts and pages should only have persistent field set to true under the most dire of functionality circumstances.
Setting them to true will keep them active at all times,
reducing browser efficiency.

<h2 id="migration">Background Migration</h2>
If you are currently using a persistent background page, please refer to
<a href="/background_migration">Background Migration Guide</a>
for instruction on how to switch to a non-persistent model.
</p>

<h2 id="listeners">Setting Up Listeners</h2>

<p>
Listeners will need to be structured synchronously,
as background scripts lay dormant until a top leve listener is envoked.
This behavior frees up memory and other system resources,
providing considerable performance advantages.
</p>

<p>
An effective background script may including something like this:

  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(function(message) {
      alert(message)
    });

    chrome.runtime.onMessageExternal.addListener(function(messageExternal) {
      alert(messageExternal)
    });
  </pre>

The following would not work inside a background script:
  <pre data-filename="notGoodBackground.js">
    const eventList = ['onMessage', 'onMessageExternal'];

    eventList.forEach(function(event) {
      chrome.runtime.event.addListener(function(message) {
        alert(message)
      });
    });
  </pre>
</p>

<h2 id="filtersAndInitiation">Filters and Initiation</h2>
<p>
Including <a href="events#filtered">event filters</a>
will restrict your event notifications to the cases you care about.
For example, if you listen to the
<code><a href="extensions/tabs#event-onUpdated">tabs.onUpdated </a></code> event,
try using the <code>$(ref:webNavigation.onCompleted)</code> event with filters instead,
as the tabs API does not support filters.

<pre data-filename="background.js">
  chrome.webNavigation.onCompleted.addListener(function() {
      alert("This is my favorite website!");
  }, {url: [{urlMatches : 'https://www.google.com/'}]})
</pre>

If your extension needs some initialization,
like a state set, when your extension is installed,
listen to the <code>$(ref:runtime.onInstalled)</code> event.
This is also a good spot for <a href="contextMenus">Context Menu</a> entries,
and other such one-time initialization.

<pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function(setUp) {
    chrome.contextMenus.create({
      "id": "sampleContextMenu",
      "title": "Sample Context Menu",
      "contexts": ["selection"]
    });
  });
</pre>
</p>

<h2 id="responding">Responding to Listeners</h2>

<p>
Background scripts are able to respond to events in multiple ways.
<br>
  You can include a api calls inside listeners:
  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(
      function(message, callback) {
       	if (message == “setAlarm”){
        chrome.alarms.create({delayInMinutes: 5})
        }
     });
  </pre>
</p>

<p>
Make calls to outside JavaScript files:

  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(
      function(message, callback) {
        if (message == “runLogic”){
          chrome.tabs.executeScript({
            'logic.js'
          });
        }
     });
  </pre>
</p>

<p>
And insert content scripts directly:

  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(
      function(message, callback) {
        if (message == “changeColor”){
          chrome.tabs.executeScript({
            code: 'document.body.style.backgroundColor="orange"'
          });
        }
     });
  </pre>
</p>

<h2 id="unloading">Unloading Background Scrips</h2>

<p>
Background scripts will unload after they have been inactive for a few seconds.
If you need to do any last minute cleanup,
you can listen to the <code>$(ref:runtime.onSuspend)</code> event.

  <pre data-filename="background.js">
    chrome.runtime.onSuspend.addListener(function() {
      console.log("Unloading.");
      chrome.browserAction.setBadgeText({text: ""});
    });
  </pre>

However, we recommend persisting periodically as well,
as it will save important data if your extension crashes without
recieving <code>onSuspend</code>.

You can use the <a href="/storage">Storage API</a> to assist with this:
  <pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function() {
    chrome.storage.local.set({ 'variable': variableInformation });
  })
  </pre>
</p>

<p>
If your extension uses <a href="messaging">message passing</a>,
ensure all ports are closed.
The background script will not unload until all message ports have shut.
Listening to the $(ref:runtime.Port.onDisconnect) event will give insight to
when open ports are closing.
You can manually close them with $(ref:runtime.Port.disconnect).
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(message, callback) {
      if(message == "hello"){
        sendResponse({greeting: "welcome!"})
      }
      else if (message == “goodbye”){
        chrome.runtime.Port.disconnect();
      }
   });
</pre>
</p>

<p>
The lifetime of a background script is observable by monitoring
when an entry for the extension appears and dissapears from Chrome's task manager.

</p>
