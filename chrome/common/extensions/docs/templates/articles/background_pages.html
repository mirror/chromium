<h1>Event Management with Background Scripts</h1>

<p>
Extension functionality often relies on interaction with outside browser events,
such as receiving a <a href="extensions/samples#search:notifications">notification</a>,
<a href="extensions/samples#search:new%20tab">opening a new tab</a> or
<a href="extensions/samples#search:bookmarks">removing a bookmark</a>.
Create effective background scripts that stay dormant until these events are fired
and unload after they've responded.
</p>

<h2 id="manifest">Registering Background Scripts</h2>
<p>
Background scripts must be registered in the manifest
under the background section with the "persistence" field set to false.

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "scripts": ["background.js"],
    "persistent": false
  }</b>,
  ...
}
</pre>
</p>

<p>
You can register multiple background scripts for more modularized code.
  <pre>
    {
       "name": "My extension",
       ...
       "background": {
         "scripts": [
         "backgroundContextMenus.js",
         "backgroundOmniBox.js",
         "backgroundOauth.js"
         ],
         "persistent": false
       },
       ...
     }
  </pre>
</p>

<p>
If a background script relies on creating HTML elements dymanically with JavaScript,
it can be registered as a page:

  <pre data-filename="manifest.json">
  {
    "name": "My extension",
    ...
    <b>"background": {
      "page": "background.html",
      "persistent": false
    }</b>,
    ...
  }
  </pre>
  The background script can then be called in a script tag:
  <pre data-filename="background.html">
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Water Popup&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        // call to background script
       &lt;script src="background.js">&lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  </pre>
</p>

<p>
Background scripts and pages should only have persistent field set to true under the most dire of functionality circumstances.
Setting them to true will keep them active at all times,
reducing browser efficiency.
</p>

<p>
If you are currently using a persistent background page, please refer to
<a href="/background_migration">Background Migration Guide</a>
for instruction on how to switch to a non-persistent model.
</p>

<h2 id="listeners">Setting Up Listeners</h2>

<p>
Structure event listeners synchronously
so that the background script lays dormant until a top-level event is invoked.
This frees up memory and other system resources,
providing considerable performance advantages.
</p>

<p>
An effective background script includes something like this:

  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(function(message) {
      alert(message)
    });

    chrome.runtime.onMessageExternal.addListener(function(messageExternal) {
      alert(messageExternal)
    });
  </pre>

The following would not work inside a background script:
  <pre data-filename="notGoodBackground.js">
    const eventList = ['onMessage', 'onMessageExternal'];

    eventList.forEach(function(event) {
      chrome.runtime.event.addListener(function(message) {
        alert(message)
      });
    });
  </pre>
</p>

<h2 id="filtersAndInitiation">Filters and Initiation</h2>
<p>
Including <a href="events#filtered">event filters</a>
will restrict your event notifications to the cases you care about.
For example, if you listen to the
<code><a href="extensions/tabs#event-onUpdated">tabs.onUpdated </a></code> event,
try using the <code>$(ref:webNavigation.onCompleted)</code> event with filters instead,
as the tabs API does not support filters.

<pre data-filename="background.js">
  chrome.webNavigation.onCompleted.addListener(function() {
      alert("This is my favorite website!");
  }, {url: [{urlMatches : 'https://www.google.com/'}]})
</pre>

If your extension needs some initialization,
like a state set, when your extension is installed,
listen to the <code>$(ref:runtime.onInstalled)</code> event.
This is also a good spot for <a href="contextMenus">Context Menu</a> entries,
and other such one-time initialization.

<pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function(setUp) {
    chrome.contextMenus.create({
      "id": "sampleContextMenu",
      "title": "Sample Context Menu",
      "contexts": ["selection"]
    });
  });
</pre>
</p>

<h2 id="responding">Responding to Listeners</h2>

<p>
Background scripts respond to events in multiple ways.
<br>
  You can include API calls inside listeners:
  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(
      function(message, callback) {
       	if (message == “setAlarm”){
        chrome.alarms.create({delayInMinutes: 5})
        }
     });
  </pre>
</p>

<p>
Make calls to outside JavaScript files:

  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(
      function(message, callback) {
        if (message == “runLogic”){
          chrome.tabs.executeScript({
            'logic.js'
          });
        }
     });
  </pre>
</p>

<p>
And insert content scripts directly:

  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(
      function(message, callback) {
        if (message == “changeColor”){
          chrome.tabs.executeScript({
            code: 'document.body.style.backgroundColor="orange"'
          });
        }
     });
  </pre>
</p>

<h2 id="unloading">Unloading Background Scrips</h2>

<p>
Background scripts unload after a few seconds of inactivity.
If you need to do any last minute cleanup,
you can listen to the <code>$(ref:runtime.onSuspend)</code> event.

  <pre data-filename="background.js">
    chrome.runtime.onSuspend.addListener(function() {
      console.log("Unloading.");
      chrome.browserAction.setBadgeText({text: ""});
    });
  </pre>

Data should be persisted periodically
so that important information is not lost if your extension crashes without receiving
<code>onSuspend</code>.


You can use the <a href="/storage">Storage API</a> to assist with this:
  <pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function() {
    chrome.storage.local.set({ 'variable': variableInformation });
  })
  </pre>
</p>

<p>
If your extension uses <a href="messaging">message passing</a>,
ensure all ports are closed.
The background script will not unload until all message ports have shut.
Listening to the $(ref:runtime.Port.onDisconnect) event will give insight to
when open ports are closing.
You can manually close them with $(ref:runtime.Port.disconnect).
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(message, callback) {
      if(message == "hello"){
        sendResponse({greeting: "welcome!"})
      }
      else if (message == “goodbye”){
        chrome.runtime.Port.disconnect();
      }
   });
</pre>
</p>

<p>
The lifetime of a background script is observable by monitoring
when an entry for the extension appears and dissapears from Chrome's task manager.
</p>
<img src="{{static}}/images/taskManager"
     height="600"
     alt="Chrome with an extension's popup open.">
<p>
Open the task manager by clicking Chrome's menu icon,
the three dots in the upper right corner of the browser,
hovering over more tools and selecting "Task Manager".
</p>
