<h1>Event Management with Background Scripts</h1>

<p>
Extension functionality often relies on interaction with outside browser events,
such as receiving a notification, opening a new tab or removing a bookmark.
Background scripts hold the listeners for these events.
They stay dormant until a registered event is fired,
then execute the appropriate code,
and unload when their job is completed.
This behavior frees up memory and other system resources,
providing a considerable performance advantage,
especially on low powered devices.
</p>

<h2 id="manifest">Registering Background Scripts</h2>
<p>
Background scripts must be registered in the manifest,
and you may include multiple files,
under the background section.
The “persistence” field needs to be included and set it to false:

<pre data-filename="manifest.json">
{
  "name": "My extension",
  ...
  <b>"background": {
    "scripts": ["background.js"],
    "persistent": false
  }</b>,
  ...
}
</pre>
</p>

<p>
If your background script relies on HTML elements,
you can include it in a script tag at the bottom of a page and register the background field as a page,
instead of a script. You can only register one background page:

  <pre data-filename="manifest.json">
  {
    "name": "My extension",
    ...
    <b>"background": {
      "page": "background.html",
      "persistent": false
    }</b>,
    ...
  }
  </pre>
</p>

<p>
Background scripts and pages should only have persistent field set to true under the most dire of functionality circumstances.
Setting them to true will keep them active at all times,
cutting into system resources and dragging on browser efficiency.
</p>

<h2 id="listeners">Setting Up Listeners</h2>

<p>
Background script are extremely customizable to your extensions needs.
You can register just one listener, or many.
However, because the background script dormant until a listener is triggered,
you will need to keep listeners at top-level scope structed synchronously.
</p>

<p>
An effective background script may including something that looks like:

  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(function(message) {
      alert(message)
    });

    chrome.runtime.onMessageExternal.addListener(function(message) {
      alert(message)
    });
  </pre>

The following would not work inside a background script:
  <pre data-filename="notGoodBackground.js">
    const eventList = ['onMessage', 'onMessageExternal'];

    eventList.forEach(function(event) {
      chrome.runtime.event.addListener(function(message) {
        alert(message)
      });
    });
  </pre>
</p>

<h2 id="filtersAndInitiation">Filters and Initiation</h2>

<p>
Background scripts core function is to only respond to events relevant to your extension.
Including <a href="events#filtered">event filters</a>
is a fantastic way to restrict your event notifications to cases you care about:
</p>

<p>
Think about including <a href="events#filtered">event filters</a>
to restrict your event notifications to the cases you care about.
For example, if you listen to the
<code><a href="extensions/tabs#event-onUpdated">tabs.onUpdated </a></code> event,
try using the <code>$(ref:webNavigation.onCompleted)</code> event with filters instead,
as the tabs API does not support filters.

<pre data-filename="background.js">
  chrome.webNavigation.onCompleted.addListener(function() {
      alert("This is my favorite website!");
  }, {url: [{urlMatches : 'https://www.google.com/'}]})
</pre>

If your extension needs some initialization,
like a state set, when your extension is installed,
listen to the <code>$(ref:runtime.onInstalled)</code> event.
This is also a good spot for <a href="contextMenus">Context Menu</a> entries,
and other such one-time initialization.

<pre data-filename="background.js">
  chrome.runtime.onInstalled.addListener(function(setUp) {
    chrome.contextMenus.create({
      "id": "sampleContextMenu",
      "title": "Sample Context Menu",
      "contexts": ["selection"]
    });
  });
</pre>
</p>

<h2 id="responding">Responding to Listeners</h2>

<p>
Your background script is here to listen for events and tasks,
and then dispatch the response.
A background script can respond in mulitple ways.
</p>

<p>

<p>
  You can include a api calls inside listeners:
  <pre data-filename="background.js">
    chrome.runtime.onMessage.addListener(
      function(message, callback) {
       	if (message == “setAlarm”){
        chrome.alarms.create({delayInMinutes: 5})
        }
     });
  </pre>
</p>

<p>
Make calls to outside JavaScript files:

  <pre data-filename="background.js">
    chrome.alarms.onAlarm.addListener(function() {
    	chrome.tabs.executeScript({
        'logic.js'
      });
    });
  </pre>
</p>

<p>
And insert content scripts directly:

  <pre data-filename="background.js">
    chrome.alarms.onAlarm.addListener(function() {
    	chrome.tabs.executeScript({
        code: 'document.body.style.backgroundColor="orange"'
      });
    });
  </pre>
</p>

<h2 id="unloading">Unloading Background Scrips</h2>

<p>
Background scripts will unload after they have been inactive for a few seconds.
If you need to do any last minute cleanup,
you can listen to the <code>$(ref:runtime.onSuspend)</code> event.

  <pre data-filename>
    chrome.runtime.onSuspend.addListener(function() {
      console.log("Unloading.");
      chrome.browserAction.setBadgeText({text: ""});
    });
  </pre>

However, we reccomend persisting periodically as well,
as it will save important data if your extension crashes without
recieving <code>onSuspend</code>.
</p>

<p>
If your extension uses <a href="messaging">message passing</a>,
ensure all ports are closed.
The background script will not unload until all message ports are closed.
You can manually close them with $(ref:runtime.Port.disconnect).
<pre data-filename="background.js">
  chrome.runtime.onMessage.addListener(
    function(message, callback) {
      if(message == "hello"){
        sendResponse({greeting: "welcome!"})
      }
      else if (message == “goodbye”){
        chrome.runtime.Port.disconnect();
      }
   });
</pre>
</p>

<p>
You can listen to the $(ref:runtime.Port.onDisconnect) event to ensure your ports are closing
and observe your background scrips lifetime by opening Chrome's task manager.
You can see when background script loads and unloads by monitoring when an
entry for your extension appears in the list of processes.
</p>
