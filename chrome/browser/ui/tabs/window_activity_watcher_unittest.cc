// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/tabs/window_activity_watcher.h"

#include <memory>
#include <vector>

#include "base/macros.h"
#include "base/memory/ptr_util.h"
#include "base/observer_list.h"
#include "base/strings/stringprintf.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/browser_list.h"
#include "chrome/browser/ui/browser_window_observer.h"
#include "chrome/browser/ui/tabs/tab_metrics_event.pb.h"
#include "chrome/browser/ui/tabs/tab_ukm_test_helper.h"
#include "chrome/test/base/test_browser_window.h"
#include "chrome/test/base/testing_profile.h"
#include "content/public/test/web_contents_tester.h"
#include "services/metrics/public/cpp/ukm_builders.h"
#include "services/metrics/public/interfaces/ukm_interface.mojom.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "ui/base/ui_base_types.h"

using metrics::WindowMetricsEvent;
using ukm::builders::TabManager_WindowMetrics;

namespace {

const char* kEntryName = TabManager_WindowMetrics::kEntryName;
const char* kTestUrl = "https://example.com/";

// TestBrowserWindow whose show state can be modified.
class FakeBrowserWindow : public TestBrowserWindow {
 public:
  FakeBrowserWindow() = default;
  ~FakeBrowserWindow() override = default;

  // Helper function to handle FakeBrowserWindow lifetime. Modeled after
  // CreateBrowserWithTestWindowForParams.
  static std::unique_ptr<Browser> CreateBrowserWithFakeWindowForParams(
      Browser::CreateParams* params) {
    // TestBrowserWindowOwner takes ownersip of the window and will destroy the
    // window (along with itself) automatically when the browser is closed.
    FakeBrowserWindow* window = new FakeBrowserWindow;
    new TestBrowserWindowOwner(window);

    params->window = window;
    auto browser = std::make_unique<Browser>(*params);
    window->browser_ = browser.get();
    window->Activate();
    return browser;
  }

  // TestBrowserWindow:
  void Activate() override {
    if (is_active_)
      return;
    is_active_ = true;
    // With a real view, activating would update the BrowserList.
    BrowserList::SetLastActive(browser_);
  }
  void Deactivate() override {
    if (!is_active_)
      return;
    is_active_ = false;
    // With a real view, deactivating would notify the BrowserList.
    BrowserList::NotifyBrowserNoLongerActive(browser_);
  }
  bool IsActive() const override { return is_active_; }
  bool IsMaximized() const override {
    return show_state_ == ui::SHOW_STATE_MAXIMIZED;
  }
  bool IsMinimized() const override {
    return show_state_ == ui::SHOW_STATE_MINIMIZED;
  }
  bool IsFullscreen() const override {
    return show_state_ == ui::SHOW_STATE_FULLSCREEN;
  }
  void Maximize() override { UpdateShowState(ui::SHOW_STATE_MAXIMIZED); }
  void Minimize() override { UpdateShowState(ui::SHOW_STATE_MINIMIZED); }
  void Restore() override { UpdateShowState(ui::SHOW_STATE_NORMAL); }
  void AddObserver(BrowserWindowObserver* observer) override {
    browser_window_observers_.AddObserver(observer);
  }
  void RemoveObserver(BrowserWindowObserver* observer) override {
    browser_window_observers_.RemoveObserver(observer);
  }

  void EnterFullscreen() { UpdateShowState(ui::SHOW_STATE_FULLSCREEN); }

 private:
  void UpdateShowState(ui::WindowShowState show_state) {
    // Update |show_state_| before |is_active_| so both values are updated
    // when observers are notified.
    show_state_ = show_state;
    show_state_ == ui::SHOW_STATE_MINIMIZED ? Deactivate() : Activate();
    for (auto& observer : browser_window_observers_)
      observer.OnShowStateChanged();
  }

  Browser* browser_;
  base::ObserverList<BrowserWindowObserver> browser_window_observers_;
  bool is_active_ = false;
  ui::WindowShowState show_state_ = ui::SHOW_STATE_NORMAL;

  DISALLOW_COPY_AND_ASSIGN(FakeBrowserWindow);
};

}  // namespace

// Tests UKM entries generated by WindowMetricsLogger at the request of
// WindowActivityWatcher.
class WindowActivityWatcherTest : public TabActivityTestBase {
 protected:
  WindowActivityWatcherTest() = default;
  ~WindowActivityWatcherTest() override { EXPECT_FALSE(WasNewEntryRecorded()); }

  // Adds a tab and simulates a basic navigation.
  void AddTab(Browser* browser) {
    content::WebContentsTester::For(
        AddWebContentsAndNavigate(browser->tab_strip_model(), GURL(kTestUrl)))
        ->TestSetIsLoading(false);
  }

  bool WasNewEntryRecorded() {
    return ukm_entry_checker_.NumNewEntriesRecorded(kEntryName) > 0;
  }

  UkmEntryChecker* ukm_entry_checker() { return &ukm_entry_checker_; }

 private:
  UkmEntryChecker ukm_entry_checker_;

  DISALLOW_COPY_AND_ASSIGN(WindowActivityWatcherTest);
};

// Tests UKM logging of window changes.
TEST_F(WindowActivityWatcherTest, WindowChanges) {
  Browser::CreateParams params(profile(), true);
  std::unique_ptr<Browser> browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  FakeBrowserWindow* window =
      static_cast<FakeBrowserWindow*>(browser->window());
  AddTab(browser.get());

  UkmMetricMap expected_metrics({
      {TabManager_WindowMetrics::kWindowIdName, browser->session_id().id()},
      {TabManager_WindowMetrics::kShowStateName,
       WindowMetricsEvent::SHOW_STATE_NORMAL},
      {TabManager_WindowMetrics::kTypeName, WindowMetricsEvent::TYPE_TABBED},
      {TabManager_WindowMetrics::kIsActiveName, 1},
      {TabManager_WindowMetrics::kTabCountName, 1},
  });
  {
    SCOPED_TRACE("");
    // Window UKMs are not expected to be keyed to a URL.
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->window()->Maximize();
  expected_metrics[TabManager_WindowMetrics::kShowStateName] =
      WindowMetricsEvent::SHOW_STATE_MAXIMIZED;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->window()->Restore();
  expected_metrics[TabManager_WindowMetrics::kShowStateName] =
      WindowMetricsEvent::SHOW_STATE_NORMAL;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  window->EnterFullscreen();
  expected_metrics[TabManager_WindowMetrics::kShowStateName] =
      WindowMetricsEvent::SHOW_STATE_FULLSCREEN;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->window()->Restore();
  expected_metrics[TabManager_WindowMetrics::kShowStateName] =
      WindowMetricsEvent::SHOW_STATE_NORMAL;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->window()->Minimize();
  expected_metrics[TabManager_WindowMetrics::kShowStateName] =
      WindowMetricsEvent::SHOW_STATE_MINIMIZED;
  expected_metrics[TabManager_WindowMetrics::kIsActiveName] = 0;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->tab_strip_model()->CloseAllTabs();
}

// Tests UKM logging of two browser windows.
TEST_F(WindowActivityWatcherTest, MultipleWindows) {
  Browser::CreateParams params(profile(), true);
  std::unique_ptr<Browser> browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  AddTab(browser.get());

  UkmMetricMap expected_metrics({
      {TabManager_WindowMetrics::kWindowIdName, browser->session_id().id()},
      {TabManager_WindowMetrics::kShowStateName,
       WindowMetricsEvent::SHOW_STATE_NORMAL},
      {TabManager_WindowMetrics::kTypeName, WindowMetricsEvent::TYPE_TABBED},
      {TabManager_WindowMetrics::kIsActiveName, 1},
      {TabManager_WindowMetrics::kTabCountName, 1},
  });
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->window()->Minimize();
  expected_metrics[TabManager_WindowMetrics::kShowStateName] =
      WindowMetricsEvent::SHOW_STATE_MINIMIZED;
  expected_metrics[TabManager_WindowMetrics::kIsActiveName] = 0;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  // A new entry is not created if nothing changes.
  EXPECT_FALSE(WasNewEntryRecorded());

  // A second browser can be logged.
  Browser::CreateParams params_2(Browser::TYPE_POPUP, profile(), true);
  std::unique_ptr<Browser> browser_2 =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params_2);

  // An entry is not logged until a tab is added to the new window.
  EXPECT_FALSE(WasNewEntryRecorded());

  AddTab(browser_2.get());
  UkmMetricMap expected_metrics_2({
      {TabManager_WindowMetrics::kWindowIdName, browser_2->session_id().id()},
      {TabManager_WindowMetrics::kShowStateName,
       WindowMetricsEvent::SHOW_STATE_NORMAL},
      {TabManager_WindowMetrics::kTypeName, WindowMetricsEvent::TYPE_POPUP},
      {TabManager_WindowMetrics::kIsActiveName, 1},
      {TabManager_WindowMetrics::kTabCountName, 1},
  });
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics_2);
  }

  // Switching the active browser logs two events.
  browser_2->window()->Deactivate();
  expected_metrics_2[TabManager_WindowMetrics::kIsActiveName] = 0;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics_2);
  }

  browser->window()->Restore();
  expected_metrics[TabManager_WindowMetrics::kShowStateName] =
      WindowMetricsEvent::SHOW_STATE_NORMAL;
  expected_metrics[TabManager_WindowMetrics::kIsActiveName] = 1;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->tab_strip_model()->CloseAllTabs();
  browser_2->tab_strip_model()->CloseAllTabs();
}

// Tests moving a tab between browser windows.
TEST_F(WindowActivityWatcherTest, MoveTabToOtherWindow) {
  Browser::CreateParams params(profile(), true);
  std::unique_ptr<Browser> starting_browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  AddTab(starting_browser.get());
  UkmMetricMap starting_browser_metrics({
      {TabManager_WindowMetrics::kWindowIdName,
       starting_browser->session_id().id()},
      {TabManager_WindowMetrics::kIsActiveName, 1},
      {TabManager_WindowMetrics::kTabCountName, 1},
  });
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(),
                                        starting_browser_metrics);
  }

  // Add a second tab, so we can detach it while leaving the original window
  // behind.
  AddTab(starting_browser.get());
  starting_browser_metrics[TabManager_WindowMetrics::kTabCountName].value() = 2;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(),
                                        starting_browser_metrics);
  }

  // Drag the tab out of its window.
  content::WebContents* dragged_tab =
      starting_browser->tab_strip_model()->DetachWebContentsAt(1);
  starting_browser_metrics[TabManager_WindowMetrics::kTabCountName].value() = 1;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(),
                                        starting_browser_metrics);
  }
  starting_browser->window()->Deactivate();
  starting_browser_metrics[TabManager_WindowMetrics::kIsActiveName].value() =
      false;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(),
                                        starting_browser_metrics);
  }

  // Create a new Browser for the tab.
  std::unique_ptr<Browser> created_browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  created_browser->window()->Activate();
  created_browser->tab_strip_model()->InsertWebContentsAt(
      0, dragged_tab, TabStripModel::ADD_ACTIVE);
  UkmMetricMap created_browser_metrics({
      {TabManager_WindowMetrics::kWindowIdName,
       created_browser->session_id().id()},
      {TabManager_WindowMetrics::kIsActiveName, 1},
      {TabManager_WindowMetrics::kTabCountName, 1},
  });
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(),
                                        created_browser_metrics);
  }

  starting_browser->tab_strip_model()->CloseAllTabs();
  created_browser->tab_strip_model()->CloseAllTabs();
}

// Tests that a replaced tab still causes event logging upon being detached.
TEST_F(WindowActivityWatcherTest, ReplaceTab) {
  Browser::CreateParams params(profile(), true);
  std::unique_ptr<Browser> browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  AddTab(browser.get());
  UkmMetricMap expected_metrics({
      {TabManager_WindowMetrics::kWindowIdName, browser->session_id().id()},
      {TabManager_WindowMetrics::kTabCountName, 1},
  });
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  // Add a tab that will be replaced.
  AddTab(browser.get());
  expected_metrics[TabManager_WindowMetrics::kTabCountName].value() = 2;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  // Replace the tab.
  content::WebContents::CreateParams web_contents_params(profile(), nullptr);
  content::WebContents* new_contents =
      content::WebContentsTester::CreateTestWebContents(web_contents_params);
  std::unique_ptr<content::WebContents> old_contents = base::WrapUnique(
      browser->tab_strip_model()->ReplaceWebContentsAt(1, new_contents));

  // Close the replaced tab. This should log an event with an updated TabCount.
  browser->tab_strip_model()->CloseWebContentsAt(1, TabStripModel::CLOSE_NONE);
  expected_metrics[TabManager_WindowMetrics::kTabCountName].value() = 1;
  {
    SCOPED_TRACE("");
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->tab_strip_model()->CloseAllTabs();
}

// Tests that window show state change counts are properly bucketized.
TEST_F(WindowActivityWatcherTest, ShowStateChangeCounts) {
  Browser::CreateParams params(profile(), true);
  std::unique_ptr<Browser> browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  UkmMetricMap expected_metrics({
      {TabManager_WindowMetrics::kMaximizeCountName, 0},
  });

  AddTab(browser.get());
  ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);

  // Expected buckets for each count value.
  const std::vector<int> kExpectedBuckets = {
      // clang-format off
      0,
      1,
      2, 2,
      4, 4, 4, 4,
      8, 8, 8, 8, 8, 8, 8, 8,
      16, 16,  // ...
      // clang-format on
  };

  for (size_t i = 1; i < kExpectedBuckets.size(); i++) {
    SCOPED_TRACE(base::StringPrintf("Iteration: %zd", i));
    browser->window()->Maximize();
    expected_metrics[TabManager_WindowMetrics::kMaximizeCountName] =
        kExpectedBuckets[i];
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);

    // Restore the window so we can maximize again. This logs another entry.
    browser->window()->Restore();
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->tab_strip_model()->CloseAllTabs();
}

// Tests that tab counts (which use a custom spacing factor) are properly
// bucketized.
TEST_F(WindowActivityWatcherTest, TabCounts) {
  Browser::CreateParams params(profile(), true);
  std::unique_ptr<Browser> browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  UkmMetricMap expected_metrics;

  // Expected buckets for each tab count using a spacing factor of 1.5.
  const std::vector<int> kExpectedBuckets = {
      // clang-format off
      0,        // Not actually tested, since we don't log windows with 0 tabs.
      1, 2, 3,  // Values up to 3 should be represented exactly.
      4, 4,
      6, 6,
      8, 8, 8, 8,
      12, 12, 12, 12, 12, 12,
      18, 18,  // ...
      // clang-format on
  };

  for (size_t i = 1; i < kExpectedBuckets.size(); i++) {
    SCOPED_TRACE(base::StringPrintf("Tab count: %zd", i));
    AddTab(browser.get());
    // We only log a new UKM if the values are different, post-sanitization.
    if (kExpectedBuckets[i] == kExpectedBuckets[i - 1]) {
      EXPECT_EQ(0, ukm_entry_checker()->NumNewEntriesRecorded(kEntryName));
      continue;
    }

    expected_metrics[TabManager_WindowMetrics::kTabCountName] =
        kExpectedBuckets[i];
    ukm_entry_checker()->ExpectNewEntry(kEntryName, GURL(), expected_metrics);
  }

  browser->tab_strip_model()->CloseAllTabs();
}

// Tests that incognito windows are ignored.
TEST_F(WindowActivityWatcherTest, Incognito) {
  Browser::CreateParams params(profile()->GetOffTheRecordProfile(), true);
  std::unique_ptr<Browser> browser =
      FakeBrowserWindow::CreateBrowserWithFakeWindowForParams(&params);
  AddTab(browser.get());
  EXPECT_EQ(0u, ukm_entry_checker()->NumEntries(kEntryName));

  browser->tab_strip_model()->CloseAllTabs();
}
