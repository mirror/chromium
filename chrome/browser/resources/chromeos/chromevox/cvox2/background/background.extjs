// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Include test fixture.
GEN_INCLUDE(['../../testing/chromevox_e2e_test_base.js']);

/**
 * Test fixture for cvox2.Background.
 * @constructor
 * @extends {ChromeVoxE2ETest}
 */
function BackgroundTest() {}

BackgroundTest.prototype = {
  __proto__: ChromeVoxE2ETest.prototype,

  // This method is called without a |this| instance bound.
  /** @override */
  testGenCppIncludes: function() {
    ChromeVoxE2ETest.prototype.testGenCppIncludes.call(this);
    GEN('#include "base/command_line.h"');
    GEN('#include "chromeos/chromeos_switches.h"');
  },

  // This method is called without a |this| instance bound.
  /** @override */
  testGenPreamble: function() {
    GEN_BLOCK(function() {/*!
      CommandLine* command_line = CommandLine::ForCurrentProcess();
      command_line->AppendSwitch(chromeos::switches::kEnableChromeVoxNext);
    */});
    ChromeVoxE2ETest.prototype.testGenPreamble.call(this);
  },

  /** @override */
  setUp: function() {
    this.mockTts = new MockTts();
    cvox.ChromeVox.tts = this.mockTts;
  }
};

/**
 * Mock tts class.
 * @constructor
 * @extends {cvox.TtsInterface}
 */
var MockTts = function() {
};

MockTts.prototype = {
  /**
   * A list of predicate, start, and end callbacks for a pending expectation.
   * @type {!Array.<{{predicate: function(string) : boolean,
   *     startCallback: function() : void,
   *     endCallback: function() : void}>}
   * @private
   */
  expectations_: [],

  /**
   * A list of strings stored whenever there are no expectations.
   * @type {!Array.<string}
   * @private
   */
  idleUtterances_: [],

  /** @override */
  speak: function(textString, queueMode, properties) {
    this.process_(textString);
  },

  /**
   * Adds an expectation for the given string to be spoken. If satisfied,
   * |opt_callback| is called.
   * @param {string} expectedText
   * @param {function() : void=} opt_callback
   */
  expectSpeech: function(expectedText, opt_callback) {
    var expectation = {};
    expectation.endCallback = opt_callback;
    this.addExpectation_(expectedText, expectation);
  },

  /**
   * Adds an expectation for the given string to be spoken after |opt_callback|
   * executes.
   * @param {string} expectedText
   * @param {function() : void=} opt_callback
   */
  expectSpeechAfter: function(expectedText, opt_callback) {
    var expectation = {};
    if (this.expectations_.length == 0 && opt_callback)
      opt_callback();
    else
      expectation.startCallback = opt_callback;
    this.addExpectation_(expectedText, expectation);
  },

  /**
   * Finishes expectations and calls testDone.
   */
  finishExpectations: function() {
    this.expectSpeechAfter('', testDone);
  },

  /**
   * @private
   * @param {string} expectedText Text expected spoken.
   * @param {{startCallback: function() : void,
   *     endCallback: function() : void}=} opt_expectation
   */
  addExpectation_: function(expectedText, opt_expectation) {
    var expectation = opt_expectation ? opt_expectation : {};

    expectation.predicate = function(actualText) {
      return actualText.indexOf(expectedText) != -1;
    };

    this.expectations_.push(expectation);

    // Process any idleUtterances.
    this.idleUtterances_.forEach(function(utterance) {
      this.process_(utterance, true);
    });
  },

  /**
   * @param {string} textString Utterance to match against callbacks.
   * @param {boolean=} opt_manual True if called outside of tts.speak.
   * @private
   */
  process_: function(textString, opt_manual) {
    if (this.expectations_.length == 0) {
      if (!opt_manual)
        this.idleUtterances_.push(textString);
      return;
    }

    var allUtterances = this.idleUtterances_.concat([textString]);
    var targetExpectation = this.expectations_.shift();
    if (allUtterances.some(targetExpectation.predicate)) {
      this.idleUtterances_.length = 0;
      if (targetExpectation.endCallback)
        targetExpectation.endCallback();
      var nextExpectation = this.expectations_[0];
      if (nextExpectation && nextExpectation.startCallback)
        nextExpectation.startCallback();
    } else {
      this.expectations_.unshift(targetExpectation);
    }
  },
};

/** Tests that ChromeVox classic is in this context. */
SYNC_TEST_F('BackgroundTest', 'ClassicNamespaces', function() {
  assertEquals('object', typeof(cvox));
  assertEquals('function', typeof(cvox.ChromeVoxBackground));
});

/** Tests that ChromeVox next is in this context. */
SYNC_TEST_F('BackgroundTest', 'NextNamespaces', function() {
  assertEquals('object', typeof(cvox2));
  assertEquals('function', typeof(cvox2.Background));
});

/** Tests that ChromeVox reads the desktop tree. */
TEST_F('BackgroundTest', 'DesktopFocus', function() {
  function findStatusTray(root) {
    if (root.role == chrome.automation.RoleType.button &&
        root.attributes.name &&
        root.attributes.name.indexOf('Status tray') != -1) {
      return root;
    }
    for (var i = 0; i < root.children().length; i++) {
      var found = findStatusTray(root.children()[i]);
      if (found)
        return found;
    }
    return null;
  }

  chrome.automation.getDesktop(function(root) {
    var testButton = findStatusTray(root);
    cvox.ChromeVox.tts.expectSpeech('Status tray', testDone);
    testButton.focus();
  });
});

/** Tests feedback once a page loads. */
TEST_F('BackgroundTest', 'InitialFeedback', function() {
  this.runWithDocument(function() {/*!
    <p>start
    <p>end
  */},
  function() {
    cvox.ChromeVox.tts.expectSpeech('start', function() {
      cvox2.global.backgroundObj.onGotCommand('nextLine');
    });
    cvox.ChromeVox.tts.expectSpeech('end', testDone);
  }.bind(this));
});

/** Tests consistency of navigating forward and backward. */
TEST_F('BackgroundTest', 'ForwardBackwardNavigation', function() {
  this.runWithDocument(function() {/*!
    <p>start</p>
    <a href='#a'>alpha</a>
    <a href='#b'>beta</a>
    <p>
      <h1>charlie</h1>
      <a href='foo'>delta</a>
    </p>
    <a href='#bar'>echo</a>
    <h2>foxtraut</h2>
    <p>end<span>of test</span></p>
  */},
  function() {
    var doCmd = function(cmd) {
      return function() {
        cvox2.global.backgroundObj.onGotCommand(cmd);
      };
    };

    var expectAfter =
        cvox.ChromeVox.tts.expectSpeechAfter.bind(cvox.ChromeVox.tts);

    cvox.ChromeVox.tts.expectSpeech('start');
    expectAfter('alpha', doCmd('nextLink'));
    expectAfter('beta', doCmd('nextLink'));
    expectAfter('delta', doCmd('nextLink'));
    expectAfter('beta', doCmd('previousLink'));

    expectAfter('charlie', doCmd('nextHeading'));
    expectAfter('foxtraut', doCmd('nextHeading'));
    expectAfter('charlie', doCmd('previousHeading'));

    expectAfter('delta', doCmd('nextElement'));
    expectAfter('echo', doCmd('nextElement'));
    expectAfter('foxtraut', doCmd('nextElement'));
    expectAfter('end', doCmd('nextElement'));
    expectAfter('foxtraut', doCmd('previousElement'));

    expectAfter('end', doCmd('nextLine'));

    // TODO(dtseng): Note that this line break is based off of the way inline
    // textboxes breaks on spans.
    expectAfter('of test', doCmd('nextLine'));
    expectAfter('end', doCmd('previousLine'));

    expectAfter('start', doCmd('goToBeginning'));
    expectAfter('of test', doCmd('goToEnd'));

    cvox.ChromeVox.tts.finishExpectations();
  }.bind(this));
});
