// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

package chromeos.power.ml;

// Proto buffer for events used in predicting user activity. This proto will
// represent one training example and will contain both features and labels. At
// inference time, the only missing fields will be the labels.
message UserActivityEvent {
  // 1. Model params
  // model_start_delay_sec defines the idle delay for an ML model to start
  // making a prediction. Event logging will be triggered after this amount of
  // inactivity. Value will be in the range of 10sec - 20sec, which may be tuned
  // following experiments.
  optional int32 model_start_delay_sec = 1;
  // model_timeout_delay_sec defines extended idle period following screen-off,
  // at which point we will log event type to be TIMEOUT. Value will be
  // ~10sec or shorter, which may be tuned following experiments.
  optional int32 model_timeout_delay_sec = 2;

  // 2. Labels
  // Event type as training labels.
  enum Type {
    REACTIVATE = 1;
    OFF = 2;
    TIMEOUT = 3;
  }

  optional Type type = 3;

  // Trigger of the event. Currently not used as labels and stored for analysis
  // only.
  enum Reason {
    USER_ACTIVITY = 1;
    VIDEO_ACTIVITY = 2;
    POWER_CHANGED = 3;
    LID_CLOSED = 4;
    SHUTDOWN = 5;
    SESSION_STOPPED = 6;
    SCREEN_OFF = 7;
    SCREEN_LOCK = 8;
    IDLE_SLEEP = 9;
  }

  optional Reason reason = 4;

  // 3. Features
  // Time taken to transition between states.
  optional int32 on_to_dim_sec = 5;
  optional int32 dim_to_screen_off_sec = 6;

  // Last activity and last user activity as seconds since midnight in the local
  // time zone.
  optional int32 last_activity_time_sec = 7;
  optional int32 last_user_activity_time_sec = 8;

  enum DayOfWeek {
    MON = 1;
    TUE = 2;
    WED = 3;
    THU = 4;
    FRI = 5;
    SAT = 6;
    SUN = 7;
  }
  optional DayOfWeek last_activity_day = 9;

  // Time from last mouse/key to when the model starts. This may not be the same
  // as model_start_delay_sec, depending on what the last activity is.
  optional int32 time_since_last_mouse_sec = 10;
  optional int32 time_since_last_key_sec = 11;

  // Duration of activity (user or video) up to last_activity_time_sec. If
  // activity starts at time t1, then recent_time_active_sec =
  // |last_activity_time_sec - t1|. We ignore short periods of idle time (i.e.
  // user is considered active in this idle period), but the short periods must
  // be shorter than model_start_delay_sec.
  // TODO(jiameng): we may consider a different way of measuring continued
  // activity following experiments.
  optional int32 recent_time_active_sec = 12;

  // Extension IDs of active and recently-closed Chrome apps.
  repeated string active_apps = 13;
  repeated string closed_apps = 14;

  // TODO(jiameng): add tab identifiers.

  // At the moment, we only log events when device is Chromebook, hence we
  // ignore types such as Chromebase, Chromebit and Chromebox. In the future, we
  // would log events for tablets, phones etc.
  enum DeviceType {
    UNKNOWN_DEVICE = 0;
    CHROMEBOOK = 1;
  }

  optional DeviceType device_type = 15;

  // Device mode.
  enum DeviceMode {
    UNKNOWN_MODE = 0;
    // Lid is closed.
    CLOSED_LID = 1;
    // Lid is open, tablet mode is off or unsupported.
    CLAMSHELL = 2;
    // LID is open, tablet mode is on or no lid at all.
    TABLET = 3;
  }
  optional DeviceMode device_mode = 16;

  optional float battery_level = 17;
  optional bool on_battery = 18;

  // Region and languages. We will use country code for region and IETF language
  // tags for languages.
  // TODO(jiameng): we may revise this after experimentations.
  optional string region = 19;
  repeated string languages = 20;

  // Whether user/device is managed.
  enum ManagementType {
    UNKNOWN_TYPE = 0;
    MANAGED = 1;
    UNMANAGED = 2;
  }
  optional ManagementType user_management = 21;
  optional ManagementType device_management = 22;

  // Whether network is connected.
  optional bool is_online = 23;
}
