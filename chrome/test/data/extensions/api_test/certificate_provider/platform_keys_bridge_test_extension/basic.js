// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The URL will be ".../main.html?testCase#param", so the test case to run is
// transported as |location.search| and an (optional) parameter, such as the
// hash function to use, is transported as |location.hash|.
var selectedTestCase = location.search.slice(1);
var testCaseParameter;
if (location.hash) {
  testCaseParameter = location.hash.slice(1);
}

console.log('[SELECTED TEST CASE] ' + selectedTestCase);

var assertEq = chrome.test.assertEq;
var assertTrue = chrome.test.assertTrue;
var assertFalse = chrome.test.assertFalse;
var assertNoLastError = chrome.test.assertNoLastError;
var assertLastError = chrome.test.assertLastError;
var fail = chrome.test.fail;
var succeed = chrome.test.succeed;
var callbackPass = chrome.test.callbackPass;
var callbackFail = chrome.test.callbackFail;

// Each value is the path to a file in this extension's folder that will be
// loaded and replaced by a Uint8Array in the setUp() function below.
var data = {
  // DER-encoded DistinguishedName of issuer of root1_l1_leaf_cert.
  // Synchronized with certificateProvider test extension using
  // sync_cert_and_issuer.sh .
  // Note that this certificate is adverties ad supporting SHA-1 only by the
  // certificate_provider test_extension.
  root1_l1_leaf_cert_issuer: 'root1_l1_leaf_issuer_dn.der',

  // X.509 certificate expected to be returned from certificateProvider when
  // filtering by root1_l1_leaf_cert_issuer.
  // Synchronized with certificateProvider test extension using
  // sync_cert_and_issuer.sh .
  root1_l1_leaf_cert: 'root1_l1_leaf.der',

  // DER-encoded DistinguishedName of issuer of root2_l1_leaf_cert.
  // Synchronized with certificateProvider test extension using
  // sync_cert_and_issuer.sh .
  // Note that this certificate is advertised as supporting SHA-1, SHA-256,
  root2_l1_leaf_cert_issuer: 'root2_l1_leaf_issuer_dn.der',

  // X.509 certificate expected to be returned from certificateProvider when
  // filtering by root2_l1_leaf_cert_issuer.
  // Synchronized with certificateProvider test extension using
  // sync_cert_and_issuer.sh .
  root2_l1_leaf_cert: 'root2_l1_leaf.der',

  // The string "hello world".
  // Generated by sync_cert_and_issuer.sh .
  data_to_sign: 'data_to_sign',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-1 as the hash function.
  // Generated by sync_cert_and_issuer.sh .
  data_signature_sha1_pkcs: 'data_signature_sha1_pkcs',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-256 as the hash function.
  // Generated by sync_cert_and_issuer.sh .
  data_signature_sha256_pkcs: 'data_signature_sha256_pkcs',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-384 as the hash function.
  // Generated by sync_cert_and_issuer.sh .
  data_signature_sha384_pkcs: 'data_signature_sha384_pkcs',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-512 as the hash function.
  // Generated by sync_cert_and_issuer.sh .
  data_signature_sha512_pkcs: 'data_signature_sha512_pkcs'
};

// Reads the binary file at |path| and passes it as a Uint8Array to |callback|.
function readFile(path, callback) {
  var oReq = new XMLHttpRequest();
  oReq.responseType = 'arraybuffer';
  oReq.open('GET', path, true /* asynchronous */);
  oReq.onload = function() {
    var arrayBuffer = oReq.response;
    if (arrayBuffer) {
      callback(new Uint8Array(arrayBuffer));
    } else {
      callback(null);
    }
  };
  oReq.send(null);
}

// For each key in dictionary, replaces the path dictionary[key] by the content
// of the resource located at that path stored in a Uint8Array.
function readData(dictionary, callback) {
  var keys = Object.keys(dictionary);
  function recurse(index) {
    if (index >= keys.length) {
      callback();
      return;
    }
    var key = keys[index];
    var path = dictionary[key];
    readFile(path, function(array) {
      assertTrue(!!array);
      dictionary[key] = array;
      recurse(index + 1);
    });
  }

  recurse(0);
}

// Some array comparison. Note: not lexicographical!
function compareArrays(array1, array2) {
  if (array1.length < array2.length)
    return -1;
  if (array1.length > array2.length)
    return 1;
  for (var i = 0; i < array1.length; i++) {
    if (array1[i] < array2[i])
      return -1;
    if (array1[i] > array2[i])
      return 1;
  }
  return 0;
}

function chooseExpectedSignature(hashAlgorithm) {
  switch (hashAlgorithm.toLowerCase()) {
    case 'sha-1':
      return data.data_signature_sha1_pkcs;
    case 'sha-256':
      return data.data_signature_sha256_pkcs;
    case 'sha-384':
      return data.data_signature_sha384_pkcs;
    case 'sha-512':
      return data.data_signature_sha512_pkcs;
  }
  chrome.test.fail('Unsupported hash algorithm: ' + hashAlgorithm);
}

function testBasic() {
  // For testBasic, the testCaseParameter is the hash algorithm to be used.
  var hashAlgorithm = testCaseParameter;
  var expectedSignature = chooseExpectedSignature(hashAlgorithm);

  var certificateSelectRequest = {
    certificateTypes: [],
    certificateAuthorities: [data.root2_l1_leaf_cert_issuer.buffer]
  };

  var selectDetails = {interactive: true, request: certificateSelectRequest};
  chrome.platformKeys.selectClientCertificates(
      selectDetails, function(matches) {
        assertEq(1, matches.length, 'Expected exactly 1 matched certificate.');
        var match = matches[0];
        assertEq(data.root2_l1_leaf_cert, new Uint8Array(match.certificate));
        var expectedAlgorithm = {
          modulusLength: 2048,
          name: 'RSASSA-PKCS1-v1_5',
          publicExponent: new Uint8Array([0x01, 0x00, 0x01])
        };
        assertEq(
            expectedAlgorithm, match.keyAlgorithm,
            'Member algorithm of Match does not equal the expected algorithm')
        chrome.test.sendMessage('Matched expected certificate');

        var keyParams = {
          name: 'RSASSA-PKCS1-v1_5',
          // Algorithm names are case-insensitive.
          hash: {name: hashAlgorithm}
        };
        var signParams = {
          // Algorithm names are case-insensitive.
          name: 'RSASSA-Pkcs1-v1_5'
        };

        chrome.platformKeys.getKeyPair(
            match.certificate, keyParams, function(publicKey, privateKey) {
              assertNoLastError();
              chrome.test.sendMessage('Got keypair');
              chrome.platformKeys.subtleCrypto()
                  .sign(signParams, privateKey, data.data_to_sign)
                  .then(function(signature) {
                    var actualSignature = new Uint8Array(signature);
                    assertTrue(
                        compareArrays(expectedSignature, actualSignature) == 0,
                        'Incorrect signature');
                    chrome.test.sendMessage('Accepted signature');
                  })
            });
      });
}

function runTestHashNotSupported(
    cert_issuer_buffer, expected_cert, hash_to_use) {
  var certificateSelectRequest = {
    certificateTypes: [],
    certificateAuthorities: [cert_issuer_buffer]
  };

  var selectDetails = {interactive: true, request: certificateSelectRequest};
  chrome.platformKeys.selectClientCertificates(
      selectDetails, function(matches) {
        assertEq(1, matches.length, 'Expected exactly 1 matched certificate.');
        var match = matches[0];
        assertEq(expected_cert, new Uint8Array(match.certificate));
        chrome.test.sendMessage('Matched expected certificate');

        var keyParams = {
          name: 'RSASSA-PKCS1-v1_5',
          // Algorithm names are case-insensitive.
          hash: {name: hash_to_use}
        };

        chrome.platformKeys.getKeyPair(
            match.certificate, keyParams, function(publicKey, privateKey) {
              assertLastError('Hash not supported.');
              chrome.test.sendMessage('getKeyPair error');
            });
      });
}
function testWrongHash() {
  runTestHashNotSupported(
      data.root1_l1_leaf_cert_issuer.buffer, data.root1_l1_leaf_cert,
      'Sha-256');
}

function testHashNoneNotSupported() {
  runTestHashNotSupported(
      data.root2_l1_leaf_cert_issuer.buffer, data.root2_l1_leaf_cert, 'none');
}

var testCases = {
  basic: testBasic,
  wrongHash: testWrongHash,
  hashNoneNotSupported: testHashNoneNotSupported,
};

// Reads in data stored in files, then calls the selected test case.
readData(data, testCases[selectedTestCase]);
