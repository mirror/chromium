// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

// The URL will be ".../basic.html?testCase#param", so the test case to run is
// transported as |location.search| and an (optional) parameter, such as the
// hash function to use, is transported as |location.hash|.
var selectedTestCase = location.search.slice(1);
var testCaseParameter;
if (location.hash) {
  testCaseParameter = location.hash.slice(1);
}

console.log('[SELECTED TEST CASE] ' + selectedTestCase);

var assertEq = chrome.test.assertEq;
var assertTrue = chrome.test.assertTrue;
var assertFalse = chrome.test.assertFalse;
var assertNoLastError = chrome.test.assertNoLastError;
var assertLastError = chrome.test.assertLastError;
var fail = chrome.test.fail;
var succeed = chrome.test.succeed;
var callbackPass = chrome.test.callbackPass;
var callbackFail = chrome.test.callbackFail;

// Each value is the path to a file in this extension's folder that will be
// loaded and replaced by a Uint8Array in the setUp() function below.
var data = {
  // DER-encoded DistinguishedName of issuer of root1_l1_leaf_cert.
  // Generated by create_test_certs.sh.
  // Note that this certificate is advertied as supporting SHA-1 only by the
  // certificate_provider test_extension.
  root1_l1_leaf_cert_issuer: 'root1_l1_leaf_issuer_dn.der',

  // X.509 certificate expected to be returned from certificateProvider when
  // filtering by root1_l1_leaf_cert_issuer.
  // Generated by create_test_certs.sh.
  root1_l1_leaf_cert: 'root1_l1_leaf.der',

  // X.509 certificate expected to be not available throgh the platformKeys API.
  // Generated by create_test_certs.sh.
  root1_l1_leaf_other_cert: 'root1_l1_leaf_other.der',

  // DER-encoded DistinguishedName of issuer of root2_l1_leaf_cert.
  // Generated by create_test_certs.sh.
  // Note that this certificate is advertised as supporting SHA-1, SHA-256,
  root2_l1_leaf_cert_issuer: 'root2_l1_leaf_issuer_dn.der',

  // X.509 certificate expected to be returned from certificateProvider when
  // filtering by root2_l1_leaf_cert_issuer.
  // Generated by create_test_certs.sh.
  root2_l1_leaf_cert: 'root2_l1_leaf.der',

  // The string "hello world".
  // Generated by create_test_certs.sh.
  data_to_sign: 'data_to_sign',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-1 as the hash function.
  // Generated by create_test_certs.sh.
  data_signature_sha1_pkcs: 'data_signature_sha1_pkcs',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-256 as the hash function.
  // Generated by create_test_certs.sh.
  data_signature_sha256_pkcs: 'data_signature_sha256_pkcs',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-384 as the hash function.
  // Generated by create_test_certs.sh.
  data_signature_sha384_pkcs: 'data_signature_sha384_pkcs',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with
  // root2_l1_leaf_cert,
  // using SHA-512 as the hash function.
  // Generated by create_test_certs.sh.
  data_signature_sha512_pkcs: 'data_signature_sha512_pkcs'
};

// Reads the binary file at |path| and passes it as a Uint8Array to |callback|.
function readFile(path, callback) {
  var oReq = new XMLHttpRequest();
  oReq.responseType = 'arraybuffer';
  oReq.open('GET', path, true /* asynchronous */);
  oReq.onload = function() {
    var arrayBuffer = oReq.response;
    if (arrayBuffer) {
      callback(new Uint8Array(arrayBuffer));
    } else {
      callback(null);
    }
  };
  oReq.send(null);
}

// For each key in dictionary, replaces the path dictionary[key] by the content
// of the resource located at that path stored in a Uint8Array.
function readData(dictionary, callback) {
  var keys = Object.keys(dictionary);
  function recurse(index) {
    if (index >= keys.length) {
      callback();
      return;
    }
    var key = keys[index];
    var path = dictionary[key];
    readFile(path, function(array) {
      assertTrue(!!array);
      dictionary[key] = array;
      recurse(index + 1);
    });
  }

  recurse(0);
}

function chooseExpectedSignature(hashAlgorithm) {
  switch (hashAlgorithm.toLowerCase()) {
    case 'sha-1':
      return data.data_signature_sha1_pkcs;
    case 'sha-256':
      return data.data_signature_sha256_pkcs;
    case 'sha-384':
      return data.data_signature_sha384_pkcs;
    case 'sha-512':
      return data.data_signature_sha512_pkcs;
  }
  chrome.test.fail('Unsupported hash algorithm: ' + hashAlgorithm);
}

function testBasic() {
  // For testBasic, the testCaseParameter is the hash algorithm to be used.
  var hashAlgorithm = testCaseParameter;
  var expectedSignature = chooseExpectedSignature(hashAlgorithm);

  var certificateSelectRequest = {
    certificateTypes: [],
    certificateAuthorities: [data.root2_l1_leaf_cert_issuer.buffer]
  };

  var selectDetails = {interactive: true, request: certificateSelectRequest};
  chrome.platformKeys.selectClientCertificates(
      selectDetails, function(matches) {
        assertEq(1, matches.length, 'Expected exactly 1 matched certificate.');
        var match = matches[0];
        assertEq(data.root2_l1_leaf_cert, new Uint8Array(match.certificate));
        var expectedAlgorithm = {
          modulusLength: 2048,
          name: 'RSASSA-PKCS1-v1_5',
          publicExponent: new Uint8Array([0x01, 0x00, 0x01])
        };
        assertEq(
            expectedAlgorithm, match.keyAlgorithm,
            'Member algorithm of Match does not equal the expected algorithm')
        chrome.test.sendMessage('Matched expected certificate', function() {

          var keyParams = {
            name: 'RSASSA-PKCS1-v1_5',
            // Algorithm names are case-insensitive.
            hash: {name: hashAlgorithm}
          };
          var signParams = {
            // Algorithm names are case-insensitive.
            name: 'RSASSA-Pkcs1-v1_5'
          };

          chrome.platformKeys.getKeyPair(
              match.certificate, keyParams, function(publicKey, privateKey) {
                assertNoLastError();
                chrome.test.sendMessage('Got keypair', function() {
                  chrome.platformKeys.subtleCrypto()
                      .sign(signParams, privateKey, data.data_to_sign)
                      .then(
                          function(signature) {
                            var actualSignature = new Uint8Array(signature);
                            assertEq(
                                expectedSignature, actualSignature,
                                'Incorrect signature');
                            chrome.test.sendMessage('Accepted signature');
                          },
                          function(error) {
                            chrome.test.sendMessage('Sign operation failed');
                          });
                });
              });
        });
      });
}

function runTestHashNotSupported(
    certIssuerBuffer, expectedCert, hashAlgorithm) {
  var certificateSelectRequest = {
    certificateTypes: [],
    certificateAuthorities: [certIssuerBuffer]
  };

  var selectDetails = {interactive: true, request: certificateSelectRequest};
  chrome.platformKeys.selectClientCertificates(
      selectDetails, function(matches) {
        assertEq(1, matches.length, 'Expected exactly 1 matched certificate.');
        var match = matches[0];
        assertEq(expectedCert, new Uint8Array(match.certificate));
        chrome.test.sendMessage('Matched expected certificate', function() {

          var keyParams = {
            name: 'RSASSA-PKCS1-v1_5',
            // Algorithm names are case-insensitive.
            hash: {name: hashAlgorithm}
          };

          chrome.platformKeys.getKeyPair(
              match.certificate, keyParams, function(publicKey, privateKey) {
                assertLastError('Hash not supported.');
                chrome.test.sendMessage('getKeyPair error');
              });
        });
      });
}

function testWrongHash() {
  runTestHashNotSupported(
      data.root1_l1_leaf_cert_issuer.buffer, data.root1_l1_leaf_cert,
      'Sha-256');
}

function testHashNoneNotSupported() {
  runTestHashNotSupported(
      data.root2_l1_leaf_cert_issuer.buffer, data.root2_l1_leaf_cert, 'none');
}

function testInvalidCert() {
  var keyParams = {
    name: 'RSASSA-PKCS1-v1_5',
    // Algorithm names are case-insensitive.
    hash: {name: 'sha-256'}
  };

  var certificate = new Uint8Array([1, 2, 3]).buffer;
  chrome.platformKeys.getKeyPair(
      data.root1_l1_leaf_other_cert.buffer, keyParams,
      function(publicKey, privateKey) {
        assertLastError('Key not found.');
        chrome.test.sendMessage('getKeyPair error');
      });
}

var testCases = {
  basic: testBasic,
  wrongHash: testWrongHash,
  hashNoneNotSupported: testHashNoneNotSupported,
  invalidCert: testInvalidCert,
};

// Reads in data stored in files, then calls the selected test case.
readData(data, testCases[selectedTestCase]);
