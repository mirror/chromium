// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var selectedTestCase = location.hash.slice(1);
console.log('[SELECTED TEST CASE] ' + selectedTestCase);

var assertEq = chrome.test.assertEq;
var assertTrue = chrome.test.assertTrue;
var assertFalse = chrome.test.assertFalse;
var assertNoLastError = chrome.test.assertNoLastError;
var assertLastError = chrome.test.assertLastError;
var fail = chrome.test.fail;
var succeed = chrome.test.succeed;
var callbackPass = chrome.test.callbackPass;
var callbackFail = chrome.test.callbackFail;

// Each value is the path to a file in this extension's folder that will be
// loaded and replaced by a Uint8Array in the setUp() function below.
var data = {
  // X.509 certificate expected to be returned from certificateProvider.
  // Synchronized with certificateProvider test extension using
  // sync_cert_and_issuer.sh .
  l1_leaf_cert: 'l1_leaf.der',

  // DER-encoded DistinguishedName of issuer of l1_leaf_cert.
  // Synchronized with certificateProvider test extension using
  // sync_cert_and_issuer.sh .
  l1_leaf_cert_issuer: 'l1_leaf_issuer_dn.der',

  // The string "hello world".
  // Generated by sync_cert_and_issuer.sh .
  data_to_sign: 'data_to_sign',

  // A signature of data_to_sign using RSASSA-PKCS1-v1_5 with l1_leaf_Cert,
  // using SHA-1 as the hash function.
  // Generated by sync_cert_and_issuer.sh .
  data_signature_sha1_pkcs: 'data_signature_sha1_pkcs'
};

// Reads the binary file at |path| and passes it as a Uint8Array to |callback|.
function readFile(path, callback) {
  var oReq = new XMLHttpRequest();
  oReq.responseType = 'arraybuffer';
  oReq.open('GET', path, true /* asynchronous */);
  oReq.onload = function() {
    var arrayBuffer = oReq.response;
    if (arrayBuffer) {
      callback(new Uint8Array(arrayBuffer));
    } else {
      callback(null);
    }
  };
  oReq.send(null);
}

// For each key in dictionary, replaces the path dictionary[key] by the content
// of the resource located at that path stored in a Uint8Array.
function readData(dictionary, callback) {
  var keys = Object.keys(dictionary);
  function recurse(index) {
    if (index >= keys.length) {
      callback();
      return;
    }
    var key = keys[index];
    var path = dictionary[key];
    readFile(path, function(array) {
      assertTrue(!!array);
      dictionary[key] = array;
      recurse(index + 1);
    });
  }

  recurse(0);
}

// Some array comparison. Note: not lexicographical!
function compareArrays(array1, array2) {
  if (array1.length < array2.length)
    return -1;
  if (array1.length > array2.length)
    return 1;
  for (var i = 0; i < array1.length; i++) {
    if (array1[i] < array2[i])
      return -1;
    if (array1[i] > array2[i])
      return 1;
  }
  return 0;
}

function testBasic() {
  var certificateSelectRequest = {
    certificateTypes: [],
    certificateAuthorities: [data.l1_leaf_cert_issuer.buffer]
  };

  var selectDetails = {interactive: true, request: certificateSelectRequest};
  chrome.platformKeys.selectClientCertificates(
      selectDetails, function(matches) {
        assertEq(1, matches.length, 'Expected exactly 1 matched certificate.');
        var match = matches[0];
        assertEq(data.l1_leaf_cert, new Uint8Array(match.certificate));
        var expectedAlgorithm = {
          modulusLength: 2048,
          name: 'RSASSA-PKCS1-v1_5',
          publicExponent: new Uint8Array([0x01, 0x00, 0x01])
        };
        assertEq(
            expectedAlgorithm, match.keyAlgorithm,
            'Member algorithm of Match does not equal the expected algorithm')
        chrome.test.sendMessage('Matched expected certificate');

        var keyParams = {
          name: 'RSASSA-PKCS1-v1_5',
          // Algorithm names are case-insensitive.
          hash: {name: 'Sha-1'}
        };
        var signParams = {
          // Algorithm names are case-insensitive.
          name: 'RSASSA-Pkcs1-v1_5'
        };

        chrome.platformKeys.getKeyPair(
            match.certificate, keyParams, function(publicKey, privateKey) {
              assertNoLastError();
              chrome.test.sendMessage('Got keypair');
              chrome.platformKeys.subtleCrypto()
                  .sign(signParams, privateKey, data.data_to_sign)
                  .then(function(signature) {
                    var actualSignature = new Uint8Array(signature);
                    assertTrue(
                        compareArrays(
                            data.data_signature_sha1_pkcs, actualSignature) ==
                            0,
                        'Incorrect signature');
                    chrome.test.sendMessage('Accepted signature');
                  })
            });
      });
}

function testWrongHash() {
  var certificateSelectRequest = {
    certificateTypes: [],
    certificateAuthorities: [data.l1_leaf_cert_issuer.buffer]
  };

  var selectDetails = {interactive: true, request: certificateSelectRequest};
  chrome.platformKeys.selectClientCertificates(
      selectDetails, function(matches) {
        assertEq(1, matches.length, 'Expected exactly 1 matched certificate.');
        var match = matches[0];
        assertEq(data.l1_leaf_cert, new Uint8Array(match.certificate));
        chrome.test.sendMessage('Matched expected certificate');

        var keyParams = {
          name: 'RSASSA-PKCS1-v1_5',
          // Algorithm names are case-insensitive.
          hash: {name: 'Sha-256'}
        };
        var signParams = {
          // Algorithm names are case-insensitive.
          name: 'RSASSA-Pkcs1-v1_5'
        };

        chrome.platformKeys.getKeyPair(
            match.certificate, keyParams, function(publicKey, privateKey) {
              assertLastError('Hash not supported.');
              chrome.test.sendMessage('getKeyPair error');
            });
      });
}

var testCases = {
  basic: testBasic,
  wrongHash: testWrongHash,
};

// Reads in data stored in files, then calls the selected test case.
readData(data, testCases[selectedTestCase]);
