// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

var assertEq = chrome.test.assertEq;
var assertTrue = chrome.test.assertTrue;
var callbackPass = chrome.test.callbackPass;
var succeed = chrome.test.succeed;

// X.509 certificate in DER encoding issued by 'root1.pem' which is set to be
// trusted by the test setup.
// Read from 'root1_l1_leaf1.der', generated by create_test_certs.sh .
var root1_l1_leaf_cert = null;

// X.509 certificate in DER encoding issued by 'root2.pem' which is set to be
// trusted by the test setup.
// Read from 'root2_l1_leaf1.der', generated by create_test_certs.sh .
var root2_l1_leaf_cert = null;

// Reads the binary file at |path| and passes it as a Uint8Array to |callback|.
function readFile(path, callback) {
  var oReq = new XMLHttpRequest();
  oReq.responseType = "arraybuffer";
  oReq.open("GET", path, true /* asynchronous */);
  oReq.onload = function() {
    var arrayBuffer = oReq.response;
    if (arrayBuffer) {
      callback(new Uint8Array(arrayBuffer));
    } else {
      callback(null);
    }
  };
  oReq.send(null);
}

function compareBuffers(a, b) {
  if (a.length != b.length)
    return false;
  for (var i = 0; i < a.length; i++) {
    if (a[i] != b[i])
      return false;
  }
  return true;
}

var signDigestRequest;
var signCallback;

function register() {
  assertTrue(!!chrome.certificateProvider);
  assertTrue(!!chrome.certificateProvider.onCertificatesRequested);
  assertTrue(!!chrome.certificateProvider.onSignDigestRequested);

  var validRoot1CertInfo = {
    certificate: root1_l1_leaf_cert.buffer,
    supportedHashes: ['SHA1']
  };
  var validRoot2CertInfo = {
    certificate: root2_l1_leaf_cert.buffer,
    supportedHashes: ['SHA1', 'SHA256', 'SHA384', 'SHA512', 'MD5_SHA1']
  };
  var invalidCert = new Uint8Array([1, 2, 3, 4, 5]);
  var invalidCertInfo = {
    certificate: invalidCert.buffer,
    supportedHashes: ['SHA256']
  };

  function checkResult(rejectedCerts) {
    assertEq(1, rejectedCerts.length);
    assertTrue(compareBuffers(invalidCert, new Uint8Array(rejectedCerts[0])));
  }

  function reportCertificates(reportCallback) {
    reportCallback(
        [validRoot1CertInfo, validRoot2CertInfo, invalidCertInfo],
        callbackPass(checkResult));
  }

  chrome.certificateProvider.onCertificatesRequested.addListener(
      callbackPass(reportCertificates));

  chrome.certificateProvider.onSignDigestRequested.addListener(function(
      request, callback) {
    var selectedCertInfo;
    if (compareBuffers(
            root1_l1_leaf_cert, new Uint8Array(request.certificate))) {
      selectedCertInfo = validRoot1CertInfo;
    } else if (compareBuffers(
                   root2_l1_leaf_cert, new Uint8Array(request.certificate))) {
      selectedCertInfo = validRoot2CertInfo;
    } else {
      fail('Unknown certificate passed to onSignDigestRequeted.');
      return;
    }
    // The sign request must refer to one of the hashes that were declared as
    // supported.
    assertTrue(selectedCertInfo.supportedHashes.includes(request.hash));
    signCallback = callback;
    signDigestRequest = request;
    succeed();
  });

  succeed();
}

function replyWithSignature(signature) {
  signCallback(signature.buffer);
}

function replyWithSignatureSecondTime() {
  var signature = new Uint8Array([1,2,3]);
  try {
    signCallback(signature.buffer);
  } catch (e) {
    return true;
  }
  return false;
}

function runTest() {
  chrome.test.runTests([register]);
}

readFile('root1_l1_leaf.der', function(read_root1_l1_leaf_cert) {
  root1_l1_leaf_cert = read_root1_l1_leaf_cert;
  readFile('root2_l1_leaf.der', function(read_root2_l1_leaf_cert) {
    root2_l1_leaf_cert = read_root2_l1_leaf_cert;
    runTest();
  });
});
