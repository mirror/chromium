// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Accessibility Test API
 */

 /**
 * @typedef {{
 *  runOnly: {
 *    type: string,
 *    values: Array<string>
 *  }
 * }}
 * @see https://github.com/dequelabs/axe-core/blob/develop/doc/API.md#options-parameter
 */
AccessibilityTest.AuditOptions;

/**
 * @typedef {{
 *   name: string,
 *   auditOptions: ?AccessibilityTest.AuditOptions,
 *   setup: ?function,
 *   tests: Object<string, function(): Promise>
 * }}
 */
AccessibilityTest.Definition;

/**
 * Accessibility Test
 * @namespace
 */
function AccessibilityTest() {}

/**
 * Hard-coded list of audit rule ids from the aXe-core audit.
 *
 * This list is generated by pasting the third_party/axe-core/axe.js code into
 * the browser console and running:
 * axe.getRules().map(function(ruleObj) {
 *   return ruleObj.ruleId
 * });
 *
 * Aforementioned code cannot be run in the file because during build time,
 * js2gtest.js evals the file without any dependencies. At
 * this point, not even a browser window exists. Thus, axe can only be
 * referenced during runtime within the TEST_F call.
 */
AccessibilityTest.ruleIds = [
  'accesskeys',
  'area-alt',
  'aria-allowed-attr',
  'aria-hidden-body',
  'aria-required-attr',
  'aria-required-children',
  'aria-required-parent',
  'aria-roles',
  'aria-valid-attr-value',
  'aria-valid-attr',
  'audio-caption',
  'blink',
  'button-name',
  'bypass',
  'checkboxgroup',
  'color-contrast',
  'definition-list',
  'dlitem',
  'document-title',
  'duplicate-id',
  'empty-heading',
  'frame-title-unique',
  'frame-title',
  'heading-order',
  'hidden-content',
  'href-no-hash',
  'html-has-lang',
  'html-lang-valid',
  'image-alt',
  'image-redundant-alt',
  'input-image-alt',
  'label-title-only',
  'label',
  'layout-table',
  'link-in-text-block',
  'link-name',
  'list',
  'listitem',
  'marquee',
  'meta-refresh',
  'meta-viewport-large',
  'meta-viewport',
  'object-alt',
  'p-as-heading',
  'radiogroup',
  'region',
  'scope-attr-valid',
  'server-side-image-map',
  'skip-link',
  'tabindex',
  'table-duplicate-name',
  'table-fake-caption',
  'td-has-header',
  'td-headers-attr',
  'th-has-data-cells',
  'valid-lang',
  'video-caption',
  'video-description'
];

/**
 * Run aXe-core accessibility audit, print console-friendly representation
 * of violations to console, and fail the test.
 * @param {AccessibilityTest.AuditOptions} options Dictionary disabling specific
 *    audit rules.
 * @return {Promise} A promise that will be resolved with the accessibility
 *    audit is complete.
 */
AccessibilityTest.runAudit = function(options) {
  // Ignore iron-iconset-svg elements that have duplicate ids and result in
  // false postives from the audit.
  var context = {
    exclude: ['iron-iconset-svg']
  };
  options = options || {};

  return new Promise(function(resolve, reject) {
    axe.run(context, options, function(err, results) {
      if (err) reject(err);

      var violationCount = results.violations.length;
      if (violationCount) {
        // Pretty print out the violations detected by the audit.
        console.log(JSON.stringify(results.violations, null, 4));
        reject('Found ' + violationCount + ' accessibility violations.');
      } else {
        resolve();
      }
    });
  });
};

/**
 * Define mocha suite(s). If the ||runOnly|| attribute of ||test.auditOptions||
 * is not defined, generate a test suite for every audit rule. Otherwise, define
 * a single test suite with the provided options.
 * @param {AccessibilityTestDefinition} test Object configuring the test.
 * @constructor
 */
AccessibilityTest.define = function(test) {
  var axeConfig = test.auditOptions || {};
  // Maintain a list of test definitions to define using Mocha.
  var tests = [test];

  // This option override should go first b/c it creates multiple test targets.
  if (!axeConfig.runOnly) {
    tests = [];
    // Define a mocha suite to run each audit rule separately.
    for (let ruleId of AccessibilityTest.ruleIds) {
      var newTestDefinition = Object.assign({}, test);
      newTestDefinition.name = test.name + '_' + ruleId;
      newTestDefinition.auditOptions = Object.assign({}, axeConfig)
      newTestDefinition.auditOptions.runOnly = {
        type: 'rule',
        values: [ruleId]
      };

      tests.push(newTestDefinition)
    }
  }

  // Add more overrides of the audit options here if necessary in the future.
  AccessibilityTest.defineAccessibilityTestSuite_(tests);
}

/**
 * Defines mocha suite(s) testing accessibility for each test definition in
 * given list. If the ||runOnly|| attribute of ||test.auditOptions|| is not
 * defined, generate a test suite for every audit rule. Otherwise, define a
 * single test suite with the provided options.
 * @param {Array<AccessibilityTestDefinition>} List of test definitions.
 */
AccessibilityTest.defineAccessibilityTestSuite_= function(tests) {
  for (let testDef of tests) {
    suite(testDef.name, function() {
      setup(testDef.setup);
      for (var testMember in testDef.tests) {
        test(testMember, AccessibilityTest.getMochaTest(testMember, testDef));
      }
    });
  }
}

/**
 *
 * Return a function that runs the accessibility audit after executing the
 * function corresponding to the ||testMember|| attribute of ||testDef||.
 * @param {string} testMember The name of the mocha test
 * @param {AccessibilityTestDefinition} testDef Object configuring the test
 *    suite to which this test belongs.
 */
AccessibilityTest.getMochaTest = function(testMember, testDef) {
  // Run commands specified by the test definition followed by the
  // accessibility audit.
  return function() {
    var promise = testDef.tests[testMember]();
    if (promise) {
      return promise.then(function() {
        return AccessibilityTest.runAudit(testDef.auditOptions);
      });
    } else {
      return AccessibilityTest.runAudit(testDef.auditOptions);
    }
  };
};

