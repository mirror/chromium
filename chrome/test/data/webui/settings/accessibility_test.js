// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Accessibility Test API
 */

/**
 * Accessibility Test
 * @namespace
 */
function AccessibilityTest() {}

/**
 * @typedef {{
 *   name: string,
 *   auditOptions: ?AccessibilityTest.AuditOptions,
 *   setup: ?function,
 *   tests: Object<string, function(): Promise>
 * }}
 */
AccessibilityTest.Definition;

/**
 * @typedef {{
 *   runOnly: {
 *     type: string,
 *     values: Array<string>
 *   }
 * }}
 * @see https://github.com/dequelabs/axe-core/blob/develop/doc/API.md#options-parameter
 */
AccessibilityTest.AuditOptions;

/**
 * @param {string} auditRuleId aXe-core audit rule ID of the rule to except
 * @param {!function(axe.NodeResult)} selector Function that returns false when
 *    the node result should be excluded from violations for the audit rule.
 * @constructor
 */
AccessibilityTest.Exception = function(auditRuleId, excluder) {
  return {
    auditRuleId: auditRuleId, excluder: excluder
  }
};

/**
 * Hard-coded list of audit rule ids from the aXe-core audit.
 *
 * This list is generated by pasting the third_party/axe-core/axe.js code into
 * the browser console and running:
 * axe.getRules().map(function(ruleObj) {
 *   return ruleObj.ruleId
 * });
 *
 * Aforementioned code cannot be run in the file because during build time,
 * js2gtest.js evals the file without any dependencies. At
 * this point, not even a browser window exists. Thus, axe can only be
 * referenced during runtime within the TEST_F call.
 */
AccessibilityTest.ruleIds = [
  'accesskeys',
  'area-alt',
  'aria-allowed-attr',
  'aria-hidden-body',
  'aria-required-attr',
  'aria-required-children',
  'aria-required-parent',
  'aria-roles',
  'aria-valid-attr-value',
  'aria-valid-attr',
  'audio-caption',
  'blink',
  'button-name',
  'bypass',
  'checkboxgroup',
  'color-contrast',
  'definition-list',
  'dlitem',
  'document-title',
  'duplicate-id',
  'empty-heading',
  'frame-title-unique',
  'frame-title',
  'heading-order',
  'hidden-content',
  'href-no-hash',
  'html-has-lang',
  'html-lang-valid',
  'image-alt',
  'image-redundant-alt',
  'input-image-alt',
  'label-title-only',
  'label',
  'layout-table',
  'link-in-text-block',
  'link-name',
  'list',
  'listitem',
  'marquee',
  'meta-refresh',
  'meta-viewport-large',
  'meta-viewport',
  'object-alt',
  'p-as-heading',
  'radiogroup',
  'region',
  'scope-attr-valid',
  'server-side-image-map',
  'skip-link',
  'tabindex',
  'table-duplicate-name',
  'table-fake-caption',
  'td-has-header',
  'td-headers-attr',
  'th-has-data-cells',
  'valid-lang',
  'video-caption',
  'video-description'
];

/**
 * Run aXe-core accessibility audit, print a console-friendly representation
 * of violations to console, and if there are violations, fail the test.
 * @param {AccessibilityTest.AuditOptions} options Dictionary disabling specific
 *    audit rules.
 * @param {Array<AccessibilityTest.Exception>} exceptions List of exceptions to
 *     exclude from audit results.
 * @return {Promise} A promise that will be resolved with the accessibility
 *    audit is complete.
 */
AccessibilityTest.runAudit = function(options, exceptions) {
  // Ignore iron-iconset-svg elements that have duplicate ids and result in
  // false postives from the audit.
  var context = {exclude: ['iron-iconset-svg']};
  options = options || {};
  // Run the audit with element references included in the results.
  options.elementRef = true;
  exceptions = exceptions || [];

  return new Promise(function(resolve, reject) {
    axe.run(context, options, function(err, results) {
      if (err)
        reject(err);

      var filteredViolations =
          AccessibilityTest.pruneExceptions_(results.violations, exceptions);

      var violationCount = filteredViolations.length;
      if (violationCount) {
        AccessibilityTest.printViolations(filteredViolations);
        reject('Found ' + violationCount + ' accessibility violations.');
      } else {
        resolve();
      }
    });
  });
};

/**
 * Get list of audit violations that excludes given exceptions.
 * @param {!Array<axe.Result>} violations List of accessibility violations.
 * @param {!Array<AccessibilityTest.Exception>} exceptions List of exceptions
 *    to prune from the results.
 * @return {!Array<axe.Result>} List of violations that do not
 *    match those described by exceptions.
 */
AccessibilityTest.pruneExceptions_ = function(violations, exceptions) {
  // Create a dictionary to map violation types to their objects
  var violationMap = {};
  for (i = 0; i < violations.length; i++) {
    violationMap[violations[i].id] = violations[i];
  }

  // Check for and remove any nodes specified as exceptions.
  for (let exception of exceptions) {
    if (exception.auditRuleId in violationMap) {
      var violation = violationMap[exception.auditRuleId];
      var filteredNodes = violation.nodes.filter(exception.excluder);
      // Abandon the violation if all of its nodes are exceptions.
      if (filteredNodes.length > 0) {
        violation.nodes = filteredNodes;
        violationMap[exception.auditRuleId].nodes = filteredNodes;
      } else
        delete violationMap[exception.auditRuleId];
    }
  }
  return Object.values(violationMap);
};

/**
 * Define mocha suite(s). If the ||runOnly|| attribute of ||test.auditOptions||
 * is not defined, generate a test suite for every audit rule. Otherwise, define
 * a single test suite with the provided options.
 * @param {AccessibilityTestDefinition} test Object configuring the test.
 * @constructor
 */
AccessibilityTest.define = function(test) {
  var axeConfig = test.auditOptions || {};
  // Maintain a list of test definitions to define using Mocha.
  var tests = [test];

  // This option override should go first b/c it creates multiple test targets.
  if (!axeConfig.runOnly) {
    tests = [];
    // Define a mocha suite to run each audit rule separately.
    for (let ruleId of AccessibilityTest.ruleIds) {
      var newTestDefinition = Object.assign({}, test);
      newTestDefinition.name = test.name + '_' + ruleId;
      newTestDefinition.auditOptions = Object.assign({}, axeConfig)
      newTestDefinition.auditOptions.runOnly = {
        type: 'rule',
        values: [ruleId]
      };

      tests.push(newTestDefinition)
    }
  }

  // Add more overrides of the audit options here if necessary in the future.
  AccessibilityTest.defineAccessibilityTestSuite_(tests);
}

/**
 * Defines mocha suite(s) testing accessibility for each test definition in
 * given list. If the ||runOnly|| attribute of ||test.auditOptions|| is not
 * defined, generate a test suite for every audit rule. Otherwise, define a
 * single test suite with the provided options.
 * @param {Array<AccessibilityTestDefinition>} List of test definitions.
 */
AccessibilityTest.defineAccessibilityTestSuite_= function(tests) {
  for (let testDef of tests) {
    suite(testDef.name, function() {
      setup(testDef.setup);
      for (var testMember in testDef.tests) {
        test(testMember, AccessibilityTest.getMochaTest(testMember, testDef));
      }
    });
  }
}

/**
 * Return a function that runs the accessibility audit after executing the
 * function corresponding to the ||testMember|| attribute of ||testDef||.
 * @param {string} testMember The name of the mocha test
 * @param {AccessibilityTestDefinition} testDef Object configuring the test
 *    suite to which this test belongs.
 */
AccessibilityTest.getMochaTest = function(testMember, testDef) {
  // Run commands specified by the test definition followed by the
  // accessibility audit.
  return function() {
    var promise = testDef.tests[testMember]();
    if (promise) {
      return promise.then(function() {
        return AccessibilityTest.runAudit(
            testDef.auditOptions, testDef.exceptions);
      });
    } else {
      return AccessibilityTest.runAudit(
          testDef.auditOptions, testDef.exceptions);
    }
  };
};

/**
 * Pretty-print violations to the console.
 * @param {!Array<axe.Result>} List of violations to display
 */
AccessibilityTest.printViolations = function(violations) {
  // Elements have circular references and must be removed before printing.
  for (let violation of violations) {
    for (let node of violation.nodes) {
      delete node['element'];
    }
  }

  console.log(JSON.stringify(violations, null, 4));
};
