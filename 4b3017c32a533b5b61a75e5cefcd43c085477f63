{
  "comments": [
    {
      "key": {
        "uuid": "4c252b72_64c8f78d",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 272,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-09-07T00:46:31Z",
      "side": 1,
      "message": "We might have a legacy IPC vs Mojo IPC ordering issue here. The intent is to wait for the IPC sent via ServiceWorkerHandle::OnVersionStateChanged() to reach the renderer first, so when .ready resolves, registration.active has \u0027activating\u0027 or \u0027activated\u0027 state. But ServiceWorkerMsg_ServiceWorkerStateChanged is still a legacy IPC message.\n\nSee also the comment in ServiceWorkerVersion::SetStatus.\n\nIs there a guaranteed ordering somehow with the associated interface stuff we\u0027ve been doing?",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "310af4f3_3f3969aa",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 272,
      "author": {
        "id": 1125915
      },
      "writtenOn": "2017-09-07T01:28:46Z",
      "side": 1,
      "message": "Pipes for SWContainer/SWContainerHost are associated with the channel, so we no longer have race between legacy IPC messages and Mojo IPC messages in my understanding:)",
      "parentUuid": "4c252b72_64c8f78d",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bfafda83_d118e3b4",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 272,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-09-07T02:01:31Z",
      "side": 1,
      "message": "Thanks, that\u0027s good to know :)",
      "parentUuid": "310af4f3_3f3969aa",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06d095ad_6e2a57a0",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1213,
      "author": {
        "id": 1125915
      },
      "writtenOn": "2017-09-07T01:28:46Z",
      "side": 1,
      "message": "You can use base::MakeUnique\u003cOneShotGetReadyCallback\u003e()",
      "range": {
        "startLine": 1213,
        "startChar": 21,
        "endLine": 1213,
        "endChar": 56
      },
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5617e0f6_161e2b58",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1213,
      "author": {
        "id": 1161621
      },
      "writtenOn": "2017-09-07T03:40:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "06d095ad_6e2a57a0",
      "range": {
        "startLine": 1213,
        "startChar": 21,
        "endLine": 1213,
        "endChar": 56
      },
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5e398380_278673a5",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1214,
      "author": {
        "id": 1125915
      },
      "writtenOn": "2017-09-07T01:28:46Z",
      "side": 1,
      "message": "Ah, we can convert this callback to OnceCallback in later patch.",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edca27f0_7de6d198",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1214,
      "author": {
        "id": 1161621
      },
      "writtenOn": "2017-09-07T03:40:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5e398380_278673a5",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "650f4cd8_82042ca9",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1241,
      "author": {
        "id": 1125915
      },
      "writtenOn": "2017-09-07T01:28:46Z",
      "side": 1,
      "message": "Do you know what happen if the connection to the renderer is destroyed just before calling callback?\nI\u0027m worried that in that case the refcount for SWRegistrationObject/SWObject will be leaked.\n\nOne possible straightforward solution would be mojoifing SWRegistrationObject/SWObject and using their error callbacks.",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9e48395_3dce9b04",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1241,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-09-07T02:01:31Z",
      "side": 1,
      "message": "Good thought. Haven\u0027t looked in detail, but how do we deal with the issue in with the non-mojofied path?",
      "parentUuid": "650f4cd8_82042ca9",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5ab5080_9bf61286",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1241,
      "author": {
        "id": 1125915
      },
      "writtenOn": "2017-09-07T02:14:35Z",
      "side": 1,
      "message": "Hmm, actually I think this is a very difficult problem to solve with the non-mojofied path...\nI\u0027m now gradually thinking we should add associated message pipes for the two objects to keep them alive before this patch.",
      "parentUuid": "d9e48395_3dce9b04",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f831079_8e5e0fdb",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1241,
      "author": {
        "id": 1161621
      },
      "writtenOn": "2017-09-07T02:42:49Z",
      "side": 1,
      "message": "Yeah, exactly it\u0027s a problem, and I suppose it is an existing problem before? Even in legacy IPC world, if an unexpected renderer crash just happened at the time point after we have incremented the refcount at line1239, renderer has no any chance sending back to browser process the DecreRefCount IPC, so the refcount for SWRegistrationObject/SWObject will be leaked.\n\nI noticed it when I was considering about SWRegistrationHost interface, and have wrote the idea at https://crbug.com/758151 to solve it, exactly the same with yours:) //Hands\n    Using SWRegistrationHost/SWHost mojo connections\u0027 error handlers to count the references of SWRegistrationObject/SWObject.\n\nI\u0027m planning to do that work right after this CL :)",
      "parentUuid": "f5ab5080_9bf61286",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7eebc6e_d85f57c9",
        "filename": "content/browser/service_worker/service_worker_provider_host.cc",
        "patchSetId": 1
      },
      "lineNbr": 1241,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-09-11T06:33:48Z",
      "side": 1,
      "message": "I think the non-mojofied path handles this by SWDispatcherHost() being destroyed, which destroys all the SWHandles? In which case, the mojo-path also handles this, since dispatcher host still owns our Handles?",
      "parentUuid": "5f831079_8e5e0fdb",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce84b8ba_a3533140",
        "filename": "content/browser/service_worker/service_worker_provider_host.h",
        "patchSetId": 1
      },
      "lineNbr": 343,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-09-07T02:01:31Z",
      "side": 1,
      "message": "I feel having both GetRegistrationForReadyCompleteCallback and GetRegistrationForReadyCallback is getting too confusing.\n\nThis whole OneShotGetReadyCallback() is a bit suspect. We already have OnceCallback which should guarantee \"one-shot\".\n\nCould we do some better refactoring here? If this struct just has a `base::OnceCallback\u003c\u003e callback`, do we need bool |called|? After running the callback, I think if (!callback) can be used to detect the callback was called.",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33ab0dec_aa8a7ab5",
        "filename": "content/browser/service_worker/service_worker_provider_host.h",
        "patchSetId": 1
      },
      "lineNbr": 343,
      "author": {
        "id": 1161621
      },
      "writtenOn": "2017-09-07T03:40:25Z",
      "side": 1,
      "message": "Done. Yeah I should have done the small refactor from the beginning.. Thanks!",
      "parentUuid": "ce84b8ba_a3533140",
      "revId": "4b3017c32a533b5b61a75e5cefcd43c085477f63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}