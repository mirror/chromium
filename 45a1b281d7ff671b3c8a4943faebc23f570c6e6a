{
  "comments": [
    {
      "key": {
        "uuid": "e4fce81e_beeeb26f",
        "filename": "android_webview/java/src/org/chromium/android_webview/AwContents.java",
        "patchSetId": 21
      },
      "lineNbr": 396,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-09-20T04:19:13Z",
      "side": 1,
      "message": "this should be in WebContentsImpl. like I said, embedder should not know what\u0027s in the object holder",
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a0e944a_1b133431",
        "filename": "android_webview/java/src/org/chromium/android_webview/AwContents.java",
        "patchSetId": 21
      },
      "lineNbr": 396,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-09-20T06:06:12Z",
      "side": 1,
      "message": "I meant to keep this instance on the side of callsite, not passing it WebContents using object holder. The only data that WebContents needs to manage JavaBridgetHostDispatcher is retained object. In this CL WebView also keeps track of the injected objects so that it can migrate them from one to another by itself, rather than getting them back from WebContents.getJavascriptInterfaces() which I removed in this CL.",
      "parentUuid": "e4fce81e_beeeb26f",
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b75aee39_15290847",
        "filename": "android_webview/java/src/org/chromium/android_webview/AwContents.java",
        "patchSetId": 21
      },
      "lineNbr": 396,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-09-20T21:26:18Z",
      "side": 1,
      "message": "\u003e I meant to keep this instance on the side of callsite, not passing it WebContents using object holder. The only data that WebContents needs to manage JavaBridgetHostDispatcher is retained object. In this CL WebView also keeps track of the injected objects so that it can migrate them from one to another by itself, rather than getting them back from WebContents.getJavascriptInterfaces() which I removed in this CL.\n\nThat was my original comment. mJavascriptInterfaces is an implementation detail of js interface, so it should not cross the content api boundary. Either you are moving js interface from CVC to WC, in which case this should be in WC, or you can consider moving the entire js interface implementation to webview, although I\u0027m not sure if all the native hooks are there",
      "parentUuid": "5a0e944a_1b133431",
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2cbd643_484a29f5",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 53,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-09-20T04:19:13Z",
      "side": 1,
      "message": "this doesn\u0027t need to be public",
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9e850fe_520eb136",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 53,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-09-20T06:06:12Z",
      "side": 1,
      "message": "WebView uses it to populate a map (object holder), then WebContents pulls each entry out to do the appropriate task. So it should be visible to embedder. What is the structure you have in mind that doesn\u0027t need this to be public?",
      "parentUuid": "f2cbd643_484a29f5",
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69d3abc3_3d0e171b",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 480,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-09-20T04:19:13Z",
      "side": 1,
      "message": "hmm, \"setObjectHolder\" doesn\u0027t quite work, because obviously WebContentsImpl can\u0027t strongly hold the object holder either. It\u0027s going to need java delegate or something that returns the object holder on request, and might be null if underlying thing has gone away. or WebContentsImpl only holds a weakreference to the object holder.\n\nalso maybe use a sparse array instead?",
      "range": {
        "startLine": 480,
        "startChar": 25,
        "endLine": 480,
        "endChar": 28
      },
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a42f3ae6_ce95ad4c",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 480,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-09-20T06:06:12Z",
      "side": 1,
      "message": "In this CL, object holder is just a vehicle of the objects it holds. WebContents doesn\u0027t keep a reference to the holder itself. Only the entries, once pulled out, are kept and referenced weakly. My intention is to have embedder responsible for the ownership of them to guarantee they are not garbage-collected, and dispose once they\u0027re out of use.",
      "parentUuid": "69d3abc3_3d0e171b",
      "range": {
        "startLine": 480,
        "startChar": 25,
        "endLine": 480,
        "endChar": 28
      },
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0f693079_3b3911a0",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 480,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-09-20T21:26:18Z",
      "side": 1,
      "message": "\u003e In this CL, object holder is just a vehicle of the objects it holds. WebContents doesn\u0027t keep a reference to the holder itself. Only the entries, once pulled out, are kept and referenced weakly. My intention is to have embedder responsible for the ownership of them to guarantee they are not garbage-collected, and dispose once they\u0027re out of use.\n\nEmbedder can own the map, but it should not know what\u0027s in that map.\n\nAnd when WebContents wants to insert something into the map, it needs to update embedder for the map again, which doesn\u0027t work with a setter",
      "parentUuid": "a42f3ae6_ce95ad4c",
      "range": {
        "startLine": 480,
        "startChar": 25,
        "endLine": 480,
        "endChar": 28
      },
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d1ed3913_c5b13c69",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 480,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-09-20T22:25:16Z",
      "side": 1,
      "message": "Okay now I think I got your point. My line of thought was, \u0027if there\u0027s something WebContents cannot hold a strong ref to, let it be created by the embedder and pass it to WebContents\u0027 but yours is the other way around \u0027let WebContents create it and pass it to embedder upon request via API\u0027.",
      "parentUuid": "0f693079_3b3911a0",
      "range": {
        "startLine": 480,
        "startChar": 25,
        "endLine": 480,
        "endChar": 28
      },
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "415b3c19_50d18651",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 480,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-09-20T22:31:21Z",
      "side": 1,
      "message": "\u003e Okay now I think I got your point. My line of thought was, \u0027if there\u0027s something WebContents cannot hold a strong ref to, let it be created by the embedder and pass it to WebContents\u0027 but yours is the other way around \u0027let WebContents create it and pass it to embedder upon request via API\u0027.\n\nYeah, something like that.\n\nLosing static type checking though :( :( :( maybe one day I\u0027ll decide that\u0027s worse than null checks and just revert to weak jni ref",
      "parentUuid": "d1ed3913_c5b13c69",
      "range": {
        "startLine": 480,
        "startChar": 25,
        "endLine": 480,
        "endChar": 28
      },
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72b04c14_3b981d6e",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 480,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-09-20T23:10:19Z",
      "side": 1,
      "message": "\u003e And when WebContents wants to insert something into the map, it needs to update embedder for the map again, which doesn\u0027t work with a setter\n\nOne more question for clarification - for WebContents to \u0027update embedder for the map again\u0027, it sounds like then the WebContents should keep the callable (or whatever is passed from the embedder via setObjectHolder), and use it later. Wouldn\u0027t it create another reference back to WebView, which will keep gc from doing its job? \n\nThe callable I think better be for one-time use, and make sure that WebContentsImpl should be ready with all the objects inside the holder when the API is invoked so that it can(should) be called only once. Then callable might not be necessary in the first place.",
      "parentUuid": "415b3c19_50d18651",
      "range": {
        "startLine": 480,
        "startChar": 25,
        "endLine": 480,
        "endChar": 28
      },
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "131ad91d_82952973",
        "filename": "content/public/android/java/src/org/chromium/content_public/browser/WebContents.java",
        "patchSetId": 21
      },
      "lineNbr": 480,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-09-21T02:39:21Z",
      "side": 1,
      "message": "\u003e \u003e And when WebContents wants to insert something into the map, it needs to update embedder for the map again, which doesn\u0027t work with a setter\n\u003e \n\u003e One more question for clarification - for WebContents to \u0027update embedder for the map again\u0027,\n\ns/update/ask/ might be better word\n\n\u003e it sounds like then the WebContents should keep the callable (or whatever is passed from the embedder via setObjectHolder), and use it later. Wouldn\u0027t it create another reference back to WebView, which will keep gc from doing its job? \n\u003e \n\u003e The callable I think better be for one-time use, and make sure that WebContentsImpl should be ready with all the objects inside the holder when the API is invoked so that it can(should) be called only once. Then callable might not be necessary in the first place.\n\nCallable or something similar is fine. There needs to be a WeakReference somewhere, and that should probably be in android_webview code",
      "parentUuid": "72b04c14_3b981d6e",
      "range": {
        "startLine": 480,
        "startChar": 25,
        "endLine": 480,
        "endChar": 28
      },
      "revId": "45a1b281d7ff671b3c8a4943faebc23f570c6e6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}