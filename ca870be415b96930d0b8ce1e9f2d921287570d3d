{
  "comments": [
    {
      "key": {
        "uuid": "10c415d3_e9117b7c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "There is code that limits this to 1000 images, but that might be too large of a number.",
      "range": {
        "startLine": 12,
        "startChar": 57,
        "endLine": 13,
        "endChar": 18
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5885e9c_ebede05f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 24,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Link a bug, or remove this line please.",
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "956a2a86_4d7d3633",
        "filename": "cc/paint/paint_image.h",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Please document these two calls.",
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3c497db_f9424423",
        "filename": "cc/paint/paint_image.h",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Should this be renamed to id(), since you don\u0027t seem to be using the word \"stable\" in new places that reference this.",
      "range": {
        "startLine": 123,
        "startChar": 5,
        "endLine": 123,
        "endChar": 14
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7913a9c_3a1ded0f",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 1,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "2017",
      "range": {
        "startLine": 1,
        "startChar": 13,
        "endLine": 1,
        "endChar": 17
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08a18a32_9360537f",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 10,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Is there anyway to do this without introducing a singleton? This means that if compositors are sharing a process, they will all be using the same destruction tracker, which seems awkward.",
      "range": {
        "startLine": 10,
        "startChar": 30,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70f99b41_7f1fa01e",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 10,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T00:51:08Z",
      "side": 1,
      "message": "The use of the singleton was because I was relying on the destruction of the ImageFrameGenerator to clear the cache, which can be destroyed on any thread and wouldn\u0027t have access to the compositor. And it was a safe place to ensure that the image is not being referenced on the main thread or any cached recordings so we can definitely discard it.\n\nWe would have multiple compositors sharing it but I think we could also have multiple compositors sharing the same image. The ResourceCache should provide the same ImageResource for an image.\n\nBut enne@ also mentioned that it wasn\u0027t great to have the threading semantics here where we are getting notifications from any thread (because the generator can be destroyed on any thread) in this class that are getting posted back to the compositor thread using the ObserverList. The alternate would be to tie this with an object on the main thread that can get to the compositor and send a list of such images with a commit. But I\u0027m not clear on where to do that right now and if there is an object that I can clearly bound the decode\u0027s lifetime with. If this doesn\u0027t look like the right approach to do this, I can revisit once I have explored the alternatives in more detail.",
      "parentUuid": "08a18a32_9360537f",
      "range": {
        "startLine": 10,
        "startChar": 30,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "401efdb0_bf9078fd",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 10,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "\u003e The use of the singleton was because I was relying on the destruction of the ImageFrameGenerator to clear the cache, which can be destroyed on any thread and wouldn\u0027t have access to the compositor. And it was a safe place to ensure that the image is not being referenced on the main thread or any cached recordings so we can definitely discard it.\n\nTBH, I\u0027m not too worried about threading here, since the caches are already thread aware, so if you make the image destruction function be thread safe (which you did), it doesn\u0027t really matter what thread executes that, right? Maybe there is a cache destruction race?\n\n\u003e \n\u003e We would have multiple compositors sharing it but I think we could also have multiple compositors sharing the same image. The ResourceCache should provide the same ImageResource for an image.\n\nWould that be using the same ImageFrameGenerator?\n\n\u003e \n\u003e But enne@ also mentioned that it wasn\u0027t great to have the threading semantics here where we are getting notifications from any thread (because the generator can be destroyed on any thread) in this class that are getting posted back to the compositor thread using the ObserverList. The alternate would be to tie this with an object on the main thread that can get to the compositor and send a list of such images with a commit. But I\u0027m not clear on where to do that right now and if there is an object that I can clearly bound the decode\u0027s lifetime with. If this doesn\u0027t look like the right approach to do this, I can revisit once I have explored the alternatives in more detail.\n\nYour alternative would work, but I\u0027m unclear why we need to tie this to the main thread. We could opaquely tie this to any object on any thread via some sort of destruction callback that is updatable, right?\n\nWhat I mean to say is that this destruction is going to be observed by the compositor caches only and do state modifications if that image exists, so we don\u0027t really need to observe any destruction unless the cache observed the generator existence in the first place, right? If the cache observed the generator existence though, it can create a new destruction callback for that image and set it on the PaintImageGenerator (if the image is backed by one). Then it\u0027s really the PaintImageGenerator that can have the destruction callback and you avoid singletons. (I\u0027m not considering the case of multiple compositors sharing the same generator here if that\u0027s possible, but in theory it\u0027s extendable to that via a list of destruction callbacks). I\u0027m not necessarily saying this approach is better, but it seems to be more targeted than a singleton and addresses the direct case of caches observing image destruction. It\u0027s something to consider.",
      "parentUuid": "70f99b41_7f1fa01e",
      "range": {
        "startLine": 10,
        "startChar": 30,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c569b361_df9a266f",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 10,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T18:57:58Z",
      "side": 1,
      "message": "\u003e \u003e The use of the singleton was because I was relying on the destruction of the ImageFrameGenerator to clear the cache, which can be destroyed on any thread and wouldn\u0027t have access to the compositor. And it was a safe place to ensure that the image is not being referenced on the main thread or any cached recordings so we can definitely discard it.\n\u003e \n\u003e TBH, I\u0027m not too worried about threading here, since the caches are already thread aware, so if you make the image destruction function be thread safe (which you did), it doesn\u0027t really matter what thread executes that, right? Maybe there is a cache destruction race?\n\nYou\u0027re right, for the cache it shouldn\u0027t matter what thread it runs on. Just access to the cache to run the callback would need to be handled.\n\n\u003e \n\u003e \u003e \n\u003e \u003e We would have multiple compositors sharing it but I think we could also have multiple compositors sharing the same image. The ResourceCache should provide the same ImageResource for an image.\n\u003e \n\u003e Would that be using the same ImageFrameGenerator?\n\nI just tried to validate my assumption by opening multiple tabs with the same page, which I think should render in the same process but I see different resources for them for the same URL. I assumed since the MemoryCache (https://cs.chromium.org/chromium/src/third_party/WebKit/Source/platform/loader/fetch/MemoryCache.h) was a singleton in a process, we would get the same resource. Not sure what exactly is going on here.\n\n\u003e \n\u003e \u003e \n\u003e \u003e But enne@ also mentioned that it wasn\u0027t great to have the threading semantics here where we are getting notifications from any thread (because the generator can be destroyed on any thread) in this class that are getting posted back to the compositor thread using the ObserverList. The alternate would be to tie this with an object on the main thread that can get to the compositor and send a list of such images with a commit. But I\u0027m not clear on where to do that right now and if there is an object that I can clearly bound the decode\u0027s lifetime with. If this doesn\u0027t look like the right approach to do this, I can revisit once I have explored the alternatives in more detail.\n\u003e \n\u003e Your alternative would work, but I\u0027m unclear why we need to tie this to the main thread. We could opaquely tie this to any object on any thread via some sort of destruction callback that is updatable, right?\n\u003e \n\u003e What I mean to say is that this destruction is going to be observed by the compositor caches only and do state modifications if that image exists, so we don\u0027t really need to observe any destruction unless the cache observed the generator existence in the first place, right? If the cache observed the generator existence though, it can create a new destruction callback for that image and set it on the PaintImageGenerator (if the image is backed by one). Then it\u0027s really the PaintImageGenerator that can have the destruction callback and you avoid singletons. (I\u0027m not considering the case of multiple compositors sharing the same generator here if that\u0027s possible, but in theory it\u0027s extendable to that via a list of destruction callbacks). I\u0027m not necessarily saying this approach is better, but it seems to be more targeted than a singleton and addresses the direct case of caches observing image destruction. It\u0027s something to consider.\n\nThat\u0027s a really good point and was actually the alternative I had started with. You can put a list of callbacks on the generator or it can keep the latest one. I think the list is better. But I can\u0027t give it a callback with a weak ptr to the cache since it will have to be posted back to the thread on which the ptrs are invalidated. The idea I had there was to keep a static map.\n\nbase::flat_map\u003cCacheId, ImageDecodeCache*\u003e s_cache_map_.\n\nAnd protected access to it with a lock. The cache adds and removes itself to the map. And the opaque destruction callback added to the generator has the cache_id. When the callback runs, it can check if the cache still exists in the map to forward it to the cache. Does that sound better?",
      "parentUuid": "401efdb0_bf9078fd",
      "range": {
        "startLine": 10,
        "startChar": 30,
        "endLine": 10,
        "endChar": 71
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58521ed7_8a2886d2",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 30,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "On what thread is this going to run?",
      "range": {
        "startLine": 30,
        "startChar": 2,
        "endLine": 30,
        "endChar": 20
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4268d9cc_04a2bf47",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 30,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T00:51:08Z",
      "side": 1,
      "message": "It runs on the thread on which the observer was registered, so the compositor thread for the caches.",
      "parentUuid": "58521ed7_8a2886d2",
      "range": {
        "startLine": 30,
        "startChar": 2,
        "endLine": 30,
        "endChar": 20
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8232760_a508023d",
        "filename": "cc/paint/paint_image_destruction_tracker.cc",
        "patchSetId": 6
      },
      "lineNbr": 30,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "Can you leave a comment to that effect?",
      "parentUuid": "4268d9cc_04a2bf47",
      "range": {
        "startLine": 30,
        "startChar": 2,
        "endLine": 30,
        "endChar": 20
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94f8ebf4_586e1cc5",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 1,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "2017",
      "range": {
        "startLine": 1,
        "startChar": 13,
        "endLine": 1,
        "endChar": 17
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40b41112_ce3d560e",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 9,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Can this be a forward declare, or does it need to be included?",
      "range": {
        "startLine": 9,
        "startChar": 11,
        "endLine": 9,
        "endChar": 41
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0149a84_b8930710",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 15,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Add a class comment describing what this is with sample usage please.\n\nAlso, nit: this class seems to be somewhat poorly named, since it\u0027s not actually tracking anything except a list of observers.",
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0952ddd1_478bd0bd",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 17,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Same.",
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05447122_e9e9b3af",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "nit: observer",
      "range": {
        "startLine": 27,
        "startChar": 29,
        "endLine": 27,
        "endChar": 32
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b10f146d_3947e154",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 28,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Same.",
      "range": {
        "startLine": 28,
        "startChar": 32,
        "endLine": 28,
        "endChar": 35
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a4d2579c_0223b6f0",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 30,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Comment",
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a58794f2_0514edb8",
        "filename": "cc/paint/paint_image_destruction_tracker.h",
        "patchSetId": 6
      },
      "lineNbr": 39,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Comment why this is the thread safe version, please.",
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac71221a_2037ecc9",
        "filename": "cc/paint/paint_image_generator.cc",
        "patchSetId": 6
      },
      "lineNbr": 17,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Sorry I missed this in previous reviews, but this also seems a bit awkward. PaintImageGenerator seems to be already tightly coupled with PaintImage, but the change you have here is adding to the coupling. Should the content id be coming exclusively from the generator itself (ie PaintImageGenerator::GetNextContentId()?). It\u0027s unclear why PaintImage is generating content ids when it\u0027s not actually dictating the content but simply storing it.",
      "range": {
        "startLine": 17,
        "startChar": 6,
        "endLine": 17,
        "endChar": 59
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7a43eac_75d1e78e",
        "filename": "cc/paint/paint_image_generator.cc",
        "patchSetId": 6
      },
      "lineNbr": 17,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T00:51:08Z",
      "side": 1,
      "message": "The reason we had to keep the ContentId on PaintImage is because PaintRecord backed images also generate content ids as they create new PaintRecords https://cs.chromium.org/chromium/src/cc/paint/paint_image_builder.h?l\u003d40.\n\nThanks for pointing this out though. Since ContentId can uniquely identify a constant data backing across PaintImages, I think the FrameKey doesn\u0027t need the PaintImage::Id. The ContentId, frame_index and subset is enough to identify a unique frame.",
      "parentUuid": "ac71221a_2037ecc9",
      "range": {
        "startLine": 17,
        "startChar": 6,
        "endLine": 17,
        "endChar": 59
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b990fc3_a6c7b0d4",
        "filename": "cc/paint/paint_image_generator.cc",
        "patchSetId": 6
      },
      "lineNbr": 17,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "IWYU",
      "range": {
        "startLine": 17,
        "startChar": 28,
        "endLine": 17,
        "endChar": 38
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ad8f9a3_d5b0a250",
        "filename": "cc/paint/paint_image_generator.cc",
        "patchSetId": 6
      },
      "lineNbr": 17,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "Ok, that\u0027s fine. I do think we can do better here by not using PaintImage as the common base of all paint image backing classes. It\u0027s not really the base, it\u0027s the owner. Maybe we need a set of paint image utils that would provide this type of functionality.",
      "parentUuid": "e7a43eac_75d1e78e",
      "range": {
        "startLine": 17,
        "startChar": 6,
        "endLine": 17,
        "endChar": 59
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fac9a5c0_e9c4e477",
        "filename": "cc/paint/paint_image_generator.h",
        "patchSetId": 6
      },
      "lineNbr": 71,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "PaintImage is generally created after PaintImageGenerator is, since PaintImage owns PaintImageGenerator. Where is this id coming from?",
      "range": {
        "startLine": 71,
        "startChar": 22,
        "endLine": 71,
        "endChar": 51
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c97c1f33_f44df2de",
        "filename": "cc/paint/paint_image_generator.h",
        "patchSetId": 6
      },
      "lineNbr": 71,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T00:51:08Z",
      "side": 1,
      "message": "The PaintImage::Id is generated by the source of PaintImages before creating them, so it can pass this id to the generators it creates.",
      "parentUuid": "fac9a5c0_e9c4e477",
      "range": {
        "startLine": 71,
        "startChar": 22,
        "endLine": 71,
        "endChar": 51
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bfd3ffd9_3880d424",
        "filename": "cc/paint/paint_image_generator.h",
        "patchSetId": 6
      },
      "lineNbr": 71,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "My hesitation here is that there is nothing preventing a PaintImageGenerator to have a different id from the PaintImage that contains it. It\u0027s kind of meant to be the same id but it\u0027s stored on two classes (and in the two classes, one owns the other).\n\nThis is fine for what this is doing, but I wonder if there\u0027s a way we can make this patch clean up the id ownership instead of adding a bit more complexity",
      "parentUuid": "c97c1f33_f44df2de",
      "range": {
        "startLine": 71,
        "startChar": 22,
        "endLine": 71,
        "endChar": 51
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f025a49c_efe25c61",
        "filename": "cc/paint/paint_image_generator.h",
        "patchSetId": 6
      },
      "lineNbr": 71,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T18:57:58Z",
      "side": 1,
      "message": "Thanks for pointing this out. I now realize that having the PaintImage::Id on the FrameKey is unnecessary. I\u0027m going to first have a patch to remove it which should eliminate a ton of complexity here.",
      "parentUuid": "bfd3ffd9_3880d424",
      "range": {
        "startLine": 71,
        "startChar": 22,
        "endLine": 71,
        "endChar": 51
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b6f3160_c6b448ac",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 681,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Write this as a for loop, please.",
      "range": {
        "startLine": 680,
        "startChar": 0,
        "endLine": 681,
        "endChar": 32
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56a0c18f_e2e92308",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 684,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "nit: ++key_it;",
      "range": {
        "startLine": 684,
        "startChar": 6,
        "endLine": 684,
        "endChar": 15
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "539f4edd_534d556c",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 688,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "I was under the impression that the upload is independent of the the generator. Why can\u0027t the upload exist and be reffed and used by Skia when this is called? Can you comment to explain please?",
      "range": {
        "startLine": 688,
        "startChar": 8,
        "endLine": 688,
        "endChar": 57
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7a30841_a911d0dd",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 688,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T00:51:08Z",
      "side": 1,
      "message": "The callback is dispatched only when the ImageFrameGenerator is being destroyed. If there is an upload ref, that means a raster/upload task exists which uses this image so it should have a RasterSource with a cached generator. From what I understood, it shouldn\u0027t be possible to have the cache keep an image locked if there are no references to the encoded image. Could I be missing a case here?",
      "parentUuid": "539f4edd_534d556c",
      "range": {
        "startLine": 688,
        "startChar": 8,
        "endLine": 688,
        "endChar": 57
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43500dd6_f7633698",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 688,
      "author": {
        "id": 1231409
      },
      "writtenOn": "2017-09-01T14:16:37Z",
      "side": 1,
      "message": "I think it may be useful to keep this function generic, and not tie this to ImageFrameGenerator destruction logic only, we may decide to evict an entry based on memory pressure etc or some other hint in cc as well (that was the original intention of the code).wdyt ?",
      "range": {
        "startLine": 688,
        "startChar": 57,
        "endLine": 688,
        "endChar": 0
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "83ac763b_302dbee7",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 688,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "\u003e The callback is dispatched only when the ImageFrameGenerator is being destroyed. If there is an upload ref, that means a raster/upload task exists which uses this image so it should have a RasterSource with a cached generator. From what I understood, it shouldn\u0027t be possible to have the cache keep an image locked if there are no references to the encoded image. Could I be missing a case here?\n\nI\u0027m just saying that we\u0027re assuming the _decoded date_ is unreffed when the _encoded data_ is deleted, which seems unrelated. If that\u0027s true, then that\u0027s fine. Can you leave a comment to explain why this is true?",
      "parentUuid": "b7a30841_a911d0dd",
      "range": {
        "startLine": 688,
        "startChar": 8,
        "endLine": 688,
        "endChar": 57
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24fcb174_110fd617",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 688,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "That makes sense and I agree. The memory pressure could probably be handled internally by the cache, but there is no reason to have this function not be robust for uses other than the image destruction.\n\nThe way this is being phrased now would require a paint image id and a content id. I think this is just paint_image.stable_id() and paint_image.content_id() (does that one exist?). Or maybe this is some other value stored in the generator? Our id ownership is becoming a bit messy.",
      "parentUuid": "43500dd6_f7633698",
      "range": {
        "startLine": 688,
        "startChar": 57,
        "endLine": 688,
        "endChar": 0
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "734b245a_054cdbb6",
        "filename": "cc/tiles/gpu_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 688,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T18:57:58Z",
      "side": 1,
      "message": "The paint_image_id is unnecessary (https://chromium-review.googlesource.com/c/chromium/src/+/646959 should remove it from the FrameKey). The content_id exists in the generator but it is dependent on the frame index.",
      "parentUuid": "24fcb174_110fd617",
      "range": {
        "startLine": 688,
        "startChar": 57,
        "endLine": 688,
        "endChar": 0
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e493134f_1e64c587",
        "filename": "cc/tiles/gpu_image_decode_cache_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 1742,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Remove the test if it\u0027s no longer valid.",
      "range": {
        "startLine": 1742,
        "startChar": 0,
        "endLine": 1742,
        "endChar": 2
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "703737c7_4ea7fb7a",
        "filename": "cc/tiles/gpu_image_decode_cache_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 1742,
      "author": {
        "id": 1231409
      },
      "writtenOn": "2017-09-01T14:16:37Z",
      "side": 1,
      "message": "why shouldnt we test code which reside in cc, here as well ?\nAs commented in the implementation, isn\u0027t it good to avoid eviction exclusively controlled by blink ?",
      "range": {
        "startLine": 1742,
        "startChar": 2,
        "endLine": 1742,
        "endChar": 0
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e6debd9_847c380f",
        "filename": "cc/tiles/gpu_image_decode_cache_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 1742,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "Yes. I forgot to mention in the general comment, but we do need test coverage for the new functionality (whether we change this test or write new ones doesn\u0027t really matter)",
      "parentUuid": "703737c7_4ea7fb7a",
      "range": {
        "startLine": 1742,
        "startChar": 2,
        "endLine": 1742,
        "endChar": 0
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6d2c74e_2f68d9ce",
        "filename": "cc/tiles/gpu_image_decode_cache_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 1742,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T18:57:58Z",
      "side": 1,
      "message": "I wasn\u0027t planning on landing it this way. :) Was just trying to do some perf testing. I\u0027ll update this test for the new functionality.",
      "parentUuid": "8e6debd9_847c380f",
      "range": {
        "startLine": 1742,
        "startChar": 2,
        "endLine": 1742,
        "endChar": 0
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "efb58d0a_b608864d",
        "filename": "cc/tiles/image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "This tightly couples any ImageDecodeCache implementation to PaintImageDestructionTracker. Have you considered alternate approaches, like PaintImageDestructionTracker having an updated non-owning pointer to the current decode cache? I\u0027m just curious why you decided on this design.",
      "range": {
        "startLine": 12,
        "startChar": 2,
        "endLine": 12,
        "endChar": 64
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50c58821_0c5606c7",
        "filename": "cc/tiles/image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-09-01T00:51:08Z",
      "side": 1,
      "message": "With the current design, the destruction tracker would be shared across compositors in a process so it would have a list of these caches.",
      "parentUuid": "efb58d0a_b608864d",
      "range": {
        "startLine": 12,
        "startChar": 2,
        "endLine": 12,
        "endChar": 64
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ef538af_c809d06a",
        "filename": "cc/tiles/image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-09-01T17:47:50Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "50c58821_0c5606c7",
      "range": {
        "startLine": 12,
        "startChar": 2,
        "endLine": 12,
        "endChar": 64
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b70cee5_8da8139a",
        "filename": "cc/tiles/software_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 879,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Use a for loop please.",
      "range": {
        "startLine": 878,
        "startChar": 0,
        "endLine": 879,
        "endChar": 32
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5ffe702_e5b1ed75",
        "filename": "cc/tiles/software_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 882,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "nit: ++key_it;",
      "range": {
        "startLine": 882,
        "startChar": 6,
        "endLine": 882,
        "endChar": 15
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd82e184_0b82f09c",
        "filename": "cc/tiles/software_image_decode_cache.cc",
        "patchSetId": 6
      },
      "lineNbr": 1113,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Don\u0027t do this please. DecodedImage is agnostic to the decode cache being used and it should stay that way.",
      "range": {
        "startLine": 1113,
        "startChar": 2,
        "endLine": 1113,
        "endChar": 38
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "995dc788_9477a17e",
        "filename": "cc/tiles/software_image_decode_cache_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 1674,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Remove the test if it\u0027s no longer relevant.",
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a282a59_0e74bc6a",
        "filename": "third_party/WebKit/Source/platform/graphics/DecodingImageGenerator.cpp",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "We\u0027re not creating a paint image here, so it\u0027s unclear to me why we\u0027re getting a paint image id.",
      "range": {
        "startLine": 58,
        "startChar": 38,
        "endLine": 59,
        "endChar": 29
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbdb8bdd_e298d1e6",
        "filename": "third_party/WebKit/Source/platform/graphics/Image.h",
        "patchSetId": 6
      },
      "lineNbr": 256,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-31T23:14:36Z",
      "side": 1,
      "message": "Either the function or the variable name have to change here.",
      "range": {
        "startLine": 256,
        "startChar": 17,
        "endLine": 256,
        "endChar": 65
      },
      "revId": "ca870be415b96930d0b8ce1e9f2d921287570d3d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}