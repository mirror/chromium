{
  "comments": [
    {
      "key": {
        "uuid": "1dfa0ba0_b9da94d0",
        "filename": "chrome/browser/predictors/loading_predictor.cc",
        "patchSetId": 4
      },
      "lineNbr": 59,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2017-07-05T08:14:15Z",
      "side": 1,
      "message": "Is it possible in the case where we have both types of prediction that the second one will skip ahead of the first one in the task queue of the DNS resolution threads?",
      "range": {
        "startLine": 59,
        "startChar": 8,
        "endLine": 59,
        "endChar": 26
      },
      "revId": "9453d87905925206ca37f42608a04e6ffb213b53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50c97769_4777edf7",
        "filename": "chrome/browser/predictors/loading_predictor.cc",
        "patchSetId": 4
      },
      "lineNbr": 59,
      "author": {
        "id": 1194993
      },
      "writtenOn": "2017-07-05T12:32:59Z",
      "side": 1,
      "message": "It\u0027s possible, I think. Preconnects and preresolves end up calling HostResolver::Resolve() that puts requests into a priority queue. We issue preconnects and preresolves with the same IDLE priority, so they are competing.\n\nIn the preresolve case we call HostResolver::Resolve() almost directly with some throttling at net::Predictor level.\n\nThe preconnect is more complicated and HostResolver::Resolve() could be called asynchronously due asynchronous proxy resolution or throttling on a net-stack level. If so, a request gets to a priority queue of HostResolver after preresolve requests. I don\u0027t know how common this throttling is though. Here is an implementation of this throttling: https://cs.chromium.org/chromium/src/net/http/http_stream_factory_impl_job.cc?l\u003d783\u0026gs\u003dcpp%253Anet%253A%253Aclass-HttpStreamFactoryImpl%253A%253Aclass-Job%253A%253ADoEvaluateThrottle()%2540chromium%252F..%252F..%252Fnet%252Fhttp%252Fhttp_stream_factory_impl_job.cc%257Cdef\u0026gsn\u003dDoEvaluateThrottle\u0026ct\u003dxref_usages",
      "parentUuid": "1dfa0ba0_b9da94d0",
      "range": {
        "startLine": 59,
        "startChar": 8,
        "endLine": 59,
        "endChar": 26
      },
      "revId": "9453d87905925206ca37f42608a04e6ffb213b53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0fd4f6b1_f3e34c27",
        "filename": "chrome/browser/predictors/loading_predictor.cc",
        "patchSetId": 4
      },
      "lineNbr": 267,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2017-07-05T08:14:15Z",
      "side": 1,
      "message": "nit:\nNOTIMPLEMENTED()?\n\n(with an unconditional return before, otherwise the static_assert() would bite you).",
      "range": {
        "startLine": 267,
        "startChar": 10,
        "endLine": 267,
        "endChar": 18
      },
      "revId": "9453d87905925206ca37f42608a04e6ffb213b53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a181a80b_08d21fe6",
        "filename": "chrome/browser/predictors/loading_predictor.cc",
        "patchSetId": 4
      },
      "lineNbr": 267,
      "author": {
        "id": 1194993
      },
      "writtenOn": "2017-07-05T12:32:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0fd4f6b1_f3e34c27",
      "range": {
        "startLine": 267,
        "startChar": 10,
        "endLine": 267,
        "endChar": 18
      },
      "revId": "9453d87905925206ca37f42608a04e6ffb213b53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5b3ce908_dd3ab73e",
        "filename": "chrome/browser/predictors/loading_predictor.h",
        "patchSetId": 4
      },
      "lineNbr": 105,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2017-07-05T08:14:15Z",
      "side": 1,
      "message": "Is it necessarily fire and forget?\n\nFor instance, a good way to rate limit the connections is to first do a DNS resolution, and wait for its completion before connecting to the origin, since DNS necessarily has to precede the connection.\n\nUnless it\u0027s a connection to an HTTP/2 origin for which we already have a socket ready, in which case we don\u0027t do anything (but in this case as well, waiting for the DNS resolution may be a good idea).",
      "revId": "9453d87905925206ca37f42608a04e6ffb213b53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f517a0a2_b4c02107",
        "filename": "chrome/browser/predictors/loading_predictor.h",
        "patchSetId": 4
      },
      "lineNbr": 105,
      "author": {
        "id": 1194993
      },
      "writtenOn": "2017-07-05T12:32:59Z",
      "side": 1,
      "message": "It will cost one extra host resolution request per each preconnect request (we already have one if a socket pool isn\u0027t already full).\n\nIn this case DNS callback to start preconnect shouldn\u0027t go through UI thread so we could wrap it in the one MaybeAddPreconnectAndPreresolve() function. On a IO thread side we\u0027ll have a single PreconnectManager object that will dispatch all the requests. WDYT?",
      "parentUuid": "5b3ce908_dd3ab73e",
      "revId": "9453d87905925206ca37f42608a04e6ffb213b53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}