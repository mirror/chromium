{
  "comments": [
    {
      "key": {
        "uuid": "fbfad779_34269cb3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 15
      },
      "lineNbr": 17,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "nit: s/CanCommitOrigin/origin/ ?",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 17,
        "endChar": 15
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c42d10c_4a32ccaa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 15
      },
      "lineNbr": 17,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Oops.  Done.",
      "parentUuid": "fbfad779_34269cb3",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 17,
        "endChar": 15
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "969df01b_9b2deeda",
        "filename": "content/browser/frame_host/navigation_controller_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 383,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "base_url, perhaps? (It\u0027s not really the target_url in the sense that we aren\u0027t going to navigate to it.)",
      "range": {
        "startLine": 383,
        "startChar": 9,
        "endLine": 383,
        "endChar": 19
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a59beb68_0e1ff4c5",
        "filename": "content/browser/frame_host/navigation_controller_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 383,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "969df01b_9b2deeda",
      "range": {
        "startLine": 383,
        "startChar": 9,
        "endLine": 383,
        "endChar": 19
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f1677085_2fefa35c",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 963,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Thanks for fixing all these tests to behave more sanely with --site-per-process! :)  Now that they won\u0027t result in CanCommitOrigin kills anymore, should we add a test to ensure that we actually kill the renderer if it tries to commit an invalid origin with an origin lock?  Maybe something similar to SecurityExploitBrowserTest.MismatchedOriginOnCommit but with origin locks?",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6dabe713_7f2956e7",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 963,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Good point.  I\u0027ve added SitePerProcessBrowserTest.CommittedOriginIncompatibleWithOriginLock and verified that it passes after my CL and fails before my CL.\n\nI\u0027ve decided to add the test to SitePerProcessBrowserTest and not to SecurityExploitBrowserTest, because my test only makes sense in presence of an origin lock (so - in presence of either --site-per-process or --isolated-origins).\n\nWhen working on the new test, I\u0027ve found out that SecurityExploitBrowserTest.MismatchedOriginOnCommit is broken - it now hits RFH_INTERFACE_PROVIDER_MISSING because it incorrectly simulates DidCommitProvisionalLoad IPC (it doesn\u0027t pass an service_manager::mojom::InterfaceProviderRequest.  Because of this it doesn\u0027t really test the right kills - the test always passes because of another kill that is unrelated to the kill the test wanted to verify.  I\u0027ve fixed the test.",
      "parentUuid": "f1677085_2fefa35c",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c33abe0_9ceb12a5",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 963,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-21T03:17:34Z",
      "side": 1,
      "message": "\u003e Good point.  I\u0027ve added SitePerProcessBrowserTest.CommittedOriginIncompatibleWithOriginLock and verified that it passes after my CL and fails before my CL.\n\u003e \n\u003e I\u0027ve decided to add the test to SitePerProcessBrowserTest and not to SecurityExploitBrowserTest, because my test only makes sense in presence of an origin lock (so - in presence of either --site-per-process or --isolated-origins).\n\nAck.\n\n\u003e \n\u003e When working on the new test, I\u0027ve found out that SecurityExploitBrowserTest.MismatchedOriginOnCommit is broken - it now hits RFH_INTERFACE_PROVIDER_MISSING because it incorrectly simulates DidCommitProvisionalLoad IPC (it doesn\u0027t pass an service_manager::mojom::InterfaceProviderRequest.  Because of this it doesn\u0027t really test the right kills - the test always passes because of another kill that is unrelated to the kill the test wanted to verify.  I\u0027ve fixed the test.\n\nThanks for fixing it!",
      "parentUuid": "6dabe713_7f2956e7",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "05eada5d_30050e62",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 1957,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Hmm, I\u0027m curious if the test\u0027s intention was to deliberately change the url on forward navigation, according to its comment \"Tests what happens when a forward navigation produces a new page.\"?  Maybe simulating that url2 now redirects to url3?  Although the test isn\u0027t doing redirects, the comment is very similar to that on Reload_GeneratesNewPage, which is doing that through a redirect.  Maybe we should tweak the test to do something similar here instead of removing url3?",
      "range": {
        "startLine": 1957,
        "startChar": 60,
        "endLine": 1957,
        "endChar": 64
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18308d87_a4707238",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 1957,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Good catch.  Done.\n\nI think the navigating RFH first changes after |controller.GoForward()| (because we are navigating from url1 -\u003e url2) and then it changes again because of the redirect - this is why I\u0027ve got 2 calls to GetNavigatingRenderFrameHost() instead of introducing a |navigating_rfh| variable.",
      "parentUuid": "05eada5d_30050e62",
      "range": {
        "startLine": 1957,
        "startChar": 60,
        "endLine": 1957,
        "endChar": 64
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d4f60759_06ad87dc",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3082,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Could you also use NavigationSimulator here to avoid the navigating_rfh, by doing CreateRendererInitiated() + Start() here, and Commit() after checking for the interstitial?",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbd5dc6c_542f2899",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3082,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Good idea.\n\nI should use CreateBrowserInitiated though, because of ui::PAGE_TRANSITION_TYPED, right?\n\nI am also not sure what you mean by \"after checking for the interstitial\".  AFAICT, the test doesn\u0027t check that the interstitial is actually visible - the first verification (on line 3103) happens after committing the normal page.",
      "parentUuid": "d4f60759_06ad87dc",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e332e153_e93ea42e",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3082,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-21T03:17:34Z",
      "side": 1,
      "message": "\u003e Good idea.\n\u003e \n\u003e I should use CreateBrowserInitiated though, because of ui::PAGE_TRANSITION_TYPED, right?\n\nAh, right.\n\n\u003e I am also not sure what you mean by \"after checking for the interstitial\".  AFAICT, the test doesn\u0027t check that the interstitial is actually visible - the first verification (on line 3103) happens after committing the normal page.\n\nSorry, what I meant was what you ended up doing -- calling Commit() after setting the pending entry\u0027s page type to be PAGE_TYPE_INTERSTITIAL. :)",
      "parentUuid": "bbd5dc6c_542f2899",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6449390e_3e9017de",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3468,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "optional: might be worthwhile extracting this into a test helper, given that this ended up in quite a few places?",
      "range": {
        "startLine": 3466,
        "startChar": 40,
        "endLine": 3468,
        "endChar": 73
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1064e844_4efb9e53",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3468,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6449390e_3e9017de",
      "range": {
        "startLine": 3466,
        "startChar": 40,
        "endLine": 3468,
        "endChar": 73
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a41b178c_1b141bfe",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3843,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Why would there be no bad message here in --site-per-process?",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c6b762b_54261282",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3843,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "We still detect a bad message in IsURLSameDocumentNavigation, but we kill another process ( |rph| is the old process from before the swapping that can occur on line 3838 here).  Instead of special-casing AreAllSitesIsolatedForTesting() I should be updating |rph| instead.  Done?",
      "parentUuid": "a41b178c_1b141bfe",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "67e0108c_d31e368c",
        "filename": "content/browser/frame_host/navigation_controller_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3843,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-21T03:17:34Z",
      "side": 1,
      "message": "Makes sense, thanks!",
      "parentUuid": "7c6b762b_54261282",
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1110b4c9_b0a30d1a",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 843,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "target_url? (Since it\u0027s not really an origin?)",
      "range": {
        "startLine": 843,
        "startChar": 14,
        "endLine": 843,
        "endChar": 27
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f901ee15_0224009d",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 843,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Done (but renamed to |base_url| for consistency with navigation_controller_impl.cc).",
      "parentUuid": "1110b4c9_b0a30d1a",
      "range": {
        "startLine": 843,
        "startChar": 14,
        "endLine": 843,
        "endChar": 27
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0297301c_606e965a",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 858,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "There are a few other places where SetSite may be called, and I\u0027m curious whether we need to fall back to base URL in any of those:\n- DidNavigate, which uses params.url.  (I\u0027m assuming it\u0027s not the base URL, because there\u0027s also params.base_url.)\n- BrowsingInstance::GetSiteInstanceForURL() - which may matter if we are creating a new BrowsingInstance via LoadDataWithBaseURL, if that\u0027s even possible?\n- a case in DetermineSiteInstanceForURL which may matter for session restore (actually, might be worth trying session restore with a base URL)",
      "range": {
        "startLine": 858,
        "startChar": 0,
        "endLine": 858,
        "endChar": 39
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd86fcdc_e01b1235",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 858,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Thanks for pointing out the other places.\n\n\u003e There are a few other places where SetSite may be called, and I\u0027m curious whether we need to fall back to base URL in any of those:\n\u003e - DidNavigate, which uses params.url.  (I\u0027m assuming it\u0027s not the base URL, because there\u0027s also params.base_url.)\n\nGood catch - initially I didn\u0027t see that we have access to |params.base_url| here.  I\u0027ve changed the SetSite callsite above to use |base_url| if possible.\n\nOne other notes (probably not quite related to the CL under review): I wonder if we should use |params.url| VS |params.origin| when calculating the site URL.  I\u0027ve started a discussion about this at https://groups.google.com/a/chromium.org/d/topic/site-isolation-dev/36Cy9IzLi90/discussion\n\n\u003e - BrowsingInstance::GetSiteInstanceForURL() - which may matter if we are creating a new BrowsingInstance via LoadDataWithBaseURL, if that\u0027s even possible?\n\nI think that BrowsingInstance::GetSiteInstanceForURL() would matter only if LoadDataWithBaseURL could create a new frame within an *existing* (not new) browsing instance.  And I think this is not possible - LoadDataWithBaseURL is always a top-level, browser-initiated navigation (and therefore should be happening in a new browsing instance I think).\n\nOTOH, I am not quite sure if all browser-initiated navigations result in a *new* browsing instance.  I don\u0027t think that\u0027s true.  But then - this might be a separate bug (?).\n\n\u003e - a case in DetermineSiteInstanceForURL which may matter for session restore (actually, might be worth trying session restore with a base URL)\n\nGood catch.  I think that in this case, we need to ensure that |dest_url| passed to DetermineSiteInstanceForURL takes base URL into account.  This argument comes from either:\n\n- RenderFrameHostManager::GetSiteInstanceForNavigationRequest - I\u0027ve made changes to take into account |request.common_params().base_url_for_data_url|.\n\n- NavigatorImpl::NavigateToEntry - this is a non-PlzNavigate path.  Nevertheless, I\u0027ve made changes to pass base URL if needed.\n\nI do notice that the changed |dest_url| is used in quite a few places.  But it seems to me that all of them should be happy with having the base URL instead:\n\n- RenderFrameHostManager::DetermineSiteInstanceForURL passes |dest_url| to:\n    - constructor of SiteInstanceDescriptor\n    - ContentBrowserClient::ShouldStayInParentProcessForNTP\n    - RenderProcessHost::ShouldUseProcessPerSite\n    - RenderProcessHostImpl::GetProcessHostForSite\n        - QUESTION: Is it okay that base URL might be a full URL, rather than a \"site\"?\n                    (this question potentially applies to other uses of |dest_url|)\n    - HasWrongProcessForURL\n        - This is great.  It matches my changes in NavigationControllerImpl::Reload\n          which also needs to call HasWrongProcessForURL with the base URL if present.\n    - WebUIControllerFactoryRegistry::UseWebUIForURL\n        - Should be fine I think.  Should be a no-op in all legitimate cases I would hope.\n          (not sure if LoadDataWithBaseURL can be used for chrome://... URLs)\n    - SiteInstanceImpl::ShouldAssignSiteForURL\n        - This is great.  It matches my changes above where we also need to call\n          ShouldAssignSiteForURL with the base URL\n    - IsRendererDebugURL\n    - comparison of |dest_url| with about:blank, about:srcdoc and data:...\n        - Should be fine - this just reuses |source_instance|.\n          Also - I don\u0027t know why anyone would use about:blank or data:...\n          as a base URL - seems unlikely.\n    - IsCurrentlySameSite\n    - SiteInstanceImpl::DoesSiteRequireDedicatedProcess\n        - This is great.  It matches my changes above where we also need to call\n          DoesSiteRequireDedicatedProcess with the base URL\n\n- RenderFrameHostManager::GetSiteInstanceForNavigation passes |dest_url| to:\n    - SiteInstanceImpl::GetEffectiveURL / ShouldSwapBrowsingInstancesForNavigation\n    - DetermineSiteInstanceForURL (already covered above)\n\n- RenderFrameHostManager::UpdateStateForNavigate passes |dest_url| to:\n    - GetSiteInstanceForNavigation (already covered above)\n    - CanSubframeSwapProcess\n    - UpdatePendingWebUI\n    - UpdatePendingWebUIOnCurrentFrameHost\n\n- RenderFrameHostManager::Navigate passes |dest_url| to:\n    - UpdateStateForNavigate (already covered above)\n\n\nPS. After your comment about SiteInstanceImpl::SetSite, I\u0027ve also looked at callers of\n\n- SiteInstanceImpl::ShouldAssignSiteForURL (all callers covered by this CL)\n- HasWrongProcessForURL\n    - NavigationControllerImpl::Reload is covered by this CL\n    - RFHM::DetermineSiteInstanceForURL is covered (after you comment)\n    - RFHM::IsRendererTransferNeededForNavigation is not covered,\n      but this is non-PlzNavigate, so maybe this is okay?\n    - RFHM::IsCurrentlySameSite\n        - Calls from RFHM::RFHM::DetermineSiteInstanceForURL are covered by this CL\n        - Call from RFHM::IsRendererTransferNeededForNavigation is not covered,\n          but (as above) this is non-PlzNavigate, so maybe okay?\n- DoesSiteRequireDedicatedProcess\n    - NavigationRequest::OnResponseStarted is covered by this CL\n    - For RFHM::DetermineSiteInstanceForURL + RFHM::IsRendererTransferNeededForNavigation\n      see the comments above\n    - SiteInstanceImpl::RequiresDedicatedProcess is fine, because\n      it passes |site_| which is already covered by SiteInstanceImpl::SetSite analysis\n    - SiteInstanceImpl::ShouldLockToOrigin\n        - Called by SiteInstanceImpl::LockToOriginIfNeeded which is fine,\n          because it passes |site_| which is already covered by\n          SiteInstanceImpl::SetSite analysis\n        - Also called by RenderProcessHostImpl::IsSuitableHost.\n          This seems fine, although I admit that I haven\u0027t gone through all\n           the transitive callers.",
      "parentUuid": "0297301c_606e965a",
      "range": {
        "startLine": 858,
        "startChar": 0,
        "endLine": 858,
        "endChar": 39
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "770a824f_316b6637",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 858,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-21T03:17:34Z",
      "side": 1,
      "message": "\u003e Thanks for pointing out the other places.\n\u003e \n\u003e \u003e There are a few other places where SetSite may be called, and I\u0027m curious whether we need to fall back to base URL in any of those:\n\u003e \u003e - DidNavigate, which uses params.url.  (I\u0027m assuming it\u0027s not the base URL, because there\u0027s also params.base_url.)\n\u003e \n\u003e Good catch - initially I didn\u0027t see that we have access to |params.base_url| here.  I\u0027ve changed the SetSite callsite above to use |base_url| if possible.\n\u003e \n\u003e One other notes (probably not quite related to the CL under review): I wonder if we should use |params.url| VS |params.origin| when calculating the site URL.  I\u0027ve started a discussion about this at https://groups.google.com/a/chromium.org/d/topic/site-isolation-dev/36Cy9IzLi90/discussion\n\nYup, I\u0027ll try to think more about that and follow up there.  I\u0027ll also note that I\u0027m not thrilled about having to call SetSite in so many places.  Maybe we can try calling SetSite() from OnResponseStarted unconditionally (not just for sites requiring dedicated processes), and just remove the SetSite() call from DidNavigate.\n\n\u003e \n\u003e \u003e - BrowsingInstance::GetSiteInstanceForURL() - which may matter if we are creating a new BrowsingInstance via LoadDataWithBaseURL, if that\u0027s even possible?\n\u003e \n\u003e I think that BrowsingInstance::GetSiteInstanceForURL() would matter only if LoadDataWithBaseURL could create a new frame within an *existing* (not new) browsing instance.  And I think this is not possible - LoadDataWithBaseURL is always a top-level, browser-initiated navigation (and therefore should be happening in a new browsing instance I think).\n\nI\u0027m a bit confused here. :)\n\nI agree LoadDataWithBaseURL should always be browser-initiated: we kill the renderer if it tries to do it in RFHI::BeginNavigation().\n\nWhy is LoadDataWithBaseURL always a navigation in a new BI though?  BrowsingInstance::GetSiteInstanceForURL can be called by both SI::CreateForURL (new BI), and SI::GetRelatedSiteInstance() (same BI). At least in the \u003cwebview\u003e case, it should presumably always stay in the current chrome-guest:// SI/BI (so I don\u0027t know if we\u0027ll actually ever need to determine a new SiteInstance site URL in that case).\n\nAlso, why wouldn\u0027t this matter for the cases with a new browsing instance?\n\n\u003e \n\u003e OTOH, I am not quite sure if all browser-initiated navigations result in a *new* browsing instance.  I don\u0027t think that\u0027s true.  But then - this might be a separate bug (?).\n\nRight, I don\u0027t think browser-initiated navigations always result in a new browsing instance today.  If A opens B and I navigate B to C via omnibox, C\u0027s opener will still be A, right?\n\n\u003e \n\u003e \u003e - a case in DetermineSiteInstanceForURL which may matter for session restore (actually, might be worth trying session restore with a base URL)\n\u003e \n\u003e Good catch.  I think that in this case, we need to ensure that |dest_url| passed to DetermineSiteInstanceForURL takes base URL into account.  This argument comes from either:\n\u003e \n\u003e - RenderFrameHostManager::GetSiteInstanceForNavigationRequest - I\u0027ve made changes to take into account |request.common_params().base_url_for_data_url|.\n\u003e \n\u003e - NavigatorImpl::NavigateToEntry - this is a non-PlzNavigate path.  Nevertheless, I\u0027ve made changes to pass base URL if needed.\n\u003e \n\u003e I do notice that the changed |dest_url| is used in quite a few places.  But it seems to me that all of them should be happy with having the base URL instead:\n\u003e \n\u003e - RenderFrameHostManager::DetermineSiteInstanceForURL passes |dest_url| to:\n\u003e     - constructor of SiteInstanceDescriptor\n\u003e     - ContentBrowserClient::ShouldStayInParentProcessForNTP\n\u003e     - RenderProcessHost::ShouldUseProcessPerSite\n\u003e     - RenderProcessHostImpl::GetProcessHostForSite\n\u003e         - QUESTION: Is it okay that base URL might be a full URL, rather than a \"site\"?\n\u003e                     (this question potentially applies to other uses of |dest_url|)\n\nGetProcessHostForSite() should be ok, because it does its own GetSiteForURL().  Don\u0027t know about the others though...\n\n\u003e     - HasWrongProcessForURL\n\u003e         - This is great.  It matches my changes in NavigationControllerImpl::Reload\n\u003e           which also needs to call HasWrongProcessForURL with the base URL if present.\n\u003e     - WebUIControllerFactoryRegistry::UseWebUIForURL\n\u003e         - Should be fine I think.  Should be a no-op in all legitimate cases I would hope.\n\u003e           (not sure if LoadDataWithBaseURL can be used for chrome://... URLs)\n\u003e     - SiteInstanceImpl::ShouldAssignSiteForURL\n\u003e         - This is great.  It matches my changes above where we also need to call\n\u003e           ShouldAssignSiteForURL with the base URL\n\u003e     - IsRendererDebugURL\n\u003e     - comparison of |dest_url| with about:blank, about:srcdoc and data:...\n\u003e         - Should be fine - this just reuses |source_instance|.\n\u003e           Also - I don\u0027t know why anyone would use about:blank or data:...\n\u003e           as a base URL - seems unlikely.\n\u003e     - IsCurrentlySameSite\n\u003e     - SiteInstanceImpl::DoesSiteRequireDedicatedProcess\n\u003e         - This is great.  It matches my changes above where we also need to call\n\u003e           DoesSiteRequireDedicatedProcess with the base URL\n\u003e \n\u003e - RenderFrameHostManager::GetSiteInstanceForNavigation passes |dest_url| to:\n\u003e     - SiteInstanceImpl::GetEffectiveURL / ShouldSwapBrowsingInstancesForNavigation\n\u003e     - DetermineSiteInstanceForURL (already covered above)\n\u003e \n\u003e - RenderFrameHostManager::UpdateStateForNavigate passes |dest_url| to:\n\u003e     - GetSiteInstanceForNavigation (already covered above)\n\u003e     - CanSubframeSwapProcess\n\u003e     - UpdatePendingWebUI\n\u003e     - UpdatePendingWebUIOnCurrentFrameHost\n\u003e \n\u003e - RenderFrameHostManager::Navigate passes |dest_url| to:\n\u003e     - UpdateStateForNavigate (already covered above)\n\u003e \n\u003e \n\u003e PS. After your comment about SiteInstanceImpl::SetSite, I\u0027ve also looked at callers of\n\u003e \n\u003e - SiteInstanceImpl::ShouldAssignSiteForURL (all callers covered by this CL)\n\u003e - HasWrongProcessForURL\n\u003e     - NavigationControllerImpl::Reload is covered by this CL\n\u003e     - RFHM::DetermineSiteInstanceForURL is covered (after you comment)\n\u003e     - RFHM::IsRendererTransferNeededForNavigation is not covered,\n\u003e       but this is non-PlzNavigate, so maybe this is okay?\n\nThis is actually used in PlzNavigate too, I think, for example in call sites in RFHM::GetSiteInstanceForNavigationRequest and CanSubframeSwapProcess.\n\n\u003e     - RFHM::IsCurrentlySameSite\n\u003e         - Calls from RFHM::RFHM::DetermineSiteInstanceForURL are covered by this CL\n\u003e         - Call from RFHM::IsRendererTransferNeededForNavigation is not covered,\n\u003e           but (as above) this is non-PlzNavigate, so maybe okay?\n\u003e - DoesSiteRequireDedicatedProcess\n\u003e     - NavigationRequest::OnResponseStarted is covered by this CL\n\u003e     - For RFHM::DetermineSiteInstanceForURL + RFHM::IsRendererTransferNeededForNavigation\n\u003e       see the comments above\n\u003e     - SiteInstanceImpl::RequiresDedicatedProcess is fine, because\n\u003e       it passes |site_| which is already covered by SiteInstanceImpl::SetSite analysis\n\u003e     - SiteInstanceImpl::ShouldLockToOrigin\n\u003e         - Called by SiteInstanceImpl::LockToOriginIfNeeded which is fine,\n\u003e           because it passes |site_| which is already covered by\n\u003e           SiteInstanceImpl::SetSite analysis\n\u003e         - Also called by RenderProcessHostImpl::IsSuitableHost.\n\u003e           This seems fine, although I admit that I haven\u0027t gone through all\n\u003e            the transitive callers.",
      "parentUuid": "cd86fcdc_e01b1235",
      "range": {
        "startLine": 858,
        "startChar": 0,
        "endLine": 858,
        "endChar": 39
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3d21cb3b_b0ed65c7",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 858,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-21T23:56:21Z",
      "side": 1,
      "message": "\u003e \u003e Thanks for pointing out the other places.\n\u003e \u003e \n\u003e \u003e \u003e There are a few other places where SetSite may be called, and I\u0027m curious whether we need to fall back to base URL in any of those:\n\u003e \u003e \u003e - DidNavigate, which uses params.url.  (I\u0027m assuming it\u0027s not the base URL, because there\u0027s also params.base_url.)\n\u003e \u003e \n\u003e \u003e Good catch - initially I didn\u0027t see that we have access to |params.base_url| here.  I\u0027ve changed the SetSite callsite above to use |base_url| if possible.\n\u003e \u003e \n\u003e \u003e One other notes (probably not quite related to the CL under review): I wonder if we should use |params.url| VS |params.origin| when calculating the site URL.  I\u0027ve started a discussion about this at https://groups.google.com/a/chromium.org/d/topic/site-isolation-dev/36Cy9IzLi90/discussion\n\u003e \n\u003e Yup, I\u0027ll try to think more about that and follow up there.  I\u0027ll also note that I\u0027m not thrilled about having to call SetSite in so many places.  Maybe we can try calling SetSite() from OnResponseStarted unconditionally (not just for sites requiring dedicated processes), and just remove the SetSite() call from DidNavigate.\n\nAck.  This makes sense to me I think.  I can try that in a follow-up CL.\n\nWhat about the call to SetSite from RenderFrameHostManager::DetermineSiteInstanceForURL.  This is probably still needed (based on the comment there), right?\n\n\u003e \u003e \u003e - BrowsingInstance::GetSiteInstanceForURL() - which may matter if we are creating a new BrowsingInstance via LoadDataWithBaseURL, if that\u0027s even possible?\n\u003e \u003e \n\u003e \u003e I think that BrowsingInstance::GetSiteInstanceForURL() would matter only if LoadDataWithBaseURL could create a new frame within an *existing* (not new) browsing instance.  And I think this is not possible - LoadDataWithBaseURL is always a top-level, browser-initiated navigation (and therefore should be happening in a new browsing instance I think).\n\u003e \n\u003e I\u0027m a bit confused here. :)\n\u003e \n\u003e I agree LoadDataWithBaseURL should always be browser-initiated: we kill the renderer if it tries to do it in RFHI::BeginNavigation().\n\u003e \n\u003e Why is LoadDataWithBaseURL always a navigation in a new BI though?  BrowsingInstance::GetSiteInstanceForURL can be called by both SI::CreateForURL (new BI), and SI::GetRelatedSiteInstance() (same BI). At least in the \u003cwebview\u003e case, it should presumably always stay in the current chrome-guest:// SI/BI (so I don\u0027t know if we\u0027ll actually ever need to determine a new SiteInstance site URL in that case).\n\nI think I was confused by our *intention* (but not *behavior* AFAICT) to swap BI when navigating *cross-site* via the omnibox.  Since LoadDataWithBaseURL can be for a \"same-site\" (according to base URL) navigation, then it might indeed not swap BI (even if we implemented our intention).\n\n\u003e Also, why wouldn\u0027t this matter for the cases with a new browsing instance?\n\nBecause BrowsingInstance::GetSiteInstanceForURL is only called when reusing an old browsing instance.  If LoadDataWithBaseURL always used a new browsing instance (which we\u0027ve established above is not true) then we wouldn\u0027t have to worry about using base URL in the call to SetSite made by BrowsingInstance::GetSiteInstanceForURL.\n\n\n\nFWIW, in the latest patchset I\u0027ve tried to revert all the changes related to base URL / SetSite.  Instead of making these product code changes, I\u0027ve tweaked 5 NavigationControllerBrowserTest that call LoadDataWithBaseURL to skip these tests when running with --site-per-process.  I\u0027ve also tweaked MessagePortProviderBrowserTest.PostMessage to avoid using LoadDataWithBaseURL (and to improve test verification to also cover the source origin).\n\nWDYT?",
      "parentUuid": "770a824f_316b6637",
      "range": {
        "startLine": 858,
        "startChar": 0,
        "endLine": 858,
        "endChar": 39
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19e99c67_f6afab09",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 858,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-22T22:36:48Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Thanks for pointing out the other places.\n\u003e \u003e \u003e \n\u003e \u003e \u003e \u003e There are a few other places where SetSite may be called, and I\u0027m curious whether we need to fall back to base URL in any of those:\n\u003e \u003e \u003e \u003e - DidNavigate, which uses params.url.  (I\u0027m assuming it\u0027s not the base URL, because there\u0027s also params.base_url.)\n\u003e \u003e \u003e \n\u003e \u003e \u003e Good catch - initially I didn\u0027t see that we have access to |params.base_url| here.  I\u0027ve changed the SetSite callsite above to use |base_url| if possible.\n\u003e \u003e \u003e \n\u003e \u003e \u003e One other notes (probably not quite related to the CL under review): I wonder if we should use |params.url| VS |params.origin| when calculating the site URL.  I\u0027ve started a discussion about this at https://groups.google.com/a/chromium.org/d/topic/site-isolation-dev/36Cy9IzLi90/discussion\n\u003e \u003e \n\u003e \u003e Yup, I\u0027ll try to think more about that and follow up there.  I\u0027ll also note that I\u0027m not thrilled about having to call SetSite in so many places.  Maybe we can try calling SetSite() from OnResponseStarted unconditionally (not just for sites requiring dedicated processes), and just remove the SetSite() call from DidNavigate.\n\u003e \n\u003e Ack.  This makes sense to me I think.  I can try that in a follow-up CL.\n\u003e \n\u003e What about the call to SetSite from RenderFrameHostManager::DetermineSiteInstanceForURL.  This is probably still needed (based on the comment there), right?\n\nThanks for raising this -- thinking about that call, I don\u0027t actually understand it. :) Why would none of the pages share renderers in process-per-site after restore?  If this is only about process-per-site, then it seems we would\u0027ve already done the right thing and returned after processing the process-per-site case earlier in that same block, regardless of session restore (https://cs.chromium.org/chromium/src/content/browser/frame_host/render_frame_host_manager.cc?l\u003d1140\u0026rcl\u003da5f2b542466dc51ec76f68cd383697bd26a3f28f).\n\nI tried tracing it back, and it\u0027s been there forever, in the initial commit (https://chromium.googlesource.com/chromium/src/+blame/2526315929de99fa5762583621fb52b626a62ef9/chrome/browser/web_contents.cc#897) [Comment added later in https://codereview.chromium.org/1519025].  So much has changed since then that I\u0027d try taking it out and see if anything breaks. :)   Charlie might also have more context for it -- let\u0027s follow up on this with him.\n\n\u003e \n\u003e \u003e \u003e \u003e - BrowsingInstance::GetSiteInstanceForURL() - which may matter if we are creating a new BrowsingInstance via LoadDataWithBaseURL, if that\u0027s even possible?\n\u003e \u003e \u003e \n\u003e \u003e \u003e I think that BrowsingInstance::GetSiteInstanceForURL() would matter only if LoadDataWithBaseURL could create a new frame within an *existing* (not new) browsing instance.  And I think this is not possible - LoadDataWithBaseURL is always a top-level, browser-initiated navigation (and therefore should be happening in a new browsing instance I think).\n\u003e \u003e \n\u003e \u003e I\u0027m a bit confused here. :)\n\u003e \u003e \n\u003e \u003e I agree LoadDataWithBaseURL should always be browser-initiated: we kill the renderer if it tries to do it in RFHI::BeginNavigation().\n\u003e \u003e \n\u003e \u003e Why is LoadDataWithBaseURL always a navigation in a new BI though?  BrowsingInstance::GetSiteInstanceForURL can be called by both SI::CreateForURL (new BI), and SI::GetRelatedSiteInstance() (same BI). At least in the \u003cwebview\u003e case, it should presumably always stay in the current chrome-guest:// SI/BI (so I don\u0027t know if we\u0027ll actually ever need to determine a new SiteInstance site URL in that case).\n\u003e \n\u003e I think I was confused by our *intention* (but not *behavior* AFAICT) to swap BI when navigating *cross-site* via the omnibox.  Since LoadDataWithBaseURL can be for a \"same-site\" (according to base URL) navigation, then it might indeed not swap BI (even if we implemented our intention).\n\u003e \n\u003e \u003e Also, why wouldn\u0027t this matter for the cases with a new browsing instance?\n\u003e \n\u003e Because BrowsingInstance::GetSiteInstanceForURL is only called when reusing an old browsing instance.  If LoadDataWithBaseURL always used a new browsing instance (which we\u0027ve established above is not true) then we wouldn\u0027t have to worry about using base URL in the call to SetSite made by BrowsingInstance::GetSiteInstanceForURL.\n\nDoesn\u0027t matter now - but doesn\u0027t SiteInstance::CreateForURL() create a new BI and then call BI::GetSiteInstanceForURL on that new BI, and hence call SetSite will still happen in that case?\n\n\u003e \n\u003e \n\u003e \n\u003e FWIW, in the latest patchset I\u0027ve tried to revert all the changes related to base URL / SetSite.  Instead of making these product code changes, I\u0027ve tweaked 5 NavigationControllerBrowserTest that call LoadDataWithBaseURL to skip these tests when running with --site-per-process.  I\u0027ve also tweaked MessagePortProviderBrowserTest.PostMessage to avoid using LoadDataWithBaseURL (and to improve test verification to also cover the source origin).\n\u003e \n\u003e WDYT?\n\nAck - makes sense to me, thanks!",
      "parentUuid": "3d21cb3b_b0ed65c7",
      "range": {
        "startLine": 858,
        "startChar": 0,
        "endLine": 858,
        "endChar": 39
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bc831adb_504e66dd",
        "filename": "content/browser/frame_host/navigation_request.cc",
        "patchSetId": 15
      },
      "lineNbr": 858,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-22T22:56:33Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Yup, I\u0027ll try to think more about that and follow up there.  I\u0027ll also note that I\u0027m not thrilled about having to call SetSite in so many places.  Maybe we can try calling SetSite() from OnResponseStarted unconditionally (not just for sites requiring dedicated processes), and just remove the SetSite() call from DidNavigate.\n\u003e \u003e \n\u003e \u003e Ack.  This makes sense to me I think.  I can try that in a follow-up CL.\n\u003e \u003e \n\u003e \u003e What about the call to SetSite from RenderFrameHostManager::DetermineSiteInstanceForURL.  This is probably still needed (based on the comment there), right?\n\u003e \n\u003e Thanks for raising this -- thinking about that call, I don\u0027t actually understand it. :) Why would none of the pages share renderers in process-per-site after restore?  If this is only about process-per-site, then it seems we would\u0027ve already done the right thing and returned after processing the process-per-site case earlier in that same block, regardless of session restore (https://cs.chromium.org/chromium/src/content/browser/frame_host/render_frame_host_manager.cc?l\u003d1140\u0026rcl\u003da5f2b542466dc51ec76f68cd383697bd26a3f28f).\n\u003e \n\u003e I tried tracing it back, and it\u0027s been there forever, in the initial commit (https://chromium.googlesource.com/chromium/src/+blame/2526315929de99fa5762583621fb52b626a62ef9/chrome/browser/web_contents.cc#897) [Comment added later in https://codereview.chromium.org/1519025].  So much has changed since then that I\u0027d try taking it out and see if anything breaks. :)   Charlie might also have more context for it -- let\u0027s follow up on this with him.\n\u003e \n\nOk.  I\u0027ve touched this line in my follow-up (not-yet-uploaded) CL, so hopefully I\u0027ll remember to talk about this.\n\n\u003e \u003e \u003e Also, why wouldn\u0027t this matter for the cases with a new browsing instance?\n\u003e \u003e \n\u003e \u003e Because BrowsingInstance::GetSiteInstanceForURL is only called when reusing an old browsing instance.  If LoadDataWithBaseURL always used a new browsing instance (which we\u0027ve established above is not true) then we wouldn\u0027t have to worry about using base URL in the call to SetSite made by BrowsingInstance::GetSiteInstanceForURL.\n\u003e \n\u003e Doesn\u0027t matter now - but doesn\u0027t SiteInstance::CreateForURL() create a new BI and then call BI::GetSiteInstanceForURL on that new BI, and hence call SetSite will still happen in that case?\n\nYou\u0027re right - I didn\u0027t think of this scenario.",
      "parentUuid": "19e99c67_f6afab09",
      "range": {
        "startLine": 858,
        "startChar": 0,
        "endLine": 858,
        "endChar": 39
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1e8472e3_c5ee71be",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 3272,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Since we typically call GetSiteForURL on the URL rather than origin, I\u0027m wondering if it makes sense at all to use |url| instead of |origin_url| here, since both are passed in?  (We\u0027ve already checked that origin_url and url match up above...)\n\nThis would allow it to resolve the right site URL for hosted apps, and maybe that will help with the ShouldLockToOrigin hosted apps issue you mention below?\n\nIn the future, once we start locking hosted apps to their underlying origin, it seems that we\u0027ll want to also somehow pass that underlying origin to CheckOriginLock() somehow, instead of the site_url?  (Not sure what the plumbing for that will look like yet...)",
      "range": {
        "startLine": 3272,
        "startChar": 63,
        "endLine": 3272,
        "endChar": 73
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13ef5bd7_d3f85038",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 3272,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "\u003e Since we typically call GetSiteForURL on the URL rather than origin, I\u0027m wondering if it makes sense at all to use |url| instead of |origin_url| here, since both are passed in?  (We\u0027ve already checked that origin_url and url match up above...)\n\n\u003e This would allow it to resolve the right site URL for hosted apps, and maybe that will help with the ShouldLockToOrigin hosted apps issue you mention below?\n\nThat is a really good point and something I haven\u0027t thought about myself - thanks for pointing this out.  I think identifying hosted apps based on |url| (rather than |origin|) has some potential and we could try doing it in the NO_LOCK case that is currently problematic for hosted apps.  OTOH, when doing this we would have to carve out an exception for about:blank and this might require some careful thinking:\n\n1) would the NO_LOCK case still offer a valuable protection in presence of the about:blank protection?  A compromised renderer could just say that is commits about:blank at isolated origin.\n\n2) we would definitely want to keep the WRONG_LOCK case free of any exceptions\n \n\u003e In the future, once we start locking hosted apps to their underlying origin, it seems that we\u0027ll want to also somehow pass that underlying origin to CheckOriginLock() somehow, instead of the site_url?  (Not sure what the plumbing for that will look like yet...)\n\nI don\u0027t know :-(",
      "parentUuid": "1e8472e3_c5ee71be",
      "range": {
        "startLine": 3272,
        "startChar": 63,
        "endLine": 3272,
        "endChar": 73
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1815805_9e7f7ab4",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 3272,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-21T03:17:34Z",
      "side": 1,
      "message": "Good points about about:blank, it\u0027s indeed problematic. :)  Like about:srcdoc as well.  A few more thoughts, all fine to explore in followups:\n\n* Maybe one option is to use |url| instead of |origin_url| only if |url-\u003eIsStandard()| is true, because this guarantees that the url and origin matched up on line 3258?  There should be no danger in using |url| in that case, even for HAS_WRONG_LOCK.  (The latter may matter once we start locking hosted apps to an origin.)  That would cover the common http/https cases.\n\n* Maybe we should also do the origin lock check on the |url| when |origin| is unique, at least in some cases (e.g., when |url| is standard)?  Otherwise, a page could bypass this whole sanity check by sandboxing itself (e.g., via CSP sandbox flags), thanks to line 3254.  Since that\u0027d be a check on the URL, it might belong in CanCommitURL instead.\n\n* As a separate potential sanity check, I don\u0027t think |origin_url| can ever be about:*.  If we see that, we should probably kill the renderer.  (the origin should always be inherited for about: or, for browser-initiated navigations to about:blank, it should be null/unique.)",
      "parentUuid": "13ef5bd7_d3f85038",
      "range": {
        "startLine": 3272,
        "startChar": 63,
        "endLine": 3272,
        "endChar": 73
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "52e10022_b2b76c1b",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 3272,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-21T23:56:21Z",
      "side": 1,
      "message": "\u003e Good points about about:blank, it\u0027s indeed problematic. :)  Like about:srcdoc as well.  A few more thoughts, all fine to explore in followups:\n\u003e \n\u003e * Maybe one option is to use |url| instead of |origin_url| only if |url-\u003eIsStandard()| is true, because this guarantees that the url and origin matched up on line 3258?  There should be no danger in using |url| in that case, even for HAS_WRONG_LOCK.  (The latter may matter once we start locking hosted apps to an origin.)  That would cover the common http/https cases.\n\nYes - I also wondered about something like what you propose.  My main concern here, is that a compromised renderer can easily side-step the checks if we allow exceptions for these special cases (a compromised renderer can just pretend it is one of the special cases).\n\n\u003e * Maybe we should also do the origin lock check on the |url| when |origin| is unique, at least in some cases (e.g., when |url| is standard)?  Otherwise, a page could bypass this whole sanity check by sandboxing itself (e.g., via CSP sandbox flags), thanks to line 3254.  Since that\u0027d be a check on the URL, it might belong in CanCommitURL instead.\n\nI think bypassing these checks for a unique origin / sandboxed frame is fine:\n\n- In theory the frame with unique origin should not have access to the data associated with the origin of its URL.  OTOH, we don\u0027t isolate unique origins today, so I am not sure if the browser process can robustly deny access to such frames (I\u0027ve opened https://crbug.com/796968 to try to answer this question).\n\n- It seems to me that the whole point of sandboxed frames is that they *can* commit a URL, but their origin becomes unique.  SOP is based on the origin, not the URL.  Therefore I think that site isolation and renderer kills should also be focused on the origin, not the URL.  I understand that today site_url is calculated based on the url, but isn\u0027t this a historical accident (that today in the past browser process did not calculate the origin being navigated to and relied on the origin reported via DidCommitProvisionalLoad).\n\n\u003e * As a separate potential sanity check, I don\u0027t think |origin_url| can ever be about:*.  If we see that, we should probably kill the renderer.  (the origin should always be inherited for about: or, for browser-initiated navigations to about:blank, it should be null/unique.)\n\nInteresting idea.  I guess we can try returning false from CanCommitOrigin if |origin.GetURL().SchemeIs(url::kAboutScheme)|.  I can try that in a follow-up CL.",
      "parentUuid": "d1815805_9e7f7ab4",
      "range": {
        "startLine": 3272,
        "startChar": 63,
        "endLine": 3272,
        "endChar": 73
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1fffa527_d88c4928",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 3272,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-22T22:36:48Z",
      "side": 1,
      "message": "\u003e \u003e Good points about about:blank, it\u0027s indeed problematic. :)  Like about:srcdoc as well.  A few more thoughts, all fine to explore in followups:\n\u003e \u003e \n\u003e \u003e * Maybe one option is to use |url| instead of |origin_url| only if |url-\u003eIsStandard()| is true, because this guarantees that the url and origin matched up on line 3258?  There should be no danger in using |url| in that case, even for HAS_WRONG_LOCK.  (The latter may matter once we start locking hosted apps to an origin.)  That would cover the common http/https cases.\n\u003e \n\u003e Yes - I also wondered about something like what you propose.  My main concern here, is that a compromised renderer can easily side-step the checks if we allow exceptions for these special cases (a compromised renderer can just pretend it is one of the special cases).\n\nYes, agreed with this concern.  I was thinking to use the |url| only for the IsStandard case() and fall back to the |origin| otherwise -- would that introduce any new side-stepping of the checks here?  Also, a compromised renderer can already skip the new verification by sending a \"null\" params.origin in DidCommit, right?  (But maybe enough browser-side checks will fail that it doesn\u0027t make much sense for it to do that, as you note below?)\n\n\u003e \n\u003e \u003e * Maybe we should also do the origin lock check on the |url| when |origin| is unique, at least in some cases (e.g., when |url| is standard)?  Otherwise, a page could bypass this whole sanity check by sandboxing itself (e.g., via CSP sandbox flags), thanks to line 3254.  Since that\u0027d be a check on the URL, it might belong in CanCommitURL instead.\n\u003e \n\u003e I think bypassing these checks for a unique origin / sandboxed frame is fine:\n\u003e \n\u003e - In theory the frame with unique origin should not have access to the data associated with the origin of its URL.  OTOH, we don\u0027t isolate unique origins today, so I am not sure if the browser process can robustly deny access to such frames (I\u0027ve opened https://crbug.com/796968 to try to answer this question).\n\nYes, exactly.  Blink should deny access to cookies/localStorage/etc. from a sandboxed frame, but with a compromised renderer I don\u0027t think we\u0027d block access in CanAccessDataForOrigin, etc..  Let\u0027s follow up on your bug.\n\n\u003e \n\u003e - It seems to me that the whole point of sandboxed frames is that they *can* commit a URL, but their origin becomes unique.  SOP is based on the origin, not the URL.  Therefore I think that site isolation and renderer kills should also be focused on the origin, not the URL.  I understand that today site_url is calculated based on the url, but isn\u0027t this a historical accident (that today in the past browser process did not calculate the origin being navigated to and relied on the origin reported via DidCommitProvisionalLoad).\n\nI think this makes sense.  If a.com embeds a sandboxed frame a.com/s, we could even put it into an OOPIF, as the two shouldn\u0027t be able to script each other.  We could then origin-lock it to a unique lock, to prevent it from accessing any data from a.com.  (We\u0027d do this only if the sandbox attribute didn\u0027t include allow-same-origin.)  This would certainly impact our process count, though maybe we could group all unique-origin frames into one process? :)\n\n\u003e \n\u003e \u003e * As a separate potential sanity check, I don\u0027t think |origin_url| can ever be about:*.  If we see that, we should probably kill the renderer.  (the origin should always be inherited for about: or, for browser-initiated navigations to about:blank, it should be null/unique.)\n\u003e \n\u003e Interesting idea.  I guess we can try returning false from CanCommitOrigin if |origin.GetURL().SchemeIs(url::kAboutScheme)|.  I can try that in a follow-up CL.\n\nAck",
      "parentUuid": "52e10022_b2b76c1b",
      "range": {
        "startLine": 3272,
        "startChar": 63,
        "endLine": 3272,
        "endChar": 73
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19db17c2_0fc78dc1",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 3283,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Do you mean if ShouldLockToOrigin(site_url) *returns true*?",
      "range": {
        "startLine": 3283,
        "startChar": 9,
        "endLine": 3283,
        "endChar": 37
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d182067c_e04b8605",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 15
      },
      "lineNbr": 3283,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Yes - this is what I meant :-).  Done.",
      "parentUuid": "19db17c2_0fc78dc1",
      "range": {
        "startLine": 3283,
        "startChar": 9,
        "endLine": 3283,
        "endChar": 37
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "339583fe_12faaaf0",
        "filename": "content/browser/web_contents/web_contents_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 1821,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Would it be better to leave the cross-site navigation in and either use the NavigationSimulator or compute navigating_rfh instead, like the other tests, so we still have cross-process navigation coverage of interstitial dismissal via --site-per-process?  (Same for ShowInterstitialOnInterstitial below)",
      "range": {
        "startLine": 1821,
        "startChar": 0,
        "endLine": 1821,
        "endChar": 42
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c27af60f_180123f9",
        "filename": "content/browser/web_contents/web_contents_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 1821,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "I am not sure.  This goes against the principle that a test should test one and only one thing.  If cross-site navigation coverage is important, it should have another test.\n\nI understand that the same concern applies to navigation_controller_impl_unittest.cc - I was also wondering what is the right thing to do over there.  One difference is that here there are only 3 tests affected + here we haven\u0027t had to use |navigating_rfh| trick yet.\n\nSo - I think making the tests same-site here might be okay?",
      "parentUuid": "339583fe_12faaaf0",
      "range": {
        "startLine": 1821,
        "startChar": 0,
        "endLine": 1821,
        "endChar": 42
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2138b52d_8fd59148",
        "filename": "content/browser/web_contents/web_contents_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3302,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-12-19T02:33:06Z",
      "side": 1,
      "message": "Yes, changing to a chromium.org seems right here, as the test intends for this third navigation to remain a same-process navigation with the first one.",
      "range": {
        "startLine": 3302,
        "startChar": 15,
        "endLine": 3302,
        "endChar": 20
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71305ce1_a57ad913",
        "filename": "content/browser/web_contents/web_contents_impl_unittest.cc",
        "patchSetId": 15
      },
      "lineNbr": 3302,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-12-20T22:48:17Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "2138b52d_8fd59148",
      "range": {
        "startLine": 3302,
        "startChar": 15,
        "endLine": 3302,
        "endChar": 20
      },
      "revId": "9b6414bff1a4d809739817a0ad762b654ad8acd6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}