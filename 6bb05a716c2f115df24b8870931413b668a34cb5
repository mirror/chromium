{
  "comments": [
    {
      "key": {
        "uuid": "ff0812fe_9b2957a3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 7,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "end with period",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "655a038d_78848f2d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "note that \"per verification vs per request\" are not clear when reading this.\nI think saying per-URLRequest vs per CertVerifyProc::Verify() or some such thing would clarify.",
      "range": {
        "startLine": 27,
        "startChar": 22,
        "endLine": 27,
        "endChar": 54
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79763c6f_db453ed9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "This paragraph seems to describe consequences of how CertVerifyProc is layered by CachingCertVerifier (not a 1:1 relationship between URLRequestJobs and CertVerifyProc::Verify() calls).\n\nI don\u0027t think all the justification is needed in the CL description. Rather these differences would be better explained in the histogram description for the corresponding metrics.",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fbafa10_c452ffde",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-21T02:35:02Z",
      "side": 1,
      "message": "It has no relation to CachingCertVerifier, but because multiple URLRequests may reuse sockets (HTTP/2, QUIC, or HTTP/1.1 + KeepAlive). I think it\u0027s important to include this in the CL description, considering a whole academic paper was written on the importance of these differences in drawing conclusions ( https://research.google.com/pubs/pub46197.html )",
      "parentUuid": "79763c6f_db453ed9",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85e1c170_d6149602",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "Can you link to a bug motivating this change?\n\nThere may be some risk to this being reverted due to binary size increase for all the cert hashes (how much rodata does it add?), I think it would be helpful to have a bug on file for the change acknowledging this cost.",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a87de84_74495397",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-21T02:35:02Z",
      "side": 1,
      "message": "Yes, that was acked as a TODO before landing :)",
      "parentUuid": "85e1c170_d6149602",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "321be0f6_23076776",
        "filename": "net/cert/cert_verify_proc.cc",
        "patchSetId": 4
      },
      "lineNbr": 275,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "From the name I would have expected it to histogram the chain\u0027s root.\nHave you considered names like \"HistogramFirstKnownRoot\", or \"MostSpecificTrustAnchor\" as this is called in the histogram description?",
      "range": {
        "startLine": 275,
        "startChar": 5,
        "endLine": 275,
        "endChar": 28
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4363c5bf_5b228bb9",
        "filename": "net/cert/cert_verify_proc.cc",
        "patchSetId": 4
      },
      "lineNbr": 275,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-21T02:35:02Z",
      "side": 1,
      "message": "Hrm. I was hoping to avoid that confusion, but it looks like I failed.\n\nThe common issue is that \u0027root cert\u0027 and \u0027trust anchor\u0027 are used interchangably, and there may be multiple trust anchors within a given chain. This is because a given platform may have a different set of trust anchors than how we (Chrome) logically view trust anchors (and their operating organizations).\n\nI wanted to avoid the confusion from the more precise term \"trust anchor\" from the code, but opted for more specificity in the description.\n\nHow do you feel about RecordTrustAnchorHistogram? Even \u0027most-specific\u0027 was a linguistic nuance I was dancing around, so I was wanting to avoid that in the API signature. I think it also means renaming the histogram - which I\u0027ve gone ahead and done.",
      "parentUuid": "321be0f6_23076776",
      "range": {
        "startLine": 275,
        "startChar": 5,
        "endLine": 275,
        "endChar": 28
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b31c9055_27f9ff67",
        "filename": "net/cert/cert_verify_proc.cc",
        "patchSetId": 4
      },
      "lineNbr": 278,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "I think we may as well histogram the zero value too (outside of this loop, when no known root was identified).\n\nCould help validate that we have enumerated the full set of known roots; especially if we have a histogram for CertVerifyResult::is_issued_by_known_root to compare it against.",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f2b3709_d59a4e30",
        "filename": "net/cert/cert_verify_proc.cc",
        "patchSetId": 4
      },
      "lineNbr": 278,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-21T02:35:02Z",
      "side": 1,
      "message": "It\u0027s intentional that this isn\u0027t histogrammed.\n\nFor example, in a certificate chain of \u0027leaf\u0027, \u0027intermediate\u0027, \u0027root\u0027, where root is a trust anchor, both \u0027leaf\u0027 and \u0027intermediate\u0027 would return 0.\n\nThis is because of working in a bottom-up approach, but the same concern would apply in a top-down approach of \u0027leaf\u0027, \u0027intermediate\u0027, \u0027trust-anchor 1\u0027, \u0027bridge\u0027, \u0027trust anchor 2\u0027 - simply walking down from TA2 to the first zero value (bridge) would miss \u0027trust anchor 1\u0027.\n\nFinally, there\u0027s the enterprise scenario of only a single trusted root (the organization\u0027s \u0027trust store\u0027 key), which goes \u0027leaf\u0027, \u0027intermediate\u0027, \u0027public trust anchor\u0027, \u0027private enterprise key\u0027. This is an existing deficiency of \u0027is_issued_by_known_root\u0027 for those organizations, but it\u0027s why this approach was chosen. There\u0027s no interest in knowing about \u0027leaf\u0027, \u0027intermediate\u0027, or \u0027bridge\u0027",
      "parentUuid": "b31c9055_27f9ff67",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96364f64_7bf25a30",
        "filename": "net/cert/cert_verify_proc.cc",
        "patchSetId": 4
      },
      "lineNbr": 280,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "nit \"Usage\" makes me think key usage / EKU. May just all this \"KnownRoot\"?",
      "range": {
        "startLine": 280,
        "startChar": 49,
        "endLine": 280,
        "endChar": 62
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b5197ec_877f5d4f",
        "filename": "net/cert/known_roots.cc",
        "patchSetId": 4
      },
      "lineNbr": 1,
      "author": {
        "id": 1103654
      },
      "writtenOn": "2017-11-20T23:19:45Z",
      "side": 1,
      "message": "Nit: No (c) for new files.",
      "range": {
        "startLine": 1,
        "startChar": 16,
        "endLine": 1,
        "endChar": 17
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89b071c8_381a75a8",
        "filename": "net/cert/known_roots.cc",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 1103654
      },
      "writtenOn": "2017-11-20T23:19:45Z",
      "side": 1,
      "message": "Nit: Seems like this code could use a unit test.\n\nNot sure if you want to use the real generated data from the test or supply some dummy data, but would be good to check the logic.\n\nAlso, the unit test could test that kRootCerts is actually in sorted order - since that is required for this code to work correctly.",
      "range": {
        "startLine": 37,
        "startChar": 75,
        "endLine": 37,
        "endChar": 0
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "535161bd_2ee360fd",
        "filename": "net/cert/known_roots.h",
        "patchSetId": 4
      },
      "lineNbr": 8,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "for the global int32_t (rather than std::int32_t), shouldn\u0027t we be including \u003cstdint.h\u003e instead? (which is what you use in root_cert_list_generated.h).",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a368142_d4c5029f",
        "filename": "net/cert/known_roots.h",
        "patchSetId": 4
      },
      "lineNbr": 20,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "nit: Instead of \"ForHashValue\" how about \"ForSPKI\" or \"FromSPKI\". And the parameter can then be named |spki_hash| instead of just |hash|.",
      "range": {
        "startLine": 20,
        "startChar": 44,
        "endLine": 20,
        "endChar": 56
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c11943b_23ed7106",
        "filename": "net/cert/root_cert_list_generated.h",
        "patchSetId": 4
      },
      "lineNbr": 5,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "nit: generated by.\n\nSplitting ends on language, but I don\u0027t think \"auto-generated\" is the right term given this is a manually run process, and not something the build would do automatically.",
      "range": {
        "startLine": 5,
        "startChar": 16,
        "endLine": 5,
        "endChar": 35
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17119714_773299e7",
        "filename": "net/cert/root_cert_list_generated.h",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "can we save some bytes by using an int16_t?",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 22
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fd04f1cb_603bd89a",
        "filename": "net/cert/root_cert_list_generated.h",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-21T02:35:02Z",
      "side": 1,
      "message": "Histograms themselves use int32_t for the underlying type, but it also wouldn\u0027t save bytes in the structure due to the alignment requirements for pointers, of which sha256_spki_hash would be. That is, unfortunately, we\u0027d still end up with two bytes of padding if I\u0027m not mistaken.",
      "parentUuid": "17119714_773299e7",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 22
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d516aa53_c87a830e",
        "filename": "net/data/ssl/root_stores/README.md",
        "patchSetId": 4
      },
      "lineNbr": 20,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "nit: mention that this is hex-encoded somewhere.",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c41933f_ba2be918",
        "filename": "net/data/ssl/root_stores/README.md",
        "patchSetId": 4
      },
      "lineNbr": 60,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "Useful documentation in this file!",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d5d4f62_e7ce4608",
        "filename": "net/url_request/url_request_http_job.cc",
        "patchSetId": 4
      },
      "lineNbr": 89,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "same comment as in other locatio: spki_hashes",
      "range": {
        "startLine": 89,
        "startChar": 50,
        "endLine": 89,
        "endChar": 56
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30c5922d_c51839fc",
        "filename": "net/url_request/url_request_http_job.cc",
        "patchSetId": 4
      },
      "lineNbr": 1478,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "Is this intentionally different in terms of errors? The per-verification logging only happens on successful verifications, whereas I believe this runs on failed cert verifications. Or is |transaction_| expected to be null in those cases?",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "739c214b_bd2faed9",
        "filename": "net/url_request/url_request_http_job.cc",
        "patchSetId": 4
      },
      "lineNbr": 1478,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-21T02:35:02Z",
      "side": 1,
      "message": "Good point; it doesn\u0027t necessarily reset transaction_, so this would count those cases (and miss cases where transaction_ had been reset as part of error processing)\n\nI\u0027ve since moved this up to OnStartCompleted and updated the error parsing and checking.",
      "parentUuid": "30c5922d_c51839fc",
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "61a156e1_c919353f",
        "filename": "tools/metrics/histograms/histograms.xml",
        "patchSetId": 4
      },
      "lineNbr": 40052,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-11-21T00:19:14Z",
      "side": 1,
      "message": "Isn\u0027t this the same comment as below? I expect you mean to distinguish between per-[URL]request vs per-cert verify",
      "range": {
        "startLine": 40052,
        "startChar": 4,
        "endLine": 40052,
        "endChar": 16
      },
      "revId": "6bb05a716c2f115df24b8870931413b668a34cb5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}