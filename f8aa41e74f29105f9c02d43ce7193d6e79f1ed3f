{
  "comments": [
    {
      "key": {
        "uuid": "b8e79778_5ac3d2dd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2018-01-02T14:32:24Z",
      "side": 1,
      "message": "didn\u0027t read chrome code, but this description doesn\u0027t really make sense to me\n\nCompositorView and ComopsitorSurfaceHolder are pretty tightly coupled (they used to be the same thing before this whole surface switching thing for full screen happened). So I don\u0027t really understand what it means to destroy one but not the other.",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f2290c9_6d2842f0",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/compositor/CompositorView.java",
        "patchSetId": 2
      },
      "lineNbr": 423,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2018-01-02T18:55:53Z",
      "side": 1,
      "message": "conceptually it seems odd that we are nulling this out.\n\nSimply based on the name, it seems like the surface manager \"should\" be in charge of managing the surfaces.  I\u0027m wondering why we couldn\u0027t make it be aware of the VR state of the world and allow an injected surface.\n\nAlternatively, could this swap out the surface manager from a OverlayModeCapableSurfaceManager to a VrSurfaceManager?  Ideally, i\u0027d like to avoid forking the code everywhere if that is possible.",
      "range": {
        "startLine": 423,
        "startChar": 8,
        "endLine": 423,
        "endChar": 33
      },
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fa27bea_05c49789",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/compositor/CompositorView.java",
        "patchSetId": 2
      },
      "lineNbr": 423,
      "author": {
        "id": 1002411
      },
      "writtenOn": "2018-01-08T23:11:28Z",
      "side": 1,
      "message": "Reusing the existing CompositorSurfaceManager but with an injected Surface was kind of gross, so I went with an interface and separate implementation of the SurfaceManager for VR.",
      "parentUuid": "4f2290c9_6d2842f0",
      "range": {
        "startLine": 423,
        "startChar": 8,
        "endLine": 423,
        "endChar": 33
      },
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fd2edcb0_419c3513",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2018-01-02T14:32:24Z",
      "side": 1,
      "message": "DCHECK this is not throwing away an existing layer. Also what about readback_layer_tree_? Registering/unregistering begin frame source. Root layer bounds, \n\nshould avoid duplicating this code with the constructor/destructor. This should do things like a proper setter, so check if root_window_ \u003d\u003d root_window, allow nulls. Then constructor and destructor can just call this instead",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b00d129c_1df4b214",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 1002411
      },
      "writtenOn": "2018-01-09T17:16:05Z",
      "side": 1,
      "message": "I don\u0027t think we want the destructor calling this function exactly, and I don\u0027t think we want to allow a null root window (as the class expects a non-null root_window_ at all times). Instead I\u0027ve extracted the common functionality for teardown.\n\nI\u0027d also like to simplify this here by not worrying about the begin frame source, and just DCHECKing that we don\u0027t currently have a surface (as is the case for VR), with a TODO for if we ever want to use this function when we do have a surface.",
      "parentUuid": "fd2edcb0_419c3513",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a211ac24_f39a198e",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2018-01-09T18:32:36Z",
      "side": 1,
      "message": "\u003e I don\u0027t think we want the destructor calling this function exactly, and I don\u0027t think we want to allow a null root window (as the class expects a non-null root_window_ at all times). Instead I\u0027ve extracted the common functionality for teardown.\n\u003e \n\u003e I\u0027d also like to simplify this here by not worrying about the begin frame source, and just DCHECKing that we don\u0027t currently have a surface (as is the case for VR), with a TODO for if we ever want to use this function when we do have a surface.\n\nwhat does BFS have to do with the android surface?\n\nAlso you missed the bit about calling root_window_-\u003eGetLayer()-\u003eSetBounds on the new window",
      "parentUuid": "b00d129c_1df4b214",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1893a57a_841e108b",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 1002411
      },
      "writtenOn": "2018-01-09T18:52:43Z",
      "side": 1,
      "message": "BFS isn\u0027t set if we don\u0027t have a surface (SetVisible(false) is called), so if we do the window swap while we don\u0027t have a surface, we don\u0027t have to do anything. Adding a surface later will correctly set visibility and BFS (AFAIK).\n\n(Also, added the SetBounds call)",
      "parentUuid": "a211ac24_f39a198e",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a65e40c0_bd2b1379",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2018-01-09T19:08:50Z",
      "side": 1,
      "message": "\u003e BFS isn\u0027t set if we don\u0027t have a surface (SetVisible(false) is called), so if we do the window swap while we don\u0027t have a surface, we don\u0027t have to do anything. Adding a surface later will correctly set visibility and BFS (AFAIK).\n\u003e \n\u003e (Also, added the SetBounds call)\n\nMaybe DCHECK(!display_) then, and also add a comment explaining it\u0027s to ensure no BFS is registered to the old window, and no BFS needs to be registered on the new window.",
      "parentUuid": "1893a57a_841e108b",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e6e6c1e_987cf030",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 1002411
      },
      "writtenOn": "2018-01-09T19:13:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a65e40c0_bd2b1379",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "75d7623c_8409f075",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 539,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2018-01-02T14:32:24Z",
      "side": 1,
      "message": "similarly, dedup this with CreateLayerTreeHost",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55f37974_ce48329f",
        "filename": "content/browser/renderer_host/compositor_impl_android.cc",
        "patchSetId": 2
      },
      "lineNbr": 539,
      "author": {
        "id": 1002411
      },
      "writtenOn": "2018-01-09T17:16:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "75d7623c_8409f075",
      "revId": "f8aa41e74f29105f9c02d43ce7193d6e79f1ed3f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}