// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module cc.mojom;

import "cc/ipc/filter_operations.mojom";
import "cc/ipc/render_pass_id.mojom";
import "cc/ipc/shared_quad_state.mojom";
import "cc/ipc/surface_id.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";
import "ui/gfx/mojo/transform.mojom";

struct Color {
  uint32 rgba;
};

struct DebugBorderQuadState {
  // Debug border color.
  Color color;

  // Debug border width.
  int32 width;
};

// TODO(jamesr): Populate subtype fields.
struct IoSurfaceContentQuadState {};

struct RenderPassQuadState {
  cc.mojom.RenderPassId render_pass_id;

  // If nonzero, resource id of mask to use when drawing this pass.
  uint32 mask_resource_id;
  gfx.mojom.PointF mask_uv_scale;
  gfx.mojom.Size mask_texture_size;

  // Post-processing filters, applied to the pixels in the render pass' texture.
  cc.mojom.FilterOperations filters;

  // The scale from layer space of the root layer of the render pass to
  // the render pass physical pixels. This scale is applied to the filter
  // parameters for pixel-moving filters. This scale should include
  // content-to-target-space scale, and device pixel ratio.
  gfx.mojom.PointF filters_scale;

  // Post-processing filters, applied to the pixels showing through the
  // background of the render pass, from behind it.
  cc.mojom.FilterOperations background_filters;
};

struct SolidColorQuadState {
  Color color;
  bool force_anti_aliasing_off;
};

struct SurfaceQuadState {
  cc.mojom.SurfaceId surface;
};

struct TextureQuadState {
  uint32 resource_id;
  bool premultiplied_alpha;
  gfx.mojom.PointF uv_top_left;
  gfx.mojom.PointF uv_bottom_right;
  Color background_color;
  array<float, 4> vertex_opacity;
  bool y_flipped;
  bool nearest_neighbor;
  bool secure_output_only;
};

struct TileQuadState {
  gfx.mojom.RectF tex_coord_rect;
  gfx.mojom.Size texture_size;
  bool swizzle_contents;
  uint32 resource_id;
  bool nearest_neighbor;
};

struct StreamVideoQuadState {};

enum YUVColorSpace {
  REC_601,       // SDTV standard with restricted "studio swing" color range.
  REC_709,       // HDTV standard with restricted "studio swing" color range.
  JPEG,          // Full color range [0, 255] JPEG color space.
};

struct YUVVideoQuadState {
  gfx.mojom.RectF ya_tex_coord_rect;
  gfx.mojom.RectF uv_tex_coord_rect;
  gfx.mojom.Size ya_tex_size;
  gfx.mojom.Size uv_tex_size;
  uint32 y_plane_resource_id;
  uint32 u_plane_resource_id;
  uint32 v_plane_resource_id;
  uint32 a_plane_resource_id;
  YUVColorSpace color_space;
  float resource_offset;
  float resource_multiplier;
};

enum Material {
  DEBUG_BORDER = 1,
  PICTURE_CONTENT,
  RENDER_PASS,
  SOLID_COLOR,
  STREAM_VIDEO_CONTENT,
  SURFACE_CONTENT,
  TEXTURE_CONTENT,
  TILED_CONTENT,
  YUV_VIDEO_CONTENT,
};

struct DrawQuad {
  Material material;

  // This rect, after applying the quad_transform(), gives the geometry that
  // this quad should draw to. This rect lives in content space.
  gfx.mojom.Rect rect;

  // This specifies the region of the quad that is opaque. This rect lives in
  // content space.
  gfx.mojom.Rect opaque_rect;

  // Allows changing the rect that gets drawn to make it smaller. This value
  // should be clipped to |rect|. This rect lives in content space.
  gfx.mojom.Rect visible_rect;

  // Allows changing the rect that gets drawn to make it smaller. This value
  // should be clipped to |rect|. This rect lives in content space.
  bool needs_blending;

  // Index into the containing pass' shared quad state array which has state
  // (transforms etc) shared by multiple quads.
  uint32 shared_quad_state_index;

  // Only one of the following will be set, depending on the material.
  DebugBorderQuadState? debug_border_quad_state;
  IoSurfaceContentQuadState? io_surface_quad_state;
  RenderPassQuadState? render_pass_quad_state;
  SolidColorQuadState? solid_color_quad_state;
  SurfaceQuadState? surface_quad_state;
  TextureQuadState? texture_quad_state;
  TileQuadState? tile_quad_state;
  StreamVideoQuadState? stream_video_quad_state;
  YUVVideoQuadState? yuv_video_quad_state;
};

struct RenderPass {
  cc.mojom.RenderPassId id;
  gfx.mojom.Rect output_rect;
  gfx.mojom.Rect damage_rect;
  gfx.mojom.Transform transform_to_root_target;
  bool has_transparent_background;
  array<DrawQuad> quads;
  array<cc.mojom.SharedQuadState> shared_quad_states;
};
