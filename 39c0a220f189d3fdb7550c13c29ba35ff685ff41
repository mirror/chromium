{
  "comments": [
    {
      "key": {
        "uuid": "aa808041_09bd4742",
        "filename": "gin/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1116032
      },
      "writtenOn": "2017-11-09T15:15:39Z",
      "side": 1,
      "message": "nit: v8_task_runner?",
      "range": {
        "startLine": 67,
        "startChar": 5,
        "endLine": 67,
        "endChar": 18
      },
      "revId": "39c0a220f189d3fdb7550c13c29ba35ff685ff41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d65203dc_85cfe1e7",
        "filename": "gin/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2017-11-15T10:53:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aa808041_09bd4742",
      "range": {
        "startLine": 67,
        "startChar": 5,
        "endLine": 67,
        "endChar": 18
      },
      "revId": "39c0a220f189d3fdb7550c13c29ba35ff685ff41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2674021a_ebb82303",
        "filename": "gin/per_isolate_data.cc",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2017-11-09T11:39:41Z",
      "side": 1,
      "message": "As a high level point, before I go into a detailed review, I want to make sure this solves your bug. \n\nSince the task runners are shared pointers, they will still live after the PerIsolateData has been destroyed (if held by background tasks) - as such the tasks will still get posted to them. Having read your doc again, I think the sequeunce of events you describe is not quite correct - you mention that the task runner is deleted in WebThreadSupportingGC::ShutdownOnThread, however this isn\u0027t always the actual task runner being used here (e.g., if base::ThreadTaskRunnerHandle::Get() is called you get the default task runner, and if the Blink Scheduler is enabled you get the V8TaskRunner [1]).\n\nAs such, there might still be tasks posted after the PerIsolateData has been deleted. I think this is OK since the task runner doesn\u0027t access PerIsolateData, however it does mean we still need to be careful to ensure that we drain all tasks before the isolate itself destroyed. Would it make sense to add an API to V8TaskRunner to drain the queue and call that when the isolate is being destroyed (similar to what you did in default platform)?\n\n[1] https://cs.chromium.org/chromium/src/third_party/WebKit/Source/bindings/core/v8/V8Initializer.cpp?l\u003d611",
      "revId": "39c0a220f189d3fdb7550c13c29ba35ff685ff41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eca1c04d_7984efdb",
        "filename": "gin/per_isolate_data.cc",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1116032
      },
      "writtenOn": "2017-11-09T15:15:39Z",
      "side": 1,
      "message": "The contract we ended up with in Chrome is that there\u0027s no way to flush already-queued tasks from the queue; everything posted up until the current point will eventually run. If clients need to cancel tasks, they should use a weak pointer bound as the first argument to do that.\n\nI think that leaves us with two options:\n\n1. Use similar weak pointer semantics with the isolate in v8. This is probably difficult.\n\n2. Wrap the posted tasks in V8ForegroundTaskRunner with a weak pointer and add a way to shut down the task runner which invalidates the pointers.",
      "parentUuid": "2674021a_ebb82303",
      "revId": "39c0a220f189d3fdb7550c13c29ba35ff685ff41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b3deedf_8325d26a",
        "filename": "gin/per_isolate_data.cc",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2017-11-10T15:00:18Z",
      "side": 1,
      "message": "With the CancelableTaskManager we already have a mechanism in V8 which invalidates tasks in the task queue which should not be executed. The contract in V8 is that any task which accesses the isolate has to be managed by a CancelableTaskManager. The CancelableTaskManager invalidates all its tasks when the isolate shuts down, which means they will just return when they get called, without executing any code.\n\nThere may be an issue though with the RunWithLocker wrapper which is sometimes used to wrap tasks. This wrapper accesses the isolate before the invalidated task is actually accessed. If you say that tasks are always executed, we have to fix this in some way. Ross, do you know more about this RunWithLocker stuff? Is this actually a problem we have to deal with?",
      "parentUuid": "eca1c04d_7984efdb",
      "revId": "39c0a220f189d3fdb7550c13c29ba35ff685ff41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3bb3484_e3932e0d",
        "filename": "gin/per_isolate_data.cc",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2017-11-10T16:59:06Z",
      "side": 1,
      "message": "Yes you\u0027re right, the CancelableTaskManager should ensure we are safe within V8, it\u0027s just the RunWithLocker wrapper which is a potential issue (and is a pain since the task runner needs to keep the isolate around).\n\nAFAIK the locker mode is only used for PAC file processing in the browser process, and I don\u0027t think that isolate ever gets destroyed if it is created, so it should be safe.\n\nLet\u0027s do this - create two foreground-task-runners - one for locker use-case and the normal one without, that way we can avoid having a pointer to the isolate in the normal foreground-task-runner which will ensure we don\u0027t accidentally use it in the future. While doing this, could you put each of the task runners (and the background-task-runner) in seperate cc/h files.",
      "parentUuid": "5b3deedf_8325d26a",
      "revId": "39c0a220f189d3fdb7550c13c29ba35ff685ff41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bfd2cb1_ed8addda",
        "filename": "gin/per_isolate_data.cc",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1141154
      },
      "writtenOn": "2017-11-15T10:53:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b3bb3484_e3932e0d",
      "revId": "39c0a220f189d3fdb7550c13c29ba35ff685ff41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}