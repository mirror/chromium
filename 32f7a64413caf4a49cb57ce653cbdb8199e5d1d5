{
  "comments": [
    {
      "key": {
        "uuid": "1dcb58dc_3611b2c8",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 33
      },
      "lineNbr": 1918,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-25T01:30:08Z",
      "side": 1,
      "message": "can this be BindOnce?",
      "range": {
        "startLine": 1918,
        "startChar": 16,
        "endLine": 1918,
        "endChar": 29
      },
      "revId": "32f7a64413caf4a49cb57ce653cbdb8199e5d1d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2dba2dea_5a92a7fa",
        "filename": "content/browser/appcache/appcache_storage_impl.cc",
        "patchSetId": 33
      },
      "lineNbr": 1954,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-07-25T01:30:08Z",
      "side": 1,
      "message": "This code assumes we\u0027ll be receiving a post cleanup callback in the future. I\u0027m not sure that\u0027s a safe assumption? What if we\u0027ve already received the post cleanup callback or if diskcache initialziation was never attempted? It looks like DatabaseTask::OnFatalError can occur prior to diskcache intialization.\n\nHere\u0027s an idea, have two flags...\n\ndelete_and_start_over_pending_\ndisk_cache_directory_in_use_\n\nThe latter is set to true when disk_cache_-\u003eInitWithDiskBackend() is called and reset to false in the callback. If !disk_cache_directory_in_use_, DeleteAndStartOver does not have to wait for the post cleanup callback.",
      "range": {
        "startLine": 1954,
        "startChar": 4,
        "endLine": 1954,
        "endChar": 34
      },
      "revId": "32f7a64413caf4a49cb57ce653cbdb8199e5d1d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d072a9f_720e320a",
        "filename": "content/browser/cache_storage/cache_storage_cache.cc",
        "patchSetId": 33
      },
      "lineNbr": 1402,
      "author": {
        "id": 1116284
      },
      "writtenOn": "2017-07-25T17:44:52Z",
      "side": 1,
      "message": "This is unfortunately too simple a solution. We don\u0027t reuse CacheStorageCache objects. Once it\u0027s closed it can\u0027t reopen the cache, hence waiting_for_backend_close_ won\u0027t work. Instead, the CacheStorage, which owns the CacheStorageCache\u0027s, will need to keep track of which CacheStorageCache\u0027s are in the midst of closing and delay the creation of new ones. Since that\u0027s blocking you here I\u0027ll work on that asap.",
      "range": {
        "startLine": 1402,
        "startChar": 4,
        "endLine": 1402,
        "endChar": 30
      },
      "revId": "32f7a64413caf4a49cb57ce653cbdb8199e5d1d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac577442_9ba02901",
        "filename": "content/browser/cache_storage/cache_storage_cache.cc",
        "patchSetId": 33
      },
      "lineNbr": 1402,
      "author": {
        "id": 1226494
      },
      "writtenOn": "2017-07-25T17:57:18Z",
      "side": 1,
      "message": "So it\u0027s not the only thing that\u0027s going on. See also \nhttps://chromium-review.googlesource.com/c/565465/33/net/disk_cache/disk_cache.cc#193\nI am not entirely comfortable with that, though; it\u0027s semantically messy with user callbacks also existing.\n\nHaving things care about the callback from CacheStorageCache::CloseImpl returning is probably better.\n\nThis isn\u0027t an immediate blocking concern, though, since this CL has a lot of pieces which have to go in separately before this. Like the whole CleanupContext thing in disk_cache. \n\n(And a lot of more mundane stuff covering simpler usages)",
      "parentUuid": "3d072a9f_720e320a",
      "range": {
        "startLine": 1402,
        "startChar": 4,
        "endLine": 1402,
        "endChar": 30
      },
      "revId": "32f7a64413caf4a49cb57ce653cbdb8199e5d1d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ff69483_8121d4dd",
        "filename": "content/browser/cache_storage/cache_storage_cache.cc",
        "patchSetId": 33
      },
      "lineNbr": 1402,
      "author": {
        "id": 1116284
      },
      "writtenOn": "2017-07-25T20:21:36Z",
      "side": 1,
      "message": "Ohh.. if the backend could keep track of this and just delay creation (in a sane way) that would be *awesome*. \n\nI\u0027ve written the CacheStorage patch which calls Close for every backend and waits for it to complete, it\u0027s pretty large and certainly adds some complexity. I think I\u0027d prefer the backend solution since that solves the problem for all consumers automatically.\n\nWIP CL here: https://chromium-review.googlesource.com/585599",
      "parentUuid": "ac577442_9ba02901",
      "range": {
        "startLine": 1402,
        "startChar": 4,
        "endLine": 1402,
        "endChar": 30
      },
      "revId": "32f7a64413caf4a49cb57ce653cbdb8199e5d1d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}