// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef REMOTING_PROTOCOL_TRANSPORT_H_
#define REMOTING_PROTOCOL_TRANSPORT_H_

#include <string>

#include "base/basictypes.h"
#include "base/callback_forward.h"
#include "base/memory/scoped_ptr.h"
#include "base/threading/non_thread_safe.h"
#include "net/base/ip_endpoint.h"
#include "remoting/protocol/errors.h"

namespace cricket {
class Candidate;
}  // namespace cricket

namespace buzz {
class XmlElement;
}  // namespace buzz

namespace remoting {
namespace protocol {

class Authenticator;
class DatagramChannelFactory;
class P2PDatagramSocket;
class StreamChannelFactory;

enum class TransportRole {
  SERVER,
  CLIENT,
};

struct TransportRoute {
  enum RouteType {
    DIRECT,
    STUN,
    RELAY,
  };

  // Helper method to get string representation of the type.
  static std::string GetTypeString(RouteType type);

  TransportRoute();
  ~TransportRoute();

  RouteType type;
  net::IPEndPoint remote_address;
  net::IPEndPoint local_address;
};

// Transport objects are responsible for establishing P2P connections.
//
// TODO(sergeyu): Remove this interface and rename TransportSession interface to
// Transport.
class Transport : public base::NonThreadSafe {
 public:
  class EventHandler {
   public:
    EventHandler() {};
    virtual ~EventHandler() {};

    // Called to pass ICE credentials to the session. Used only for STANDARD
    // version of ICE, see SetIceVersion().
    virtual void OnTransportIceCredentials(Transport* transport,
                                           const std::string& ufrag,
                                           const std::string& password) = 0;

    // Called when the transport generates a new candidate that needs
    // to be passed to the AddRemoteCandidate() method on the remote
    // end of the connection.
    virtual void OnTransportCandidate(Transport* transport,
                                      const cricket::Candidate& candidate) = 0;

    // Called when transport route changes. Can be called even before
    // the transport is connected.
    virtual void OnTransportRouteChange(Transport* transport,
                                        const TransportRoute& route) = 0;

    // Called when when the transport has failed to connect or reconnect.
    virtual void OnTransportFailed(Transport* transport) = 0;

    // Called when the transport is about to be deleted.
    virtual void OnTransportDeleted(Transport* transport) = 0;
  };

  typedef base::Callback<void(scoped_ptr<P2PDatagramSocket>)> ConnectedCallback;

  Transport() {}
  virtual ~Transport() {}

  // Connects the transport and calls the |callback| after that.
  virtual void Connect(const std::string& name,
                       Transport::EventHandler* event_handler,
                       const ConnectedCallback& callback) = 0;

  // Sets remote ICE credentials.
  virtual void SetRemoteCredentials(const std::string& ufrag,
                                    const std::string& password) = 0;

  // Adds |candidate| received from the peer.
  virtual void AddRemoteCandidate(const cricket::Candidate& candidate) = 0;

  // Name of the channel. It is used to identify the channel and
  // disambiguate candidates it generates from candidates generated by
  // parallel connections.
  virtual const std::string& name() const = 0;

  // Returns true if the channel is already connected.
  virtual bool is_connected() const = 0;

 private:
  DISALLOW_COPY_AND_ASSIGN(Transport);
};

// TransportSession represents a P2P connection that consists of one or more
// channels.
class TransportSession {
 public:
  class EventHandler {
   public:
    // Called to send a transport-info message.
    virtual void OnOutgoingTransportInfo(
        scoped_ptr<buzz::XmlElement> message) = 0;

    // Called when transport route changes.
    virtual void OnTransportRouteChange(const std::string& channel_name,
                                        const TransportRoute& route) = 0;

    // Called when there is an error connecting the session.
    virtual void OnTransportError(ErrorCode error) = 0;
  };

  TransportSession() {}
  virtual ~TransportSession() {}

  // Starts transport session. Both parameters must outlive TransportSession.
  virtual void Start(EventHandler* event_handler,
                     Authenticator* authenticator) = 0;

  // Called to process incoming transport message. Returns false if
  // |transport_info| is in invalid format.
  virtual bool ProcessTransportInfo(buzz::XmlElement* transport_info) = 0;

  // Channel factory for the session that creates raw ICE channels.
  virtual DatagramChannelFactory* GetDatagramChannelFactory() = 0;

  // Channel factory for the session that creates stream channels.
  virtual StreamChannelFactory* GetStreamChannelFactory() = 0;

  // Returns a factory that creates multiplexed channels over a single stream
  // channel.
  virtual StreamChannelFactory* GetMultiplexedChannelFactory() = 0;

 private:
  DISALLOW_COPY_AND_ASSIGN(TransportSession);
};

class TransportFactory {
 public:
  TransportFactory() { }
  virtual ~TransportFactory() { }

  // Called to notify transport factory that a new transport might be created
  // soon, e.g. when a new session is being created. Implementation may use it
  // to start asynchronous preparation, e.g. fetch a new relay token if
  // necessary while the session is being authenticated.
  virtual void PrepareTokens() = 0;

  // Creates a new TransportSession. The factory must outlive the session.
  virtual scoped_ptr<TransportSession> CreateTransportSession() = 0;

 private:
  DISALLOW_COPY_AND_ASSIGN(TransportFactory);
};

}  // namespace protocol
}  // namespace remoting

#endif  // REMOTING_PROTOCOL_TRANSPORT_H_
