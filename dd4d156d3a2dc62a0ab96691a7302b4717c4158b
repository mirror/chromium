{
  "comments": [
    {
      "key": {
        "uuid": "648b1f8f_5d4c1592",
        "filename": "third_party/zlib/adler32.c",
        "patchSetId": 26
      },
      "lineNbr": 77,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T16:38:08Z",
      "side": 1,
      "message": "I like that you tested for a NULL buffer before calling into the optimized code (as that free us from having to test for it in there).\n\nOn the other hand, it is a valid use case that a complaint Adler-32 implementation has to return 1L for a NULL buffer.\n\nIn this scenario (unless I\u0027m misreading), this specific test case that is part of the unit tests I wrote to validate the NEON code would fail in the SSE implementation.",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "211e2054_6e6a9f6c",
        "filename": "third_party/zlib/adler32.c",
        "patchSetId": 26
      },
      "lineNbr": 77,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T16:45:02Z",
      "side": 1,
      "message": "While at it, maybe you could move the call to the first line entering the function? (i.e. before the local variables were declared).",
      "parentUuid": "648b1f8f_5d4c1592",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b65cd438_89429c93",
        "filename": "third_party/zlib/adler32.c",
        "patchSetId": 26
      },
      "lineNbr": 77,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-15T17:44:16Z",
      "side": 1,
      "message": "\u003e I like that you tested for a NULL buffer before calling into the optimized code (as that free us from having to test for it in there).\n\nRight. And as you correctly noted alder32 should return 1L for a NULL buffer ...\n\n\u003e In this scenario (unless I\u0027m misreading), this specific test case that is part of the unit tests I wrote to validate the NEON code would fail in the SSE implementation.\n\nSo if buf is NULL, the SSE code is not entered, I think that\u0027s clear, so we fall into the existing code\n\n  /* in case user likes doing a byte at a time ...\n  if (len \u003d\u003d 1) {\n    adler +\u003d buf[0];\n    ...\n  }\n\n  /* initial Adler-32 value (deferred check for len \u003d\u003d 1 speed) */\n  if (buf \u003d\u003d Z_NULL)\n     return 1L;\n\nIf your test is for the buf \u003d\u003d NULL case, looks to me like it should work.\n\n\u003e While at it, maybe you could move the call to the first line entering the function? (i.e. before the local variables were declared).\n\nPossible, but the odd way this buf \u003d\u003d Z_NULL code is written (the comment says something about speed, a possible slight hint) suggests that we should maybe leave it alone. The odd way the code is written is enough to make we wary: I have no evidence, but I suspect someone wrote this code this way on purpose.",
      "parentUuid": "211e2054_6e6a9f6c",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c867509_67dd23a7",
        "filename": "third_party/zlib/adler32.c",
        "patchSetId": 26
      },
      "lineNbr": 77,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T17:53:00Z",
      "side": 1,
      "message": "The main issue I see is that the unit tests would be calling into the SIMD implementation directly.\n\nIn this scenario, if we have:\nadler \u003d adler32_z(0, NULL, 0);\nsimd \u003d adler32_simd(0, NULL, 0);\n\nIt would produce conflicting checksums. \n\nIn any case, it is always a good practice to test for the parameters received inside of your implementation.",
      "parentUuid": "b65cd438_89429c93",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2e71f44f_44b759a5",
        "filename": "third_party/zlib/adler32.c",
        "patchSetId": 26
      },
      "lineNbr": 77,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T17:57:19Z",
      "side": 1,
      "message": "In retrospect, since there is no longer validation of the parameters, in this test case the SSE3 code would happily proceed incorrectly with this call:\nsimd \u003d adler32_simd(0, NULL, 1024);",
      "parentUuid": "7c867509_67dd23a7",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0842bdf2_418ef2e1",
        "filename": "third_party/zlib/adler32.c",
        "patchSetId": 26
      },
      "lineNbr": 77,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-19T03:07:22Z",
      "side": 1,
      "message": "adler32_simd is not a public interface, so there is no need to test it directly.  I updated the bench.cpp tool to test all these odd parameter cases to check that there no conflicting checksums compared to adler32_z().",
      "parentUuid": "2e71f44f_44b759a5",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "698edf7f_1dc85389",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 26
      },
      "lineNbr": 46,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T18:19:28Z",
      "side": 1,
      "message": "Nit: maybe reverse the order to be aligned with the NEON implementation?",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53f0c2e8_27d5375a",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 26
      },
      "lineNbr": 46,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-19T03:07:22Z",
      "side": 1,
      "message": "I used the order from alder32.c (not sure why we\u0027d want a different order to that code FWIW).",
      "parentUuid": "698edf7f_1dc85389",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "342715b2_7a50ba51",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 26
      },
      "lineNbr": 213,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T16:32:39Z",
      "side": 1,
      "message": "Zlib will still build fine and work correctly using the K\u0026R C implementation.\n\nI wonder if instead of \u0027error\u0027 you should use a \u0027#pragma messsage\u0027 to let people know that they are missing an optimized implementation?\n\nPlus, the buildsystem should not include this file for the wrong build target anyway.",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8109177b_5d267901",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 26
      },
      "lineNbr": 213,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-15T17:44:16Z",
      "side": 1,
      "message": "Developer will add their port to some build file, and likely then try a basic compile.\n\nNot sure about #pragma, but #error breaks the compile and prints the \"No adler32 simd is defined for your port.\" message, this to guide the developer on what to do next (add you port code here).\n\nFormally, I had nothing here.  Compile error would about no return statement, or something equally cryptic.  #error gives developer a better hint re: the actual problem.",
      "parentUuid": "342715b2_7a50ba51",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "56578679_2f664576",
        "filename": "third_party/zlib/inflate.c",
        "patchSetId": 26
      },
      "lineNbr": 205,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T16:28:54Z",
      "side": 1,
      "message": "For ARM currently we have our own copy of inffast and inflate.\n\nWhat happens if this code is built for other platform !\u003d Intel (e.g. mips)? Will this function resolve to a \u0027nop\u0027 or maybe it should be guarded behind a macro (e.g. #ifdef INTEL)?",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a82a0394_61564c52",
        "filename": "third_party/zlib/inflate.c",
        "patchSetId": 26
      },
      "lineNbr": 205,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-15T17:44:16Z",
      "side": 1,
      "message": "Yes, x86_check_features() provide by Intel has a stub implementation that does nothing on other ports (aka platforms, eg., MIPS, ARM NEON, etc) in my understanding of it.\n\nSince that stub works everywhere (and only does real something real on the INTEL port), it doesn\u0027t need a #ifdef guard.\n\nc.f. the same line of code in deflate.c, which has been in use for some time.  It has no #ifdef guards either.",
      "parentUuid": "56578679_2f664576",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0bfb04a6_6c1551ed",
        "filename": "third_party/zlib/inflate.c",
        "patchSetId": 26
      },
      "lineNbr": 205,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T17:53:00Z",
      "side": 1,
      "message": "The stub implies in a function call?",
      "parentUuid": "a82a0394_61564c52",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "72a1eb35_2a02b7dc",
        "filename": "third_party/zlib/inflate.c",
        "patchSetId": 26
      },
      "lineNbr": 205,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-19T03:11:14Z",
      "side": 1,
      "message": "Refer to https://cs.chromium.org/search/?q\u003dzlib+deflate.c+x86_check_features\u0026sq\u003dpackage:chromium\u0026type\u003dcs",
      "parentUuid": "0bfb04a6_6c1551ed",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34e1b7b1_ef89fa8e",
        "filename": "third_party/zlib/inflate.c",
        "patchSetId": 26
      },
      "lineNbr": 205,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2017-09-28T08:37:54Z",
      "side": 1,
      "message": "I see the stub here:\nhttps://cs.chromium.org/chromium/src/third_party/zlib/simd_stub.c?q\u003dzlib+x86_check_features\u0026sq\u003dpackage:chromium\u0026l\u003d33\u0026dr\u003dCSs",
      "parentUuid": "72a1eb35_2a02b7dc",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cfdd6b5_7ae85f5d",
        "filename": "third_party/zlib/names.h",
        "patchSetId": 26
      },
      "lineNbr": 166,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-15T16:25:13Z",
      "side": 1,
      "message": "The reason this symbols are redefined is to avoid link clashes with other zlibs inside of Chrome (like in PDFium) and the system\u0027s zlib.\n\nFor the first case, PDFium now uses Chromium\u0027s zlib and no longer ships another copy of zlib. For the second, you should not have clashes with zlib (e.g. they don\u0027t define \u0027adler32_simd\u0027).",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9c5b458_ba8c3e50",
        "filename": "third_party/zlib/names.h",
        "patchSetId": 26
      },
      "lineNbr": 166,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-15T17:44:16Z",
      "side": 1,
      "message": "Yes, for the image decoders libpng libjpeg etc, we do this name mangling also for the same reasons: to support folks who build chromium with the USE_SYSTEM_LIBJPEG build flag (linux distros typically).",
      "parentUuid": "1cfdd6b5_7ae85f5d",
      "revId": "dd4d156d3a2dc62a0ab96691a7302b4717c4158b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}