{
  "comments": [
    {
      "key": {
        "uuid": "61c0e8c7_05dbda73",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-10T22:48:42Z",
      "side": 1,
      "message": "So... my understanding is that constexpr means that a function can be evaluated at compile time, but it doesn\u0027t actually force it. There are known cases (not clear on when, may be mostly VC++ and therefore not relevant) where a constexpr function/object is not done at compile time. Or at least the guarantees are more subtle and less strict than you might expect.\n\nI\u0027m not sure what to do about this in this context, but maybe just be careful about over promising.",
      "revId": "c54e31ffcddc4edd0e477b2e096e5c92633d6bd4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdda46d8_89f54b3a",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-11T16:58:12Z",
      "side": 1,
      "message": "+thakis: do you know if clang guarantees that it will use the constexpr path to construction if available? Or does the variable actually have to be marked constexpr (which doesn\u0027t work for globals as constexpr implies const :(...)? I\u0027m having a hard time figuring out whether the spec provides this.",
      "parentUuid": "61c0e8c7_05dbda73",
      "revId": "c54e31ffcddc4edd0e477b2e096e5c92633d6bd4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "faf740ce_7f8ec111",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1001629
      },
      "writtenOn": "2018-01-11T18:01:05Z",
      "side": 1,
      "message": "(short disclaimer: I don\u0027t 100% know the answer and I\u0027m technically still away until next Thu so I won\u0027t read up on it. cxx@chromium.org can probably answer your question.)\n\nWhat Bruce says is generally correct. In practice, I\u0027d be surprised if that happened for globals though. On the third hand, the standard doesn\u0027t guarantee it. Maybe you can try a few things locally in a small test program and see if you can find an example where the initializer is emited even though a ctor is constexpr? If so, that\u0027d be an example to disprove our assumption.\n\n(clang usually doesn\u0027t emit a static initializer if it can compile-time-evaluate a ctor even if it\u0027s not marked constexpr.)\n\nAnother thing to possibly look at is how -Wglobal-constructors and constexpr interact. I know that -Wglobal-constructors fires for (non-constexpr) cases where the compiler _might_ emit an initializer but clang\u0027s optimizer removes it, making the warning a bit too strict for us in practice. Maybe it doesn\u0027t fire for constexpr initializers -- that would make constexpr + that warning enabled something that does the right thing at compile time (...but it\u0027d be inconsistent with clang\u0027s policy to emit -Wglobabl-ctors for non-constexpr-but-constant-in-practice things, so I\u0027m not sure how the warning actually behaves).\n\nOur static initializer detection that runs on the binary will save us when we get it wrong.",
      "parentUuid": "fdda46d8_89f54b3a",
      "revId": "c54e31ffcddc4edd0e477b2e096e5c92633d6bd4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9efda2ec_7322ecbe",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-11T18:56:28Z",
      "side": 1,
      "message": "The other risk with changing to globals is destructors - maybe add a warning about those? Or maybe it\u0027s good enough as is.",
      "parentUuid": "faf740ce_7f8ec111",
      "revId": "c54e31ffcddc4edd0e477b2e096e5c92633d6bd4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0d1ecb9_3ea724cf",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-11T22:30:57Z",
      "side": 1,
      "message": "As mentioned on chromium-dev, I\u0027m not sure I\u0027d be comfortable changing this guidance due to destructors: https://groups.google.com/a/chromium.org/forum/#!topic/chromium-dev/0BEHxQncAKY",
      "parentUuid": "9efda2ec_7322ecbe",
      "revId": "c54e31ffcddc4edd0e477b2e096e5c92633d6bd4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "81edfffe_88343cc3",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-11T22:52:19Z",
      "side": 1,
      "message": "I\u0027m trying to get rid of static uninitializers as we speak : https://chromium-review.googlesource.com/c/chromium/src/+/860617. Objections? Thoughts?",
      "parentUuid": "c0d1ecb9_3ea724cf",
      "revId": "c54e31ffcddc4edd0e477b2e096e5c92633d6bd4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b59ffc1_f5575903",
        "filename": "base/lazy_instance.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-12T23:45:07Z",
      "side": 1,
      "message": "I\u0027ve been thinking about this more, and I think we don\u0027t want to recommend this. It seems quite dicey to have to rely on fast termination to avoid issues with global destructors in the Chrome binary--not to mention we\u0027ll still be emitting the binary code that runs them.\n\nDoes the built-in synchronization on static do a better job of not spinning than LazyInstance? If that works, I\u0027d be inclined to go with that approach. I also think we should add a NoDestructor\u003c\u003e helper to avoid all the static T* instance \u003d new T; boilerplate, but that\u0027s a separate discussion.",
      "parentUuid": "81edfffe_88343cc3",
      "revId": "c54e31ffcddc4edd0e477b2e096e5c92633d6bd4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}