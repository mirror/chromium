{
  "comments": [
    {
      "key": {
        "uuid": "0d6ed082_ad31e99a",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 31,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2018-01-03T21:24:23Z",
      "side": 1,
      "message": "This seems quite fragile.  Is there a more direct way to do this?",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f77da55_b704e3ee",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 176,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2018-01-03T21:24:23Z",
      "side": 1,
      "message": "This is an awkward indirection through PaintRecord just to write an SkPicture into some backing printing context.\n\nI assume that this is all getting drawn into some top level SkiaPaintCanvas / SkCanvas? GraphicsContext itself already has some Printing() boolean.  As an alternate suggestion, could you just store this SkCanvas on the context (possibly as a part of setting Printing to true?) and then just draw your placeholder into it directly?",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bddc3e11_8804cefa",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 176,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2018-01-08T23:35:28Z",
      "side": 1,
      "message": "Sorry, I misunderstood how printing works.  It appears this is all recorded into a PaintOpBuffer and not going directly into an SkCanvas at the bottom of the recording stack.\n\nI think this is still too heavy-handed in PaintOpBuffer.  I think storing an SkPicture pointer on every PaintOpBuffer just for the case that the PaintOpBuffer represents a placeholder is very big.\n\nI\u0027m going to propose the following, which should be extensible for the next person who wants to do something similar:\n* add a new CustomData PaintOpType and a CustomDataOp PaintOp class that stores a size_t data\n* add a custom_data_callback function to PlaybackParams\n* when rasterizing, if a CustomDataOp is encountered, call the custom data callback with the data and the PaintCanvas (and maybe the playback params too)\n\nThat should give you enough to store the id directly and then stitch them back together later without requiring putting an SkPicture on every PaintOpBuffer.",
      "parentUuid": "1f77da55_b704e3ee",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70fe5aef_bae15f65",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 176,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-08T23:36:08Z",
      "side": 1,
      "message": "Ultimately, I think we need to know where to insert the content for the OOPIF. It sounds like the proposal is to avoid creating a placeholder SkPicture, and to just store some structured data in SkMetadata (i.e. a map of IDs to bounds). Do I understand this correctly?\n\nIf I understood it correctly, I actually like it a lot. I\u0027ve been thinking about how to do the cross-process re-assembly. Using SkPicture directly has the problem where picture IDs aren\u0027t unique between processes, and we have to jump through a lot of hoops to try to make this safe. If we don\u0027t use SkPicture at all, then we can use something like base::UnguessableToken and do much better. WDYT?",
      "parentUuid": "1f77da55_b704e3ee",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74041432_8149695e",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 176,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2018-01-09T00:57:19Z",
      "side": 1,
      "message": "I don\u0027t think my proposal handles the cross-process reassembly, because right now you\u0027re still using Skia and SkPictures for that reassembly.  What I proposed is all for what\u0027s happening in the renderer itself.  The callback function will just get called during the PaintOpBuffer -\u003e SkPicture playback prior to cross-process serialization.  In the future, if you ever use PaintOpBuffer serialization, then this proposal will work quite naturally.\n\nI don\u0027t think it matters that picture IDs are not unique within processes.  I think the deserialization for oopifs will just have to happen in a bottom up manner, where you deserialize leaf pictures first.  Each deserialization operation will have its own \"namespace\" of ids that won\u0027t conflict.\n\nDo you need an unguessable token? I think a malicious renderer could attempt to reassemble the page in some incorrect (or infinitely looping) order, but the reassembly is happening elsewhere so it\u0027s not gaining access to anything that it shouldn\u0027t have.",
      "parentUuid": "70fe5aef_bae15f65",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "100a58ff_486ace93",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 176,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-09T23:28:05Z",
      "side": 1,
      "message": "Ah... my original concern was that we could confuse the utility process that\u0027s combining the different pictures together, but I think I\u0027m mistaken in that regard. Regarding unguessable tokens, I think it could make things easier: if we could embed the unguessable token for the frame directly during serialization, then we wouldn\u0027t need to do picture ID mapping in PdfCompositorImpl.\n\nSince frames don\u0027t have an unguessable token associated yet, we\u0027ll probably have to do something more complicated where we accumulate routing IDs in a vector, send the vector with the printing IPCs, and have the browser associate the actual child ID with it, and forward the serialized picture, subframe routing IDs, plus the child ID over to the printing utility process.\n\nFor now, I\u0027d propose something like this (this is somewhat orthogonal to enne\u0027s idea, since this is more about the cross-process reassembly):\n- Add a method to RemoteFrameClient and WebRemoteFrameClient like RegisterCrossProcessFrameForPrintingContext(uint32_t picture_id, std::map\u003cuint32_t, int\u003e* picture_id_to_routing_id_map);\n- content::RenderFrameProxy::RegisterCrossProcessFrameForPrintingContext() will simply insert picture ID + GetRoutingID() into the map.\n- Once painting the page for printing is done, the renderer sends the SkPicture and the map of dependent cross-process frame proxy IDs to the browser.\n- The browser can take the proxy routing ID values from the map and convert them into a RenderFrameHost child + routing ID (validating that the frame actually contains the subframe proxies in question). It sends:\n  - the child ID and the routing ID of the frame that produced the SkPicture\n  - the SkPicture\n  - the picture ID to routing ID map, with the routing IDs converted to (child ID, render frame host ID) tuples.\n\nSince the utility process will only use the RenderFrameHost child ID + routing ID for reassembly, reassembly becomes a simple mapping of picture ID -\u003e render frame host ID, and then looking up the corresponding SkPicture for that RFH in the utility process if it exists.\n\n(Btw, I\u0027m assuming that the normal print path uses the //content objects and not the custom embedder helpers in //components/printing/renderer/print_render_frame_helper.cc...)",
      "parentUuid": "74041432_8149695e",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "197d798f_f3c68810",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 176,
      "author": {
        "id": 1002198
      },
      "writtenOn": "2018-01-10T09:27:40Z",
      "side": 1,
      "message": "Thanks for all the suggestions.\n\n@enne, I think I roughly understand what you prefer. It adds less weight on PaintOpBuffer. But it will add more changes into the PaintOpBuffer -\u003e Skia -\u003e serialization part. Basically, we need to remember PaintOpBuffer(or the new type)\u0027s ids and the mapping between them to SkPictures\u0027, and during serialization we need to map them back. \n   If attaching SkPicture to PaintOpBuffer is too heavy, we can add one bit flag in PaintOpBuffer to mark \u0027external\u0027, and only ExternalPaintOpBuffer has attached SkPicture. Would that work?\n\n@Daniel, I think we can make the current mechanism work. Basically, for each frame, we use rph routing id + frame\u0027s own routing id to globally identify it. For content, since it always lives in a frame, we use the enclosing frame\u0027s global id + content\u0027s own id (32bit) to identify it. I reworked this into https://chromium-review.googlesource.com/c/chromium/src/+/767912, pls take a look there.",
      "parentUuid": "100a58ff_486ace93",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f32ea52_da74261a",
        "filename": "third_party/WebKit/Source/core/frame/RemoteFrameView.cpp",
        "patchSetId": 12
      },
      "lineNbr": 176,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2018-01-10T18:49:11Z",
      "side": 1,
      "message": "I think all you need is a vector of SkPictures and store the index into that vector.  Agreed that it adds more changes to the PaintOpBuffer -\u003e Skia portion (but not serialization).  However, I think what I suggest is the better the right approach.  I don\u0027t think this one edge use case for printing merits such special casing in PaintOpBuffer.  I think it\u0027s better to implement a reusable primitive in PaintOpBuffer that other future use cases can take advantage of.",
      "parentUuid": "197d798f_f3c68810",
      "revId": "acc7d99c43a0fa3e93a14099b3c91b2241be8ab3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}