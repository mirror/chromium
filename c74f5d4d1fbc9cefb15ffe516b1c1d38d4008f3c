{
  "comments": [
    {
      "key": {
        "uuid": "e0c9f7dc_667ab30b",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-09-01T15:28:51Z",
      "side": 1,
      "message": "Doesn\u0027t this comment apply to |message_loop_lock_| as well? If it doesn\u0027t (e.g. PostPendingTaskLockRequired() only returns true to one caller), mention that in this comment. \n\nFrom my investigation, this (PostPendingTaskLockRequired() only returning true to one caller) doesn\u0027t appear to be true on Android (see always_schedule_work_ and AlwaysNotifyPump()).\n\nSo on Android, if ScheduleWork causes a context switch, it will be done while holding |message_loop_lock_| and that sounds bad for the reasons mentioned above.\n\nSounds like we need something that strictly blocks destruction but doesn\u0027t otherwise block multiple callers of PostTask.",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0429ee22_bfca4744",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T17:31:32Z",
      "side": 1,
      "message": "The Android ScheduleWork path looks reasonable:\n\nC++-------message_pump_android.cc\nJava_SystemMessageHandler_scheduleWork(env, system_message_handler_obj_);\n\nJava------SystemMessageHandler.java\nsendMessage(obtainAsyncMessage(SCHEDULED_WORK));\n\nWhich just calls android.os.Handler.sendMessage:\nhttps://developer.android.com/reference/android/os/Handler.html#sendMessage(android.os.Message)\nhttp://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/os/Handler.java#519\n\nsendMessage(Message msg)\nsendMessageDelayed(msg, 0);\nsendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\nenqueueMessage(queue, msg, uptimeMillis); \nqueue.enqueueMessage(msg, uptimeMillis);\nWhich leads here\nhttp://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/os/MessageQueue.java#533\n\nThis is akin to adding a message to the end of a message queue, kind of like here!\n\nAnd could cause a nativeWake, which goes to\nhttp://androidxref.com/7.1.1_r6/xref/system/core/include/utils/Looper.h#279\nWhich says\n     * This method can be called on any thread.\n     * This method returns immediately.\n\nMy reading of this is that this call should be fast for Android. Thoughts?",
      "parentUuid": "e0c9f7dc_667ab30b",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6af1011_9db78b84",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T17:36:55Z",
      "side": 1,
      "message": "Found the wake code:\nhttp://androidxref.com/7.1.1_r6/xref/system/core/libutils/Looper.cpp#407\nssize_t nWrite \u003d TEMP_FAILURE_RETRY(write(mWakeEventFd, \u0026inc, sizeof(uint64_t)));\nnWrite is expected to be uint64_t",
      "parentUuid": "0429ee22_bfca4744",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75c14b4d_59a3ecba",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T18:02:40Z",
      "side": 1,
      "message": "And just for notes, I believe the eventfd wake code is here:\nhttp://elixir.free-electrons.com/linux/v4.3/source/fs/eventfd.c#L242\n\nEven if ScheduleWork did take a long time under contention, _all_ PostPendingTasks would block on any sync primitives used by the kernel, so having a read write lock will not help here as we\u0027ll just block later on.",
      "parentUuid": "e6af1011_9db78b84",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f7a309fa_4bc87858",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-09-04T17:43:13Z",
      "side": 1,
      "message": "Well, that might be true, but I don\u0027t think the generic impl of incoming_task_queue.cc should rely on the existing platform-specific implementations.\n\nAnd re. \"Even if ScheduleWork did take a long time under contention, _all_ PostPendingTasks would block on any sync primitives used by the kernel, so having a read write lock will not help here as we\u0027ll just block later on.\"\n\nmaybe, but I\u0027d hope the kernel impl is smart enough to release its lock before forcing a context switch (re. issue documented by the comment above).\n\nCan we use some kind of semaphore scheme to lock the destruction only?",
      "parentUuid": "75c14b4d_59a3ecba",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d56d9d0c_b924a4de",
        "filename": "base/message_loop/incoming_task_queue.h",
        "patchSetId": 4
      },
      "lineNbr": 101,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-09-01T15:28:51Z",
      "side": 1,
      "message": "Protected by |incoming_queue_lock_|.",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b5f60d8_ee22007f",
        "filename": "base/message_loop/incoming_task_queue.h",
        "patchSetId": 4
      },
      "lineNbr": 101,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T20:39:34Z",
      "side": 1,
      "message": "This is covered by the |incoming_queue_lock_| comment.",
      "parentUuid": "d56d9d0c_b924a4de",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30c0b25f_305552b2",
        "filename": "base/message_loop/incoming_task_queue.h",
        "patchSetId": 4
      },
      "lineNbr": 101,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T21:14:18Z",
      "side": 1,
      "message": "Fixed up all of the declarations here:\nhttps://chromium-review.googlesource.com/c/chromium/src/+/648452",
      "parentUuid": "5b5f60d8_ee22007f",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}