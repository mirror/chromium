{
  "comments": [
    {
      "key": {
        "uuid": "e0c9f7dc_667ab30b",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-09-01T15:28:51Z",
      "side": 1,
      "message": "Doesn\u0027t this comment apply to |message_loop_lock_| as well? If it doesn\u0027t (e.g. PostPendingTaskLockRequired() only returns true to one caller), mention that in this comment. \n\nFrom my investigation, this (PostPendingTaskLockRequired() only returning true to one caller) doesn\u0027t appear to be true on Android (see always_schedule_work_ and AlwaysNotifyPump()).\n\nSo on Android, if ScheduleWork causes a context switch, it will be done while holding |message_loop_lock_| and that sounds bad for the reasons mentioned above.\n\nSounds like we need something that strictly blocks destruction but doesn\u0027t otherwise block multiple callers of PostTask.",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0429ee22_bfca4744",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T17:31:32Z",
      "side": 1,
      "message": "The Android ScheduleWork path looks reasonable:\n\nC++-------message_pump_android.cc\nJava_SystemMessageHandler_scheduleWork(env, system_message_handler_obj_);\n\nJava------SystemMessageHandler.java\nsendMessage(obtainAsyncMessage(SCHEDULED_WORK));\n\nWhich just calls android.os.Handler.sendMessage:\nhttps://developer.android.com/reference/android/os/Handler.html#sendMessage(android.os.Message)\nhttp://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/os/Handler.java#519\n\nsendMessage(Message msg)\nsendMessageDelayed(msg, 0);\nsendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\nenqueueMessage(queue, msg, uptimeMillis); \nqueue.enqueueMessage(msg, uptimeMillis);\nWhich leads here\nhttp://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/os/MessageQueue.java#533\n\nThis is akin to adding a message to the end of a message queue, kind of like here!\n\nAnd could cause a nativeWake, which goes to\nhttp://androidxref.com/7.1.1_r6/xref/system/core/include/utils/Looper.h#279\nWhich says\n     * This method can be called on any thread.\n     * This method returns immediately.\n\nMy reading of this is that this call should be fast for Android. Thoughts?",
      "parentUuid": "e0c9f7dc_667ab30b",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6af1011_9db78b84",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T17:36:55Z",
      "side": 1,
      "message": "Found the wake code:\nhttp://androidxref.com/7.1.1_r6/xref/system/core/libutils/Looper.cpp#407\nssize_t nWrite \u003d TEMP_FAILURE_RETRY(write(mWakeEventFd, \u0026inc, sizeof(uint64_t)));\nnWrite is expected to be uint64_t",
      "parentUuid": "0429ee22_bfca4744",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75c14b4d_59a3ecba",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T18:02:40Z",
      "side": 1,
      "message": "And just for notes, I believe the eventfd wake code is here:\nhttp://elixir.free-electrons.com/linux/v4.3/source/fs/eventfd.c#L242\n\nEven if ScheduleWork did take a long time under contention, _all_ PostPendingTasks would block on any sync primitives used by the kernel, so having a read write lock will not help here as we\u0027ll just block later on.",
      "parentUuid": "e6af1011_9db78b84",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f7a309fa_4bc87858",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-09-04T17:43:13Z",
      "side": 1,
      "message": "Well, that might be true, but I don\u0027t think the generic impl of incoming_task_queue.cc should rely on the existing platform-specific implementations.\n\nAnd re. \"Even if ScheduleWork did take a long time under contention, _all_ PostPendingTasks would block on any sync primitives used by the kernel, so having a read write lock will not help here as we\u0027ll just block later on.\"\n\nmaybe, but I\u0027d hope the kernel impl is smart enough to release its lock before forcing a context switch (re. issue documented by the comment above).\n\nCan we use some kind of semaphore scheme to lock the destruction only?",
      "parentUuid": "75c14b4d_59a3ecba",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12e283b6_f7975268",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-09-05T15:14:40Z",
      "side": 1,
      "message": "An atomic variable can help if we want to avoid mutual exclusion between calls to ScheduleWork:\n\nIncomingTaskQueue::PostPendingTask() {\n  // Add task to queue.\n  // ...\n\n  auto old_value \u003d NoBarrier_AtomicIncrement(\u0026num_schedule_work_, 1);\n  if (old_value \u003c 0) {\n    // Too late!\n  } else {\n    message_loop_-\u003eScheduleWork();\n  }\n\n  NoBarrier_AtomicIncrement(\u0026num_schedule_work, -1);\n}\n\nIncomingTaskQueue::WillDestroyCurrentMessageLoop() {\n  for (;;) {\n    int old_value \u003d NoBarrier_CompareAndSwap(\n        \u0026num_schedule_work_, 0, std::numeric_limits\u003cint\u003e::min());\n    if (old_value \u003d\u003d 0) {\n      // No pending ScheduleWork! Ok to cleanup.\n      // return;\n    }\n  }\n  // Use ConditionVariable instead of spinning if we think it\u0027s worth it.\n}\n\nDisclaimer: Didn\u0027t check if barriers are required.",
      "parentUuid": "f7a309fa_4bc87858",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58defeef_f20aa0fa",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-05T16:10:10Z",
      "side": 1,
      "message": "Re:  I don\u0027t think the generic impl of incoming_task_queue.cc should rely on the existing platform-specific implementations.\n\nIncomingTaskQueue should rely on the specified contract of ScheduleWork(), which is to return quickly. A context switch is not in the contract unless the underlying kernel structures are themselves contended.",
      "parentUuid": "12e283b6_f7975268",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a0698bf_9dff4c3c",
        "filename": "base/message_loop/incoming_task_queue.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-05T21:29:02Z",
      "side": 1,
      "message": "To reiterate:\n* For Android:\n  * If ScheduleWork() is slow, then having multiple callers won\u0027t speed things up\n  * If ScheduleWork() is fast, then the lock will not be held for a long time.\n  * Code analysis suggests this will be fine in either case.\n* For other platforms\n  * ScheduleWork() is only called once. Other concurrent callers get to bypass the\n    ScheduleWork() call.\n\nThis suggests doing any extra bookkeeping of the status of calls won\u0027t actually speed anything up.",
      "parentUuid": "58defeef_f20aa0fa",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d56d9d0c_b924a4de",
        "filename": "base/message_loop/incoming_task_queue.h",
        "patchSetId": 4
      },
      "lineNbr": 101,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-09-01T15:28:51Z",
      "side": 1,
      "message": "Protected by |incoming_queue_lock_|.",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b5f60d8_ee22007f",
        "filename": "base/message_loop/incoming_task_queue.h",
        "patchSetId": 4
      },
      "lineNbr": 101,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T20:39:34Z",
      "side": 1,
      "message": "This is covered by the |incoming_queue_lock_| comment.",
      "parentUuid": "d56d9d0c_b924a4de",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30c0b25f_305552b2",
        "filename": "base/message_loop/incoming_task_queue.h",
        "patchSetId": 4
      },
      "lineNbr": 101,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-09-01T21:14:18Z",
      "side": 1,
      "message": "Fixed up all of the declarations here:\nhttps://chromium-review.googlesource.com/c/chromium/src/+/648452",
      "parentUuid": "5b5f60d8_ee22007f",
      "revId": "c74f5d4d1fbc9cefb15ffe516b1c1d38d4008f3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}