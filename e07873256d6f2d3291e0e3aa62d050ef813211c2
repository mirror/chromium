{
  "comments": [
    {
      "key": {
        "uuid": "397c062c_f850e3ee",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-10-17T02:08:12Z",
      "side": 1,
      "message": "This feels a bit hacky. Instead of reading back RGB, why not use YuvReadbackInterface? I know it\u0027s deprecated, but we discussed a longer-term strategy for future clean-up; so, feel free to use it. :)\n\nUsing YuvReadbackInterface would clean-up a lot of this client-side code, and would be much more performant (12bpp instead of 32bpp being downloaded from the GPU). In addition, it would automatically leverage ccameron@\u0027s current efforts to improve color accuracy.",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5254a41c_e7b060cb",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-10-19T00:19:46Z",
      "side": 1,
      "message": "Two problems with using ReadbackYUVInterface as it is now. It doesn\u0027t read Alpha channel, would need another read call. Canvas textures have origin flipped, and it would need to be post processed. I want to tackle these requirements in the future refactor explained in the bug and move to that. We want to ship a working async functionality quickly-for a blocked client- and improve on it.\nhttps://bugs.chromium.org/p/chromium/issues/detail?id\u003d774297",
      "parentUuid": "397c062c_f850e3ee",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba180590_46dd0cf3",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-10-26T04:41:20Z",
      "side": 1,
      "message": "re alpha channel: How common is it to capture with the alpha channel versus not? Meaning, would you get a big performance win for the 99% of use cases, if you used ReadbackYUV when no alpha is needed (and just use the slower path when the alpha channel is needed)?\n\nre origin flipped: ReadbackYUVInterface can do that already. There is a \"flip\" argument in the CreateReadbackYUV() method.",
      "parentUuid": "5254a41c_e7b060cb",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3360d6f_90150143",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-10-29T19:59:53Z",
      "side": 1,
      "message": "isOpaque() is pretty dumb unfortunately. Unless devs specify {alpha: false} when creating a canvas, we don\u0027t know if there is relevant content in alpha channel and isOpaque() is false. That is quite often, see my skia bug below for details.\nhttps://bugs.chromium.org/p/skia/issues/detail?id\u003d7085\n\nCreateReadbackPipelineYUV() is getting deprecated, right? I thought that\u0027s why you asked me to factor out into a smaller design in a new class in our email thread and I filed the bug below. As I said, I had the intention of landing this code quickly for unblocking the client we are in touch with, but this CL discussion seems to never ending. \nhttps://bugs.chromium.org/p/chromium/issues/detail?id\u003d774297",
      "parentUuid": "ba180590_46dd0cf3",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "677c7fa4_75e893fa",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-10-29T23:32:48Z",
      "side": 1,
      "message": "\u003e As I said, I had the intention of landing this code quickly for unblocking the client we are in touch with, but this CL discussion seems to never ending.\n\nWhat client is this? If you are being pressured into short-cutting the engineering process, I would be happy to speak to them on your behalf. It seems this change was originally perceived to be a quick-fix; but the new elements are not fitting quite right, and so it\u0027s taking time to figure things out.\n\nThe discussion on this particular CL is lengthy because there were/are several very difficult issues to consider and resolve (https://www.chromium.org/developers/core-principles):\n\n1. Speed: This CL is about making things faster. Was this the fastest possible solution? We all know it is not. So, then we needed to understand whether making the current trade-off was the right decision. It was prudent to explore more options before \"settling.\"\n\n2. Security: You\u0027re doing something new here in the render process (GPU readback). Could a compromised renderer sandbox allow malicious code to readback textures it shouldn\u0027t? Yes. Actually, I\u0027m not sure we have completely figured this one out. This is why I encouraged you to include a security reviewer several days ago.\n\n3. Stability: Who owns GLHelper and what do we do when a GL context is lost? This happens quite frequently in-the-wild, as GPU drivers are very buggy. Chromium developers have spent lots of time adding infrastructure in the browser to deal with this exact problem. Unfortunately, that infrastructure doesn\u0027t seem to easily integrate with the new thing you\u0027re doing here (being in the render process). So, we\u0027ve yet to figure out how to resolve that.\n\n4. Simplicity: The \"pretend the Y plane of a YUV VideoFrame is really ARGB data\" thing, the technical debt this incurs, and other tangibles. It took some discussion to figure out how to leverage the existing VideoFrame memory pooling without having to do that.",
      "parentUuid": "a3360d6f_90150143",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "61a7afb9_ccf04cdc",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2017-10-30T17:56:52Z",
      "side": 1,
      "message": "Not to short-circuit the review process, but one point: this CL doesn\u0027t change the security model of the canvas capture code, at least not to the best of my understanding. The current code does a GPU-\u003eCPU readback synchronously. Emircan\u0027s CL attempts to use existing mechanisms to do the readback asynchronously. Checks like whether the canvas is tainted and therefore ineligible for readback (and presumably capture) are already delegated to the renderer-side canvas code.",
      "parentUuid": "677c7fa4_75e893fa",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "307b7422_1695cdb3",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-10-31T16:17:38Z",
      "side": 1,
      "message": "Regarding loss, the owner of WebGraphicsContext3dProvider just needs to set a callback on it, and when it\u0027s called, discard and recreate a new provider. Providers in blink are singly-owned (tho they can share an underlying GL context internally) so that each owner can set its own callback and act independently.\n\nThe fact this code is in content/renderer/ and not in blink platform makes me wonder if its following onion soup principles - which afaik go the opposite direction. Should this be part of a platform/graphics/ API that blink consumes rather than in content?\n\nRegarding using GLHelper with WebGraphicsContext3dProvider - probably we need blink::Platform to do that, since it\u0027s the renderer_blink_platform_impl that knows the underlying type of Providers it hands out - and this would be compatible with putting the code in platform/graphics/.",
      "parentUuid": "61a7afb9_ccf04cdc",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1778edc_e060bb46",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 249,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-10-17T02:08:12Z",
      "side": 1,
      "message": "Creating and destroying GLHelper for each frame is very expensive. GLHelper caches a lot of things that latency intensive (e.g., it probes the implementation for readback strategy, and other things.)\n\nYou should create it once, upon first use. Perhaps GLHelper should be added to RenderThreadImpl?",
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67b0ae5d_140ba437",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 249,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-10-17T19:30:35Z",
      "side": 1,
      "message": "I think a good place for a GLHelper instance to live is in viz::ContextProvider (possible lazily initialized). That way it\u0027s life time would be tied to the life time of the gpu channel it uses. Also, this means it could be accessed via ContextProviderWrapper.",
      "parentUuid": "f1778edc_e060bb46",
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cdfe94a3_5999d1ac",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 249,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-10-31T16:17:38Z",
      "side": 1,
      "message": "I\u0027d rather not tie it to ContextProvider so much. GrContext is tied to ContextProvider like so and it\u0027s been a real pain as a result multiple times. If I could go back I would not do that again.",
      "parentUuid": "67b0ae5d_140ba437",
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edaddbb4_f9636bd0",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 251,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-10-17T19:30:35Z",
      "side": 1,
      "message": "Using the sharedMainThreadContextProvider may not be safe.  There is no strict guarantee that this is the same context that created \u0027image\u0027.  There is a potential data security vulnerability here. For example after a GPU context reset, the texture ID returned by skia might not be valid in the new SharedMainThreadContext. Then the readback might be reading back content from a different texture, possibly leaking private (or cross-origin) data.",
      "range": {
        "startLine": 251,
        "startChar": 25,
        "endLine": 251,
        "endChar": 56
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}