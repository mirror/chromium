{
  "comments": [
    {
      "key": {
        "uuid": "397c062c_f850e3ee",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-10-17T02:08:12Z",
      "side": 1,
      "message": "This feels a bit hacky. Instead of reading back RGB, why not use YuvReadbackInterface? I know it\u0027s deprecated, but we discussed a longer-term strategy for future clean-up; so, feel free to use it. :)\n\nUsing YuvReadbackInterface would clean-up a lot of this client-side code, and would be much more performant (12bpp instead of 32bpp being downloaded from the GPU). In addition, it would automatically leverage ccameron@\u0027s current efforts to improve color accuracy.",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5254a41c_e7b060cb",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-10-19T00:19:46Z",
      "side": 1,
      "message": "Two problems with using ReadbackYUVInterface as it is now. It doesn\u0027t read Alpha channel, would need another read call. Canvas textures have origin flipped, and it would need to be post processed. I want to tackle these requirements in the future refactor explained in the bug and move to that. We want to ship a working async functionality quickly-for a blocked client- and improve on it.\nhttps://bugs.chromium.org/p/chromium/issues/detail?id\u003d774297",
      "parentUuid": "397c062c_f850e3ee",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba180590_46dd0cf3",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-10-26T04:41:20Z",
      "side": 1,
      "message": "re alpha channel: How common is it to capture with the alpha channel versus not? Meaning, would you get a big performance win for the 99% of use cases, if you used ReadbackYUV when no alpha is needed (and just use the slower path when the alpha channel is needed)?\n\nre origin flipped: ReadbackYUVInterface can do that already. There is a \"flip\" argument in the CreateReadbackYUV() method.",
      "parentUuid": "5254a41c_e7b060cb",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3360d6f_90150143",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 239,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-10-29T19:59:53Z",
      "side": 1,
      "message": "isOpaque() is pretty dumb unfortunately. Unless devs specify {alpha: false} when creating a canvas, we don\u0027t know if there is relevant content in alpha channel and isOpaque() is false. That is quite often, see my skia bug below for details.\nhttps://bugs.chromium.org/p/skia/issues/detail?id\u003d7085\n\nCreateReadbackPipelineYUV() is getting deprecated, right? I thought that\u0027s why you asked me to factor out into a smaller design in a new class in our email thread and I filed the bug below. As I said, I had the intention of landing this code quickly for unblocking the client we are in touch with, but this CL discussion seems to never ending. \nhttps://bugs.chromium.org/p/chromium/issues/detail?id\u003d774297",
      "parentUuid": "ba180590_46dd0cf3",
      "range": {
        "startLine": 238,
        "startChar": 1,
        "endLine": 239,
        "endChar": 55
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1778edc_e060bb46",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 249,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-10-17T02:08:12Z",
      "side": 1,
      "message": "Creating and destroying GLHelper for each frame is very expensive. GLHelper caches a lot of things that latency intensive (e.g., it probes the implementation for readback strategy, and other things.)\n\nYou should create it once, upon first use. Perhaps GLHelper should be added to RenderThreadImpl?",
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67b0ae5d_140ba437",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 249,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-10-17T19:30:35Z",
      "side": 1,
      "message": "I think a good place for a GLHelper instance to live is in viz::ContextProvider (possible lazily initialized). That way it\u0027s life time would be tied to the life time of the gpu channel it uses. Also, this means it could be accessed via ContextProviderWrapper.",
      "parentUuid": "f1778edc_e060bb46",
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edaddbb4_f9636bd0",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 251,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-10-17T19:30:35Z",
      "side": 1,
      "message": "Using the sharedMainThreadContextProvider may not be safe.  There is no strict guarantee that this is the same context that created \u0027image\u0027.  There is a potential data security vulnerability here. For example after a GPU context reset, the texture ID returned by skia might not be valid in the new SharedMainThreadContext. Then the readback might be reading back content from a different texture, possibly leaking private (or cross-origin) data.",
      "range": {
        "startLine": 251,
        "startChar": 25,
        "endLine": 251,
        "endChar": 56
      },
      "revId": "e07873256d6f2d3291e0e3aa62d050ef813211c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}