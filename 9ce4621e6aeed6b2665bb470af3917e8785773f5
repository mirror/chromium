{
  "comments": [
    {
      "key": {
        "uuid": "cfdccc35_a0faa14f",
        "filename": "components/arc/power/arc_power_bridge_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2017-11-01T06:30:14Z",
      "side": 1,
      "message": "i\u0027m getting a DCHECK in this call\u0027s RunUntilIdle call:\n\n  [ RUN      ] ArcPowerBridgeTest.DifferentWakeLocks\n  [134299:134299:1031/231729.445182:10907563459045:FATAL:binding_state.cc(90)] Check failed: !router_. \n  #0 0x7fa6c5f33d9c base::debug::StackTrace::StackTrace()\n  #1 0x7fa6c5f5a36c logging::LogMessage::~LogMessage()\n  #2 0x7fa6c49ffdee mojo::internal::BindingStateBase::BindInternal()\n  #3 0x000002673373 mojo::internal::BindingState\u003c\u003e::Bind()\n  #4 0x000002672643 device::TestWakeLockProvider::OnBindInterface()\n  ...\n\ni\u0027m guessing that i\u0027m not doing something that i need to be doing in TestWakeLockProvider\u0027s OnBindInterface, and sending a second request to the same provider causes trouble as a result.",
      "revId": "9ce4621e6aeed6b2665bb470af3917e8785773f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f851235_d94f7152",
        "filename": "components/arc/power/arc_power_bridge_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-11-01T16:57:25Z",
      "side": 1,
      "message": "The check indicates that TestWakeLockProvider::binding_ is bound by the time you call Bind(). This is not OK, and you have two good options to solve it:\n\n1) Explicitly Close() binding_ before re-binding it.\n2) Use a BindingSet instead.\n\n#1 is fine if you don\u0027t care about any of InterfacePtrs remaining valid concurrently. #2 is probably a safer general-purpose solution for the test fixture in case you do ever want that support.\n\nAs an aside, I also would discourage use of RunUntilIdle() in favor of waiting for more specific events if possible. Makes the test expectations clearer, and avoids any potential problems from inconsistency between the scheduling environment\u0027s notion of \"idle\" vs the actual state of the process. Of course you can also ignore this comment, but if I had my druthers RunUntilIdle would not even exist... :)",
      "parentUuid": "cfdccc35_a0faa14f",
      "revId": "9ce4621e6aeed6b2665bb470af3917e8785773f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5ecc631_8acca7dc",
        "filename": "components/arc/power/arc_power_bridge_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2017-11-01T21:42:13Z",
      "side": 1,
      "message": "thanks, BindingSet was an easy fix for this.\n\nre RunUntilIdle, is your preference to still use RunLoop but to call QuitClosure/Run instead? would you e.g. make the Acquire and Release helpers here take a bool param specifying whether they should expect a wake lock change in the service, and then pass the quit closure to TestWakeLockProvider so it can run it when it sees a change?\n\nor maybe there\u0027s a more-targeted way to wait for mojo-related tasks to finish here...",
      "parentUuid": "9f851235_d94f7152",
      "revId": "9ce4621e6aeed6b2665bb470af3917e8785773f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59f9b857_01e31f1a",
        "filename": "components/arc/power/arc_power_bridge_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-11-01T21:48:34Z",
      "side": 1,
      "message": "In general yeah, RunLoop explicit QuitClosure invocation is the gist. In this case maybe it would be sufficient to add an API to TestWakeLockProvider like, SetOnWakeLockRequestedCallback, SetOnWakeLockCanceledCallback? Just closures that if non-null will be invoked when those messages are received? Not sure if that\u0027s sufficient, just a thought at a glance.\n\nI wouldn\u0027t try to treat Mojo-related tasks as anything special in the system. We certainly don\u0027t frame them as anything special, they\u0027re just tasks.",
      "parentUuid": "d5ecc631_8acca7dc",
      "tag": "mailMessageId\u003d\u003cCA+apAgHMp-C-g146CpHLZWCBcnx_OzN0dtmU+u5yBcsiXW9LtQ@mail.gmail.com\u003e",
      "revId": "9ce4621e6aeed6b2665bb470af3917e8785773f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c513942_b8166ea7",
        "filename": "components/arc/power/arc_power_bridge_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2017-11-01T22:19:13Z",
      "side": 1,
      "message": "hmm, i\u0027m having a hard time removing the RunUntilIdle call here without reducing test coverage. the crux of the problem is that ArcPowerBridge may or may not acquire/release the provider\u0027s WakeLock, depending on whether it\u0027s the first/last ARC request or not. the tests know when the mojo request is expected or not, so it\u0027s pretty straightforward to pass that through to the helper methods, e.g.\n\n  void AcquireDisplayWakeLock(mojom::DisplayWakeLockType type,\n                              bool wait_for_service) {\n    power_bridge_-\u003eOnAcquireDisplayWakeLock(type);\n    if (wait_for_service) {\n      base::RunLoop run_loop;\n      wake_lock_provider_-\u003eSetWakeLockRequestedCallback(run_loop.QuitClosure());\n      run_loop.Run();\n    }\n  }\n\nwhen i do this, though, it seems like there\u0027s a chance that i\u0027ll miss catching bugs where ARC requests trigger mojo calls that shouldn\u0027t have happened. for example, if the ReleaseDisplayWakeLock call on line 99 below were to cause the lock to be canceled at the provider, i\u0027ll presumably fail to catch that if i don\u0027t run the message loop to completion before checking that the lock is still held at the provider on line 100.\n\ndoes that make sense? any suggestions? it feels like i\u0027d have a hard time catching this without RunUntilIdle unless i instrument ArcPowerBridge to expose extra info to tests, which i\u0027d prefer to avoid.",
      "parentUuid": "59f9b857_01e31f1a",
      "revId": "9ce4621e6aeed6b2665bb470af3917e8785773f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7df34e66_e693775a",
        "filename": "components/arc/power/arc_power_bridge_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-11-01T22:32:43Z",
      "side": 1,
      "message": "Sure, it makes sense, and I don\u0027t want to push back too hard on this because I know it\u0027s technically OK to use RunUntilIdle in this case with the state of the world as it is, and I see why this is annoying to change.\n\nI think the point remains true though that there is really no way to ever guarantee that \"run the message loop to completion\" is sufficient unless you\u0027re sure that all async work in the test environment goes through the same scheduler in the same process. (Of course, again, we know that\u0027s true in this case at the moment). So I try to discourage it but it\u0027s an understandable compromise. :)",
      "parentUuid": "8c513942_b8166ea7",
      "tag": "mailMessageId\u003d\u003cCA+apAgEkZRHsunuvFdRNBxXrcXZB7O+_NRgz-S8SzxCwFb-npA@mail.gmail.com\u003e",
      "revId": "9ce4621e6aeed6b2665bb470af3917e8785773f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}