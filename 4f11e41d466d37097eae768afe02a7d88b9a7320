{
  "comments": [
    {
      "key": {
        "uuid": "952a8cec_15728417",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java",
        "patchSetId": 1
      },
      "lineNbr": 706,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-24T17:57:44Z",
      "side": 1,
      "message": "I\u0027m not sure this is going to be a 100% reliable fix.  While this prevents the save state in onStop, there is nothing that prevents the tab model selector from saving again while in the background and removing the now moved tab.\n\nSince any subsequent saveState will just iterate over the list of tabs in the model, any following one will cause the tab state to be deleted.\n\nI do think this does need a more involved change, but I don\u0027t have a great immediate suggestion.  We could introduce the concept of a detached tab that isn\u0027t actually removed from another activities tab model.  We\u0027d likely need to add checks to verify that two activities don\u0027t attempt to use the tab at the same time though.  This definitely gets complicated as we can\u0027t naively select the previous tab as there might not be any other tab or the other selected tab could be closed by a delayed javascript causing our now detached tab to get selected and thus clobbering any of our activity stuff.\n\nWe could introduce the concept of a detached tab to the tab model and update TabPersistentStore#serializeTabModelSelector to add the detached tabs at the right place.  We could always save them at the end or potentially try to interleave them in the correct position based on their parent ID/previous ID.  Without the positioning fix, I suspect this option is going to be less painful as the rest of the system wouldn\u0027t need to be taught about detached tabs nor would we need to expand the concept of the TabModel#getComprehensiveModel() to include them.  With that said, making the comprehensive model aware of this might not be bad either, but again, I wouldn\u0027t rank that super high in terms of priority.\n\nThat being said, VR discussed this concept a long time ago, but we shot it down because of the potential side effects, but I think having persisted detached tabs hang off of the model shouldn\u0027t be too bad.\n\nOn another note, I don\u0027t see any code in FullscreenActivity that handles the case where Chrome\u0027s process is killed while it is running.  Ahh, but it looks like it has android:noHistory set which means that you should never be able to return to it after the fact (was wondering if we needed to just call finish if we saw savedInstanceState !\u003d null, but that was done via android magic instead...nvm).\n\nMy basic thinking is we could change Tab#detach to do something like:\n\n\nvoid detach(boolean transferOwnership) {\n    if (tabModelSelector !\u003d null) {\n        TabModel model \u003d tabModelSelector.getModel(mIncognito);\n        model.removeTab(this);\n        if (!transferOwnership) model.addDetachedTab(this);\n    }\n}\n\nWe\u0027d always be removing the tab from the model so UI like the tab strip/toolbar number count would decrement, but the model itself would then save it in serializeTabModelSelector by:\n\n        TabModel normalModel \u003d selector.getModel(false);\n        TabModelMetadata normalInfo \u003d new TabModelMetadata(normalModel.index());\n        for (int i \u003d 0; i \u003c normalModel.getCount(); i++) {\n            normalInfo.ids.add(normalModel.getTabAt(i).getId());\n            normalInfo.urls.add(normalModel.getTabAt(i).getUrl());\n        }\n        for (int i \u003d 0; i \u003c normalModel.getDetachedCount(); i++) {\n            normalInfo.ids.add(normalModel.getDetachedTabAt(i).getId());\n            normalInfo.ids.add(normalModel.getDetachedTabAt(i).getId());\n        }\n\nGranted, this could be the home of untold number of other gotchas, so I can\u0027t guarantee this will be bulletproof in other regards.",
      "revId": "4f11e41d466d37097eae768afe02a7d88b9a7320",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1543be43_76a620ad",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java",
        "patchSetId": 1
      },
      "lineNbr": 706,
      "author": {
        "id": 1116074
      },
      "writtenOn": "2017-10-24T19:18:27Z",
      "side": 1,
      "message": "Is there a reason why does FullscreenActivity not save its state? If it did save it in a way that that tabState is merged back to the Tabbed mode model that should solve this problem, right? Ted, can we use the thing we do for Browser Actions where we save their state while in a separate model and then tabbed mode gets them in its model the next time it restores tabs here?\n\nLike Ted mentioned, the most fragile part of a detached tab list inside a model is this concept of transferring ownership I believe, because there might be more than a boolean state here. When I first read that I thought we are talking about not transferring the tab to the other activity, but we are actually talking about another layer of transfer on the model here. So it might be possible to get permutations of both (Activity ownership and Model ownership) which might gets things quite entangled. Is there any hard fast rule we can set around that? When you detach but not attach, maybe you have to transfer tab model ownership and not keep it in your detached list?(Since that would be the hardest to keep track of). If you do attach and do transfer ownership, that means the new Activity owns most of the tab related functionality (the other one can\u0027t show it, take screenshots/thumbnails from it), but state bookkeeping is the old activity\u0027s business?\n\nI do agree, right now we leave the question of what reparenting does to the TabModel up in the air a bit and especially new use cases have been running into issues around this though.",
      "parentUuid": "952a8cec_15728417",
      "revId": "4f11e41d466d37097eae768afe02a7d88b9a7320",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a4357f8_16d861c7",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java",
        "patchSetId": 1
      },
      "lineNbr": 706,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-24T21:07:47Z",
      "side": 1,
      "message": "Ufft...Yusuf\u0027s comment made me realize that CTA could die in the background while FullscreenActivity is shown, which would prevent further state updates and then transfering back the tab display from fullscreen to CTA gets muddled.\n\nI do think the browser actions/activity owning it\u0027s own state is probably the most robust solution, but causes a non-trivial amount of overhead where fullscreenactivity would be creating it\u0027s own tab list file and CTA would need to merge it back in during restore if they\u0027re both dead as well as the live merging that Browser Actions does.\n\nDepending on the urgency of the fix, we could look at a various set of options from extracting browser action behavior to a common structure to making tab model work ok-ish with detached but still owned tabs.  This is the solution I mentioned above, but it\u0027s not terribly robust if the tab state file needs to be resaved due to something that makes Tab#isTabStateDirty true after entering fullscreen -- shouldn\u0027t happen because navigations aren\u0027t supported if I recall.  CTA and it\u0027s owned TabModelImpl/TabModelSelectorImpl provides the signal to resave tab state files and FullscreenActivity doesn\u0027t have such a thing.  We might need to educate the TabPersistentStore to check some global tab reparenting container to see if it\u0027s about to restore a tab that is owned by another activity.  If CTA dies in the background and you\u0027ve got a live tab from FullscreenActivity, you wouldn\u0027t want it to be duplicated and you also wouldn\u0027t want the renderer to be killed if you can avoid it so we\u0027d need a way for CTA to restore the state file but take a live tab instead of creating a new one.",
      "parentUuid": "1543be43_76a620ad",
      "revId": "4f11e41d466d37097eae768afe02a7d88b9a7320",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09d16fc3_999b9a27",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/FullscreenActivity.java",
        "patchSetId": 1
      },
      "lineNbr": 50,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-24T16:42:19Z",
      "side": 1,
      "message": "I wonder whether it would be worth making this a method on ChromeActivity that is empty by default.",
      "range": {
        "startLine": 50,
        "startChar": 55,
        "endLine": 50,
        "endChar": 72
      },
      "revId": "4f11e41d466d37097eae768afe02a7d88b9a7320",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}