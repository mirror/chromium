{
  "comments": [
    {
      "key": {
        "uuid": "bbc0bc74_d88e2543",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-06-30T18:22:39Z",
      "side": 1,
      "message": "this is internal implementation unnecessarily leaking into the public interface\n\nThe public interface should just have this take a WebContents pointer. Don\u0027t even need ViewAndroid since you can get that from WebContents.\n\nInternally, you can maybe RenderWidgetHostDelegate return the Synthesizer. If you really want to be strict, it can\u0027t be Synthesizer itself, but an interface that doesn\u0027t mention webcontents, although that seems a bit overkill",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15f09e94_15d2de19",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-07-05T06:57:37Z",
      "side": 1,
      "message": "\u003e Don\u0027t even need ViewAndroid since you can get that from WebContents. \n\nYou can\u0027t get the ViewAndroid from WebContents here. The embedder (VrShell) comes with its own WindowAndroid (and a child VA I\u0027m adding in this CL). It is different from that formed by WebContents/RenderWidgetHostView. I suspect it\u0027s because VrShell was built on top of Chrome to use Tab/WebContents but needed a Window of different factors.\n\nThat said, I still think gfx::NativeView (ViewAndroid) can be a right argument for this API. Passing WebContents to keep the reference to it may work but would look confusing if both WC/VA are used.\n\nHow about ViewAndroid(Delegate) play the role of WebContentsImpl in this regard? VAD is also per-WebContent object. So it can hold a reference to a Java object like this (no reference in Java, weak global in native only). Then I can still keep one parameter (ViewAndroid) for the interface.\n\nIf this kind of gc concern due to weak ptrs can happen for other classes as well, a general java object reference holder may be useful - you just pass the java object to it and when VAD is gone (along with WebContents) it clears up the reference. MotionEventSynthesizer will stop propagating events accordingly. \n\nOther possibility would be for the embedder to pass a dummy WebContents added just to hold the reference and provide the right Window/ViewAndroid. I think this is not as good as the other because WebContents is expensive to create.\n \n\u003e but an interface that doesn\u0027t mention webcontents, although that seems a bit overkill\n\nI\u0027ve been removing the references to WebContents/CVC in RenderWidgetHost/View one at a time to resolve all the layering violations - don\u0027t want to do the reverse..",
      "parentUuid": "bbc0bc74_d88e2543",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf14e21c_8089b99c",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-07-05T18:17:21Z",
      "side": 1,
      "message": "\u003e \u003e Don\u0027t even need ViewAndroid since you can get that from WebContents. \n\u003e \n\u003e You can\u0027t get the ViewAndroid from WebContents here. The embedder (VrShell) comes with its own WindowAndroid (and a child VA I\u0027m adding in this CL).\n\nwhy not? what\u0027s wrong with WebContents-\u003eWebContentsViewAndroid-\u003eViewAndroid?\n\n\u003e It is different from that formed by WebContents/RenderWidgetHostView. I suspect it\u0027s because VrShell was built on top of Chrome to use Tab/WebContents but needed a Window of different factors.\n\nYeah, they go through the tab reparenting path to reparent to a different window.\n\n\u003e \n\u003e That said, I still think gfx::NativeView (ViewAndroid) can be a right argument for this API. Passing WebContents to keep the reference to it may work but would look confusing if both WC/VA are used.\n\u003e \n\u003e How about ViewAndroid(Delegate) play the role of WebContentsImpl in this regard? VAD is also per-WebContent object. So it can hold a reference to a Java object like this (no reference in Java, weak global in native only). Then I can still keep one parameter (ViewAndroid) for the interface.\n\nVAD is mostly a delegate interface though (I guess it has a bunch of non-trivial default implementations that ideally would not be there). Holding onto refs to content things is a content-internal concern.\n\n\u003e \n\u003e If this kind of gc concern due to weak ptrs can happen for other classes as well, a general java object reference holder may be useful - you just pass the java object to it and when VAD is gone (along with WebContents) it clears up the reference. MotionEventSynthesizer will stop propagating events accordingly.\n\nThere\u0027s nothing general about lifetime though. There could very well be java things that\u0027s tied to lifetime of a frame rather than contents.\n\n\u003e \n\u003e Other possibility would be for the embedder to pass a dummy WebContents added just to hold the reference and provide the right Window/ViewAndroid. I think this is not as good as the other because WebContents is expensive to create.\n\nyeah don\u0027t do that\n\n\u003e  \n\u003e \u003e but an interface that doesn\u0027t mention webcontents, although that seems a bit overkill\n\u003e \n\u003e I\u0027ve been removing the references to WebContents/CVC in RenderWidgetHost/View one at a time to resolve all the layering violations - don\u0027t want to do the reverse..",
      "parentUuid": "15f09e94_15d2de19",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b175b7f6_a301543f",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-07-06T15:18:34Z",
      "side": 1,
      "message": "\u003e why not? what\u0027s wrong with WebContents-\u003eWebContentsViewAndroid-\u003eViewAndroid?\n\nOkay I didn\u0027t look hard enough; while VrShell takes over, it swaps in its own WindowAndroid to make it the parent of the WebContents\u0027s ViewAndroid tree. That will have WC\u0027s VA return the right dip scale from WA as expected. We don\u0027t need to pass VA - WebContents is enough.\n\nI still need to make sure it returns the right container view, for which I also need to swap in its ViewAndroidDelegate and later put the old one back. Will get back once it is done.",
      "parentUuid": "cf14e21c_8089b99c",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "efa53ac1_029bcaec",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-07-06T16:42:33Z",
      "side": 1,
      "message": "\u003e \u003e why not? what\u0027s wrong with WebContents-\u003eWebContentsViewAndroid-\u003eViewAndroid?\n\u003e \n\u003e Okay I didn\u0027t look hard enough; while VrShell takes over, it swaps in its own WindowAndroid to make it the parent of the WebContents\u0027s ViewAndroid tree. That will have WC\u0027s VA return the right dip scale from WA as expected. We don\u0027t need to pass VA - WebContents is enough.\n\u003e \n\u003e I still need to make sure it returns the right container view, for which I also need to swap in its ViewAndroidDelegate and later put the old one back. Will get back once it is done.\n\nThat just sounds like needing to correctly handle tab reparenting in general, whenever the container view is cached in java.",
      "parentUuid": "b175b7f6_a301543f",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9332afdf_08158ab3",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-07-06T17:29:53Z",
      "side": 1,
      "message": "\u003e That just sounds like needing to correctly handle tab reparenting in general, whenever the container view is cached in java.\n\nDoes it? VAD is per-content, not per-tab object. I think it needs to happen not as a part of reparenting task but of content switching task for the current tab, which can happen repeatedly in the reparented state. \n\nI\u0027m still trying to figure out the consequence of having a new VAD in place of current one work for a WebContents when in VrShell. Again, this happens only for native Java UI pages. Embedder does not access its CVC (and hence its container view). I *think* it will limit the cases where the container view is cached in java, and even so, it basically puts them in a hold-on state, letting the VrShell VAD forward touch events temporarily for MotionEventSynthesizer, and then will be able to restore the old VAD when VrShell gets paired with a new WebContents or destroyed.\n\nThat\u0027s how I hope it will work... would be very helpful if you see any side effect.",
      "parentUuid": "efa53ac1_029bcaec",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9069af1_f552a09c",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-07-06T22:03:21Z",
      "side": 1,
      "message": "\u003e \u003e That just sounds like needing to correctly handle tab reparenting in general, whenever the container view is cached in java.\n\u003e \n\u003e Does it? VAD is per-content, not per-tab object. I think it needs to happen not as a part of reparenting task but of content switching task for the current tab, which can happen repeatedly in the reparented state.\n\nOh you are right. \"Tab reparenting\", ie ContentViewCore.updateWindowAndroid, only updates the WindowAndroid, it does not change the container view. Looks like only webview calls ContentViewCore.setContainerView, but it correctly keeps the one in CVC and the one returned by ViewAndroidDelegate in sync, so no issues here.\n\nBut I think my point still stands that if something else caches the container view, then it needs to listen to the setContainerView event to know to update that reference.\n\n\u003e \n\u003e I\u0027m still trying to figure out the consequence of having a new VAD in place of current one work for a WebContents when in VrShell. Again, this happens only for native Java UI pages. Embedder does not access its CVC (and hence its container view). I *think* it will limit the cases where the container view is cached in java, and even so, it basically puts them in a hold-on state, letting the VrShell VAD forward touch events temporarily for MotionEventSynthesizer, and then will be able to restore the old VAD when VrShell gets paired with a new WebContents or destroyed.\n\u003e \n\u003e That\u0027s how I hope it will work... would be very helpful if you see any side effect.\n\nSo I don\u0027t actually get it. VR doesn\u0027t call setContainerView, so the container view doesn\u0027t change for VR. ViewAndroidDelegate doesn\u0027t change either. So.. what\u0027s the problem you are trying to solve here again?",
      "parentUuid": "9332afdf_08158ab3",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03c00e62_9665fdad",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-07-07T14:00:31Z",
      "side": 1,
      "message": "\u003e But I think my point still stands that if something else caches the container view, then it needs to listen to the setContainerView event to know to update that reference.\n\nPoint taken. There\u0027s no more concern on container view in the new patch where I take a different approach.\n\n\u003e So I don\u0027t actually get it. VR doesn\u0027t call setContainerView, so the container view doesn\u0027t change for VR. ViewAndroidDelegate doesn\u0027t change either. So.. what\u0027s the problem you are trying to solve here again?\n\nMy issue was mostly on VrShell side, not content/. I wanted to get a Java target view for MES out of ViewAndroid. I was trying to handle it by swapping ViewAndroidDelegate that can be obtained by |ViewAndroid::GetContainerView()| but this was opening a can of worms (what to do with container view cached in Java classes, how to restore the old one back, etc).\n\nI have a new approach, which is having another interface |MotionEventSynthesizer::SetTargetView(gfx::NativeView)| Embedder then doesn\u0027t have to shove its VAD into existing ViewAndroid tree. Now MES constructor creates a Java object and stores it in WebContentsImpl only. Actual target view that MES uses to dispatch the synthesized event to is set via the new interface. Please take another look.",
      "parentUuid": "c9069af1_f552a09c",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f245a510_489c182d",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-07-07T19:29:22Z",
      "side": 1,
      "message": "\u003e My issue was mostly on VrShell side, not content/. I wanted to get a Java target view for MES out of ViewAndroid. I was trying to handle it by swapping ViewAndroidDelegate that can be obtained by |ViewAndroid::GetContainerView()| but this was opening a can of worms (what to do with container view cached in Java classes, how to restore the old one back, etc).\n\u003e \n\u003e I have a new approach, which is having another interface |MotionEventSynthesizer::SetTargetView(gfx::NativeView)| Embedder then doesn\u0027t have to shove its VAD into existing ViewAndroid tree. Now MES constructor creates a Java object and stores it in WebContentsImpl only. Actual target view that MES uses to dispatch the synthesized event to is set via the new interface. Please take another look.\n\nOh VR targets another view? Ok, it\u0027s more broken than I thought then. And there is no way to fix that. content has no business sending events to random views. VR should just duplicate that code or something.\n\nNote to VR people. This is really really bad code. Please stop taking shortcuts like this.",
      "parentUuid": "03c00e62_9665fdad",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ee54be7_f681a866",
        "filename": "content/public/browser/android/motion_event_synthesizer.h",
        "patchSetId": 8
      },
      "lineNbr": 44,
      "author": {
        "id": 1002411
      },
      "writtenOn": "2017-07-10T17:14:46Z",
      "side": 1,
      "message": "Please mind your tone Bo, nobody here has bad intent. If there\u0027s an issue with our implementation please file a bug with some suggestions, or otherwise reach out to the team.\n\nNot only did we have no idea this was a \u0027shortcut\u0027, or \u0027bad code\u0027, but our non-\u0027VR people\u0027 reviewers also apparently didn\u0027t realize that was the case. We did what we thought was the correct way to do it.\n\nI\u0027m not sure why MES is in the content layer to begin with, that sounds like an issue in itself.",
      "parentUuid": "f245a510_489c182d",
      "revId": "29c90b3ebc3d4b3e81cd6bbc71b0cc27eab98549",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}