{
  "comments": [
    {
      "key": {
        "uuid": "6bcd7503_844bd3f9",
        "filename": "content/browser/browser_main_loop.cc",
        "patchSetId": 13
      },
      "lineNbr": 1144,
      "author": {
        "id": 1002120
      },
      "writtenOn": "2018-01-10T03:27:37Z",
      "side": 1,
      "message": "I forgot that GetThreadId() blocks on thread start. This is unfortunately makes this approach very likely undesirable since it will add startup latency.\n\nAs an alternative, presumably we could create the profiler on the IO thread itself by posting a task to its message loop here, but I\u0027m not sure what it would take to guarantee that we execute another task to destroy the object before thread exit.\n\ngab: Can you comment on the best approach here? The goal is to create and start a sampling profiler object immediately after IO thread start, then destroy the object immediately before IO thread exit. Is there a way to ensure that a posted message is run before thread exit, or would we need to do our own synchronization?",
      "range": {
        "startLine": 1144,
        "startChar": 29,
        "endLine": 1144,
        "endChar": 54
      },
      "revId": "39fd209c7440d4c31d726b841d05f3b47cc5bce0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a08a0e5_0077c527",
        "filename": "content/browser/browser_main_loop.cc",
        "patchSetId": 13
      },
      "lineNbr": 1144,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-10T10:32:40Z",
      "side": 1,
      "message": "Yes:\n\nTo run on start you need to post a task to it right after creating it.\n\nTo hook destruction use a MessageLoop::DestructionObserver (I\u0027m not a fan of those but they\u0027re still the best way to achieve that).",
      "parentUuid": "6bcd7503_844bd3f9",
      "range": {
        "startLine": 1144,
        "startChar": 29,
        "endLine": 1144,
        "endChar": 54
      },
      "revId": "39fd209c7440d4c31d726b841d05f3b47cc5bce0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f578eee_57676d0f",
        "filename": "content/browser/browser_main_loop.cc",
        "patchSetId": 13
      },
      "lineNbr": 1144,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-10T10:42:47Z",
      "side": 1,
      "message": "Actually we do have a more modern hook for destruction, if you store your object in a SequenceLocalStorageSlot on the IO thread, it will be destroyed when the sequence (thread) goes away (same timing as MessageLoop::DestructionObserver).",
      "parentUuid": "5a08a0e5_0077c527",
      "range": {
        "startLine": 1144,
        "startChar": 29,
        "endLine": 1144,
        "endChar": 54
      },
      "revId": "39fd209c7440d4c31d726b841d05f3b47cc5bce0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8de7008c_4ffe661f",
        "filename": "content/browser/browser_main_loop.cc",
        "patchSetId": 13
      },
      "lineNbr": 1144,
      "author": {
        "id": 1228990
      },
      "writtenOn": "2018-01-12T21:51:14Z",
      "side": 1,
      "message": "Thanks for the suggestions. Now the profiler is created on the IO thread in the async manner, and is stored in a SequenceLocalStorageSlot. For the profiler to start on the IO thread, we need to allow waiting on a //base sync primitive temporarily per the current implementation of the profiler. Is this okay?",
      "parentUuid": "4f578eee_57676d0f",
      "range": {
        "startLine": 1144,
        "startChar": 29,
        "endLine": 1144,
        "endChar": 54
      },
      "revId": "39fd209c7440d4c31d726b841d05f3b47cc5bce0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}