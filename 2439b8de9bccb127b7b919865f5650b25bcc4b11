{
  "comments": [
    {
      "key": {
        "uuid": "bd3594c3_b68979ff",
        "filename": "chromecast/media/cma/pipeline/stream_decryptor.h",
        "patchSetId": 5
      },
      "lineNbr": 18,
      "author": {
        "id": 1207129
      },
      "writtenOn": "2018-02-07T06:21:43Z",
      "side": 1,
      "message": "I would prefer to have a callback once a decrypted buffer is ready, instead of polling. A delegate interface might be nice:\n\n// All methods and delegate methods are called on the same thread.\nclass StreamDecryptor {\n  class Delegate {\n   virtual void OnDecryptedBuffer(scoped_refptr\u003cDecoderBufferBase\u003e buffer) \u003d 0;\n   virtual void OnDecryptionError() \u003d 0;\n   virtual void CanDecryptMoreData() \u003d 0;\n  };\n\n  virtual void Initialize(Delegate* delegate) \u003d 0;\n\n  // The delegate\u0027s CanDecryptMoreData() method will be called once\n  // the decryptor is ready to accept another buffer.\n  virtual void Decrypt(scoped_refptr\u003cDecoderBufferBase\u003e buffer) \u003d 0;\n};",
      "range": {
        "startLine": 18,
        "startChar": 6,
        "endLine": 18,
        "endChar": 21
      },
      "revId": "2439b8de9bccb127b7b919865f5650b25bcc4b11",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8547d01_540324d5",
        "filename": "chromecast/media/cma/pipeline/stream_decryptor.h",
        "patchSetId": 5
      },
      "lineNbr": 18,
      "author": {
        "id": 1211592
      },
      "writtenOn": "2018-02-07T08:19:42Z",
      "side": 1,
      "message": "This requires moving the clear buffer queue to AvPipelineImpl, in case Decoder::PushBuffer returns pending and later OnDecryptedBuffer is called. My original plan is keep the queue inside StreamDecryptor so that AvPipelineImpl holds as little buffer as possible.\n\nAre you suggesting fetch and decrypt new buffers as soon as CanDecryptMoreData is called? If so, we may hit the case where AvPipelineImpl fetches too much buffers from BufferingFrameProvider but pushing buffers to Decoder is still pending. With polling model, AvPipelineImpl can just fetch enough buffers to maintain pipeline running and avoid the edge case. Maybe we should limit the size of the clear buffer queue so that this edge case won\u0027t happen?\n\nWhat do you think?",
      "parentUuid": "bd3594c3_b68979ff",
      "range": {
        "startLine": 18,
        "startChar": 6,
        "endLine": 18,
        "endChar": 21
      },
      "revId": "2439b8de9bccb127b7b919865f5650b25bcc4b11",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb1cff25_0375d8cd",
        "filename": "chromecast/public/media/media_pipeline_backend.h",
        "patchSetId": 5
      },
      "lineNbr": 199,
      "author": {
        "id": 1207129
      },
      "writtenOn": "2018-02-07T06:33:17Z",
      "side": 1,
      "message": "OnPushBufferForDecryptComplete - so we don\u0027t have a name conflict with Decoder::Delegate methods.",
      "range": {
        "startLine": 199,
        "startChar": 19,
        "endLine": 199,
        "endChar": 39
      },
      "revId": "2439b8de9bccb127b7b919865f5650b25bcc4b11",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b357199_8ba21c98",
        "filename": "chromecast/public/media/media_pipeline_backend.h",
        "patchSetId": 5
      },
      "lineNbr": 203,
      "author": {
        "id": 1207129
      },
      "writtenOn": "2018-02-07T06:33:17Z",
      "side": 1,
      "message": "Also pass CastDecoderBuffer* here (matching the input buffer to Decrypt()) to make it easier for callers.",
      "range": {
        "startLine": 203,
        "startChar": 37,
        "endLine": 203,
        "endChar": 49
      },
      "revId": "2439b8de9bccb127b7b919865f5650b25bcc4b11",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4be46d2a_eda02585",
        "filename": "chromecast/public/media/media_pipeline_backend.h",
        "patchSetId": 5
      },
      "lineNbr": 203,
      "author": {
        "id": 1211592
      },
      "writtenOn": "2018-02-07T08:36:20Z",
      "side": 1,
      "message": "Caller needs to keep a reference to the buffer anyway, otherwise when deleting the decryptor during pipeline flush, it will cause memory leak.\n\nI guess your suggestion is to static_cast CastDecoderBuffer to DecoderBufferBase in the callback so that caller won\u0027t need a queue, right? If not, what\u0027s the purpose for returning buffer here? Compare it with the caller\u0027s reference and fail decryption when they don\u0027t match?",
      "parentUuid": "1b357199_8ba21c98",
      "range": {
        "startLine": 203,
        "startChar": 37,
        "endLine": 203,
        "endChar": 49
      },
      "revId": "2439b8de9bccb127b7b919865f5650b25bcc4b11",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d55f73d_2a5b89be",
        "filename": "chromecast/public/media/media_pipeline_backend.h",
        "patchSetId": 5
      },
      "lineNbr": 203,
      "author": {
        "id": 1207129
      },
      "writtenOn": "2018-02-07T16:05:53Z",
      "side": 1,
      "message": "Right, this way caller doesn\u0027t need a queue (assuming the uint8_t* output actually points into the CastDecoderBuffer)",
      "parentUuid": "4be46d2a_eda02585",
      "range": {
        "startLine": 203,
        "startChar": 37,
        "endLine": 203,
        "endChar": 49
      },
      "revId": "2439b8de9bccb127b7b919865f5650b25bcc4b11",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "326dadee_7a85eaac",
        "filename": "chromecast/public/media/media_pipeline_backend.h",
        "patchSetId": 5
      },
      "lineNbr": 234,
      "author": {
        "id": 1207129
      },
      "writtenOn": "2018-02-07T06:33:17Z",
      "side": 1,
      "message": "Do we always use AES decryption? Are there any other possible types that would not have the same size characteristics?\n\nIf we will always use AES decryption, just say \"The size of the decrypted data will be the same as the encrypted data\". That way readers don\u0027t wonder about other encryption types.",
      "range": {
        "startLine": 234,
        "startChar": 24,
        "endLine": 234,
        "endChar": 38
      },
      "revId": "2439b8de9bccb127b7b919865f5650b25bcc4b11",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}