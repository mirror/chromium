NEW NOTES (gri - 5/2/07)

Known problems:
- The arguments vector can be accessed from outside a function! And we cannot know that easily
  during compile-time. This may require deoptimization (or at least a simple version of it).

Contexts/Eval TODOs:
[ ] Investigate change -r74536: doesn't work on Linux/Windows
[x] Create a test case for the UNIMPLEMENTED call in Runtime::LookupCallContext()
[x] eval(function() { print("foo"); })  shouldn't call the funnction! (new eval code())
    (new eval() code disabled for now - gri 5/30/07)
[x] check error handling in compiler/codegen: MakeFunction and MakeCode seem
    not to have any meaningfull error handling at the moment!
[x] Global-level 'with' statements don't work at the moment - need to handle contexts in
    a different way for that.
[ ] Which code to use for contexts? call code or construct code?
[ ] Runtime::Push/PopContextForWith() is terribly inefficient at the moment
[ ] The prettyprinter needs to be updated (decls are not printed properly)
[ ] Mark variables as accessed from inner scopes if they might be looked up
    dynamically because of a 'with' statement - the current solution is not 100% complete
[x] The AST generated for variable access inside a 'with' statement should be different then
    the code outside; it should be the same as for the top-level eval code, but we don't know
    that until we are in the with statement itself. The parser needs to track the with nesting
    level, or we need to have another kind of scope (more work).
    => We now generate VariableProxies w/ 'with' statement information for all variable
    accesses
[ ] handling of try/catch variables and function declarations should be the same
    with respect to the introduction of explicit var statements as for variable decls.
    need to review that code.
[x] scopes.cc DeclareLocal() should probably not return anything since we must
    re-lookup a variable anyway (because: 'var v = x;' === 'var v; v = x;')
    => ok for now - only one (very controlled use)
[ ] think about for-loops introducing variables inside 'with' statements and what
    the meaning of the declaration/initialization should be if the variable name
    corresponds to a field name of the 'with' object.... (same for try-catch inside
    'with' statements)
[x] we need to mark contexts as statically introduced or dynamically introduced
    contexts because we need to be able to jump the right number of *static*
    contexts when doing indexed context accesses. with statements introduce
    extra contexts which screws up the ContectChainLength computation!
    => Fixed. The New context implementation doesn't require this anymore.
[ ] should introduce a super-class for Variable and VariableProxy, to be used
    instead of Expression - would make code clearer; also could move use_count
    into that class and then avoid having to check AsVariable() !=- NULL before
    calling record_use()
[ ] test cases to check megamorphic closure creation/use
[ ] if we have eval() we must allocate all variables, not just the ones that
    are used; also how does this interact w/ arguments vector? => test cases
[ ] create test cases using with statement, eval, and argument in various
    combinations
[x] do (intermediate scope) function names go into contexts?
    x = function f() { ... } -> is f ever in a context?
[ ] store arguments array as last parameter (always one extra parameter slot)
[ ] new context: how do we know which code to use? call_code or construct_code?
[x] lookup context chain must use static links! (fixed by storing closures in contexts)
    (create test cases w/ deep recursion, context lookup must remain cheap)
[x] store closure in context instead of code, save one slot
[ ] pass into the compiler if we need the result of eval() (or the rewriter)
[x] PrettyPrinter::Print -> Format (added static Print w/o changing the names
    of the other functions)

Misc:
[ ] use delete/delete[] instead of free() consistently
[x] do not embed global() into code, go via JSEnv*


------------------------------------------------------------------------
OLD NOTES

[todo, all]
- RelocIterator should move from code.* into a file with a better fitting name.

- According to Linus, eventually this should be under Subversion, not CVS. Alternative:
  keep it in perforce (more under lock, less accidental exposure risk), easily accessible
  to other Googlers. I can set that up. Should decide sooner then later to avoid losing a
  lot of history.

- Coding style: Linus would like us to use as much Google coding style as possible,
  if only to make sure new remote offices retain some of core Google coding discipline
  that also includes code reviews, etc. I (gri) with him to some extent, but we also
  want to move quickly. We need to strike a good balance. To be discussed.


[todo, gri]
- move native code off to non-C stack (we want to be able to run several independent
   JS executions and be able to interrupt them)
- get rid of 'unsigned', just use int (we can assume that they are at least 32bit)
  will make code much more clean and robust
- write decent assembler unittest


[design decisions]
TODO(gri): this section needs to go into Wiki. Didn't have time today. Make
sure it doesn't get lost.
- file structure: flat hierarchy, no subdirectories
- includes: use a single include in all files
- header: simple Google copyright, no names (this is open source, names will
  have to be stripped anyway)
- code reviews: for now, move forward quickly. perhaps have code walk-throughs
  later


[done]
- start thinking about code patterns, native code vs fast interpreter, etc.
- We need some mechanism/convention for intialization code, that is code that is run
  once during initialization of the VM. We probably need both, code that is run once,
  for all VMs, and code that is run once, per VM. (done -> v8.*)
- We need some kind of flag solution for testing. (done -> flags.*)
- We need a solution for handling possible stack alignment requirements for the 
  generated code. Mac OS X requires 16-byte stack alignment at function calls.
  (done -> runtime_stubs.*)
- clean up assembler, and make it work completely
- remove build_assembler_unitest and start to use SCons
- includes: The Google include-style is the same as in C/C++ generally: Have the
  #ifndef XXX__ in every header file. IMHO, sucks big-time. In sawzall we did not have
  any includes in header files, but had every .cc file contain the right include.
  Nice, but costly when include hierarchy changes. Use of an include DB solves the
  problem but requires extra build step and tool (I (gri) don't like that). Proposal:
  Since machines are fast, and this is a relatively small project, have a single file
  (globals.h) contain all the relevant includes. Only include globals.h in all .cc
  files. No includes in header files. I've tried this for a small private project and
  it worked quite well. Will also work well with precompiled headers. To discuss/decide.
  Also: Only the public interfaces will contain the #ifndef stuff, the internal files
  won't.
  Decision: use single include file.
