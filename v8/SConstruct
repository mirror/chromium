# Copyright 2006-2007 Google Inc. All Rights Reserved.

# SCons build description file.
# See http://scons.org/.


import sys, platform, os, re
from os.path import join, dirname, abspath
directory = dirname(File('version.ini').rfile().abspath)
sys.path.append(join(directory, 'tools'))
import js2c, testing


class OurDict(object):
  def __getitem__(self, key):
    return self.__getattribute__(key)


def GetSource(s):
  return join('src', s)


def InitializeCommonEnvironment(config):
  # Determine host/target os.
  if platform.system() == 'Linux':
    common.os = 'linux'
  elif platform.system() == 'Darwin':
    common.os = 'macos'
  elif platform.system() == 'Windows':
    common.os = 'win32'
  else:
    common.os = 'unknown'
  # Determine host architecture.
  if platform.machine().startswith('arm'):
    host_arch = 'arm'
  else:
    host_arch = 'ia32'
  # Setup target architecture.
  common.arch = ARGUMENTS.get('target_arch', host_arch)
  # Determine if we're cross compiling.
  cross_compiling = (common.arch != host_arch)
  common.Replace(CROSS_COMPILING=cross_compiling)
  # Setup tools for cross compilation if necessary.
  if cross_compiling:
    target_sys = ARGUMENTS.get('target_sys', '')
    tools_bin = ARGUMENTS.get('tools_bin', '')
    if not os.path.isdir(tools_bin):
      print "Building simulator for " + common.arch + " on " + common.os + "(" + host_arch + ")."
      # Undo the setting of the CROSS_COMPILING environment.
      common.Replace(CROSS_COMPILING=0)
    else:
      tools_prefix = join(tools_bin, target_sys + '-')
      for tool in ['AR', 'CC', 'CXX', 'RANLIB']:  # 'LINK' is treated differently
        common[tool] = tools_prefix + common[tool]

  def expand(files):
    return [s.replace('<os>', common.os).replace('<arch>', common.arch) for s in files]
  all_sources = File(GetSource('SOURCE')).get_contents().split("\n")
  common.source = expand([ f for f in all_sources if not f.endswith(".h") and len(f.split()) == 1 ])
  common.expand = expand

  # Setup common compilation flags from the 'COMMON' section.
  ApplyConfig(config, common, 'COMMON', {})

  # For now, we we hack this.
  common['BUILDERS']['QuickBuild'] = Builder(action="$CXX -fsyntax-only $FILES")
  common['BUILDERS']['JS2C'] = Builder(action=js2c.JS2C)
  common['BUILDERS']['MakeVersion'] = Builder(action=MakeVersion)

variants = []
def Build(config):
  for section in config.sections():
    variant = section.lower()
    if ':' in variant or variant == 'common': continue
    if share.mode != variant and share.mode != 'all': continue
    variants.append(variant)
    env = common.Copy()
    env['is_common'] = False
    env['variant'] = variant
    ApplyConfig(config, env, section, common.Dictionary())
    SConscript(GetSource('SConscript'),
               build_dir=join('bin', variant),
               exports='env variant share',
               duplicate=0)


# NOTE: Experimental support for determining tool chain.
def DetermineToolchain():
  tools = Environment()['TOOLS']
  if 'gcc' in tools:
    # On Tiger (MaxOSX 10.4) we can compile with the standard gcc config,
    # but for Leopard we need special treatment.  Tiger has kernel 8.xx and
    # Leopard has kernel 9.xx.
    if platform.system() != 'Darwin' or platform.version().find('Kernel Version 8') >= 0:
      return 'gcc'
    else:
      return 'gcc-darwin'
  if 'msvc' in tools: return 'msvc'
  print 'Could not determine toolchain; exiting.'
  sys.exit(-1)


def LoadConfig():
  name = join(directory, 'SConstruct-' + DetermineToolchain() + '.ini')
  return js2c.LoadConfigFrom(name)


def GetSubenvironment(subenvironments, name, default):
  if name in subenvironments: return subenvironments[name]
  return default


def MakeVersion(source, target, env):
  js2c.MakeVersion(str(source[0]), str(target[0]))


def ApplyConfig(config, environment, section, defaults):
  import types
  for key, value in config.items(section):
    if key.startswith('internal'):
      key = key[8:].strip()
    key = key.upper()
    # Compute any prefix from the defaults.
    prefix = None
    if value.startswith('+'):
      value = value.lstrip('+ \t')
      if key in defaults:
        prefix = defaults[key]
        if type(prefix) is types.StringType: prefix += ' '
    # Compute the effective value (using the prefix).
    value = js2c.ParseValue(value)
    if not prefix is None: value = prefix + value
    # Set the variable in the environment.
    environment.Replace(**{key: value})
  # Compute the set of sub-enviroments.
  subenvironments = {}
  environment.sub = lambda name: GetSubenvironment(subenvironments, name, environment)
  for subsection in config.sections():
    if (subsection.startswith(section + ':')):
      name = subsection[subsection.index(':') + 1:]
      env = environment.Copy()
      ApplyConfig(config, env, subsection, environment.Dictionary())
      subenvironments[name] = env


def IntOption(key, help, default):
  re_int = re.compile(r'^(?:\+|-)?\d+$')

  class ValueError(Exception):
    pass

  def converter(val):
    if re_int.match(val):
      return int(val)
    raise ValueError("Invalid value for integer option: %s" % val)

  def validator(key, val, env):
    is_int = lambda x: type(x) in [type(1), type(1L)]
    if (is_int(env[key]) == False):
      raise ValueError("Invalid value for integer option: %s" % val)

  help =  '%s (integer)' % help
  return (key, help, default, validator, converter)

def StringOption(key, help, default):
  def converter(val):
    return val

  def validator(key, val, env):
    pass

  help =  '%s (string)' % help
  return (key, help, default, validator, converter)

def Usage():
  return """
  usage: scons [options] [targets ...]

     options:
           mode=[debug|release|all]  - build debug or release bits (default all)
           output=[simple|fancy|bot] - set output mode (default fancy)
           rebuild=[yes|no]          - build before running tests
           timeout=<int>             - set timeout for tests, in seconds
                                       (default 30)
           snapshot=[yes|no]         - use snapshot in building (default yes)
           snapshot_args='string'    - pass the given arguments on to mksnapshot
                                       (default '')

     targets:
           <none>                 - builds the v8 library & shell
           check                  - builds & run the v8 debug and release tests
              gc=1                - stress the GC while running tests
              greedy=1            - stress the GC while running tests
              test=<name>         - run only the specified test
              check_args='string' - pass the given arguments on to V8 in tests
                                    (default '')

         """;
# ...
opts = Options()
opts.Add(EnumOption('output', 'output mode', 'fancy',
                    allowed_values=('simple', 'fancy', 'bot')))
opts.Add(BoolOption('gc', 'stress the GC while running tests', 0))
opts.Add(BoolOption('greedy', 'stress the GC while running tests', 0))
opts.Add(BoolOption('retest', 'mozilla-test specific: retest', 0))
opts.Add(EnumOption('mode', 'set build mode', 'all',
                    allowed_values=('debug', 'release', 'all')))
opts.Add(PathOption('cache', 'shared cache directory', None,
                    PathOption.PathIsDir))
opts.Add(PathOption('test', 'run only selected test', None,
                    PathOption.PathAccept))
opts.Add(IntOption('timeout', 'timeout for tests (in seconds)', 30))
opts.Add(EnumOption('rebuild', 'rebuild changed files', 'yes',
                    allowed_values=('yes', 'no')))
opts.Add(EnumOption('snapshot', 'use snapshot in building', 'yes',
                    allowed_values=('yes', 'no')))
opts.Add(StringOption('snapshot_args', 
                      'pass the given arguments on to mksnapshot', ''))
opts.Add(StringOption('check_args', 
                      'pass the given arguments on to V8', ''))
opts.Add(EnumOption('time', 'collect and print timing information', 'no',
                    allowed_values=('yes', 'no')))
opts.Add(EnumOption('fasttest', 'only run fast tests', 'no',
                    allowed_values = ('yes', 'no')))
common = Environment(options = opts)
common['is_common'] = True
Help(Usage())
config = LoadConfig()
InitializeCommonEnvironment(config)
share = OurDict()
share.extension_list = []
share.mode = common['mode']
if 'test' in common.Dictionary(): share.test = common['test']
else: share.test = None
if 'cache' in common.Dictionary():
  common.CacheDir(common['cache'])
share.all_mode = (share.mode == 'all')
# Don't attempt to use snapshot on ARM yet.
if common.arch == 'arm': 
  common['snapshot'] = 'no'
  common.Append(**{'CPPDEFINES': 'ARM'})


# Build all the variants described by the configuration.
Build(config)

if share.all_mode:
  AlwaysBuild(Alias('check', testing.RunTests(common)))
  Alias('build', [ var + '-build' for var in variants ])

Default('build')

# Extensions
#SConscript(join('extensions', 'SConscript'),
#           build_dir=join('bin', 'extensions'),
#           exports='common share',
#           duplicate=0)

#sourcefiles = map(GetSource, common.source)
#quickcheck = common.QuickBuild('quickcheck', sourcefiles, FILES=sourcefiles)


# Add target for generating doxygen for the api
env = Environment(ENV = {'PATH' : os.environ['PATH']})
# Have you _ever_ seen anything quite so idiotic?!?
doxy_command = '( cat $SOURCE ; echo -e "INPUT=%(api_path)s\\nEXAMPLE_PATH=%(example_path)s" ) | doxygen -'
env['BUILDERS']['Doxygen'] = Builder(action=doxy_command % {
  'api_path': directory + '/public',
  'example_path': directory + '/src/api/samples'
})
sample_env = env.Clone(CPPPATH=directory)
evaluator_cc = sample_env.Library(join('src', 'api', 'samples', 'evaluator.cc'))
process_cc = sample_env.Library(join('src', 'api', 'samples', 'process.cc'))
sample_env.Doxygen('doxy', [ join('src', 'api', 'Doxyfile'), evaluator_cc, process_cc ])

lint_ignored = []
def DoLint(f):
  if f in lint_ignored: return False
  return f.endswith('.h') or f.endswith('.cc')

files  = [ join('public', f) for f in os.listdir(join(directory, 'public')) ]
files += [ join('src', f) for f in os.listdir(join(directory, 'src')) ]
filters = testing.ReadListEntries(join(directory, 'tools', 'lint.cfg'))
env['BUILDERS']['Lint'] = Builder(action='cpplint.py --filter=%(filters)s $SOURCES' % {
    'filters': ",".join(filters)
})
env.Lint('lint', [ f for f in files if DoLint(f) ])

#product_lib = File(join('bin', 'product', 'libv8.a'))

# Add target for running api benchmarks
#SConscript(join('src', 'api', 'bench', 'SConscript'),
#           build_dir='bin',
#           exports='product_lib',
#           duplicate=0)
