# Copyright 2006-2007 Google Inc. All Rights Reserved.

# SCons build description file.
# See http://scons.org/.

# ... Refactor into configuration setup something...
import sys, os, platform, re
from os.path import join, dirname, abspath, basename

Import('env variant share')
env = env.Copy()

jsre = SConscript(join('third_party', 'jscre', 'SConscript'), exports='env')

os_id = env.os
arch = env.arch
source = env.source
build_dir = 'bin' + os.sep + env['variant'] + os.sep

natives = Split(File('SOURCE-js').get_contents());

natives_cc = env.JS2C([ 'natives.cc', 'natives-empty.cc' ], natives)

version_cc = env.MakeVersion('version.cc', join('..', '..', 'version.ini'))

# Setup compilation flags for compiling dtoa and friends.
dtoa = env.sub('dtoa')
  
nenv = env.Copy()
nenv.Append(CPPPATH='.')

# Only use the -I option for jsregexp.cc
static_natives = nenv.StaticObject('natives.cc')
static_natives_empty = nenv.StaticObject('natives-empty.cc')
static_version = nenv.StaticObject('version.cc')
static = [ dtoa.StaticObject('dtoa-config.c'),
           static_natives, static_version ]
static_light = [ dtoa.StaticObject('dtoa-config.c'),
                 static_natives_empty, static_version ]

shared_natives = nenv.SharedObject('natives.cc')
shared_natives_empty = nenv.SharedObject('natives-empty.cc')
shared_version = nenv.SharedObject('version.cc')
shared = [ dtoa.SharedObject('dtoa-config.c'),
           shared_natives, shared_version ]
shared_light = [ dtoa.SharedObject('dtoa-config.c'),
                 shared_natives_empty, shared_version ]

# Make sure that natives.cc has been completely written before we
# start to compile it.
nenv.Depends([static_natives, shared_natives], natives_cc)

shlib = env.SharedLibrary('v8', source + shared + jsre.shared)
lib = env.StaticLibrary('v8', source + static + jsre.static)
lib_light = env.StaticLibrary('v8light', source + static_light + jsre.static)

extensions = share.extension_list

# Check if we need compile the snapshot maker and to build a
# snapshot that can be included in the final VM executable.
snapshot = 'snapshot-empty.cc'
program_lib = lib
if env['snapshot'] == 'yes':
  # Create a rule to compile the snapshot maker.
  mksnapshot = nenv.Program('mksnapshot', ['mksnapshot.cc', snapshot, lib, extensions])
  
  args = env['snapshot_args']
  if 'ENABLE_LOGGING_AND_PROFILING' in env['CPPDEFINES']:
    args = args + " --logfile " + build_dir + "v8.log"
  snapshot_builder = Builder(action = '$SOURCE %s $TARGET' % args)
  nenv.Append(BUILDERS = {'Snapshot' : snapshot_builder})
  snapshot = nenv.Snapshot('snapshot.cc', mksnapshot)
  nenv.Depends(snapshot, mksnapshot)
  env.Append(CPPPATH='.')
  program_lib = lib_light
  env['CPPDEFINES'].append('USE_SNAPSHOT')

# Create a rule to compile the VM executable program. The snapshot
# may be empty.
program = env.Program('v8', ['shell.cc', 'main.cc', snapshot, program_lib, extensions])

if share.all_mode: prefix = variant + '-'
else: prefix = ''

# Create short aliases for building this variant
Alias(prefix + 'build', [program, lib])
Alias(prefix + 'program', program)
Alias(prefix + 'lib', lib)
Alias(prefix + 'shlib', shlib)


#####################################################
#
# Preliminary test support.
#
directory = join(dirname(File('main.cc').rfile().abspath), '..')
sys.path.append(join(directory, 'tools'))
import testing, testconfig

def TestSelected(file):
    if not share.test: return True
    base = basename(file)
    if share.test == base: return True
    if '.' in base: return share.test == base[:base.index('.')]
    else: return False


def CommonFlags(env):
    flags = []
    if env['variant'] == 'debug':
        flags.append('--enable-slow-asserts --debug-code --verify-heap')
    return flags

# Traverse the tests/ directory and execute all .js files. Compare the
# output (and errors) with the golden files.
# If gcstress is set to one when invoke scons, run all tests with -gc_global
# and -gc_greedy one, this may take very very long time.
# We disable stack traces, because they contain addresses, and so they are
# different every time.  We can't match them with an expected output.
flags = [ program, '-standardize-messages', '--notrace-exception' ]
flags += CommonFlags(env)
if env['check_args'] != '': flags.append(env['check_args'])
if env['gc'] == 1:
  flags.append('-gc-global')
if env['greedy'] == 1:
  flags.append('-gc-greedy')
testers = [ flags ]


def ScheduleCheckTests(env):
    config = testconfig.read_configuration(
        join(directory, 'tests', 'status.txt'),
        abspath(join(directory, 'tests'))
    )
    rules = config.get_rules(GetConfigEnv(env))
    test_spec = testconfig.TestSpecification(rules, lambda x: testconfig.SLOW in x)
    env['test_spec'] = test_spec

    # Get the list of tests from SOURCE-test and create test cases.
    tests = [s.replace('<os>', os_id).replace('<arch>', arch)
             for s in env.Split(File('SOURCE-test').get_contents())]
    for test in tests:
        if TestSelected(test):
            test_spec.register_test(test, None, "cc")

    # Add JS unit tests. Treat all tests in messages/ as negative tests.
    test_directories = [ ('core', False), ('messages', True) ];
    for (test_dir, is_negative) in test_directories:
        for root, directories, files in os.walk(join(directory, 'tests', test_dir)):
            scripts = [abspath(join(root, f)) for f in files if f.endswith('.js')]
            for script in scripts:
                if TestSelected(script):
                    for tester in testers:
                        test_spec.register_test(script, (tester, is_negative), "core")

    # Add mjsunit tests
    mjsunit_script = join(directory, 'tests', 'mjsunit.js')
    mjsunit_dirs = [ 'mjsunit' ]
    for test_dir in mjsunit_dirs:
        for root, directories, files in os.walk(join(directory, 'tests', test_dir)):
            scripts = [abspath(join(root, f)) for f in files if f.endswith('.js') and not f.startswith('x-')]
            for script in scripts:
                if TestSelected(script):
                    for tester in testers:
                        test_spec.register_test(script, tester, "mjsunit")

    for test in test_spec.cases("cc"):
        flags = CommonFlags(env)
        if test.path == 'test-serialize.cc':
          flags.append('--serialization-file ' + build_dir + 'serdes')
        testing.AddTests(env, test, flags, lib + [snapshot])
    for test in test_spec.cases("core"):
        (tester, is_negative) = test.data
        testing.AddScript(env, tester, test, is_negative)
    for test in test_spec.cases("mjsunit"):
        tester = test.data
        testing.AddMiniJSUnitTest(env, tester, test, mjsunit_script)


mozilla_test_dirs = """
  ecma
  ecma_2
  ecma_3
  js1_1
  js1_2
  js1_3
  js1_4
  js1_5
""".split()

# TODO(kasperl): Consider moving these tests to third_party/?
mozilla_path = abspath(join(directory, '..', 'data', 'mozilla_js_tests'))

framework_ignored = """
  browser.js
  shell.js
  jsref.js
  template.js
""".split()


def ComputeEffectiveStatus(status):
    if status == testing.SLOW: return testing.SKIP
    if status == testing.FAIL_OK: return testing.FAIL
    return status


def DumpStatistics(tests, map):
    print '%(n)4d Mozilla tests scheduled to be run.' % { 'n': len(tests) }
    print ' * %(n)4d tests will be skipped.' % { 'n': len(map[testing.SKIP]) + len(map[testing.SLOW]) }
    print ' * %(n)4d tests expected to be flaky, but not crash.' % { 'n': len(map[testing.FLAKY]) }
    print ' * %(n)4d tests expected to pass.' % { 'n': len(map[testing.PASS]) }
    print ' * %(n)4d tests expected to fail due to incompatibility with V8/KJS.' % { 'n' : len(map[testing.FAIL_OK]) }
    failures = map[testing.FAIL]
    print ' * %(n)4d tests expected to fail, but should be fixed:' % { 'n': len(failures) }
    if (len(failures) > 0):
        print
        failures.sort()
        for script in failures:
            print '        ' + testing.MozillaPrintName(script)
        print
    print '---------------------'    


def AddMozillaTests(test_spec):
    for test_dir in mozilla_test_dirs:
        root = join(mozilla_path, test_dir)
        for root, directories, files in os.walk(root):
            for file in files:
                name = str(file)
                if name.endswith('.js') and (not name in framework_ignored):
                    test = abspath(join(root, file))
                    test_spec.register_test(test)


esctf_path = abspath(join(directory, '..', 'data', 'esctf'))
def AddEsctfTests(test_spec):
    for root, directories, files in os.walk(esctf_path):
        for file in files:
            name = str(file)
            if name.endswith('.js'):
                test = abspath(join(root, file))
                test_spec.register_test(test)


def GetConfigEnv(env):
    result = [ ]
    result.append(env['variant'].upper())
    result.append(env.os.upper())
    result.append(env.arch.upper())
    if env['fasttest'] == 'yes':
        result.append('FAST')
    return result


esctf_framework = join(directory, 'tests', 'esctf', 'framework.js')
def ScheduleEsctfTests(env):
    config = testconfig.read_configuration(
        abspath(join(directory, 'tests', 'esctf', 'status.txt')),
        esctf_path
    )
    rules = config.get_rules(GetConfigEnv(env))
    test_spec = testconfig.TestSpecification(rules)
    env['test_spec'] = test_spec
    AddEsctfTests(test_spec)
    for test in test_spec.cases():
        runner = [ program ] + CommonFlags(env)
        runner.append(test.path)
        testing.AddEsctfTest(env, runner, test, esctf_framework)


def ScheduleMozillaTests(env):
    config = testconfig.read_configuration(
        join(directory, 'tests', 'mozilla', 'status.txt'),
        mozilla_path
    )
    rules = config.get_rules(GetConfigEnv(env))
    test_spec = testconfig.TestSpecification(rules, lambda x: testconfig.SLOW in x)
    env['test_spec'] = test_spec
    AddMozillaTests(test_spec)
    for test in test_spec.cases():
        shell_scripts = [ ]
        current = abspath(os.path.dirname(test.path))
        keep_going = True
        while keep_going:
            shell_script = join(current, 'shell.js')
            if os.path.exists(shell_script):
                shell_scripts.insert(0, shell_script)
            keep_going = not (abspath(current) == mozilla_path)
            current = abspath(join(current, '..'))
        runner = [ program ] + CommonFlags(env) + shell_scripts
        testing.AddMozillaTest(env, runner, test)
    # Dump test statistics after scheduling the tests.
    test_spec.dump_statistics()


SPECIAL_ACTIONS = ['GREEDY', 'GLOBAL', 'LEAKCHECK', 'NATIVES']


special_path = join(directory, 'tests')
def ScheduleSpecialTests(env):
    config = testconfig.read_configuration(
        join(special_path, 'special', 'status.txt'),
        special_path
    )
    rules = config.get_rules(GetConfigEnv(env))
    test_spec = testconfig.TestSpecification(rules)
    for case in rules.cases():
        outcomes = rules.get_outcomes(case)
        command = '%(VM)s'
        for action in SPECIAL_ACTIONS:
            if action in outcomes:
                name = action + '_COMMAND'
                if not name in env.Dictionary():
                    raise "No " + action + " command has been defined."
                template = env[name]
                command = template.replace('%COMMAND', command)
        test_spec.register_test(case, command)
    for test in test_spec.cases():
        testing.AddSpecialTest(env, program, test, test.data)


def CheckBuildScripts(test_case):
    source = Split(File(join('src', 'SOURCE')).get_contents())
    source_js = File(join('src', 'SOURCE-js')).get_contents().split("\n")
    source_js = [ name for name in source_js if name.endswith('.js') and len(name.split()) == 1 ]
    build = File('BUILD').get_contents()
    vcproj = File(join('vcproj', 'libv8.vcproj')).get_contents()
    for file in source + source_js:
        pattern_src = file.replace('.', '\.')
        pattern_src = re.sub('<\w+>', '.*', pattern_src)
        pattern = re.compile(pattern_src)
        if not pattern.search(build):
            test_case.fail("Source file " + file + " not listed in BUILD")
            return
        if not pattern.search(vcproj):
            test_case.fail("Source file " + file + " not listed in vcproj/libv8.vcproj")


if share.test == 'buildfiles':
    testing.AddCustomTest(env, "Build script check", CheckBuildScripts)



ScheduleCheckTests(env)
if share.test == 'mozilla':
    ScheduleMozillaTests(env)
if share.test == 'esctf':
    ScheduleEsctfTests(env)
if share.test == 'special':
    ScheduleSpecialTests(env)


check = Alias(prefix + 'check', testing.RunTests(env))
AlwaysBuild(check)
