{
  "comments": [
    {
      "key": {
        "uuid": "2fa77c7a_a17826a3",
        "filename": "chrome/browser/metrics/out_of_memory_reporter.cc",
        "patchSetId": 10
      },
      "lineNbr": 56,
      "author": {
        "id": 1125359
      },
      "writtenOn": "2017-11-02T01:50:01Z",
      "side": 1,
      "message": "Do you have to check for IsMainFrame() navigation here? to record only navigations in main frame",
      "revId": "cf1edd1be9c58ece903752131e8c624331745aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f47bea0e_16869ebe",
        "filename": "chrome/browser/metrics/out_of_memory_reporter.cc",
        "patchSetId": 10
      },
      "lineNbr": 70,
      "author": {
        "id": 1125359
      },
      "writtenOn": "2017-11-02T01:50:01Z",
      "side": 1,
      "message": "Do you know if we get this signal on Android? I guess not.\nIf we do not get this signal, then maybe we should ifdef !android this code?\nIf we do get this signal then add a comment in function below that we do not check for TERMINATION_STATUS_OOM because it is recorded above.",
      "revId": "cf1edd1be9c58ece903752131e8c624331745aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1aca0b23_9df4e996",
        "filename": "chrome/browser/metrics/out_of_memory_reporter.cc",
        "patchSetId": 10
      },
      "lineNbr": 86,
      "author": {
        "id": 1125359
      },
      "writtenOn": "2017-11-02T01:50:01Z",
      "side": 1,
      "message": "Are we sure that this method gets called after RenderProcessGone() and before the reporter gets destroyed? What if this behavior changes?",
      "range": {
        "startLine": 86,
        "startChar": 33,
        "endLine": 86,
        "endChar": 59
      },
      "revId": "cf1edd1be9c58ece903752131e8c624331745aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57c8c560_4ccb5224",
        "filename": "chrome/browser/metrics/out_of_memory_reporter.h",
        "patchSetId": 10
      },
      "lineNbr": 64,
      "author": {
        "id": 1125359
      },
      "writtenOn": "2017-11-02T01:50:01Z",
      "side": 1,
      "message": "IIUC, right now an observer has to register to all the oom detectors to listen to oom signals. I am not sure how a client would observer since the handles to the reporter are owned by the tab_helper.\nCan we make a global list of observers instead of having a list per each WebContents.\nMaybe the structure could be a singleton OOMReporter and multiple WebContentObserver(s).\n\nclass SingletonOOMReporter {\n  Add/Remove Observer;\n\n  class OOMDetector :: WebContentObserver, WebContentsUserData {\n    OnOomDetected() {\n      reporter_-\u003ereportOOM(url, ukm_id_);\n    }\n    ukm_id_\n    renderer_id_;\n  }\n  base::ObserverList\u003cObserver\u003e\n};\n\nIdeally we should have the SingletonOOMReporter be the CrashDumpManager::Observer. But, it looks like we need the rph id to source_id mapping. For this we need to insert and remove entries into the map at each navigation. So, I am not sure which is better here.",
      "revId": "cf1edd1be9c58ece903752131e8c624331745aeb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}