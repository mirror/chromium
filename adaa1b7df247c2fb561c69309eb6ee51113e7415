{
  "comments": [
    {
      "key": {
        "uuid": "50c77977_0f2f0fa8",
        "filename": "third_party/WebKit/Source/core/editing/markers/DocumentMarkerController.cpp",
        "patchSetId": 3
      },
      "lineNbr": 858,
      "author": {
        "id": 1116193
      },
      "writtenOn": "2017-08-10T02:48:10Z",
      "side": 1,
      "message": "Hmm.. Do you need to listen to other events as well? How does this work on contenteditable?",
      "range": {
        "startLine": 858,
        "startChar": 14,
        "endLine": 858,
        "endChar": 26
      },
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1cce878e_6f4f92ec",
        "filename": "third_party/WebKit/Source/core/editing/markers/DocumentMarkerController.cpp",
        "patchSetId": 3
      },
      "lineNbr": 858,
      "author": {
        "id": 1229332
      },
      "writtenOn": "2017-08-10T03:56:10Z",
      "side": 1,
      "message": "The way this works is that every text node that gets a SuggestionMarker attached (and text nodes are the *only* nodes that can get markers attached) has its own SuggestionMarkerListImpl. Any time a text node is changed, all of the SynchronousMutationObservers (of which DocumentMarkerController is one) attached to the Document get their DidUpdateCharacterData() method called.\n\nAny sort of editable text, including in a contenteditable element, is stored in a text node.",
      "parentUuid": "50c77977_0f2f0fa8",
      "range": {
        "startLine": 858,
        "startChar": 14,
        "endLine": 858,
        "endChar": 26
      },
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "080ebfbd_10ce8396",
        "filename": "third_party/WebKit/Source/core/editing/markers/DocumentMarkerController.h",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-08-08T20:40:09Z",
      "side": 1,
      "message": "It seems better to store it as a static member of SuggestionMarkerReplacementScope so that DMC is not affected too much by these low level details.",
      "range": {
        "startLine": 173,
        "startChar": 7,
        "endLine": 173,
        "endChar": 43
      },
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10a0a05b_8b8b1d3d",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1229332
      },
      "writtenOn": "2017-08-09T16:59:39Z",
      "side": 1,
      "message": "This seems like it probably doesn\u0027t handle Unicode characters that are represented in UTF-16 as surrogate pairs, does it (since I think a UChar represents a single UTF-16 code point)? How can I handle this case properly (or is it not important)?",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73966c0f_250ee34f",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1116193
      },
      "writtenOn": "2017-08-09T17:22:56Z",
      "side": 1,
      "message": "I think it depends on how Android implements it. In case Android cares about i18n in this scenario, you can use UnicodeIcu.h\u0027s IsAlphanumeric and ICU\u0027s U16_GET() to implement it.",
      "parentUuid": "10a0a05b_8b8b1d3d",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "754a2ae8_fe826b40",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1229332
      },
      "writtenOn": "2017-08-09T17:45:35Z",
      "side": 1,
      "message": "Android uses Character.codePointAt():\nhttps://android.googlesource.com/platform/frameworks/base/+/4cdeeadd42bc11f6f5f60f5301c09025cabfc65f/core/java/android/widget/SpellChecker.java#762\n\nMy reading of the code together with the Character.codePointAt() documentation:\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#codePointAt(char[],%20int)\n\nis that it\u0027s implemented correctly for text appended to the marker (where we look up the leading surrogate) but not for text prepended to the marker (where we look up the trailing surrogate, which I don\u0027t think Character.codePointAt() supports).\n\nIt looks like if we use U16_GET():\nhttps://cs.chromium.org/chromium/src/third_party/icu/source/common/unicode/utf16.h?l\u003d200\n\nit will work properly for either case (since it can apparently start on either surrogate). I think I\u0027d rather implement the Unicode handling correctly than try to match the potential Android bug exactly.",
      "parentUuid": "73966c0f_250ee34f",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "452980da_fac4c62f",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1116193
      },
      "writtenOn": "2017-08-09T18:09:42Z",
      "side": 1,
      "message": "Actually Android does it correctly... It calls codePointBefore() for the prepended text, if that\u0027s what you meant. For the text boundary change check before the marked text, you can use U16_PREV directly or wrap it inside TextBoundaries / WordBreakIterator level.",
      "parentUuid": "754a2ae8_fe826b40",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "317c97e8_2f1ba8f7",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1229332
      },
      "writtenOn": "2017-08-09T18:12:17Z",
      "side": 1,
      "message": "Oh cool, I guess that\u0027s definitely the behavior we want to use then.",
      "parentUuid": "452980da_fac4c62f",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c72b0e7a_b74c2542",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.h",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-08-08T20:40:09Z",
      "side": 1,
      "message": "It\u0027s better to pass the |data()| string directly, so that DML interface is still independent from DOM.",
      "range": {
        "startLine": 40,
        "startChar": 20,
        "endLine": 40,
        "endChar": 45
      },
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}