{
  "comments": [
    {
      "key": {
        "uuid": "080ebfbd_10ce8396",
        "filename": "third_party/WebKit/Source/core/editing/markers/DocumentMarkerController.h",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-08-08T20:40:09Z",
      "side": 1,
      "message": "It seems better to store it as a static member of SuggestionMarkerReplacementScope so that DMC is not affected too much by these low level details.",
      "range": {
        "startLine": 173,
        "startChar": 7,
        "endLine": 173,
        "endChar": 43
      },
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10a0a05b_8b8b1d3d",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1229332
      },
      "writtenOn": "2017-08-09T16:59:39Z",
      "side": 1,
      "message": "This seems like it probably doesn\u0027t handle Unicode characters that are represented in UTF-16 as surrogate pairs, does it (since I think a UChar represents a single UTF-16 code point)? How can I handle this case properly (or is it not important)?",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73966c0f_250ee34f",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1116193
      },
      "writtenOn": "2017-08-09T17:22:56Z",
      "side": 1,
      "message": "I think it depends on how Android implements it. In case Android cares about i18n in this scenario, you can use UnicodeIcu.h\u0027s IsAlphanumeric and ICU\u0027s U16_GET() to implement it.",
      "parentUuid": "10a0a05b_8b8b1d3d",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "754a2ae8_fe826b40",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1229332
      },
      "writtenOn": "2017-08-09T17:45:35Z",
      "side": 1,
      "message": "Android uses Character.codePointAt():\nhttps://android.googlesource.com/platform/frameworks/base/+/4cdeeadd42bc11f6f5f60f5301c09025cabfc65f/core/java/android/widget/SpellChecker.java#762\n\nMy reading of the code together with the Character.codePointAt() documentation:\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#codePointAt(char[],%20int)\n\nis that it\u0027s implemented correctly for text appended to the marker (where we look up the leading surrogate) but not for text prepended to the marker (where we look up the trailing surrogate, which I don\u0027t think Character.codePointAt() supports).\n\nIt looks like if we use U16_GET():\nhttps://cs.chromium.org/chromium/src/third_party/icu/source/common/unicode/utf16.h?l\u003d200\n\nit will work properly for either case (since it can apparently start on either surrogate). I think I\u0027d rather implement the Unicode handling correctly than try to match the potential Android bug exactly.",
      "parentUuid": "73966c0f_250ee34f",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "452980da_fac4c62f",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.cpp",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1116193
      },
      "writtenOn": "2017-08-09T18:09:42Z",
      "side": 1,
      "message": "Actually Android does it correctly... It calls codePointBefore() for the prepended text, if that\u0027s what you meant. For the text boundary change check before the marked text, you can use U16_PREV directly or wrap it inside TextBoundaries / WordBreakIterator level.",
      "parentUuid": "754a2ae8_fe826b40",
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c72b0e7a_b74c2542",
        "filename": "third_party/WebKit/Source/core/editing/markers/SuggestionMarkerListImpl.h",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1144165
      },
      "writtenOn": "2017-08-08T20:40:09Z",
      "side": 1,
      "message": "It\u0027s better to pass the |data()| string directly, so that DML interface is still independent from DOM.",
      "range": {
        "startLine": 40,
        "startChar": 20,
        "endLine": 40,
        "endChar": 45
      },
      "revId": "adaa1b7df247c2fb561c69309eb6ee51113e7415",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}