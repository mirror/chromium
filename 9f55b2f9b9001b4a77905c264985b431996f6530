{
  "comments": [
    {
      "key": {
        "uuid": "f0163d3c_ef6ae1ed",
        "filename": "content/browser/renderer_host/input/input_router_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 251,
      "author": {
        "id": 1115852
      },
      "writtenOn": "2017-07-19T01:56:48Z",
      "side": 1,
      "message": "This logic block is duplicated multiple times in this file.  Can you move all/most of it into WidgetInputHandler instead (always providing the handler as a callback which might be synchronously called or not based on event traits -- or even better, always called asynchronously if that doesn\u0027t matter)",
      "revId": "9f55b2f9b9001b4a77905c264985b431996f6530",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbecf7c1_5ce9d3c1",
        "filename": "content/browser/renderer_host/input/input_router_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 251,
      "author": {
        "id": 1123071
      },
      "writtenOn": "2017-07-19T13:18:35Z",
      "side": 1,
      "message": "It actually does matter quite a bit.  Since the WidgetInputHandler implementation resides on the renderer side this isn\u0027t synchronous from the browser\u0027s point of view (and making the mojo message a sync message isn\u0027t a smart approach). The WidgetInputHandler that appears in the browser process is all generated code and is a proxy object that turns calls on its virtual interface to calls on the remote interface.\n\nFor things like GestureScrollUpdates that are sent based off of the touch move acks coming back the entire latency is affected. ie. if the touch-move acks that aren\u0027t cancelable are round-tripped to the renderer the scroll update isn\u0027t fired right away and can miss frames. We\u0027ve had regressions in the past that have accidentally caused this to happen and you see it quite prominently in the UMA histograms.",
      "parentUuid": "f0163d3c_ef6ae1ed",
      "revId": "9f55b2f9b9001b4a77905c264985b431996f6530",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "91c2cbd8_ab01e249",
        "filename": "content/browser/renderer_host/input/input_router_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 251,
      "author": {
        "id": 1115852
      },
      "writtenOn": "2017-07-19T18:33:17Z",
      "side": 1,
      "message": "OK.  Can you still find a way avoid the code duplication here?  For example, you can pass around a MouseEventHandled callback and call it synchronously in the nonblocking case if needed.",
      "parentUuid": "dbecf7c1_5ce9d3c1",
      "revId": "9f55b2f9b9001b4a77905c264985b431996f6530",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f32d7bd_a5d157af",
        "filename": "content/browser/renderer_host/input/input_router_impl.h",
        "patchSetId": 2
      },
      "lineNbr": 77,
      "author": {
        "id": 1115852
      },
      "writtenOn": "2017-07-18T01:54:27Z",
      "side": 1,
      "message": "I realize this is copy-paste but may as well fix style on this: frame_tree_node_id",
      "revId": "9f55b2f9b9001b4a77905c264985b431996f6530",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}