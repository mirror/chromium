{
  "comments": [
    {
      "key": {
        "uuid": "488324be_8c91b99f",
        "filename": "android_webview/browser/aw_ssl_host_state_delegate.cc",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-12-28T21:23:06Z",
      "side": 1,
      "message": "Why change the type from |const_iterator| to |const const_iterator\u0026| ?\nfind() returns a value not a reference, so this doesn\u0027t improve things AFAICT.",
      "range": {
        "startLine": 27,
        "startChar": 12,
        "endLine": 27,
        "endChar": 13
      },
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6a7239a_5f2f90c0",
        "filename": "content/public/network/ignore_errors_cert_verifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 112,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-12-28T21:23:06Z",
      "side": 1,
      "message": "optional: more readable if use operator\u003e",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "989c5f1d_3dfb47d9",
        "filename": "content/public/network/ignore_errors_cert_verifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 112,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-12-28T21:38:41Z",
      "side": 1,
      "message": "I\u0027ve opted not to do this. The original code is simply a stl set_intersection with a short-circuit on the first result.",
      "parentUuid": "d6a7239a_5f2f90c0",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f63d638_90451dff",
        "filename": "net/base/hash_value.cc",
        "patchSetId": 4
      },
      "lineNbr": 118,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-12-28T21:23:06Z",
      "side": 1,
      "message": "The tag check (both here and in operator\u003d\u003d) seem like the sort of thing that someone will fail to update if/when a new tag is ever added.\n\nWhy not just use a generic implementation that compares the hashes as data, irrespective of tag?\n\nreturn std::lexicographical_compare(\n    lhs.data(), lhs.data() + lhs.size(),\n    rhs.data(), rhs.data() + rhs.size());",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b74a2dfc_2f56b0b1",
        "filename": "net/base/hash_value.cc",
        "patchSetId": 4
      },
      "lineNbr": 118,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-12-28T21:38:41Z",
      "side": 1,
      "message": "Did you mean if a new member is added? If so, that objection seems fundamental to any operator overloading - an std::tie() would be just as at-risk.\n\nCertainly, tags of the same length but different types should not be equivalent. This also is a prevalent pattern through Chrome code, so perhaps I\u0027m not understanding the concern?",
      "parentUuid": "8f63d638_90451dff",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fa8adef_ef11894d",
        "filename": "net/base/hash_value.cc",
        "patchSetId": 4
      },
      "lineNbr": 118,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-12-28T21:46:48Z",
      "side": 1,
      "message": "Oh! If you meant something like HASH_VALUE_SHA384, then the compiler will yell about those cases being unhandled in the switch - that\u0027s why I was explicitly removing the default case, so that it would do so :)",
      "parentUuid": "b74a2dfc_2f56b0b1",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07a996ac_d10ad6e8",
        "filename": "net/base/hash_value.cc",
        "patchSetId": 4
      },
      "lineNbr": 118,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-12-28T22:04:45Z",
      "side": 1,
      "message": "tl;dr the concern I have is operator\u003c failing to be anti-symmetric when comparing elements with differing tags (future-proofing concern, as only 1 tag type currently supported)\n\nConsider calling std::sort() on HashValues, where you had a mix of SHA256 and SHA1 (assuming we had such a tag).\n\nThis would actually be undefined behavior and could crash, as operator\u003c does not define a strict weak ordering.\n\nFor operator\u003d\u003d it is fine to require tag equality in addition to the hash data equality.\n\nHowever for operator\u003c it is definitely dangerous/wrong for it to not define a strict weak ordering over the element type (HashValue). Lots of things in the STL depend on operator\u003c inducing a streak weak ordering -- maps, sets, binary searching and sorting for instance.",
      "parentUuid": "b74a2dfc_2f56b0b1",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57a26611_796eba10",
        "filename": "net/base/hash_value.cc",
        "patchSetId": 4
      },
      "lineNbr": 118,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-12-28T22:09:52Z",
      "side": 1,
      "message": "The compiler will complain about the switch statements, yes.\n\nHowever it won\u0027t complain about the early return on mismatching tag types (the line which concerns me).",
      "parentUuid": "07a996ac_d10ad6e8",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbcf85de_e317b57a",
        "filename": "net/base/hash_value.h",
        "patchSetId": 4
      },
      "lineNbr": 30,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-12-28T21:23:06Z",
      "side": 1,
      "message": "Consider extracting this to a helper function or member function.\nFor instance:\n\nint Compare(const XXX\u0026a, const XXX\u0026b) {\n  return memcmp(...);\n}\n\n(... each and every instance of memcmp I see when reading code scares me and makes me read it carefully)",
      "range": {
        "startLine": 30,
        "startChar": 9,
        "endLine": 30,
        "endChar": 53
      },
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47407d8f_dc027ae4",
        "filename": "net/base/hash_value.h",
        "patchSetId": 4
      },
      "lineNbr": 30,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-12-28T21:38:41Z",
      "side": 1,
      "message": "Opted not to do this. While I similarly share your concern regarding memcmp() functions, I think this meets the bar of triviality that it should be plainly obvious as safe, but I\u0027ll keep it in mind for future changes.",
      "parentUuid": "dbcf85de_e317b57a",
      "range": {
        "startLine": 30,
        "startChar": 9,
        "endLine": 30,
        "endChar": 53
      },
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d97ff0ee_df6430de",
        "filename": "net/base/hash_value.h",
        "patchSetId": 4
      },
      "lineNbr": 84,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2017-12-28T21:23:06Z",
      "side": 1,
      "message": "Why not make these member functions?",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e9df767_3128b755",
        "filename": "net/base/hash_value.h",
        "patchSetId": 4
      },
      "lineNbr": 84,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-12-28T21:38:41Z",
      "side": 1,
      "message": "https://google.github.io/styleguide/cppguide.html#Operator_Overloading\n\n\"Prefer to define non-modifying binary operators as non-member functions. If a binary operator is defined as a class member, implicit conversions will apply to the right-hand argument, but not the left-hand one. It will confuse your users if a \u003c b compiles but b \u003c a doesn\u0027t.\"",
      "parentUuid": "d97ff0ee_df6430de",
      "revId": "a3b66779b7a6ab1ea838e79e21048ced669be6b4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}