{
  "comments": [
    {
      "key": {
        "uuid": "d5af016f_cb959eae",
        "filename": "chrome/browser/extensions/process_management_browsertest.cc",
        "patchSetId": 8
      },
      "lineNbr": 262,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-16T19:54:54Z",
      "side": 1,
      "message": "This is kind of an interesting place to put this test - it\u0027s not really extension-related, is it?  Is there somewhere else that would be more appropriate?",
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32c5faee_b526e964",
        "filename": "chrome/browser/extensions/process_management_browsertest.cc",
        "patchSetId": 8
      },
      "lineNbr": 262,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-11-16T20:48:38Z",
      "side": 1,
      "message": "Yes, maybe this is not quite correct.  I put it here, because a bunch of other things are verified in this test suite when max process count is limited.\n\nFWIW, I\u0027ve moved this test to //content, to RenderProcessHostTest.ProcessReuseVsBrowsingInstance and verified that it still fails before the CL and passes after the CL.  AFAICT there is no other place in //content that tests what happens after reaching the process limit - hopefully this means that the new place for the test is the right place.\n\nDone?",
      "parentUuid": "d5af016f_cb959eae",
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fe913361_245f78a6",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-11-16T16:18:20Z",
      "side": 1,
      "message": "Devlin: Daniel asked in his previous comment to point out to you the changes in this file.  In particular, he said that \"it seems a bit unfortunate to have to extract the extension for a RenderFrame based on the \u0027effective document URL\u0027\".\n\nFWIW, the look-up via GetEffectiveDocumentURL is needed for handling about:blank URLs.  See ExtensionFunctionalTest.FindingUnrelatedExtensionFramesFromAboutBlank (*) test for details about the scenario solved by using GetEffectiveDocumentURL.\n\n\nBTW, I note that \"effective URL\" is a bit of an overloaded term:\n\n- ScriptContext::GetEffectiveDocumentURL just goes up over local parents/openers until it reaches a frame that is not about:blank.  There is nothing extension-specific here (maybe this kind of functionality should instead be replaced by a new blink::WebSecurityOrigin::GetURL (or something like that, fetching the URL from the wrapped blink::SecurityOrigin).\n\n- SiteInstanceImpl::GetEffectiveURL translates hosted app URLs into extension URLs (if the original URL matched one of web extents of the hosted app).\n\n\n(*) https://chromium-review.googlesource.com/c/chromium/src/+/764487/8/chrome/browser/extensions/extension_functional_browsertest.cc#115",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9747a90f_7b69fbcd",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-16T19:54:54Z",
      "side": 1,
      "message": "Yeah, GetEffectiveDocumentURL() is a bit of a shame in general.  We have far too many different \"get the url to use\"-type methods, and it\u0027s confusing which is right (and too often, I think we choose the wrong one ;)).\n\nI\u0027d prefer we avoid adding another use of this here.  What about as an alternative, we add a method\nScriptContext* ScriptContextSet::GetScriptContextByFrame(\n    content::RenderFrame* render_frame)\nand then we use that here:\nconst Extension* GetExtensionFromFrame(content::RenderFrame* render_frame) {\n  ScriptContext* context \u003d\n      ScriptContextSet::GetScriptContextByFrame(render_frame);\n  return context ? context-\u003eeffective_extension() : nullptr;\n}\n\nWDYT?",
      "parentUuid": "fe913361_245f78a6",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f990d42c_36b63ee4",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-11-16T20:48:38Z",
      "side": 1,
      "message": "Done - thanks for the suggestion (I did look at ScriptContextSet but gave up too early).\n\nSome extra notes if you want to revise things further:\n\n- I wasn\u0027t sure if \"MainWorld\" is an important piece of information to include in the name of the new ScriptContextSet::GetContextForFrame method.\n\n- With --isolate-extensions, is it possible at all to get nullptr from 1) the new ScriptContext::GetContextForFrame or 2) the old GetContextByV8Context (except in unit tests).  Do I really need all the null checks I\u0027ve added?",
      "parentUuid": "9747a90f_7b69fbcd",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4171287_4afc7858",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-17T16:31:23Z",
      "side": 1,
      "message": "\u003e I wasn\u0027t sure if \"MainWorld\" is an important piece of information to include in the name of the new ScriptContextSet::GetContextForFrame method.\n\nNow you mention it, probably - let\u0027s do GetContextForFrameMainWorld or similar.\n\n\u003e With --isolate-extensions, is it possible at all to get nullptr from 1) the new ScriptContext::GetContextForFrame or 2) the old GetContextByV8Context (except in unit tests).  Do I really need all the null checks I\u0027ve added?\n\nShort answer: yes. During context invalidation (i.e., sometime after WillReleaseScriptContext() is called, JS can still be executing (because... I don\u0027t know, but it\u0027s always been that way ;)).  This can lead to unfortunate instances, and because of this anything that can be triggered from JS needs to account for the possibility that there isn\u0027t an associated ScriptContext (ScriptContext\u0027s lifetime is bound between DidCreateScriptContext and WillReleaseScriptContext).  Since getting a frame is triggered by script, we need these null checks.",
      "parentUuid": "f990d42c_36b63ee4",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0b7cb3e0_9552fb15",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-11-17T17:01:35Z",
      "side": 1,
      "message": "+1 for GetMainWorldContextForFrame, since that\u0027s what we really care about in this case.\n\nAlso, I\u0027d rather not add WebSecurityOrigin::GetURL: the behavior is pretty odd and is definitely extension-specific: the returned URL is *not* the inherited security origin, but the document URL of the browsing context that we think we probably inherited the security origin from.",
      "parentUuid": "c4171287_4afc7858",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46980224_12f604d3",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-11-17T17:25:01Z",
      "side": 1,
      "message": "\u003e +1 for GetMainWorldContextForFrame, since that\u0027s what we really care about in this case.\n\nOk - done.\n\n\u003e Also, I\u0027d rather not add WebSecurityOrigin::GetURL: the behavior is pretty odd and is definitely extension-specific: the returned URL is *not* the inherited security origin, but the document URL of the browsing context that we think we probably inherited the security origin from.\n\nHmmm... this CL avoids using GetEffectiveDocumentURL so the CL is probably in a good shape, but... should GetEffectiveDocumentURL eventually start returning the URL of the inherited security origin?  I assume that this is what we expect from GetEffectiveDocumentURL... :-(  \n\nI am checking in case this is something that might require some extra investigation afterwards (and so might benefit from opening a bug to track the need to do this work).  In particular - are there any troublesome scenarios that might be broken by the current, not-quite-matching-the-web behavior of GetEffectiveDocumentURL?",
      "parentUuid": "0b7cb3e0_9552fb15",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10a84321_07e1e79f",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-11-17T17:51:33Z",
      "side": 1,
      "message": "I would like to move away from GetEffectiveDocumentURL and other similar methods in favor of relying on some web platform concept like SecurityOrigin.  I don\u0027t know the subtleties of these well enough to know all the times that might vary from the current behavior, though.  Do we know in which circumstances GetEffectiveDocumentURL() returns somethign significantly different?\n\nRegardless, I don\u0027t think this blocks this CL, and is probably a better discussion for a meeting/email/bug/etc :)",
      "parentUuid": "46980224_12f604d3",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0e55be1_b1db6654",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-11-17T18:14:11Z",
      "side": 1,
      "message": "Ack.  Maybe we can hijack https://crbug.com/55084 for discussing the future of GetEffectiveDocumentURL.",
      "parentUuid": "10a84321_07e1e79f",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4c02d9a_6ff8dcd8",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-11-17T23:49:39Z",
      "side": 1,
      "message": "(Just background info)\n\nOne reason GetEffectiveDocumentURL doesn\u0027t merely return an origin is due to content script matching. I don\u0027t know if there are others.",
      "parentUuid": "f0e55be1_b1db6654",
      "range": {
        "startLine": 102,
        "startChar": 23,
        "endLine": 102,
        "endChar": 61
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62ea92ad_e000c9da",
        "filename": "extensions/renderer/extension_frame_helper.cc",
        "patchSetId": 8
      },
      "lineNbr": 178,
      "author": {
        "id": 1130134
      },
      "writtenOn": "2017-11-16T16:18:20Z",
      "side": 1,
      "message": "Please also note https://crrev.com/c/766469.  It is a bit stale, but shows that in a follow-up we plan to gather some UMA stats that hopefully will support restricting conditions that enable piercing of a browsing instance.  In particular, hopefully the piercing is only needed if the target of the lookup is a EXTENSION_BACKGROUND_PAGE or a BACKGROUND_CONTENTS.",
      "range": {
        "startLine": 178,
        "startChar": 6,
        "endLine": 178,
        "endChar": 15
      },
      "revId": "2e5ef7ea96d074db80194e074aaae7624b123165",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}