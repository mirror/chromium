{
  "comments": [
    {
      "key": {
        "uuid": "d11df6c9_5c9360a5",
        "filename": "content/network/network_service_impl.cc",
        "patchSetId": 28
      },
      "lineNbr": 218,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-12-18T20:21:35Z",
      "side": 1,
      "message": "When the client of a UDP socket no longer needs it (by disconnecting), we also need to remove the corresponding instance from |udp_sockets_|.",
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb863492_cb34b544",
        "filename": "services/network/public/interfaces/udp_socket.mojom",
        "patchSetId": 28
      },
      "lineNbr": 11,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-12-18T20:21:35Z",
      "side": 1,
      "message": "nit: It may make sense to avoid referring to a specific implementation in the interface definition.",
      "range": {
        "startLine": 11,
        "startChar": 43,
        "endLine": 11,
        "endChar": 68
      },
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a24d4d2_cc8958ad",
        "filename": "services/network/public/interfaces/udp_socket.mojom",
        "patchSetId": 28
      },
      "lineNbr": 32,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-12-18T17:05:16Z",
      "side": 1,
      "message": "Do we need Open and Connect methods?  My general feeling is that sockets should not be re-connectable or re-openable, and the simplest way to do that and make sure not to break consumers is to make an API where that\u0027s impossible.\n\nSo instead we could have:\n\nUDPSocketFactory {\n  // Or could make this return a UDPSocket as well as the result.  Just destroy the receiver to cancel.\n  Open(UDPSocket\u0026, UDPSocketReceiver, net.interfaces.AddressFamily) \u003d\u003e (int32 result);\n\n  // We don\u0027t need the family, since we can grab it from IPEndPoint.\n  OpenAndConnect(UDPSocket\u0026, UDPSocketReceiver, net.interfaces.IPEndPoint) \u003d\u003e (...)\n}",
      "range": {
        "startLine": 32,
        "startChar": 21,
        "endLine": 32,
        "endChar": 31
      },
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59484fc0_aa7293ca",
        "filename": "services/network/public/interfaces/udp_socket.mojom",
        "patchSetId": 28
      },
      "lineNbr": 70,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-12-18T16:45:53Z",
      "side": 1,
      "message": "Can we instead just have a hard-coded limit, which we guarantee that we\u0027ll allow, and get rid of this method?  Returning ERR_INSUFFICIENT_RESOURCES for some indeterminate limit seems not great.  If we want to let consumers set a lower limit (For debugging/error checking), we can just make it passed in on creation.",
      "range": {
        "startLine": 70,
        "startChar": 31,
        "endLine": 70,
        "endChar": 32
      },
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45c1469d_04c92c85",
        "filename": "services/network/public/interfaces/udp_socket.mojom",
        "patchSetId": 28
      },
      "lineNbr": 76,
      "author": {
        "id": 1118144
      },
      "writtenOn": "2017-12-16T00:14:43Z",
      "side": 1,
      "message": "Are you retaining this? I thought we agreed that this wouldn\u0027t be necessary anymore.",
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db3f4e8d_6e9e68b7",
        "filename": "services/network/public/interfaces/udp_socket.mojom",
        "patchSetId": 28
      },
      "lineNbr": 76,
      "author": {
        "id": 1140166
      },
      "writtenOn": "2017-12-16T00:54:13Z",
      "side": 1,
      "message": "Drive by comment:  Some amount of queuing should be supported *if* there is any chance you might use such an interface and care about performance.  \n\nIn my work on QUIC upload performance, I added a batching mechanism somewhat like this to net/socket (not landed yet).   I devised it as a step toward moving UDP writes to a different thread/core.   Even without the threading, I saw big gains just from the queuing/batching.   An important difference between UDP and TCP is that posix writes to UDP are 1:1 with datagrams.   You can do a large write and have the kernel break that up for you into smaller datagrams (unlike TCP which will both fragment and coalesce data into segments).   UDP constrains you to MTU sized datagrams, so batching is the only way to amortize the cost of an expensive boundary.",
      "parentUuid": "45c1469d_04c92c85",
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38b6d298_49ec7a47",
        "filename": "services/network/public/interfaces/udp_socket.mojom",
        "patchSetId": 28
      },
      "lineNbr": 76,
      "author": {
        "id": 1120845
      },
      "writtenOn": "2017-12-18T14:50:43Z",
      "side": 1,
      "message": "Thanks Jana and Buck for the QUIC insight. \nWe still need the pipelining in the mojo API layer. Randy mentioned that the cost of mojo API call is at least a PostTask if in-process and more if it crosses the process boundary. Without pipelining, this will be significantly less usable compared to //net\u0027s C++ net::UDPSocket.\n\nThere is a different type of pipelining that Randy mentioned in https://chromium-review.googlesource.com/c/chromium/src/+/796933/23/services/network/udp_socket_impl.cc#191.\nThat is between //net and the kernel. We talked about it briefly and decided that is out of scope of the CL.",
      "parentUuid": "db3f4e8d_6e9e68b7",
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "925a0fe0_0d37e3d0",
        "filename": "services/network/public/interfaces/udp_socket.mojom",
        "patchSetId": 28
      },
      "lineNbr": 117,
      "author": {
        "id": 1118144
      },
      "writtenOn": "2017-12-16T00:14:43Z",
      "side": 1,
      "message": "ditto",
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2934c00f_424fcbcf",
        "filename": "services/network/udp_socket.h",
        "patchSetId": 28
      },
      "lineNbr": 1,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-12-18T20:21:35Z",
      "side": 1,
      "message": "Curious: Is it possible to view the diff before/after renaming? It is pretty painful to review the entire class again. :)",
      "revId": "17a5ee71f975ebd03efe1a9ce102f03b7df0c301",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}