{
  "comments": [
    {
      "key": {
        "uuid": "35d18624_c3ad7733",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "nit: Might be good to point out it\u0027s a singleton up here.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21f624c1_8399c6c6",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 99,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "API design notes:\n\nI have to wonder if people won\u0027t accidentally make this mistake anyway. \n\n-----------\nI saw you have Java 8 support, so maybe the linter could catch this?\n\n   registerNativeReference(ptr, obj, Foo::bar) // warn unless Foo#bar is static.\n\n-----------\n\nAlternatively, if you used reflection to invoke the \"static native nativeDestroy(long)\" , it would absolve this problem?\n\n  void registerNativeReference(long ptr, Object object, Class\u003cT\u003e destroyer) {\n    Method destroyNative \u003d destroyer.getMethod(\"nativeDestroy\", long.TYPE);\n    if (destroyNative !\u003d static) throw;\n\n    .....\n    // instead of calling Destroyer.onDestroy, call destroyNative.invoke(long)\n  }\n  \n  void registerNativeReference(long ptr, Object object) {\n    registerNativeReference(ptr, object, object.getClass());\n  }\n\n(as a variation, if you use JNI to do this you can avoid boxing the Long pointer if thats a concern).\n\n---------",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f362ca5_012b8c70",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 106,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "nit: Destroyer\u003cT\u003e might look a bit cleaner to the user ?\n\n  BitmapDestroyer implements Destroyer\u003cBitmap\u003e\n  YuvDestroyer implements Destroyer\u003cYuv\u003e\n\netc. Not sure if it will break lambdas. Probably not, it\u0027s still a SAM.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22eb270e_4ac53854",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 124,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "(Curious random question. Why can\u0027t you just mock the regular INSTANCE here by overwriting it with reflection? Is it because there\u0027s no Looper during a test?)",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0f74e3e_8cab33f9",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 131,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "(is this an alternative syntax for {@code referent} ?)",
      "range": {
        "startLine": 131,
        "startChar": 7,
        "endLine": 131,
        "endChar": 17
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09fdcfbe_5f4c2b8d",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 158,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "Why is this needed?  We only use this reference when creating NativePhantomReference(s)",
      "range": {
        "startLine": 158,
        "startChar": 28,
        "endLine": 158,
        "endChar": 38
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73ea1fb7_4ac19fc1",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "If this genuinely happens, remove the warning?",
      "range": {
        "startLine": 162,
        "startChar": 20,
        "endLine": 162,
        "endChar": 25
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b51e5631_43c41110",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 167,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "Is it only used by testing? @VisibleForTesting ?\n\nOtherwise I\u0027m concerned native memory will be dropped on the floor (with a leak).\n\nTypically to be safe with such an operation, it would mean that the queue has to be fully drained and future attempts to register new objects would fail.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af22c8af_5c7758eb",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 175,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Is it? Isn\u0027t the referent at this point already garbage collected?",
      "range": {
        "startLine": 175,
        "startChar": 15,
        "endLine": 175,
        "endChar": 79
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "234bca9a_435cdfd7",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 175,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T23:02:07Z",
      "side": 1,
      "message": "With OpenJDK, Phantom References weren\u0027t automatically cleared as they are enqueued (prior to version 9).\n\nThis could lead to strange behavior where it was possible to resurrect an object by getting its underlying referent via reflection (Reference#getReferent()) and then re-rooting it.\n\n---\nAs for Android, in ART we do clear the objects from the phantom references (I checked our code) when they are enqueued, I\u0027m just not sure if older versions (e.g. Dalvik) have the same behavior.\n\nRegardless, it\u0027s likely an academic question since unless the object is actually resurrected after it\u0027s enqueued (which it\u0027s not here), I don\u0027t believe there\u0027s a behavioral distinction.",
      "parentUuid": "af22c8af_5c7758eb",
      "range": {
        "startLine": 175,
        "startChar": 15,
        "endLine": 175,
        "endChar": 79
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e48ed71_520fa90b",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 179,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "if our strong references set is empty, should/could we be stopping the thread at this point?",
      "range": {
        "startLine": 179,
        "startChar": 16,
        "endLine": 179,
        "endChar": 33
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e3a3f73_dac35512",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "This operation is inherently unsafe.\n\nSuppose one thread (A) calls getNativePtr, getting a non-null pointer.\nAnother thread then (B) cleans it up.\n(A) proceeds to use-after-free the pointer.\n\nLikely this should be either only @VisibleForTesting or there should be additional steps taken to ensure pointer is not destroyed while its used.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "282831ed_109d64a4",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Do you need this class to be multithreaded anyway? It seems like it would be easier to just make it non-threadsafe and require clients to synchronize access to it externally. Most objects are going to be destroyed on a single thread anyway.",
      "parentUuid": "2e3a3f73_dac35512",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1697c8c_e3fec6ac",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1107754
      },
      "writtenOn": "2017-10-09T23:48:20Z",
      "side": 1,
      "message": "Yeah we had talked about this a lot and eventually decided that we were ok with putting some onus on the caller to do the right thing (although we should definitely add more documentation here).\n\nI view this a lot like an std::unique_ptr\u003c\u003e where dropping a reference to the owning class will inherently free up all members, including the NativeRefHolder.  If you\u0027re accessing the NativeRefHolder\u0027s data at the time, that\u0027s a design flaw.\n\nI\u0027m happy to add safety checks to make this harder to break though.  We had some ideas about that:\n\n1. (We do this already) Post all automated deletes onto the UI thread, so any UI thread access is guaranteed not to have a delete come from the GC.\n2. Add a semaphore and bump it on each call to getNativePtr(), release it in a task posted to all handlers of the threads calling getNativePtr().  This would guarantee the object wouldn\u0027t be destroyed during all stack frames where getNativePtr() was called.  This was a bit scary because not all threads have a Looper (IIRC) and some background threads might block for a long time :(.\n3. Allow the creator to specify which thread should do destruction when building the ref.  I don\u0027t know if we have any use cases for this in Java currently though.\n\nI also see an interesting issue around manually calling destroy(). maybe we should be posting that to a destruction handler as well (...although I still view that a lot like std::unique_ptr\u003c\u003e::reset())?",
      "parentUuid": "282831ed_109d64a4",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c578f32_a78c153f",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-10T17:53:13Z",
      "side": 1,
      "message": "Unfortunately Java references are closer to shared_ptr than unique_ptr because we cannot guarantee a single-owner.\n\nA safer approach would be to extend the lifetime of the native ptr as long as it is accessible through a strong ref.\n\nFor example,\n(a) only allowing access through the object that called to register the pointer to begin with.\n(b) or, giving out the pointer via \"NativePointer\" object, as long as any NativePointer instances exist, do not \"Destroy\" the native long pointer.\n\nThis way there\u0027s still a bit of issues ensuring the NativePointer is not deleted, but it\u0027s a more localized problem.\n\nBetter yet, but this costs a bit of performance, have an AutoCloseable to do this.\n\n  try (NativePointer p \u003d refHolder.getNativePtr()) {\n    jni_call(p.get());\n  }\n  // forbid any usages of p.get() if it\u0027s not in a \"try-with-using\" block. perhaps with a linter?",
      "parentUuid": "c1697c8c_e3fec6ac",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad41ef73_725747a2",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "(IMO) I don\u0027t see thread safety as the main concern.  My main concern would be giving out your raw native pointer at all externally.\n\nI don\u0027t see why any class would ever expose their NativeRefHolder object.  The second they\u0027re doing that, it seems like they\u0027ve given up all control.\n\nI don\u0027t see this as a unique or sharedptr...it is the raw pointer to the native object.  It\u0027s not different than passing a raw pointer across threads in C++ and all the concerns that go along with it.  I think it would be reasonable to document the thread-safety-ness (or lack thereof) at the class level and let the consumers deal with it as dtrainor@ says.\n\nBut then, why is it an AtomicLong vs long?  I thought all the destroys were process on the main looper (i.e. not the GC thread or something)?  Or is the thought that destroy() below can be called off the UI thread?\n\nThat said, I would like to get to a world where we don\u0027t expose the long value at all.  I wonder if we could teach our jni generators to understand taking a NativeRefHolder instead of the long and that would be the sole place that could get access to this (other than passing it to the destroy method).",
      "parentUuid": "2c578f32_a78c153f",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e96a62fd_e1ba68be",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "I don\u0027t think you want ScalableTimeout if this runs in a local JUnit test â€“ this will attempt to read from /data/local/tmp/chrome_timeout_scale _on the host_ to get the scale factor :)",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 40
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33d32cb6_38727899",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 61,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "why 16 (60hz update rate)?",
      "range": {
        "startLine": 61,
        "startChar": 33,
        "endLine": 61,
        "endChar": 35
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9fae6c3d_3a8d70f0",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Add a comment that this is because the thread will be interrupted after stop() has been called, so we\u0027ll quit the loop on the next iteration?",
      "range": {
        "startLine": 63,
        "startChar": 23,
        "endLine": 63,
        "endChar": 21
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6de22876_ce72c53e",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "`\u003c`?",
      "range": {
        "startLine": 127,
        "startChar": 57,
        "endLine": 127,
        "endChar": 58
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ee6fdbf_11ef4ae6",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "No \"m\" prefix.",
      "range": {
        "startLine": 155,
        "startChar": 15,
        "endLine": 155,
        "endChar": 16
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7109fd39_6ce113e1",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 158,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Why do you need to drain the looper on an additional background thread instead of the thread the test runs on?",
      "range": {
        "startLine": 158,
        "startChar": 48,
        "endLine": 158,
        "endChar": 58
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4006b19_6ae9994c",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 167,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Clear the instance in teardown?",
      "range": {
        "startLine": 167,
        "startChar": 8,
        "endLine": 167,
        "endChar": 44
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}