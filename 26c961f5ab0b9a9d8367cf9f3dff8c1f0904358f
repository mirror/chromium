{
  "comments": [
    {
      "key": {
        "uuid": "35d18624_c3ad7733",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "nit: Might be good to point out it\u0027s a singleton up here.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34a50fb0_f5839e01",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "35d18624_c3ad7733",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "21f624c1_8399c6c6",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 99,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "API design notes:\n\nI have to wonder if people won\u0027t accidentally make this mistake anyway. \n\n-----------\nI saw you have Java 8 support, so maybe the linter could catch this?\n\n   registerNativeReference(ptr, obj, Foo::bar) // warn unless Foo#bar is static.\n\n-----------\n\nAlternatively, if you used reflection to invoke the \"static native nativeDestroy(long)\" , it would absolve this problem?\n\n  void registerNativeReference(long ptr, Object object, Class\u003cT\u003e destroyer) {\n    Method destroyNative \u003d destroyer.getMethod(\"nativeDestroy\", long.TYPE);\n    if (destroyNative !\u003d static) throw;\n\n    .....\n    // instead of calling Destroyer.onDestroy, call destroyNative.invoke(long)\n  }\n  \n  void registerNativeReference(long ptr, Object object) {\n    registerNativeReference(ptr, object, object.getClass());\n  }\n\n(as a variation, if you use JNI to do this you can avoid boxing the Long pointer if thats a concern).\n\n---------",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34f9f5a2_a8c4cfa9",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 99,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "I\u0027m not sure it necessarily has to be static though, or that it helps being static. Also, I\u0027m not sure how that would work when we use method references? Would they be static?\nI think I\u0027d be more inclined to keep the documentation for the important part here, which is to say that it should have no reference back to the referent (the object that should be garbage collected).",
      "parentUuid": "21f624c1_8399c6c6",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d071f652_fefd0ba1",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 99,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-18T21:20:51Z",
      "side": 1,
      "message": "\u003e I\u0027m not sure it necessarily has to be static though, or that it helps being static. \nStatic helps since it cannot possible keep any other object alive.\n\n\u003e Also, I\u0027m not sure how that would work when we use method references? Would they be static?\nIt could\u0027ve been a method reference to a static method (the method reference itself is just a sugar for a lambda which itself is an object).\n\n\u003e I think I\u0027d be more inclined to keep the documentation for the important part here, which is to say that it should have no reference back to the referent (the object that should be garbage collected).\n\nSGTM as long as there\u0027s a clear warning there :).",
      "parentUuid": "34f9f5a2_a8c4cfa9",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f362ca5_012b8c70",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 106,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "nit: Destroyer\u003cT\u003e might look a bit cleaner to the user ?\n\n  BitmapDestroyer implements Destroyer\u003cBitmap\u003e\n  YuvDestroyer implements Destroyer\u003cYuv\u003e\n\netc. Not sure if it will break lambdas. Probably not, it\u0027s still a SAM.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80b491c4_246493f7",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 106,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3f362ca5_012b8c70",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22eb270e_4ac53854",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 124,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "(Curious random question. Why can\u0027t you just mock the regular INSTANCE here by overwriting it with reflection? Is it because there\u0027s no Looper during a test?)",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0890148_998eb600",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 124,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "What I\u0027ve done here is typically what we\u0027ve done in other places in our code base.\nI\u0027ve changed it to use reflection now, but I\u0027m not sure how I feel about it.",
      "parentUuid": "22eb270e_4ac53854",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e0f74e3e_8cab33f9",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 131,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "(is this an alternative syntax for {@code referent} ?)",
      "range": {
        "startLine": 131,
        "startChar": 7,
        "endLine": 131,
        "endChar": 17
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40f01ebf_19eb9483",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 131,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Yes ;-)",
      "parentUuid": "e0f74e3e_8cab33f9",
      "range": {
        "startLine": 131,
        "startChar": 7,
        "endLine": 131,
        "endChar": 17
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "09fdcfbe_5f4c2b8d",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 158,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "Why is this needed?  We only use this reference when creating NativePhantomReference(s)",
      "range": {
        "startLine": 158,
        "startChar": 28,
        "endLine": 158,
        "endChar": 38
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9942f24c_ee0194ff",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 158,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "It was just for an abundance of caution not wanting to get an ClassCastException. But then again, I guess at that point it\u0027s better to crash, since something is horribly wrong. Also, removed |final| keyword.",
      "parentUuid": "09fdcfbe_5f4c2b8d",
      "range": {
        "startLine": 158,
        "startChar": 28,
        "endLine": 158,
        "endChar": 38
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "73ea1fb7_4ac19fc1",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "If this genuinely happens, remove the warning?",
      "range": {
        "startLine": 162,
        "startChar": 20,
        "endLine": 162,
        "endChar": 25
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "23a401ef_91e949bf",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Changed to Log.e(...), would that be enough you think?",
      "parentUuid": "73ea1fb7_4ac19fc1",
      "range": {
        "startLine": 162,
        "startChar": 20,
        "endLine": 162,
        "endChar": 25
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b51e5631_43c41110",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 167,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "Is it only used by testing? @VisibleForTesting ?\n\nOtherwise I\u0027m concerned native memory will be dropped on the floor (with a leak).\n\nTypically to be safe with such an operation, it would mean that the queue has to be fully drained and future attempts to register new objects would fail.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68719ec1_cd4adcdc",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 167,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "It\u0027s private, so it\u0027s not used by anyone directly, but the only caller, NativeRefAssassin#stopForTest() I\u0027ve now marked @VisibleForTesting.",
      "parentUuid": "b51e5631_43c41110",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "af22c8af_5c7758eb",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 175,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Is it? Isn\u0027t the referent at this point already garbage collected?",
      "range": {
        "startLine": 175,
        "startChar": 15,
        "endLine": 175,
        "endChar": 79
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "234bca9a_435cdfd7",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 175,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T23:02:07Z",
      "side": 1,
      "message": "With OpenJDK, Phantom References weren\u0027t automatically cleared as they are enqueued (prior to version 9).\n\nThis could lead to strange behavior where it was possible to resurrect an object by getting its underlying referent via reflection (Reference#getReferent()) and then re-rooting it.\n\n---\nAs for Android, in ART we do clear the objects from the phantom references (I checked our code) when they are enqueued, I\u0027m just not sure if older versions (e.g. Dalvik) have the same behavior.\n\nRegardless, it\u0027s likely an academic question since unless the object is actually resurrected after it\u0027s enqueued (which it\u0027s not here), I don\u0027t believe there\u0027s a behavioral distinction.",
      "parentUuid": "af22c8af_5c7758eb",
      "range": {
        "startLine": 175,
        "startChar": 15,
        "endLine": 175,
        "endChar": 79
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18e1769c_200d5225",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 175,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Kept as is then for clarity.",
      "parentUuid": "234bca9a_435cdfd7",
      "range": {
        "startLine": 175,
        "startChar": 15,
        "endLine": 175,
        "endChar": 79
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4e48ed71_520fa90b",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 179,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "if our strong references set is empty, should/could we be stopping the thread at this point?",
      "range": {
        "startLine": 179,
        "startChar": 16,
        "endLine": 179,
        "endChar": 33
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15694414_2dee54d6",
        "filename": "base/android/java/src/org/chromium/base/NativeRefAssassin.java",
        "patchSetId": 3
      },
      "lineNbr": 179,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "We could, but then we would have to autostart it again. I thought a bit about it before I sent this out, and fell on the side of not adding the extra complexity of autostop and autostart.\n\nAs it stands now, the .remove() call on the queue blocks on a .wait() call, which means that the thread is effectively stopped until something is put it in, IIUC.",
      "parentUuid": "4e48ed71_520fa90b",
      "range": {
        "startLine": 179,
        "startChar": 16,
        "endLine": 179,
        "endChar": 33
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e3a3f73_dac35512",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-06T20:22:54Z",
      "side": 1,
      "message": "This operation is inherently unsafe.\n\nSuppose one thread (A) calls getNativePtr, getting a non-null pointer.\nAnother thread then (B) cleans it up.\n(A) proceeds to use-after-free the pointer.\n\nLikely this should be either only @VisibleForTesting or there should be additional steps taken to ensure pointer is not destroyed while its used.",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "282831ed_109d64a4",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Do you need this class to be multithreaded anyway? It seems like it would be easier to just make it non-threadsafe and require clients to synchronize access to it externally. Most objects are going to be destroyed on a single thread anyway.",
      "parentUuid": "2e3a3f73_dac35512",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1697c8c_e3fec6ac",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1107754
      },
      "writtenOn": "2017-10-09T23:48:20Z",
      "side": 1,
      "message": "Yeah we had talked about this a lot and eventually decided that we were ok with putting some onus on the caller to do the right thing (although we should definitely add more documentation here).\n\nI view this a lot like an std::unique_ptr\u003c\u003e where dropping a reference to the owning class will inherently free up all members, including the NativeRefHolder.  If you\u0027re accessing the NativeRefHolder\u0027s data at the time, that\u0027s a design flaw.\n\nI\u0027m happy to add safety checks to make this harder to break though.  We had some ideas about that:\n\n1. (We do this already) Post all automated deletes onto the UI thread, so any UI thread access is guaranteed not to have a delete come from the GC.\n2. Add a semaphore and bump it on each call to getNativePtr(), release it in a task posted to all handlers of the threads calling getNativePtr().  This would guarantee the object wouldn\u0027t be destroyed during all stack frames where getNativePtr() was called.  This was a bit scary because not all threads have a Looper (IIRC) and some background threads might block for a long time :(.\n3. Allow the creator to specify which thread should do destruction when building the ref.  I don\u0027t know if we have any use cases for this in Java currently though.\n\nI also see an interesting issue around manually calling destroy(). maybe we should be posting that to a destruction handler as well (...although I still view that a lot like std::unique_ptr\u003c\u003e::reset())?",
      "parentUuid": "282831ed_109d64a4",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c578f32_a78c153f",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-10T17:53:13Z",
      "side": 1,
      "message": "Unfortunately Java references are closer to shared_ptr than unique_ptr because we cannot guarantee a single-owner.\n\nA safer approach would be to extend the lifetime of the native ptr as long as it is accessible through a strong ref.\n\nFor example,\n(a) only allowing access through the object that called to register the pointer to begin with.\n(b) or, giving out the pointer via \"NativePointer\" object, as long as any NativePointer instances exist, do not \"Destroy\" the native long pointer.\n\nThis way there\u0027s still a bit of issues ensuring the NativePointer is not deleted, but it\u0027s a more localized problem.\n\nBetter yet, but this costs a bit of performance, have an AutoCloseable to do this.\n\n  try (NativePointer p \u003d refHolder.getNativePtr()) {\n    jni_call(p.get());\n  }\n  // forbid any usages of p.get() if it\u0027s not in a \"try-with-using\" block. perhaps with a linter?",
      "parentUuid": "c1697c8c_e3fec6ac",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad41ef73_725747a2",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "(IMO) I don\u0027t see thread safety as the main concern.  My main concern would be giving out your raw native pointer at all externally.\n\nI don\u0027t see why any class would ever expose their NativeRefHolder object.  The second they\u0027re doing that, it seems like they\u0027ve given up all control.\n\nI don\u0027t see this as a unique or sharedptr...it is the raw pointer to the native object.  It\u0027s not different than passing a raw pointer across threads in C++ and all the concerns that go along with it.  I think it would be reasonable to document the thread-safety-ness (or lack thereof) at the class level and let the consumers deal with it as dtrainor@ says.\n\nBut then, why is it an AtomicLong vs long?  I thought all the destroys were process on the main looper (i.e. not the GC thread or something)?  Or is the thought that destroy() below can be called off the UI thread?\n\nThat said, I would like to get to a world where we don\u0027t expose the long value at all.  I wonder if we could teach our jni generators to understand taking a NativeRefHolder instead of the long and that would be the sole place that could get access to this (other than passing it to the destroy method).",
      "parentUuid": "2c578f32_a78c153f",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30ddc9f4_48d89596",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "There are a few suggestions and questions here:\n1) I\u0027ve changed destroying in destroy() to in fact post to the correct handler.\n2) The long is AtomicLong, since destroy() may be invoked from any thread.\n\nRegarding the thread safety, I do kind of like the AutoCloseable requirement and giving out NativePointer instead of the raw pointer (and guarding the get()-call with linter). I will consider that in a follow-up CL.\n\nI agree that no class should ever give out their NativeRefPointer, nor their raw pointer contained within it, so it would be similar rules here as what we have currently when handling raw native pointers. Which means this is no worse than before.\nAnd in fact, since the destroy is now always posted to the given handler (I guess typically the main handler), if the pointer is only accessed on that handler, it will not be destroyed within the current stack frame at least.\n\nI\u0027ve moved the destroy handler argument from the constructor of the NativeRefAssassin to the caller of NativeRefAssassin#registerReference(...), which means each class can choose which handler to be destructed on. I\u0027ve also added a helper method for when the caller wants to use the main handler.\n\nI\u0027ve also added some documentation to this method regarding this to ensure developers read about what they need to think about.\n\nMore importantly though, I think going forward we would want to hide all usage of the raw native pointer behind an interface, which would mean that no-one would have to deal with accessing the pointer in weird ways themselves.",
      "parentUuid": "ad41ef73_725747a2",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68c77a75_f5b561a2",
        "filename": "base/android/java/src/org/chromium/base/NativeRefHolder.java",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1224415
      },
      "writtenOn": "2017-10-18T21:20:51Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "30ddc9f4_48d89596",
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e96a62fd_e1ba68be",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "I don\u0027t think you want ScalableTimeout if this runs in a local JUnit test – this will attempt to read from /data/local/tmp/chrome_timeout_scale _on the host_ to get the scale factor :)",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 40
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ce7e564_5ee357fd",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e96a62fd_e1ba68be",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 40
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "33d32cb6_38727899",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 61,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-10-12T21:13:54Z",
      "side": 1,
      "message": "why 16 (60hz update rate)?",
      "range": {
        "startLine": 61,
        "startChar": 33,
        "endLine": 61,
        "endChar": 35
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3dee8ede_0a33caf3",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 61,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Yep. Made into a constant and added comment :-p",
      "parentUuid": "33d32cb6_38727899",
      "range": {
        "startLine": 61,
        "startChar": 33,
        "endLine": 61,
        "endChar": 35
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9fae6c3d_3a8d70f0",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Add a comment that this is because the thread will be interrupted after stop() has been called, so we\u0027ll quit the loop on the next iteration?",
      "range": {
        "startLine": 63,
        "startChar": 23,
        "endLine": 63,
        "endChar": 21
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73a06662_cf0e3d5b",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9fae6c3d_3a8d70f0",
      "range": {
        "startLine": 63,
        "startChar": 23,
        "endLine": 63,
        "endChar": 21
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6de22876_ce72c53e",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "`\u003c`?",
      "range": {
        "startLine": 127,
        "startChar": 57,
        "endLine": 127,
        "endChar": 58
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0f2c7ee_71405e28",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Wow... OK... So turns out SystemClock.elapsedRealtime() doesn\u0027t work like I thought it worked in Robolectric. I\u0027ve changed it now to use System.currentTimeMillis() instead, because that one does in fact advance. Also, changed the code so it\u0027s easier to reason about with nice variable names, and fixed the bug.",
      "parentUuid": "6de22876_ce72c53e",
      "range": {
        "startLine": 127,
        "startChar": 57,
        "endLine": 127,
        "endChar": 58
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8ee6fdbf_11ef4ae6",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "No \"m\" prefix.",
      "range": {
        "startLine": 155,
        "startChar": 15,
        "endLine": 155,
        "endChar": 16
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "98a1aad4_ea36333f",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8ee6fdbf_11ef4ae6",
      "range": {
        "startLine": 155,
        "startChar": 15,
        "endLine": 155,
        "endChar": 16
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7109fd39_6ce113e1",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 158,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Why do you need to drain the looper on an additional background thread instead of the thread the test runs on?",
      "range": {
        "startLine": 158,
        "startChar": 48,
        "endLine": 158,
        "endChar": 58
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e1633fe_27468f34",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 158,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "It\u0027s stupid. Basically, we can\u0027t run to the end of the looper for the destroyer while we\u0027re blocking on the tryAcquire(...) call.\nAnd the automagic that Robolectric usually uses doesn\u0027t work when we have the test thread, the thread for the cleaner, and the thread for destroying sadly. Basically, no tasks are automatically run :-/",
      "parentUuid": "7109fd39_6ce113e1",
      "range": {
        "startLine": 158,
        "startChar": 48,
        "endLine": 158,
        "endChar": 58
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4006b19_6ae9994c",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 167,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-10-06T22:46:25Z",
      "side": 1,
      "message": "Clear the instance in teardown?",
      "range": {
        "startLine": 167,
        "startChar": 8,
        "endLine": 167,
        "endChar": 44
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef106604_44186531",
        "filename": "base/android/junit/src/org/chromium/base/NativeRefAssassinTest.java",
        "patchSetId": 3
      },
      "lineNbr": 167,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-10-18T19:46:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b4006b19_6ae9994c",
      "range": {
        "startLine": 167,
        "startChar": 8,
        "endLine": 167,
        "endChar": 44
      },
      "revId": "26c961f5ab0b9a9d8367cf9f3dff8c1f0904358f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}