{
  "comments": [
    {
      "key": {
        "uuid": "6b603572_eed85738",
        "filename": "ui/compositor/layer_delegate.h",
        "patchSetId": 5
      },
      "lineNbr": 34,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-06T19:27:12Z",
      "side": 1,
      "message": "I\u0027m not super sure threaded is the right name here. If thats used in the ui animation API/docs then ok, but there\u0027s no actual thread. Composited animation or compositor-driven animation or accelerated animation (\u003e_\u003e) are all possible alternatives.",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95294252_f47ce595",
        "filename": "ui/compositor/layer_delegate.h",
        "patchSetId": 5
      },
      "lineNbr": 34,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-11-08T20:40:45Z",
      "side": 1,
      "message": "The reader doesn\u0027t need to know how animations are implemented.\n\nI removed the word \"threaded\" from comments and instead highlighted the fact that OnLayerBoundsChanged() is called at every step of an animation while OnLayerTransformed()/OnLayerOpacityChanged() are only guaranteed to be called before the first frame is rendered.\n\nIIUC, bounds animations are never threaded because every change to the bounds of a layer may affect its content (unlike a change to the transform or opacity). ajuma@: Is this right?",
      "parentUuid": "6b603572_eed85738",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1b65eecb_e5ffe4fa",
        "filename": "ui/compositor/layer_delegate.h",
        "patchSetId": 5
      },
      "lineNbr": 34,
      "author": {
        "id": 1002110
      },
      "writtenOn": "2017-11-08T20:55:25Z",
      "side": 1,
      "message": "Yes, that\u0027s right.",
      "parentUuid": "95294252_f47ce595",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e1b5f2fc_f7dacafe",
        "filename": "ui/compositor/layer_delegate.h",
        "patchSetId": 5
      },
      "lineNbr": 39,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-06T19:27:12Z",
      "side": 1,
      "message": "This feels like information that i\u0027d expect on the API where u create these animations and this could refer to that to see what are \"threaded\". But I am not finding that, if you know of any then maybe that\u0027d make sense?",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ec3de41_8b40c495",
        "filename": "ui/compositor/layer_delegate.h",
        "patchSetId": 5
      },
      "lineNbr": 39,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-11-08T20:40:45Z",
      "side": 1,
      "message": "see previous comment",
      "parentUuid": "e1b5f2fc_f7dacafe",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e67fd98_50628f0a",
        "filename": "ui/compositor/layer_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 2316,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-06T19:27:12Z",
      "side": 1,
      "message": "Isn\u0027t this the same as writing\n\nEXPECT_CALL(delegate,\n              OnLayerBoundsChanged(kTargetBounds, PropertyChangeReason::SET))\n\n?",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e94e310_7e45ebf7",
        "filename": "ui/compositor/layer_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 2316,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-11-08T20:40:45Z",
      "side": 1,
      "message": "OnLayerBoundsChanged() expects to receive the old bounds. Added |initial_bounds| variable to make this clearer.",
      "parentUuid": "6e67fd98_50628f0a",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aaedc079_4398d287",
        "filename": "ui/compositor/layer_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 2402,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-06T19:27:12Z",
      "side": 1,
      "message": "This is the magic that makes it \"non-threaded\" right? Can you comment on here how/why that is the case? Is there anything this test can check to prove that this stays true?",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d0efaea_5e3a5f64",
        "filename": "ui/compositor/layer_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 2402,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-11-08T20:40:45Z",
      "side": 1,
      "message": "CreateInterpolatedTransformElement (below) is expected to return a non-threaded LayerAnimationElement. Added ASSERT_FALSE(element-\u003eIsThreaded()) to ensure that this doesn\u0027t change.",
      "parentUuid": "aaedc079_4398d287",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65a393f2_1f7da057",
        "filename": "ui/compositor/layer_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 2515,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-06T19:27:12Z",
      "side": 1,
      "message": "At the end of the animation, if the reason is ANIMATION, how does the client know to consider the window done animating?",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3b501cb_6bcf0e14",
        "filename": "ui/compositor/layer_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 2515,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-11-08T20:40:45Z",
      "side": 1,
      "message": "The client can call \"animator-\u003eIsAnimatingProperty(LayerAnimationElement::PROPERTY)\" to know if a property is done animating.\n\nHaving a DONE_ANIMATING value in the PropertyChangeReason enum would be convenient, but:\n- It would require more refactoring, since the LayerAnimationElements which make the Set**FromAnimation() calls don\u0027t know when the animation is ending.\n- WindowOcclusionTracker would still need to call IsAnimatingOnePropertyOf() because it needs to perform an action when there are no more BOUNDS/TRANSFORM/OPACITY animations, not when a single animation ends.",
      "parentUuid": "65a393f2_1f7da057",
      "revId": "42ba3daa1e539d4e32e1ef24507df45a202e60eb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}