{
  "comments": [
    {
      "key": {
        "uuid": "1f1857af_bcea698f",
        "filename": "components/viz/service/display/surface_aggregator.cc",
        "patchSetId": 1
      },
      "lineNbr": 662,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-07-25T13:44:04Z",
      "side": 1,
      "message": "don\u0027t we need full root render pass damage for these filters to work correctly? ie. no need for a union or transform just: damage_rect \u003d full_damage;\n\nthere seem to be some code below to handle this at l.746. how is the related and why doesn\u0027t that do what we need?",
      "revId": "ae39345a96f70f868c1a5a644328eaae1464cd2d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9fa5d91b_9f77d229",
        "filename": "components/viz/service/display/surface_aggregator.cc",
        "patchSetId": 1
      },
      "lineNbr": 662,
      "author": {
        "id": 1228419
      },
      "writtenOn": "2017-07-25T15:48:11Z",
      "side": 1,
      "message": "To make damage \u003d full_damage will work and much easier.\nIt will be the simplest to set to full_damage \"if (aggregate_only_damaged_ \u0026\u0026 bg_filters.HasFilterThatMovesPixels()) damage_rect \u003d full_damage;\".\n\nHowever I found out that we only need to mark the blurring-layer (or pixel-moving-bg-filter layer) as damaged.\n\nThe line has similar code below (l. 738 now) is to handle foreground filter in surface quads. We may not in the code path: 1) needs a surface quads, 2) it is foreground pixel-moving filters.\n\nI could add some limitation to the new code only do this when aggregate_only_damaged_ \u003d\u003d true (partial-swap);\n\njbauman@, WDYT?",
      "parentUuid": "1f1857af_bcea698f",
      "revId": "ae39345a96f70f868c1a5a644328eaae1464cd2d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a54e90e3_91c9428a",
        "filename": "components/viz/service/display/surface_aggregator.cc",
        "patchSetId": 1
      },
      "lineNbr": 662,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-07-25T16:33:11Z",
      "side": 1,
      "message": "Thanks for explaining. Current patch makes sense to me then.",
      "parentUuid": "9fa5d91b_9f77d229",
      "revId": "ae39345a96f70f868c1a5a644328eaae1464cd2d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2754a2d1_5c28a3cd",
        "filename": "components/viz/service/display/surface_aggregator.cc",
        "patchSetId": 1
      },
      "lineNbr": 662,
      "author": {
        "id": 1000608
      },
      "writtenOn": "2017-07-25T18:00:22Z",
      "side": 1,
      "message": "I think aggregate_only_damaged_ will be false on Chrome OS, because overlay processors are incompatible with that flag.\n\nI think this should work. In the future we\u0027ll also want to consider that if the damage rect is empty we shouldn\u0027t need to redraw the pass at all, but that\u0027s more complicated because we\u0027d need to handle it in the second pass walking over the tree, not just in the first pass.",
      "parentUuid": "a54e90e3_91c9428a",
      "revId": "ae39345a96f70f868c1a5a644328eaae1464cd2d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d7fd269_3f1b8c6d",
        "filename": "components/viz/service/display/surface_aggregator.cc",
        "patchSetId": 1
      },
      "lineNbr": 788,
      "author": {
        "id": 1000608
      },
      "writtenOn": "2017-07-25T18:00:22Z",
      "side": 1,
      "message": "Move this to l.733 (before the loop \"for (const auto\u0026 surface_info : child_surfaces) {\").",
      "revId": "ae39345a96f70f868c1a5a644328eaae1464cd2d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "adb80920_7a88e6b9",
        "filename": "components/viz/service/display/surface_aggregator_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 2076,
      "author": {
        "id": 1116015
      },
      "writtenOn": "2017-07-25T17:14:19Z",
      "side": 1,
      "message": "Is there a test which exercises a non-pixel-moving background filter, to ensure that partial swap still invalidates only the damage rect? If not, could you add one?",
      "revId": "ae39345a96f70f868c1a5a644328eaae1464cd2d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96e86fae_a6dba900",
        "filename": "components/viz/service/display/surface_aggregator_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 2076,
      "author": {
        "id": 1228419
      },
      "writtenOn": "2017-07-25T17:16:33Z",
      "side": 1,
      "message": "Good catch. I will add one test for that now.",
      "parentUuid": "adb80920_7a88e6b9",
      "revId": "ae39345a96f70f868c1a5a644328eaae1464cd2d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}