{
  "comments": [
    {
      "key": {
        "uuid": "c713e357_82149432",
        "filename": "media/gpu/vaapi_video_decode_accelerator.cc",
        "patchSetId": 5
      },
      "lineNbr": 1070,
      "author": {
        "id": 1196204
      },
      "writtenOn": "2017-11-30T06:27:11Z",
      "side": 1,
      "message": "So this ensures that the frames (are we talking about the frames in ref_frames_ here?) are deleted in the decoder thread, while at the same time moving the destruction of the accelerator and decoder, which were created in the main thread, to that same decoder thread.\n\nSo in the end we still have objects created in one thread and deleted in another, which is not great design. Besides it kind of defeats the purpose of unique_ptr to explicitly release our objects.\n\nLast, above the declaration of various accelerators, we have the following comment:\n\n    // Accelerators come after vaapi_wrapper_ to ensure they are destroyed first.\n\nBy moving their destruction to another thread, I don\u0027t think that guarantee still holds.\n\nThere is probably a safer way to achieve what you need. The issue is that the frames are refcounted and leak to another thread which should have no business with them. This probably means that the frames are surviving for longer than they should.\n\nIntuitively, I\u0027d say that the decoder thread should clear ref_frames_ as soon as it doesn\u0027t need them anymore. Maybe when the stream ends, or the decoder is interrupted - I am not familiar enough with this code to point out exactly where this should happens, but you probably get the idea.\n\nIn the worst case, we could ask the decoder thread to run VPXDecoder::Reset() here, which would have the effect of releasing the references to the frames (you would also need to sync with the decoder thread to ensure the accelerator objects are still alive by the time the method runs), but the description of the accelerators themselves should remain in the main thread.",
      "revId": "a6395581227e52448c030ec65ba63d2de1ec023f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d08ca03_b79c36a0",
        "filename": "media/gpu/vaapi_video_decode_accelerator.cc",
        "patchSetId": 5
      },
      "lineNbr": 1070,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2017-11-30T15:31:28Z",
      "side": 1,
      "message": "\u003e So this ensures that the frames (are we talking about the frames in ref_frames_ here?) are deleted in the decoder thread, while at the same time moving the destruction of the accelerator and decoder, which were created in the main thread, to that same decoder thread.\n\u003e \n\nThe issue that started all this is that VP9Picture is RefCounted\nbut not RefCountedThreadSafe. VP9Decoder uses a vector of those [1]\nthat are created and plugged in on the vaapi worker thread (via\nCreateVP9Picture() [2] that is called from VP9Decoder::Decode() [3] \nthat is itself called from DecodeTask() [4]). When VaapiVDA is deleted\nthe VP9Pictures are dereferenced and subsequently destroyed from\nthe gpu main thread --\u003e bad.\n\n[1] https://cs.chromium.org/chromium/src/media/gpu/vp9_decoder.h?type\u003dcs\u0026sq\u003dpackage:chromium\u0026l\u003d138\n[2] https://cs.chromium.org/chromium/src/media/gpu/vaapi_video_decode_accelerator.cc?l\u003d1696\n[3] https://cs.chromium.org/chromium/src/media/gpu/vp9_decoder.cc?type\u003dcs\u0026sq\u003dpackage:chromium\u0026l\u003d137\n[4] https://cs.chromium.org/chromium/src/media/gpu/vaapi_video_decode_accelerator.cc?l\u003d615\n\n\u003e So in the end we still have objects created in one thread and deleted in another, which is not great design. Besides it kind of defeats the purpose of unique_ptr to explicitly release our objects.\n\u003e \n\nToT code has objects (the |..._accelerator_|) created on the main thread and\nbeing used on the decoder thread, via |decoder_|, which is also created on\nthe main thread but used on decoder thread, e.g. [1]\n\n[1] https://cs.chromium.org/chromium/src/media/gpu/vaapi_video_decode_accelerator.cc?q\u003dvaapi_video_decode_acc\u0026sq\u003dpackage:chromium\u0026dr\u003dC\u0026l\u003d556\n\nThe issue at hand here is that the deletion of those objects happens on\nthe main thread, which contradicts the class descriptions (e.g. [2])\nand is racy and crashy, as I can bear witness to (see the bug).\n\n[2] https://cs.chromium.org/chromium/src/media/gpu/vp9_decoder.h?type\u003dcs\u0026q\u003dVP9Decoder\u0026sq\u003dpackage:chromium\u0026l\u003d28\n\nstd::unique_ptr\u003c\u003e has more uses than automatic memory management.\nFor once, annotating that a given object is fully owned, so its\nowner can do whatever it pleases. Having an object constructed on\none thread but used (and deleted!) on another thread is a pervasive\npattern in Chromium [3,4] -- what we have now is racy and wrong,\nand I can see my Gpu process crash systematically when I compile\nwith dcheck_always_on\u003dtrue (which I recommend you do).\n\n[3] https://cs.chromium.org/chromium/src/base/sequence_checker.h?q\u003dsequencechecker\u0026sq\u003dpackage:chromium\u0026dr\u003dCSs\u0026l\u003d27\n[4] https://cs.chromium.org/search/?q\u003dcontent/+%22-%3EDeleteSoon(%22\u0026sq\u003dpackage:chromium\u0026type\u003dcs\n\n\u003e Last, above the declaration of various accelerators, we have the following comment:\n\u003e \n\u003e     // Accelerators come after vaapi_wrapper_ to ensure they are destroyed first.\n\u003e \n\u003e By moving their destruction to another thread, I don\u0027t think that guarantee still holds.\n\nThis should be addressed separately, because having a naked ptr\nto a reference counted object [1] is... surprising? Specially since\nVaapiVDA owns the accelerators, so they could hold a ref to the wrapper.\n\nAnyway, the destruction order could be enforced by simply releasing VaapiVDA\u0027s \nreference to VaapiWrapper on decoder task thread too.\n\n[1] https://cs.chromium.org/chromium/src/media/gpu/vaapi_video_decode_accelerator.cc?l\u003d262\n\n\u003e \n\u003e There is probably a safer way to achieve what you need. The issue is that the frames are refcounted and leak to another thread which should have no business with them. This probably means that the frames are surviving for longer than they should.\n\u003e \n\u003e Intuitively, I\u0027d say that the decoder thread should clear ref_frames_ as soon as it doesn\u0027t need them anymore. Maybe when the stream ends, or the decoder is interrupted - I am not familiar enough with this code to point out exactly where this should happens, but you probably get the idea.\n\u003e \n\u003e In the worst case, we could ask the decoder thread to run VPXDecoder::Reset() here, which would have the effect of releasing the references to the frames (you would also need to sync with the decoder thread to ensure the accelerator objects are still alive by the time the method runs), but the description of the accelerators themselves should remain in the main thread.",
      "parentUuid": "c713e357_82149432",
      "revId": "a6395581227e52448c030ec65ba63d2de1ec023f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3493bdcd_e046842f",
        "filename": "media/gpu/vaapi_video_decode_accelerator.cc",
        "patchSetId": 5
      },
      "lineNbr": 1070,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2017-12-06T22:38:57Z",
      "side": 1,
      "message": "Drive-by comment, with disclaimer that I\u0027m not totally familiar with the threading model around this code. That said, it seems there are a two issues:\n\nFirst, is VP9Picture supposed to only exist and be used on the decoder thread? If not, it absolutely cannot be RefCounted since the ref-counting is not atomic in the non-ThreadSafe variant! (Meaning, passing ref-counted objects across threads, even if you don\u0027t use them, will modify the internal ref-count and the increment/decrement must be made thread-safe.)\n\nSecond, it seems reasonable that the decoder could be destroyed on the decoder thread unless: 1) the decoder has object dependencies on things that must be accessed on the main thread during teardown, or 2) the main thread would need to read immutable data from that object after the decoder thread has been stopped. So, if neither of these things applies, mcasas\u0027s approach seems reasonable to me.\n\nAnother approach to consider: Instead of deleting the decoders on the decoder thread, could you explicitly delete them just after the decoder_thread_.Stop() call? That would mean the decoder is deleted on the main thread, but since the decoder thread was Stop()\u0027ed, you know there are no outstanding operations in-progress, so it should be safe. If VP9Pictures or other resources need to be deleted beforehand, you could post a task to the decoder thread to do that just before the decoder_thread_.Stop() call.",
      "parentUuid": "0d08ca03_b79c36a0",
      "revId": "a6395581227e52448c030ec65ba63d2de1ec023f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6bb61170_25a1d752",
        "filename": "media/gpu/vaapi_video_decode_accelerator.cc",
        "patchSetId": 5
      },
      "lineNbr": 1070,
      "author": {
        "id": 1196204
      },
      "writtenOn": "2017-12-07T06:05:50Z",
      "side": 1,
      "message": "\u003e First, is VP9Picture supposed to only exist and be used on the decoder thread? If not, it absolutely cannot be RefCounted since the ref-counting is not atomic in the non-ThreadSafe variant! (Meaning, passing ref-counted objects across threads, even if you don\u0027t use them, will modify the internal ref-count and the increment/decrement must be made thread-safe.)\n\nI also lack a complete understanding of this code, but this does not seem to happen here (all VP9Picture references are accessed by the decoder thread solely). On the other hand I noticed that VaapiVideoDecodeAccelerator::SurfaceReady() does pass a scoped_refptr\u003cVaapiDecodeSurface\u003e from the decoder to the main thread, which may introduce some concurrency issues?\n\n\u003e Another approach to consider: Instead of deleting the decoders on the decoder thread, could you explicitly delete them just after the decoder_thread_.Stop() call? That would mean the decoder is deleted on the main thread, but since the decoder thread was Stop()\u0027ed, you know there are no outstanding operations in-progress, so it should be safe. If VP9Pictures or other resources need to be deleted beforehand, you could post a task to the decoder thread to do that just before the decoder_thread_.Stop() call.\n\nIIUC that would still trigger the DCHECK since the reference count would be decremented in the wrong thread.",
      "parentUuid": "3493bdcd_e046842f",
      "revId": "a6395581227e52448c030ec65ba63d2de1ec023f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}