{
  "comments": [
    {
      "key": {
        "uuid": "611e2368_eaaf57da",
        "filename": "base/run_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 253,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-11-24T15:01:55Z",
      "side": 1,
      "message": "Actually, if I explicitly named this RunUntilIdle() would it help clarify the whole thing? (That\u0027s already the behavior enforced by |was_overridden|).",
      "revId": "ba430bce5a0b5ad8e2c0f55b10ff6850e0899e96",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "821b23b1_73143dbc",
        "filename": "base/run_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 277,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-23T19:14:25Z",
      "side": 1,
      "message": "ngl it\u0027s really hard to keep all the redirection and clients and delegates in my head and I don\u0027t know that I could explain to someone how to use this correctly on the first try.\n\nNot that I see anything incorrect here just.. yeah.\n\nTrying to think of other options but not doing very well.\n\nMaybe if OverridenDelegateControllerForTesting was \"OriginalDelegate\"? OriginalDelegateProxy? idk.. the name as it is left me in a state of awe for a while.\n\nAnd it feels like maybe we want to override the client, but are settling for putting a bool in the prod client? Like this is returning a different Client* that will function correctly, while the original one becomes broken but it takes quite some thinking to see that and how to use it for tests (it lets u call Run on the original delete and always return and then call your own Client in a loop right?)\n\nI guess one core premise here is that this override will be called *after* setting up the original delegate. Is that required? Would this get less complicated if the override was set up before?",
      "revId": "ba430bce5a0b5ad8e2c0f55b10ff6850e0899e96",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c0c21cc_6da63a6e",
        "filename": "base/run_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 277,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-11-24T14:23:22Z",
      "side": 1,
      "message": "\u003e ngl it\u0027s really hard to keep all the redirection and clients and delegates in my head and I don\u0027t know that I could explain to someone how to use this correctly on the first try.\n\u003e \n\nI think it\u0027s actually not that bad once you wrap your head around it.\n\nRunLoop::Delegate\u0027s interface is private. Therefore only RunLoop itself can drive it (the Delegate can\u0027t even call these methods on itself).\n\nRunLoop only has a single Delegate at a time (in TLS). That Delegate can now be overridden but not while it\u0027s running so from the entire RunLoop logic\u0027s point of view it only operates on a single Delegate (which may have been overridden before it got started but it doesn\u0027t even care to know that).\n\nA registered RunLoop::Delegate\u0027s only interface back to RunLoop is the RunLoop::Delegate::Client it\u0027s handed back on registration. With this CL, that interface only provides ShouldQuitWhenIdle() so this keeps it constrained and easy to follow (I hope...).\n\nWhen overriding we need two things :\n 1) Replace the Delegate in TLS before RunLoop is invoked to get going on it.\n 2) Be handed the previous Delegate back and have the ability to drive it. The Delegate\u0027s interface being private causes a problem here and this is the sole purpose of OverridenDelegateControllerForTesting (make a private API public in that specific use case); the alternative is to return a plain RunLoop::Delegate* but that forces each \"overridder\" to be explicitly added as a friend of RunLoop::Delegate (I otherwise like that because the whole OverridenDelegateControllerForTesting + unique_ptr makes it look like ownership when it\u0027s really just owning a redirect interface that doesn\u0027t own its underlying pointer).\n\nNote: I\u0027m not opposed to requiring every overrider being an explicit friend as in practice I expect there to be only one.\n\nPerhaps it\u0027d be easier to see where I\u0027m going with this if I provided a CL for the use case I have in mind that needs to use this? Just figured it was easier to review on its own with its own tests first.\n\n\u003e Not that I see anything incorrect here just.. yeah.\n\u003e \n\u003e Trying to think of other options but not doing very well.\n\u003e \n\u003e Maybe if OverridenDelegateControllerForTesting was \"OriginalDelegate\"? OriginalDelegateProxy? idk.. the name as it is left me in a state of awe for a while.\n\u003e \n\u003e And it feels like maybe we want to override the client, but are settling for putting a bool in the prod client? Like this is returning a different Client* that will function correctly, while the original one becomes broken but it takes quite some thinking to see that and how to use it for tests (it lets u call Run on the original delete and always return and then call your own Client in a loop right?)\n\nNo, they both function correctly. The reason the overridden Delegate needs to always return when idle is because it is always driven from inside the overridding Delegate which also needs to gain control back when it becomes idle (there\u0027s no interface on RunLoop::Delegate to RunUntilIdle() as that\u0027s implemented as a mix of RunLoop::Delegate::Run() and returning true from RunLoop::Delegate::Client::ShouldQuitWhenIdle()).\n\n\u003e \n\u003e I guess one core premise here is that this override will be called *after* setting up the original delegate. Is that required?\n\nYes, and this is explicitly mentioned in the API and verified via DCHECKs in the impl.\n\n\u003e Would this get less complicated if the override was set up before?\n\nThat\u0027s an interesting option perhaps. The best way to do it that way I think would be to have (in RunLoop):\nclass OverridingDelegate : public Delegate {\n  ...\n  Client* OnUnderlyingDelegateRegistered(Delegate* delegate);\n}\nwhich would let the overriding Delegate control what to return to the overridden Delegate. We still have a problem with exposing private methods to the overridding Delegate though so I\u0027m not sure this is any less complex overall.\n\nAlso, the current approach makes it such that all of the overriding code is test only.\n\nThe reverse approach requires the regular mode to be aware that a test-only mode may already have been installed and it should act differently if that\u0027s the case.",
      "parentUuid": "821b23b1_73143dbc",
      "revId": "ba430bce5a0b5ad8e2c0f55b10ff6850e0899e96",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}