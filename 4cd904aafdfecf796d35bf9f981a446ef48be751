{
  "comments": [
    {
      "key": {
        "uuid": "ea38a49a_71373633",
        "filename": "chrome/gpu/chrome_arc_video_decode_accelerator.cc",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1107749
      },
      "writtenOn": "2017-10-25T17:41:52Z",
      "side": 1,
      "message": "nit: I guess, this change is to show functionality? In case it isn\u0027t, I\u0027ll nit: why is this required? Could these log changes be reverted? (Similarly in other files).",
      "range": {
        "startLine": 20,
        "startChar": 8,
        "endLine": 20,
        "endChar": 13
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "385ebc57_0eefa62f",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-23T21:58:15Z",
      "side": 1,
      "message": "This needs a TODO() as exposing access to gem handles this way is really bad and it should be made clear that no one should use this and it will be removed asap.",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b5e58a5_8ad91339",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-24T09:55:03Z",
      "side": 1,
      "message": "I agree this would not have been a good idea if this was saying \"return the GEM handle for the pixmap\". But this API is not implying in any way that the id returned is a GEM handle, and the client of this API must not be interpreting it as one. From the point of view of the API client, it is just an arbitrary, abstract unique id of type uint32_t. It\u0027s up to the implementation how to implement an unique int32_t id in a platform-specific way, assuming it meets the conditions described above.\n\nThe security of this solution should also not be a concern, as the security of GEM handles is not based on their values being kept secret, as they are guessable, but on DRM access rights and the fact that they are local to a DRM file. This API is not adding any additional access to GEM/DRM rights on top of what the client might have already had.",
      "parentUuid": "385ebc57_0eefa62f",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4129483b_1abe2047",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-24T21:02:38Z",
      "side": 1,
      "message": "I\u0027m going to leave it up to ozone experts to approve this part. Here are some points to help them evaluate this:\n\n- GetUniqueId() is needed because we currently track of non-drm buffers that are identified by gem handles. See shared memory buffers in ProtectedBufferManager.cc/h.\n- I think we agree that using gem handles to identify protected posix shared memory is confusing and something we should try to remove asap. I already filed crbug.com/771863 for this and suggested a way to solve it.\n\nIMO we should at least add a TODO here to indicate that we plan to remove this. We all know that if something can be accessed, then people will start using it. Leaving it up to dnicoara@ and rjkroege@ to make the final call.",
      "parentUuid": "8b5e58a5_8ad91339",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be7fc496_587ad3af",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-25T13:17:56Z",
      "side": 1,
      "message": "\u003e - GetUniqueId() is needed because we currently track of non-drm buffers that are identified by gem handles. See shared memory buffers in ProtectedBufferManager.cc/h.\n\u003e - I think we agree that using gem handles to identify protected posix shared memory is confusing and something we should try to remove asap. I already filed crbug.com/771863 for this and suggested a way to solve it.\n\nThe suggestion above is (to my knowledge) unfortunately not sufficient. The main issue is not sharing/identifying the memory, but removing access to it when sharing. \n\nThe client must not have any access to the buffer shared with it. I am not aware of any way to share memory while completely removing access to it (both read and write) from other processes we share to, unless we implement a new type of shared memory with corresponding kernel functionality to support it.",
      "parentUuid": "4129483b_1abe2047",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "66553e80_2bb6b5df",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-26T08:57:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "be7fc496_587ad3af",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "73ba6b00_b7e50033",
        "filename": "ui/ozone/platform/drm/gpu/gbm_surface_factory.cc",
        "patchSetId": 7
      },
      "lineNbr": 194,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-10-25T07:22:55Z",
      "side": 1,
      "message": "Please pass by const ref (same below)",
      "range": {
        "startLine": 194,
        "startChar": 4,
        "endLine": 194,
        "endChar": 13
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d364d653_7b023ace",
        "filename": "ui/ozone/platform/drm/gpu/gbm_surface_factory.cc",
        "patchSetId": 7
      },
      "lineNbr": 194,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-26T08:57:39Z",
      "side": 1,
      "message": "This is an existing call in the API, not a new one, so I would prefer not to change this in this CL, if that would be ok.",
      "parentUuid": "73ba6b00_b7e50033",
      "range": {
        "startLine": 194,
        "startChar": 4,
        "endLine": 194,
        "endChar": 13
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c5e6ecd2_8a9233c7",
        "filename": "ui/ozone/platform/drm/gpu/gbm_surface_factory.cc",
        "patchSetId": 7
      },
      "lineNbr": 211,
      "author": {
        "id": 1107749
      },
      "writtenOn": "2017-10-25T17:41:52Z",
      "side": 1,
      "message": "Why is this necessary? Given that in the absence of a callback and if the callback returns nullptr, this is exactly CreateNativePixmapFromHandle(), why can\u0027t we rely on ProtectedBufferManager to return nullptr if we called CreateNativePixmapFromHandle() rather than this?",
      "range": {
        "startLine": 211,
        "startChar": 19,
        "endLine": 211,
        "endChar": 61
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "649f897e_f892c401",
        "filename": "ui/ozone/platform/drm/gpu/gbm_surface_factory.cc",
        "patchSetId": 7
      },
      "lineNbr": 211,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-26T08:57:39Z",
      "side": 1,
      "message": "A client of SurfaceFactoryOzone calls CreateNativePixmapFromHandle() with a NativePixmapHandle (NPH). SurfaceFactoryOzone calls the callback to see if we have a mapping for this in ProtectedBufferManager (PBM). PBM will need to NativePixmap::GetUniqueId() to get the id to perform the lookup, but it will get an NPH through the callback. So PBM will have to call CreateNativePixmapFromHandle() by itself again from the callback to get a NativePixmap for the lookup, which will call PBM callback again, and we will have an infinite recursion.\n\nThat\u0027s why we have this method, so that the callback is skipped.\n\nWe could change the order: first always create a NativePixmap from here, and then call the callback with a NativePixmap, instead of a NPH. However, what PBM actually does when calling CreateNativePixmapFromHandle() itself, is it passes a different size (and format as well actually). This helps us save memory, otherwise we\u0027d need the dummy NativePixmap to be as large as the protected pixmap, because the client of SurfaceFactoryOzone is not aware of the fact that this is a dummy handle (nor should it be).\n\nThis can however be addressed by splitting PBM functionality into two parts: integrating the protected pixmap path directly into GbmSurfaceFactory, including the map and the lookup, while keeping the protected shared memory path in PBM. This is the next step and what the TODO is about. This however requires a major rewrite of this CL, because of how things were designed initially.\nThe initial design actually kept this functionality completely out of GbmSurfaceFactory and Ozone API in general, including not having the callback, and not having this method either (please see patchset 6), to keep the changes to Ozone to a minimum. The only modification to Ozone API in the original design was GetUniqueId(). However, after review comments to integrate the lookup functionality in CreateNativePixmapFromHandle(), instead of GpuMemoryBufferFactoryNativePixmap::CreateImageForGpuMemoryBuffer(), and to use a callback into PBM instead, this is now needed for the above reasons.",
      "parentUuid": "c5e6ecd2_8a9233c7",
      "range": {
        "startLine": 211,
        "startChar": 19,
        "endLine": 211,
        "endChar": 61
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c7ccd75_8d7d0fad",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-23T21:58:15Z",
      "side": 1,
      "message": "Why do we need this after adding \"CreateNativePixmapForProtectedBufferHandle\"? I was expecting that CreateNativePixmapForProtectedBufferHandle would allow GbmSurfaceFactory to maintain a map between dummy handle and native pixmaps instead of having this callback mechanism. It would be fine to keep a map in the protected buffer manager code too but we\u0027d avoid having to add this callback mechanism here and we\u0027d keep the Ozone API relatively clean.\n\nNot a blocking issue for me but I\u0027d like to understand why this is needed as it seems like removing this would result in a final solution that is only requiring a relatively simple Ozone API change.",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0739d9e_120f17fb",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-24T09:55:03Z",
      "side": 1,
      "message": "The map is in PBM, because it maintains all the mappings, also the ones that are not for ProtectedPixmaps, but ProtectedSharedMemory as well. So it keeps the code in one place, contained to PBM.\n\nThe map is not handle-\u003epixmap, but pixmap-\u003epixmap. To create a NativePixmap used for lookup in the map from the NativePixmapHandle provided, we need to call CreateNativePixmapFromHandle again, so that creates an infinite recursion. This is also another reason why I initially used GMBs, so that I would have a higher-level call that could avoid the recursion.",
      "parentUuid": "9c7ccd75_8d7d0fad",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8919369_8416b8bb",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-24T21:02:38Z",
      "side": 1,
      "message": "I realize there was some more miscommunication here. The CreateNativePixmapForProtectedBufferHandle API you proposed seemed great to me as it makes it possible to maintain a gem-handle\u003c-\u003eprotected-pixmap mapping inside ozone-drm for the lifetime of the pixmap returned from this function. I assumed that\u0027s how it would be used. CreateNativePixmapForProtectedBufferHandle + NativePixmap::GetUniqueId would also allow an external gem-handle\u003c-\u003eshmem mapping to be maintained until we\u0027ve been able to remove the need for that.\n\nI\u0027m going to leave it up to dnicoara@ and rjkroege@ to decide if this delegate is OK.",
      "parentUuid": "b0739d9e_120f17fb",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6ce45fa_7197d777",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-24T23:26:23Z",
      "side": 1,
      "message": "The map is indeed gem handle -\u003e protected pixmap. However, we don\u0027t have gem handles as input from the client. The clients provide NativePixmapHandles, because they provide dmabuf fds. We need a way to translate NativePixmapHandle -\u003e gem handle first (which is CreateNativePixmapFromHandle), in order to be able to perform a lookup gem handle -\u003e protected pixmap in the map.\n\nSame issue with gem-handle\u003c-\u003eshmem. We don\u0027t have a gem handle when the client asks for the protected buffer, the client provides a NativePixmapHandle (dmabuf) and we have to import it to get the gem handle.\n\nThis is independent from where the mapping lives. Even if we had it hidden inside ozone drm, we would still have to first import NativePixmapHandles given to us by the client to get gem handles. Users of this cannot and do not use gem handles, they only know dmabuf fds; only DRM understands and is able to use GEM handles.\n\nAs for the delegate, it was proposed by you here:\nhttps://chromium-review.googlesource.com/c/chromium/src/+/689818#message-fbd6da57c3eb03bd2e21d10db4b4ff97e9ed163d\nso I thought that was your preferred alternative to my original API proposal?",
      "parentUuid": "b8919369_8416b8bb",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}