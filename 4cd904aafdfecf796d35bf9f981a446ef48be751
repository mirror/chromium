{
  "comments": [
    {
      "key": {
        "uuid": "385ebc57_0eefa62f",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-23T21:58:15Z",
      "side": 1,
      "message": "This needs a TODO() as exposing access to gem handles this way is really bad and it should be made clear that no one should use this and it will be removed asap.",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b5e58a5_8ad91339",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-24T09:55:03Z",
      "side": 1,
      "message": "I agree this would not have been a good idea if this was saying \"return the GEM handle for the pixmap\". But this API is not implying in any way that the id returned is a GEM handle, and the client of this API must not be interpreting it as one. From the point of view of the API client, it is just an arbitrary, abstract unique id of type uint32_t. It\u0027s up to the implementation how to implement an unique int32_t id in a platform-specific way, assuming it meets the conditions described above.\n\nThe security of this solution should also not be a concern, as the security of GEM handles is not based on their values being kept secret, as they are guessable, but on DRM access rights and the fact that they are local to a DRM file. This API is not adding any additional access to GEM/DRM rights on top of what the client might have already had.",
      "parentUuid": "385ebc57_0eefa62f",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4129483b_1abe2047",
        "filename": "ui/gfx/native_pixmap.h",
        "patchSetId": 7
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-24T21:02:38Z",
      "side": 1,
      "message": "I\u0027m going to leave it up to ozone experts to approve this part. Here are some points to help them evaluate this:\n\n- GetUniqueId() is needed because we currently track of non-drm buffers that are identified by gem handles. See shared memory buffers in ProtectedBufferManager.cc/h.\n- I think we agree that using gem handles to identify protected posix shared memory is confusing and something we should try to remove asap. I already filed crbug.com/771863 for this and suggested a way to solve it.\n\nIMO we should at least add a TODO here to indicate that we plan to remove this. We all know that if something can be accessed, then people will start using it. Leaving it up to dnicoara@ and rjkroege@ to make the final call.",
      "parentUuid": "8b5e58a5_8ad91339",
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c7ccd75_8d7d0fad",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-23T21:58:15Z",
      "side": 1,
      "message": "Why do we need this after adding \"CreateNativePixmapForProtectedBufferHandle\"? I was expecting that CreateNativePixmapForProtectedBufferHandle would allow GbmSurfaceFactory to maintain a map between dummy handle and native pixmaps instead of having this callback mechanism. It would be fine to keep a map in the protected buffer manager code too but we\u0027d avoid having to add this callback mechanism here and we\u0027d keep the Ozone API relatively clean.\n\nNot a blocking issue for me but I\u0027d like to understand why this is needed as it seems like removing this would result in a final solution that is only requiring a relatively simple Ozone API change.",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0739d9e_120f17fb",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-24T09:55:03Z",
      "side": 1,
      "message": "The map is in PBM, because it maintains all the mappings, also the ones that are not for ProtectedPixmaps, but ProtectedSharedMemory as well. So it keeps the code in one place, contained to PBM.\n\nThe map is not handle-\u003epixmap, but pixmap-\u003epixmap. To create a NativePixmap used for lookup in the map from the NativePixmapHandle provided, we need to call CreateNativePixmapFromHandle again, so that creates an infinite recursion. This is also another reason why I initially used GMBs, so that I would have a higher-level call that could avoid the recursion.",
      "parentUuid": "9c7ccd75_8d7d0fad",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8919369_8416b8bb",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-24T21:02:38Z",
      "side": 1,
      "message": "I realize there was some more miscommunication here. The CreateNativePixmapForProtectedBufferHandle API you proposed seemed great to me as it makes it possible to maintain a gem-handle\u003c-\u003eprotected-pixmap mapping inside ozone-drm for the lifetime of the pixmap returned from this function. I assumed that\u0027s how it would be used. CreateNativePixmapForProtectedBufferHandle + NativePixmap::GetUniqueId would also allow an external gem-handle\u003c-\u003eshmem mapping to be maintained until we\u0027ve been able to remove the need for that.\n\nI\u0027m going to leave it up to dnicoara@ and rjkroege@ to decide if this delegate is OK.",
      "parentUuid": "b0739d9e_120f17fb",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6ce45fa_7197d777",
        "filename": "ui/ozone/public/surface_factory_ozone.h",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-24T23:26:23Z",
      "side": 1,
      "message": "The map is indeed gem handle -\u003e protected pixmap. However, we don\u0027t have gem handles as input from the client. The clients provide NativePixmapHandles, because they provide dmabuf fds. We need a way to translate NativePixmapHandle -\u003e gem handle first (which is CreateNativePixmapFromHandle), in order to be able to perform a lookup gem handle -\u003e protected pixmap in the map.\n\nSame issue with gem-handle\u003c-\u003eshmem. We don\u0027t have a gem handle when the client asks for the protected buffer, the client provides a NativePixmapHandle (dmabuf) and we have to import it to get the gem handle.\n\nThis is independent from where the mapping lives. Even if we had it hidden inside ozone drm, we would still have to first import NativePixmapHandles given to us by the client to get gem handles. Users of this cannot and do not use gem handles, they only know dmabuf fds; only DRM understands and is able to use GEM handles.\n\nAs for the delegate, it was proposed by you here:\nhttps://chromium-review.googlesource.com/c/chromium/src/+/689818#message-fbd6da57c3eb03bd2e21d10db4b4ff97e9ed163d\nso I thought that was your preferred alternative to my original API proposal?",
      "parentUuid": "b8919369_8416b8bb",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 131,
        "endChar": 48
      },
      "revId": "4cd904aafdfecf796d35bf9f981a446ef48be751",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}