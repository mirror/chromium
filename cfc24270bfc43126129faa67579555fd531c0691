{
  "comments": [
    {
      "key": {
        "uuid": "df70c354_b9a49dd2",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-07-13T23:31:12Z",
      "side": 1,
      "message": "Can we add a typedef for this callback to make the code a bit easier to read?",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d4e1c97_2d5acc13",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-07-14T02:02:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "df70c354_b9a49dd2",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b77c963_0602335a",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-07-13T23:31:12Z",
      "side": 1,
      "message": "is this the only use of the callback? in that case why not create this instance on the |task_runner_| thread instead? Not having to return a handle and a callback but just an instance seems cleaner if possible.",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c07ae955_b3344d26",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-07-14T02:02:14Z",
      "side": 1,
      "message": "This is called from GpuClient too (which does not actually create a GpuMemoryBufferImpl, and instead returns the GpuMemoryBufferHandle over IPC back to the client).",
      "parentUuid": "0b77c963_0602335a",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe144527_dda6515a",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-07-14T21:20:35Z",
      "side": 1,
      "message": "Does that case need the destruction callback? Can we refactor this so we don\u0027t have to deal with the destruction callback in that case and as a result make the code easier to understand? It feels like these two types of allocations should share the code used on the allocation thread but not the code used on other threads. Ie. create the GpuMemoryBufferImpl in the allocation thread and avoid the callback return value but still reuse some of the allocation logic for the GpuClient case but not the GpuMemoryBufferImpl creation part of course.",
      "parentUuid": "c07ae955_b3344d26",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8929e9a8_31cdcb73",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-07-14T21:29:04Z",
      "side": 1,
      "message": "GpuClient does not need the destruction callback. That\u0027s why I went the weak-ptr route in the earlier patchsets.\n\nThe function is used in two places, one where we need to create the GpuMemoryBufferImpl (and therefore, need a destruction callback), and one where we need just the handle. The common code that can deal with both cases is if this function only creates a handle, and have the caller construct GpuMemoryBufferImpl (and the destruction callback) as needed. The only complication is that the destruction callback needs to do a thread-hop, necessitating either a weak-ptr, or the destruction-callback being created from here too. I am not sure we can avoid the complexities (either in this patchset, or the earlier patchsets that use the weak-ptr)",
      "parentUuid": "fe144527_dda6515a",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c0bc8d8_b2b92b97",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-07-14T22:21:26Z",
      "side": 1,
      "message": "Let me try to ask in a different way; why are we not creating the GpuMemoryBufferImpl instance on the thread where we need to create the callback instead of the thread that ServerGpuMemoryBufferManager::CreateGpuMemoryBuffer is called? So we can eliminate the need to pass both a callback and a handle to the caller thread and just pass a GpuMemoryBufferImpl instance.",
      "parentUuid": "8929e9a8_31cdcb73",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f2d00ff_71f824ea",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-07-15T02:02:12Z",
      "side": 1,
      "message": "I am afraid I don\u0027t quite understand still. Sorry :-(\n\nIf we want to create GMBImpl on |task_runner_|\u0027s thread, then it should happen either in AllocateGpuMemoryBuffer above, or in OnGpuMemoryBufferAllocated below. But I can\u0027t think of a way of doing that which does not involve having two versions of the functions with duplicated code (where callback in one version receives a handle, and the callback in the other version receives a GMBImpl).\n\nAlternatively, maybe you are suggesting that all callers, including GpuClient, should receive only a GpuMemoryBufferImpl? I don\u0027t think that will work, since the GpuClient only needs to send the handle over IPC. It does not need to retain the GpuMemoryBufferImpl, which means it will be destroyed immediately, causing the memory-buffer to be destroyed, which we do not want to happen.\n\nI can\u0027t think of another way where some callbacks (GpuClient) would receive a handle, while some other callbacks (ServerGMBManager::CreateGpuMemoryBuffer) receive a GMBImpl.\n\nMaybe I am missing something though?",
      "parentUuid": "0c0bc8d8_b2b92b97",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77f8b5cb_b134f6de",
        "filename": "components/viz/host/server_gpu_memory_buffer_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-07-17T12:14:06Z",
      "side": 1,
      "message": "\"If we want to create GMBImpl on |task_runner_|\u0027s thread, then it should happen either in AllocateGpuMemoryBuffer above, or in OnGpuMemoryBufferAllocated below. But I can\u0027t think of a way of doing that which does not involve having two versions of the functions with duplicated code (where callback in one version receives a handle, and the callback in the other version receives a GMBImpl).\"\n\nThis is what I was asking for. It seems like the best way to handle this from what I can tell but maybe I\u0027m still missing what makes this non-ideal. Is there really no way we can refactor the code to minimize duplicated code for this design? E.g. add a AllocateAndCreateGpuMemoryBuffer+OnGpuMemoryBufferCreated functions that will run on |task_runner_| and adjust AllocateGpuMemoryBuffer/OnGpuMemoryBufferAllocated to maximize code reuse between the \"allocate\" and \"create\" cases. \n\nThe current patch calls CreateBufferDestructionCallback in the \"allocate\"-only case where it\u0027s not needed afaict and I think that makes the code harder to understand.",
      "parentUuid": "5f2d00ff_71f824ea",
      "revId": "cfc24270bfc43126129faa67579555fd531c0691",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}