{
  "comments": [
    {
      "key": {
        "uuid": "4d40310c_20435f6e",
        "filename": "content/browser/DEPS",
        "patchSetId": 9
      },
      "lineNbr": 162,
      "author": {
        "id": 1223459
      },
      "writtenOn": "2017-11-15T00:55:16Z",
      "side": 1,
      "message": "delete this blank.",
      "range": {
        "startLine": 162,
        "startChar": 1,
        "endLine": 162,
        "endChar": 2
      },
      "revId": "173302bcb5f2ff1fb50c7495d5a86c4ea8f93440",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6344c660_fe61f10b",
        "filename": "content/browser/service_worker/service_worker_dispatcher_host.cc",
        "patchSetId": 9
      },
      "lineNbr": 477,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-11-15T01:20:27Z",
      "side": 1,
      "message": "I\u0027m a bit hesistant to add this new bad message since SWDH::OnCountFeature should soon change to a Mojo function that takes a WebFeature and Mojo will do the validation for us, so the bad message will just be OBSOLETE.\n\nCould we just OnCountFeature to take a mojom::WebFeature instead, then I think Chrome IPC does the validation automatically?",
      "revId": "173302bcb5f2ff1fb50c7495d5a86c4ea8f93440",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fe56586_1f2b90aa",
        "filename": "content/browser/service_worker/service_worker_dispatcher_host.cc",
        "patchSetId": 9
      },
      "lineNbr": 477,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-11-15T02:39:26Z",
      "side": 1,
      "message": "+1, probably not necessary to add a bad message here. But changing the Chrome IPC won\u0027t automatically do enum validation for mojo enums (we need to define a validation method using IPC_ENUM_MAX_TRAITS, which means we need to define a kLast, which is usually pointless in Mojo...). Given that, I think it\u0027s fine to leave this and fix in a followup (which I\u0027m assuming will be one of the next few CLs after this).",
      "parentUuid": "6344c660_fe61f10b",
      "revId": "173302bcb5f2ff1fb50c7495d5a86c4ea8f93440",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb11c4e0_0d90fc14",
        "filename": "content/browser/service_worker/service_worker_version.cc",
        "patchSetId": 9
      },
      "lineNbr": 1118,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-11-15T01:20:27Z",
      "side": 1,
      "message": "Hmm I think it may be better to do this loop in ServiceWorkerStorage::GetOrCreateRegistration. Doing it here only makes sense if it\u0027s understood that SetUsedFeatures() is called by ServiceWorkerStorage, in which case we should call it something like SetUsedFeaturesFromStorage() and we might as well just do it at the callsite in storage.\n\nI\u0027m thinking something like:\n\n// Some features may be outside the valid range of features, if the data on disk was written by a later version of Chrome than currently running (crbug.com/758419).\n// TODO(falken): Maybe Chrome should have a generic mechanism to detect profile downgrade and just abort? Or we could just crash here, but that seems extreme and difficult for a user to escape.\nfor (const uint32_t feature : data.used_features) {\n  if (out of range) {\n    data.used_features.erase(feature);\n  }\n}\nversion-\u003eset_used_features(data.used_features);",
      "revId": "173302bcb5f2ff1fb50c7495d5a86c4ea8f93440",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "437fa665_361ba852",
        "filename": "content/browser/service_worker/service_worker_version.cc",
        "patchSetId": 9
      },
      "lineNbr": 1121,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-11-15T01:20:27Z",
      "side": 1,
      "message": "I\u0027m not sure it\u0027s ok to erase in the middle of the for loop like this. Do you know?",
      "revId": "173302bcb5f2ff1fb50c7495d5a86c4ea8f93440",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e96d4c28_d6777dd4",
        "filename": "content/browser/service_worker/service_worker_version.cc",
        "patchSetId": 9
      },
      "lineNbr": 1121,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-11-15T02:39:26Z",
      "side": 1,
      "message": "Erasing from a set invalidates the current iterator. So this is unsafe since this is a range-based for loop. The standard idiom in this case is:\n\nfor (auto it \u003d used_features_.begin(); it !\u003d used_features_.end(); ) {\n  if (...)\n    it \u003d used_features_.erase(it);\n  else\n    ++it\n}\n\n(Thanks for catching this)",
      "parentUuid": "437fa665_361ba852",
      "revId": "173302bcb5f2ff1fb50c7495d5a86c4ea8f93440",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}