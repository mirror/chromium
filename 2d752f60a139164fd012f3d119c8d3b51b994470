{
  "comments": [
    {
      "key": {
        "uuid": "0d2657f4_1a18ab63",
        "filename": "base/no_destructor.h",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-06T18:37:31Z",
      "side": 1,
      "message": "should this take an \"in_place\" type argument to allow the caller to differentiate if T is convertible from an argument but also constructible from it? eg std::optional does this",
      "revId": "2d752f60a139164fd012f3d119c8d3b51b994470",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff6cafef_bbc1724a",
        "filename": "base/no_destructor.h",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-02-06T18:45:54Z",
      "side": 1,
      "message": "In my mind, we logically want to transparently forward arguments to the greatest extend possible for base::NoDestructor. Adding an in_place argument would make that a bit more awkward.\n\nDoes the in_place placeholder prevent certain types of errors?",
      "parentUuid": "0d2657f4_1a18ab63",
      "revId": "2d752f60a139164fd012f3d119c8d3b51b994470",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f40a0ef8_f1a64462",
        "filename": "base/no_destructor.h",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-06T18:50:56Z",
      "side": 1,
      "message": "I think it just makes things ambiguous.\n\nNoDestructor\u003cstd::string\u003e s(\"hi\");\n\nThis could make std::string(\"hi\") and then move it to T\u0026\u0026\nOr it could pass \"hi\" as Args\u0026\u0026 and construct it in place.\n\nWhich one does this pick now? If it picks the T\u0026\u0026 path, what happens if T is moveonly?\n\nNoDestructor\u003cstd::unique_ptr\u003cint\u003e\u003e s(new int(3));\n\nDoes this work?",
      "parentUuid": "ff6cafef_bbc1724a",
      "revId": "2d752f60a139164fd012f3d119c8d3b51b994470",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e839849_fef67cba",
        "filename": "base/no_destructor.h",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-06T18:51:34Z",
      "side": 1,
      "message": "Oops, I meant what if T is not moveable, then would it just fallback to the inplace one? unique_ptr is a bad example its moveable.",
      "parentUuid": "f40a0ef8_f1a64462",
      "revId": "2d752f60a139164fd012f3d119c8d3b51b994470",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "295d1e4f_e4d38734",
        "filename": "base/no_destructor.h",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-02-06T22:03:11Z",
      "side": 1,
      "message": "I guess my short answer is google3 seems to have no problem doing it this way. Should callers really care which one is called? As long as we implement a class that provides reasonable behavior, then I suspect that callers shouldn\u0027t want to know about this detail: it\u0027s really meant to just be a transparent forwarding helper (along the lines of std::make_unique).\n\nMy biggest worry with forcing in_place_t to be used is that it\u0027d encourage constructions like this instead:\n\nNoDestructor\u003cMyStruct\u003e m(MyStruct(param1, param2, param3));\n\nIt\u0027s not clear that this would optimize as well as the in-place variant.\n\nFor the actual question of which overload will be selected:\nMost of the time, the compiler should prefer the perfect forwarding constructor. Since perfect forwarding synthesizes parameters that are exact matches, it will generally be the best viable function. The main exceptions would be conversion constructors from list initialization (in which case, const T\u0026 or T\u0026\u0026 would be selected as the exact match).",
      "parentUuid": "3e839849_fef67cba",
      "revId": "2d752f60a139164fd012f3d119c8d3b51b994470",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a625fd47_1c72e15a",
        "filename": "base/no_destructor.h",
        "patchSetId": 5
      },
      "lineNbr": 61,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-06T18:50:56Z",
      "side": 1,
      "message": "Should we delete operator\u003d too?",
      "revId": "2d752f60a139164fd012f3d119c8d3b51b994470",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43792ef8_8aedb81c",
        "filename": "base/no_destructor.h",
        "patchSetId": 5
      },
      "lineNbr": 61,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-02-06T22:03:11Z",
      "side": 1,
      "message": "Oops, yeah. That\u0027s what I meant to write (since deleting the copy ctor suppresses the move ctor)",
      "parentUuid": "a625fd47_1c72e15a",
      "revId": "2d752f60a139164fd012f3d119c8d3b51b994470",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}