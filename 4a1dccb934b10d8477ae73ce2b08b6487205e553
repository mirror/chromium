{
  "comments": [
    {
      "key": {
        "uuid": "2b00d840_cde2d542",
        "filename": "content/browser/image_capture/image_capture_impl.cc",
        "patchSetId": 8
      },
      "lineNbr": 110,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2017-07-14T06:18:13Z",
      "side": 1,
      "message": "Seems like ScopedCallbackRunner is indeed similar to ScopedResultCallback,\nwith the difference that the former binds the arguments to the failed \nversion of the callback on construction, which IMHO dilutes the message\nand forces a base:Unretained -ugh- which is not necessary with a static\nmethod as done here. \n\nIOW I prefer\n\n  ScopedResultCallback\u003cBlaCallback\u003e scoped_callback(\n      std::move(callback), base::BindOnce(\u0026SomethingWentWrong));\n\nthan:\n\n  media::ScopedCallbackRunner(std::move(callback), false);\n\nespecially since this type of bindings happen on the \"service\" landing \nof an IPC/mojo where it makes sense to explicit the semantics of this \ntype of scoped thingy.\n\nMoreover ScopedResultCallback predates ScopedCallbackRunner, and the latter \nis used in just a few places in the code, so I propose:\n\na) moving ScopedResultCallback to media/base \nb) adapting scoped_callback_runner_unittest\nc) adapting ScopedCallbackRunner sites to the former [1]\n\nWDYT?\n\n\n[1] https://cs.chromium.org/search/?sq\u003dpackage:chromium\u0026type\u003dcs\u0026q\u003dScopedCallbackRunner",
      "range": {
        "startLine": 110,
        "startChar": 49,
        "endLine": 110,
        "endChar": 69
      },
      "revId": "4a1dccb934b10d8477ae73ce2b08b6487205e553",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1f6a7ab_e8a4c580",
        "filename": "content/browser/image_capture/image_capture_impl.cc",
        "patchSetId": 8
      },
      "lineNbr": 110,
      "author": {
        "id": 1002182
      },
      "writtenOn": "2017-07-14T06:58:50Z",
      "side": 1,
      "message": "ISTM ScopedResultCallback is more powerful but ScopedCallbackRunner is simpler.\n\nScopedResultCallback takes a failure callback, which could call the original callback with different parameters based on different conditions at run time. It may also choose not to call the original callback at all. These are not possible with ScopedCallbackRunner.\n\nThat being said, as demonstrated by this CL, all current use cases of ScopedResultCallback do not need these power features, and can actually be replaced by ScopedCallbackRunner, which IMHO has simpler/cleaner interface and usage pattern:\n\n- It makes sure the original callback will always be called, at the API level.\n- It doesn\u0027t require defining another callback (see some of the removed code in this CL).\n- It makes it clear what parameters will be used in the failure case, so readers don\u0027t need to scroll up to check the definition of the failure callback.\n\nIn summary, I still like ScopedCallbackRunner is a better solution for the simpler use case, which is probably the most common use case for both ScopedResultCallback and ScopedCallbackRunner. Feel free to keep ScopedCallbackRunner if you feel we may need it for the power use cases though.\n\ntzik: WDYT",
      "parentUuid": "2b00d840_cde2d542",
      "range": {
        "startLine": 110,
        "startChar": 49,
        "endLine": 110,
        "endChar": 69
      },
      "revId": "4a1dccb934b10d8477ae73ce2b08b6487205e553",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e3278a3c_59ec6352",
        "filename": "content/browser/image_capture/image_capture_impl.cc",
        "patchSetId": 8
      },
      "lineNbr": 110,
      "author": {
        "id": 1211094
      },
      "writtenOn": "2017-07-18T12:59:00Z",
      "side": 1,
      "message": "So, the differences of ScopedCallbackRunner and ScopedResultCallback are:\n1. SCR requires arguments for fail case even if the callback is called with successful result. SRC requires an extra function just to send an error result to the caller.\n2. Resulting callback types are OnceCallback on SCR, while SRC has its own class. SRC in the source indicates the special handling on the callback rather than hide it in the callback object.\n(1) seems less controversial to use SCR, while (2) is.\n\nI prefer ScopedCallbackRunner also for (2) as it looks simpler, but it\u0027s also reasonable to leave ScopedResultCallback to leave the special handling in the type.\nI\u0027d defer it to owners.\n\nBTW, I made a draft CL to splitting DefaultArgs part of this CL as https://chromium-review.googlesource.com/c/575119/. WDYT?",
      "parentUuid": "e1f6a7ab_e8a4c580",
      "range": {
        "startLine": 110,
        "startChar": 49,
        "endLine": 110,
        "endChar": 69
      },
      "revId": "4a1dccb934b10d8477ae73ce2b08b6487205e553",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}