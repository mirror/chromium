/* Generated by wayland-scanner 1.13.0 */

#ifndef INPUTFD_UNSTABLE_V1_CLIENT_PROTOCOL_H
#define INPUTFD_UNSTABLE_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_inputfd_unstable_v1 The inputfd_unstable_v1 protocol
 * Wayland protocol for direct fd access to input devices
 *
 * @section page_desc_inputfd_unstable_v1 Description
 *
 * This description provides a high-level overview of the interfaces
 * in this protocol. For details, see the protocol specification.
 *
 * Some input devices do not interact with the windowing system. Examples
 * of such input devices are gaming controllers or 3D mice. In many cases,
 * a client requires direct access to the device to access or interpret
 * device-specific functionality.
 *
 * This interface provides client access to input devices via a file
 * descriptor (fd). The compositor may restrict the type of device
 * accessible and it may restrict specific events from being sent to the
 * client (e.g.  by masking the Home button on a gamepad). Otherwise, a
 * client should treat the device as if opened manually.
 *
 * Multiple input devices may exists and be assigned to different seats.
 * The top-level object of this protocol is a wp_inputfd_manager. A client
 * must request the desired interface for a given seat. This object then
 * provides the list of devices for that category that match the fd type of
 * that interface. At the moment, only the evdev fd type is supported but in
 * the future, a device may be accessible via multiple fd interfaces.
 *
 * Once a compositor deems a device to be focused on the client or on a
 * client's surface it sends a focus_in event with a file descriptor for
 * this device. A compositor may arbitrarily revoke access
 * to the device by sending a wp_inputfd.focus_out. Additionally, a
 * compositor may invoke system functionality to restrict access to the
 * file descriptor, e.g. by using EVIOCREVOKE on an evdev fd.
 *
 * Otherwise, a client should treat the file descriptor as direct access to
 * the device for the duration of it having access.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 *
 * @section page_ifaces_inputfd_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_inputfd_manager_v1 - controller object for direct fd access input devices
 * - @subpage page_iface_zwp_inputfd_seat_evdev_v1 - controller object for input devices of a seat
 * - @subpage page_iface_zwp_inputfd_device_evdev_v1 - evdev-compatible inputfd device
 * @section page_copyright_inputfd_unstable_v1 Copyright
 * <pre>
 *
 * Copyright 2017 Â© Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * </pre>
 */
struct wl_seat;
struct wl_surface;
struct zwp_inputfd_device_evdev_v1;
struct zwp_inputfd_manager_v1;
struct zwp_inputfd_seat_evdev_v1;

/**
 * @page page_iface_zwp_inputfd_manager_v1 zwp_inputfd_manager_v1
 * @section page_iface_zwp_inputfd_manager_v1_desc Description
 *
 * An object that provides access to the input devices available for
 * direct fd access on this system. All input devices are associated with
 * a seat, to get access to the actual devices use
 * wp_inputfd_manager.get_seat_evdev.
 * @section page_iface_zwp_inputfd_manager_v1_api API
 * See @ref iface_zwp_inputfd_manager_v1.
 */
/**
 * @defgroup iface_zwp_inputfd_manager_v1 The zwp_inputfd_manager_v1 interface
 *
 * An object that provides access to the input devices available for
 * direct fd access on this system. All input devices are associated with
 * a seat, to get access to the actual devices use
 * wp_inputfd_manager.get_seat_evdev.
 */
extern const struct wl_interface zwp_inputfd_manager_v1_interface;
/**
 * @page page_iface_zwp_inputfd_seat_evdev_v1 zwp_inputfd_seat_evdev_v1
 * @section page_iface_zwp_inputfd_seat_evdev_v1_desc Description
 *
 * An object that provides access to the input devices available on this
 * seat via an evdev-compatible file descriptor. After binding to this
 * interface, the compositor immediately sends a set of
 * wp_inputfd_seat_evdev.device_added events for currently available
 * devices and later whenever a new device becomes available.
 * @section page_iface_zwp_inputfd_seat_evdev_v1_api API
 * See @ref iface_zwp_inputfd_seat_evdev_v1.
 */
/**
 * @defgroup iface_zwp_inputfd_seat_evdev_v1 The zwp_inputfd_seat_evdev_v1 interface
 *
 * An object that provides access to the input devices available on this
 * seat via an evdev-compatible file descriptor. After binding to this
 * interface, the compositor immediately sends a set of
 * wp_inputfd_seat_evdev.device_added events for currently available
 * devices and later whenever a new device becomes available.
 */
extern const struct wl_interface zwp_inputfd_seat_evdev_v1_interface;
/**
 * @page page_iface_zwp_inputfd_device_evdev_v1 zwp_inputfd_device_evdev_v1
 * @section page_iface_zwp_inputfd_device_evdev_v1_desc Description
 *
 * The wp_inputfd_device_evdev interface represents one device node
 * in the Linux kernel evdev interface. The fd passed to the client
 * supports the ioctls and read/write commands of that interface. The
 * protocol makes no guarantees which ioctls are available on the fd,
 * this decision is made by the kernel.
 *
 * A device has a number of static characteristics, e.g. device
 * name and pid/vid. These capabilities are sent in an event sequence
 * immediately after the wp_inputfd_seat.device_added event. This initial
 * event sequence is terminated by a wp_inputfd_device_evdev.done event. This
 * sequence is sent only once and always before the first
 * wp_inputfd_device.focus_in event.
 *
 * A device is the representation of a logical device as exposed by the
 * underlying system and may only represent parts of a single physical
 * input device. It is the client's task to identify the device as part
 * of a physical device and to group the logical devices together as
 * appropriate.
 * @section page_iface_zwp_inputfd_device_evdev_v1_api API
 * See @ref iface_zwp_inputfd_device_evdev_v1.
 */
/**
 * @defgroup iface_zwp_inputfd_device_evdev_v1 The zwp_inputfd_device_evdev_v1 interface
 *
 * The wp_inputfd_device_evdev interface represents one device node
 * in the Linux kernel evdev interface. The fd passed to the client
 * supports the ioctls and read/write commands of that interface. The
 * protocol makes no guarantees which ioctls are available on the fd,
 * this decision is made by the kernel.
 *
 * A device has a number of static characteristics, e.g. device
 * name and pid/vid. These capabilities are sent in an event sequence
 * immediately after the wp_inputfd_seat.device_added event. This initial
 * event sequence is terminated by a wp_inputfd_device_evdev.done event. This
 * sequence is sent only once and always before the first
 * wp_inputfd_device.focus_in event.
 *
 * A device is the representation of a logical device as exposed by the
 * underlying system and may only represent parts of a single physical
 * input device. It is the client's task to identify the device as part
 * of a physical device and to group the logical devices together as
 * appropriate.
 */
extern const struct wl_interface zwp_inputfd_device_evdev_v1_interface;

#define ZWP_INPUTFD_MANAGER_V1_GET_SEAT_EVDEV 0
#define ZWP_INPUTFD_MANAGER_V1_DESTROY 1


/**
 * @ingroup iface_zwp_inputfd_manager_v1
 */
#define ZWP_INPUTFD_MANAGER_V1_GET_SEAT_EVDEV_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_inputfd_manager_v1
 */
#define ZWP_INPUTFD_MANAGER_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_inputfd_manager_v1 */
static inline void
zwp_inputfd_manager_v1_set_user_data(struct zwp_inputfd_manager_v1 *zwp_inputfd_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_inputfd_manager_v1, user_data);
}

/** @ingroup iface_zwp_inputfd_manager_v1 */
static inline void *
zwp_inputfd_manager_v1_get_user_data(struct zwp_inputfd_manager_v1 *zwp_inputfd_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_inputfd_manager_v1);
}

static inline uint32_t
zwp_inputfd_manager_v1_get_version(struct zwp_inputfd_manager_v1 *zwp_inputfd_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_inputfd_manager_v1);
}

/**
 * @ingroup iface_zwp_inputfd_manager_v1
 *
 * Get the wp_inputfd_seat_evdev object for the given seat. This object
 * provides access to all exposed devices in this seat via
 * evdev-compatible file descriptors.
 *
 * The decision which device is available through this interface is
 * made by the compositor. The protocol makes no guarantees whether a
 * specific device is available through this interface.
 */
static inline struct zwp_inputfd_seat_evdev_v1 *
zwp_inputfd_manager_v1_get_seat_evdev(struct zwp_inputfd_manager_v1 *zwp_inputfd_manager_v1, struct wl_seat *seat)
{
	struct wl_proxy *inputfd_seat;

	inputfd_seat = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_inputfd_manager_v1,
			 ZWP_INPUTFD_MANAGER_V1_GET_SEAT_EVDEV, &zwp_inputfd_seat_evdev_v1_interface, NULL, seat);

	return (struct zwp_inputfd_seat_evdev_v1 *) inputfd_seat;
}

/**
 * @ingroup iface_zwp_inputfd_manager_v1
 *
 * Destroy the wp_inputfd_manager object. Objects created from this
 * object are unaffected and should be destroyed separately.
 */
static inline void
zwp_inputfd_manager_v1_destroy(struct zwp_inputfd_manager_v1 *zwp_inputfd_manager_v1)
{
	wl_proxy_marshal((struct wl_proxy *) zwp_inputfd_manager_v1,
			 ZWP_INPUTFD_MANAGER_V1_DESTROY);

	wl_proxy_destroy((struct wl_proxy *) zwp_inputfd_manager_v1);
}

/**
 * @ingroup iface_zwp_inputfd_seat_evdev_v1
 * @struct zwp_inputfd_seat_evdev_v1_listener
 */
struct zwp_inputfd_seat_evdev_v1_listener {
	/**
	 * new device notification
	 *
	 * This event is sent whenever a new device becomes available on
	 * this seat. This event only provides the object id of the
	 * devices, any static information about the device (device name,
	 * vid/pid, etc.) is sent through the wp_inputfd_device_evdev
	 * interface.
	 *
	 * Which devices are compatible input devices for this seat is a
	 * decision made by the compositor, the protocol makes no guarantee
	 * that any specific device becomes available to a client.
	 * @param id the newly added device
	 */
	void (*device_added)(void *data,
			     struct zwp_inputfd_seat_evdev_v1 *zwp_inputfd_seat_evdev_v1,
			     struct zwp_inputfd_device_evdev_v1 *id);
};

/**
 * @ingroup iface_zwp_inputfd_seat_evdev_v1
 */
static inline int
zwp_inputfd_seat_evdev_v1_add_listener(struct zwp_inputfd_seat_evdev_v1 *zwp_inputfd_seat_evdev_v1,
				       const struct zwp_inputfd_seat_evdev_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_inputfd_seat_evdev_v1,
				     (void (**)(void)) listener, data);
}

#define ZWP_INPUTFD_SEAT_EVDEV_V1_DESTROY 0

/**
 * @ingroup iface_zwp_inputfd_seat_evdev_v1
 */
#define ZWP_INPUTFD_SEAT_EVDEV_V1_DEVICE_ADDED_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_inputfd_seat_evdev_v1
 */
#define ZWP_INPUTFD_SEAT_EVDEV_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_inputfd_seat_evdev_v1 */
static inline void
zwp_inputfd_seat_evdev_v1_set_user_data(struct zwp_inputfd_seat_evdev_v1 *zwp_inputfd_seat_evdev_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_inputfd_seat_evdev_v1, user_data);
}

/** @ingroup iface_zwp_inputfd_seat_evdev_v1 */
static inline void *
zwp_inputfd_seat_evdev_v1_get_user_data(struct zwp_inputfd_seat_evdev_v1 *zwp_inputfd_seat_evdev_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_inputfd_seat_evdev_v1);
}

static inline uint32_t
zwp_inputfd_seat_evdev_v1_get_version(struct zwp_inputfd_seat_evdev_v1 *zwp_inputfd_seat_evdev_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_inputfd_seat_evdev_v1);
}

/**
 * @ingroup iface_zwp_inputfd_seat_evdev_v1
 *
 * Destroy the wp_inputfd_seat_evdev object. Objects created from this
 * object are unaffected and should be destroyed separately.
 */
static inline void
zwp_inputfd_seat_evdev_v1_destroy(struct zwp_inputfd_seat_evdev_v1 *zwp_inputfd_seat_evdev_v1)
{
	wl_proxy_marshal((struct wl_proxy *) zwp_inputfd_seat_evdev_v1,
			 ZWP_INPUTFD_SEAT_EVDEV_V1_DESTROY);

	wl_proxy_destroy((struct wl_proxy *) zwp_inputfd_seat_evdev_v1);
}

/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 * @struct zwp_inputfd_device_evdev_v1_listener
 */
struct zwp_inputfd_device_evdev_v1_listener {
	/**
	 * device name
	 *
	 * The name is a UTF-8 encoded string with the device's name,
	 * intended for presentation to the user.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_inputfd_device_evdev.done event.
	 *
	 * This event is optional, if the required information is not
	 * available for this device the event is omitted.
	 * @param name the device name
	 */
	void (*name)(void *data,
		     struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1,
		     const char *name);
	/**
	 * device USB vendor/product id
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_inputfd_device_evdev.done event.
	 *
	 * This event is optional, if the required information is not
	 * available for this device the event is omitted.
	 * @param vid USB vendor id
	 * @param pid USB product id
	 */
	void (*usb_id)(void *data,
		       struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1,
		       uint32_t vid,
		       uint32_t pid);
	/**
	 * device description events sequence complete
	 *
	 * This event is sent immediately to signal the end of the
	 * initial burst of descriptive events. A client may consider the
	 * static description of the device to be complete and finalize
	 * initialization of the device.
	 */
	void (*done)(void *data,
		     struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1);
	/**
	 * device removed event
	 *
	 * Sent when the device has been removed from the system.
	 *
	 * If the client currently has the device focus, a
	 * wp_inputfd_device_evdev.focus_out event is sent before the
	 * removed event. See wp_inputfd_device.focus_in for more details.
	 *
	 * When this event is received, the client must
	 * wp_inputfd_device_evdev.destroy the object.
	 */
	void (*removed)(void *data,
			struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1);
	/**
	 * input fd device focus in event
	 *
	 * Notification that this client now has the focus and/or access
	 * to this device. How focus is set is left to the compositor. For
	 * example, a compositor may tie joystick focus to the wl_pointer
	 * focus of this seat. The protocol does not guarantee that any
	 * specific client ever receives the focus for a device.
	 *
	 * The client is passed a file descriptor with access to this
	 * device. This file descriptor is valid until a subsequent
	 * wp_inputfd_device_evdev.focus_out event. Upon
	 * wp_inputfd_device_evdev.focus_out, the compositor may revoke the
	 * fd and further operations will fail.
	 *
	 * However, due to potential race conditions a client must be able
	 * to handle errors as if it opened the fd itself. No guarantee is
	 * given that the wp_inputfd_device_evdev.focus_out event or
	 * wp_inputfd_device_evdev.removed event are sent before the client
	 * encounters an error on the file descriptor.
	 *
	 * A compositor guarantees the file descriptor for a
	 * wp_inputfd_device_evdev refers to the same kernel device after
	 * each focus_in event. In other words, any constant information
	 * about the device obtained through the fd (e.g. the EVIOCGPROP
	 * ioctl) is the same after each focus in event. Thus, a client
	 * needs to do so only once at the first focus_in. This guarantee
	 * does not extend to information that the kernel may change at
	 * runtime (e.g. the EVIOCGABS ioctl).
	 *
	 * If applicable, this event contains the surface that has the
	 * focus. In some cases, the focus may not be tied to a specific
	 * client surface but is given to the client independent of any
	 * surface. In that case, the surface is null.
	 *
	 * The protocol guarantees that focus_in and focus_out always come
	 * in pairs. If the client currently has the focus and the device
	 * is removed, a focus_out event is sent to the client before the
	 * wp_inputfd_device_evdev.removed event.
	 * @param fd file descriptor to the device
	 * @param surface The current surface that has the device's focus
	 */
	void (*focus_in)(void *data,
			 struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1,
			 uint32_t serial,
			 int32_t fd,
			 struct wl_surface *surface);
	/**
	 * input fd device focus out event
	 *
	 * Notification that this client no longer has focus and/or
	 * access to this device. Further reads from this device's file
	 * descriptor may fail. The client must close(2) the file
	 * descriptor received in the wp_inputfd_device_evdev.focus_in
	 * event.
	 *
	 * This event does not mean the device was removed, merely that the
	 * device is focused elsewhere. For device removal, see
	 * wp_inputfd_device_evdev.removed.
	 *
	 * See wp_inputfd_device_evdev.focus_in for more details.
	 */
	void (*focus_out)(void *data,
			  struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1);
};

/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
static inline int
zwp_inputfd_device_evdev_v1_add_listener(struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1,
					 const struct zwp_inputfd_device_evdev_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_inputfd_device_evdev_v1,
				     (void (**)(void)) listener, data);
}

#define ZWP_INPUTFD_DEVICE_EVDEV_V1_DESTROY 0

/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
#define ZWP_INPUTFD_DEVICE_EVDEV_V1_NAME_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
#define ZWP_INPUTFD_DEVICE_EVDEV_V1_USB_ID_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
#define ZWP_INPUTFD_DEVICE_EVDEV_V1_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
#define ZWP_INPUTFD_DEVICE_EVDEV_V1_REMOVED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
#define ZWP_INPUTFD_DEVICE_EVDEV_V1_FOCUS_IN_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
#define ZWP_INPUTFD_DEVICE_EVDEV_V1_FOCUS_OUT_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 */
#define ZWP_INPUTFD_DEVICE_EVDEV_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_inputfd_device_evdev_v1 */
static inline void
zwp_inputfd_device_evdev_v1_set_user_data(struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_inputfd_device_evdev_v1, user_data);
}

/** @ingroup iface_zwp_inputfd_device_evdev_v1 */
static inline void *
zwp_inputfd_device_evdev_v1_get_user_data(struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_inputfd_device_evdev_v1);
}

static inline uint32_t
zwp_inputfd_device_evdev_v1_get_version(struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_inputfd_device_evdev_v1);
}

/**
 * @ingroup iface_zwp_inputfd_device_evdev_v1
 *
 * This destroys the client's resource for this inputfd object.
 */
static inline void
zwp_inputfd_device_evdev_v1_destroy(struct zwp_inputfd_device_evdev_v1 *zwp_inputfd_device_evdev_v1)
{
	wl_proxy_marshal((struct wl_proxy *) zwp_inputfd_device_evdev_v1,
			 ZWP_INPUTFD_DEVICE_EVDEV_V1_DESTROY);

	wl_proxy_destroy((struct wl_proxy *) zwp_inputfd_device_evdev_v1);
}

#ifdef  __cplusplus
}
#endif

#endif
