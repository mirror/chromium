<!DOCTYPE html>
<title>Credential Manager: create() with custom origins.</title>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="/gen/layout_test_data/mojo/public/js/mojo_bindings.js"></script>
<script src="/gen/third_party/WebKit/public/platform/modules/credentialmanager/credential_manager.mojom.js"></script>
<script src="/gen/third_party/WebKit/public/platform/modules/webauth/authenticator.mojom.js"></script>
<script src="resources/credential-helpers.js"></script>
<script>

// For tests that don't require custom-set origins.
if (document.location.hostname == "127.0.0.1")
document.location = "https://subdomain.example.test:8443/credentialmanager/credentialscontainer-create-origins.html";

promise_test(_ => {
  mockAuthenticator.setRawId(raw_id);
  mockAuthenticator.setId(id);
  mockAuthenticator.setClientDataJson(client_data_json);
  mockAuthenticator.setAttestationObject(attestation_object);
  mockAuthenticator.setAuthenticatorStatus(
    webauth.mojom.AuthenticatorStatus.SUCCESS);

  return navigator.credentials.create({publicKey}).then(r => {
      assert_equals(r.id, id, "id");
      assert_true(r.rawId instanceof ArrayBuffer);
      assert_array_equals(new Uint8Array(r.rawId),
          raw_id, "rawId returned is the same");
      assert_true(r.response instanceof AuthenticatorAttestationResponse);
      assert_true(r.response.clientDataJSON instanceof ArrayBuffer);
      assert_array_equals(new Uint8Array(r.response.clientDataJSON),
          client_data_json, "clientDataJSON returned is the same");
      assert_true(r.response.attestationObject instanceof ArrayBuffer);
      assert_array_equals(new Uint8Array(r.response.attestationObject),
          attestation_object, "attestationObject returned is the same");
      assert_not_exists(r.response, 'authenticatorData');
      assert_not_exists(r.response, 'signature');
  });
}, "Verify that the mock returns the values we give it.");

promise_test(t => {
  mockAuthenticator.setAuthenticatorStatus(
      webauth.mojom.AuthenticatorStatus.PENDING_REQUEST);
  return promise_rejects(t, "InvalidStateError",
    navigator.credentials.create({ publicKey }));
}, "Verify that pending request error returned by mock is properly handled.");

promise_test(function (t) {
  mockAuthenticator.setAuthenticatorStatus(
      webauth.mojom.AuthenticatorStatus.UNKNOWN_ERROR);
  return promise_rejects(t, "NotReadableError",
      navigator.credentials.create({ publicKey }));
}, "Verify that unknown error returned by mock is properly handled.");

promise_test(t => {
  mockAuthenticator.setAuthenticatorStatus(
      webauth.mojom.AuthenticatorStatus.NOT_ALLOWED_ERROR);
  return promise_rejects(t, "NotAllowedError",
      navigator.credentials.create({ publicKey }));
}, "Verify that not allowed error returned by mock is properly handled.");

promise_test(t => {
  mockAuthenticator.setAuthenticatorStatus(
      webauth.mojom.AuthenticatorStatus.NOT_SUPPORTED_ERROR);
  return promise_rejects(t, "NotSupportedError",
      navigator.credentials.create({ publicKey }));
}, "Verify that not supported error returned by mock is properly handled.");

promise_test(_ => {
  mockAuthenticator.reset();
  mockAuthenticator.setRawId(raw_id);
  mockAuthenticator.setId(id);
  mockAuthenticator.setClientDataJson(client_data_json);
  mockAuthenticator.setAttestationObject(attestation_object);
  mockAuthenticator.setAuthenticatorStatus(
      webauth.mojom.AuthenticatorStatus.SUCCESS);

  var custom_public_key = {
      challenge,
      rp: { name: "Acme" },
      user: public_key_user,
      pubKeyCredParams: public_key_parameters,
  };

  return navigator.credentials.create({publicKey: custom_public_key}).then(r => {
      assert_equals(r.id, id, 'id');
      assert_true(r.rawId instanceof ArrayBuffer);
      assert_array_equals(new Uint8Array(r.rawId),
          raw_id, "rawId returned is the same");
      assert_true(r.response instanceof AuthenticatorAttestationResponse);
      assert_true(r.response.clientDataJSON instanceof ArrayBuffer);
      assert_array_equals(new Uint8Array(r.response.clientDataJSON),
          client_data_json, "clientDataJSON returned is the same");
      assert_true(r.response.attestationObject instanceof ArrayBuffer);
      assert_array_equals(new Uint8Array(r.response.attestationObject),
          attestation_object, "attestationObject returned is the same");
      assert_not_exists(r.response, 'authenticatorData');
      assert_not_exists(r.response, 'signature');
  });
}, "navigator.credentials.create() with missing rp.id");

// For tests that require custom-set origins.
const VALID_ORIGIN_RPID_PAIRS = [
    { 'origin': 'https://google.test:8443',
      'rpId': 'google.test' },
    { 'origin': 'https://google.test:8443',
      'rpId': '' },
    {'origin': 'https://subdomain.example.test:8443',
      'rpId': 'example.test' },
    {'origin': 'https://subdomain.example.test:8443',
      'rpId': 'subdomain.example.test' },
    {'origin': 'https://localhost:8443',
      'rpId': 'localhost' },
];

for (let test of VALID_ORIGIN_RPID_PAIRS) {
  promise_test(t => {
    return new Promise((resolve, reject) => {
        window.addEventListener('message', t.step_func(e => {
            assert_equals(e.data, "SUCCESS");
            resolve();
        }));
        var w = window.open(test.origin
            + "/credentialmanager/resources/publickey-create-helper.html?rpId="
            + test.rpId);
        });
    }, "navigator.credentials.create({publicKey}) in '" +  test.origin
        + "' with valid |rp.id| '" + test.rpId + "' should succeed.");
}

const INVALID_ORIGIN_RPID_PAIRS = [
    { 'origin': 'https://google.test:8443',
      'rpId': 'localhost' },
    { 'origin': 'https://google.test:8443',
      'rpId': 'foo.google.test' },
    { 'origin': 'https://google.test:8443',
      'rpId': null },
    { 'origin': 'https://google.test:8443',
      'rpId': 'test' },
];

for (let test of INVALID_ORIGIN_RPID_PAIRS) {
  promise_test(t => {
    return new Promise((resolve, reject) => {
        window.addEventListener('message', t.step_func(e => {
            assert_equals(e.data, "SecurityError");
            resolve();
        }));
        var w = window.open(test.origin
            + "/credentialmanager/resources/publickey-create-helper.html?rpId="
            + test.rpId);
    });
  }, "navigator.credentials.create({publicKey}) in '" +  test.origin
      + "' with invalid |rp.id| '" + test.rpId + "' should fail.");
}

</script>