<!DOCTYPE html>
<title>Credential Manager: create() basics.</title>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="/serviceworker/resources/interfaces.js"></script>
<script src="/gen/layout_test_data/mojo/public/js/mojo_bindings.js"></script>
<script src="/gen/third_party/WebKit/public/platform/modules/webauth/authenticator.mojom.js"></script>
<script src="resources/authenticator-helpers.js"></script>
<script>
var publicKey = {
  challenge: new TextEncoder().encode("climb a mountain"),
  rp: {
    id: "1098237235409872",
    name: "Acme"
  },

  user: {
    id: "1098237235409872",
    name: "john.p.smith@example.com",
    displayName: "John P. Smith",
    icon: "https://pics.acme.com/00/p/aBjjjpqPb.png"
  },

  parameters: [
    {
    type: "public-key",
      algorithm: "ES256",
    }
  ],

  excludeList: [],
};

promise_test(function(t) {
    var credential_data = {
        id: 'id',
        password: 'pencil',
    };

    return navigator.credentials.create({password: credential_data})
        .then(function(credential) {
            assert_equals(credential.idName, 'username');
            assert_equals(credential.passwordName, 'password');
            assert_equals(credential.additionalData, null);
        });
}, "navigator.credentials.create() with valid PasswordCredentialData");

promise_test(function(t) {
    var f = document.createElement('form');
    f.innerHTML = "<input type='text' name='theId' value='musterman' autocomplete='username'>"
        + "<input type='text' name='thePassword' value='sekrit' autocomplete='current-password'>"
        + "<input type='text' name='theIcon' value='https://example.com/photo' autocomplete='photo'>"
        + "<input type='text' name='theExtraField' value='extra'>"
        + "<input type='text' name='theName' value='friendly name' autocomplete='name'>";

    return navigator.credentials.create({password: f})
        .then(function(credential) {
            assert_equals(credential.idName, 'theId');
            assert_equals(credential.passwordName, 'thePassword');

            assert_equals(credential.additionalData.get('theId'), 'musterman');
            assert_equals(credential.additionalData.get('thePassword'), 'sekrit');
            assert_equals(credential.additionalData.get('theIcon'),
                    'https://example.com/photo');
            assert_equals(credential.additionalData.get('theName'), 'friendly name');
            assert_equals(credential.additionalData.get('theExtraField'), 'extra');
        });
}, "navigator.credentials.create() with valid HTMLFormElement");

public_key_test(() => {
  var rawId = new TextEncoder("utf-8").encode("rawId");
  var id = btoa("rawId");
  var clientDataJSON = new TextEncoder("utf-8").encode("clientDataJSON");
  var attestationObject = new TextEncoder("utf-8").encode("attestationObject");
  mockAuthenticator.setRawId(rawId);
  mockAuthenticator.setId(id);
  mockAuthenticator.setClientDataJson(clientDataJSON);
  mockAuthenticator.setAttestationObject(attestationObject);

  mockAuthenticator.setAuthenticatorStatus(webauth.mojom.AuthenticatorStatus.SUCCESS);

  return navigator.credentials.create({publicKey}).then(r => {
    assert_equals(r.id, id, "id");
    assert_true(r.rawId instanceof ArrayBuffer);
    console.log(r.rawId);
    assert_array_equals(new Uint8Array(r.rawId),
        rawId, "rawId returned is the same");

    assert_true(r.response instanceof AuthenticatorAttestationResponse);
        console.log(r.response);

    assert_true(r.response.clientDataJSON instanceof ArrayBuffer);
        console.log(r.response.clientDataJSON);

    assert_array_equals(new Uint8Array(r.response.clientDataJSON),
        clientDataJSON, "clientDataJSON returned is the same");

    assert_true(r.response.attestationObject instanceof ArrayBuffer);
    console.log(r.response.attestationObject);

    assert_array_equals(new Uint8Array(r.response.attestationObject),
        attestationObject, "attestationObject returned is the same");

    assert_not_exists(r.response, 'attestationData');
    assert_not_exists(r.response, 'signature');
  });
}, "Verify that the mock returns the values we give it."); 

public_key_test(() => {
  return assertRejectsWithError(navigator.credentials.create(),
                                'NotSupportedError');
}, "navigator.credentials.create() with no argument.");

public_key_test(() => {
  mockAuthenticator.setAuthenticatorStatus(webauth.mojom.AuthenticatorStatus.CANCELLED);
  return assertRejectsWithError(navigator.credentials.create({ publicKey }),
                                'NotAllowedError');
}, "Verify that cancelled error returned by mock is properly handled.");

public_key_test(() => {
  mockAuthenticator.setAuthenticatorStatus(webauth.mojom.AuthenticatorStatus.UNKNOWN_ERROR);
  return assertRejectsWithError(navigator.credentials.create({ publicKey }),
                                'NotReadableError');
}, "Verify that unknown error returned by mock is properly handled.");

public_key_test(() => {
  mockAuthenticator.setAuthenticatorStatus(webauth.mojom.AuthenticatorStatus.NOT_ALLOWED_ERROR);
  return assertRejectsWithError(navigator.credentials.create({ publicKey }),
                                'NotAllowedError');
}, "Verify that not allowed error returned by mock is properly handled.");

public_key_test(() => {
 mockAuthenticator.setAuthenticatorStatus(webauth.mojom.AuthenticatorStatus.NOT_SUPPORTED_ERROR);
  return assertRejectsWithError(navigator.credentials.create({ publicKey }),
                                'NotSupportedError');
}, "Verify that not supported error returned by mock is properly handled.");

public_key_test(() => {
  mockAuthenticator.setAuthenticatorStatus(webauth.mojom.AuthenticatorStatus.SECURITY_ERROR);
  return assertRejectsWithError(navigator.credentials.create({ publicKey }),
                                'SecurityError');
}, "Verify that security error returned by mock is properly handled.");

public_key_test(() => {
 mockAuthenticator.setAuthenticatorStatus(webauth.mojom.AuthenticatorStatus.NOT_IMPLEMENTED);
  return assertRejectsWithError(navigator.credentials.create({ publicKey }),
                                'NotAllowedError'); 
}, 'Verify that not implemented error returned by mock is properly handled.');

</script>
