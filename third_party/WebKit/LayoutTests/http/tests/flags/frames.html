<!DOCTYPE html>
<title>Origin Flags API: Frames</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<style>iframe { display: none; }</style>
<script>
'use strict';

function snooze(t, ms) { return new Promise(r => t.step_timeout(r, ms)); }

let res_num = 0;
function uniqueName() { return 'resource ' + (++res_num); }

function iframe(url) {
  return new Promise(resolve => {
    const element = document.createElement('iframe');
    element.addEventListener(
      'load', () => { resolve(element); }, { once: true });
    element.src = url;
    document.documentElement.appendChild(element);
  });
}

function postAndWait(frame, data) {
  const window = frame.contentWindow;
  window.postMessage(data, '*');
  return new Promise(resolve => {
    const handler = event => {
      if (event.source !== window)
        return;
      self.removeEventListener('message', handler);
      resolve(event.data);
    };
    self.addEventListener('message', handler);
  });
}

promise_test(async t => {
  const res = uniqueName();

  const frame = await iframe('resources/iframe.html');
  t.add_cleanup(() => { frame.remove(); });

  const data = await postAndWait(
    frame, {op: 'request', id: 1, scope: res, mode: 'shared'});

  assert_equals(data.ack, 'request');
  assert_equals(data.id, 1);

  const flag = await requestFlag(res, 'shared');
  const data2 = await postAndWait(frame, {op: 'release', id: 1});
  assert_equals(data2.ack, 'release');
  assert_equals(data2.id, 1);

}, 'Window and Frame - shared mode');

promise_test(async t => {
  const res = uniqueName();

  const frame = await iframe('resources/iframe.html');
  t.add_cleanup(() => { frame.remove(); });

  const data = await postAndWait(
    frame, {op: 'request', id: 1, scope: res, mode: 'exclusive'});
  // Frame has the flag.
  assert_equals(data.ack, 'request');
  assert_equals(data.id, 1);

  // This request should be blocked.
  const blocked = requestFlag(res, 'exclusive');
  let got_it = false;
  blocked.then(f => { got_it = true; });

  await snooze(t, 100);
  // So we can't get it.
  assert_false(got_it);
  // Ask the frame to release it.
  const data2 = await postAndWait(frame, {op: 'release', id: 1});

  // Frame released it.
  assert_equals(data2.ack, 'release');
  assert_equals(data2.id, 1);
  const flag = await blocked;
  // Now we've got it.
  assert_true(got_it);
}, 'Window and Frame - exclusive mode');

promise_test(async t => {
  const res = uniqueName();

  const frame1 = await iframe('resources/iframe.html');
  const frame2 = await iframe('resources/iframe.html');
  const data = await postAndWait(
    frame1, {op: 'request', id: 1, scope: res, mode: 'exclusive'});

  // Frame 1 has the flag.
  assert_equals(data.ack, 'request');
  assert_equals(data.id, 1);

  // This request should be blocked.
  let got_it = false;
  const blocked = postAndWait(
    frame2, {op: 'request', id: 1, scope: res, mode: 'exclusive'});
  blocked.then(f => { got_it = true; });

  await snooze(t, 100);

  // So frame2 can't get it.
  assert_false(got_it);
  // Ask frame1 to release it.
  const data2 = await postAndWait(frame1, {op: 'release', id: 1});
  assert_equals(data2.ack, 'release');
  assert_equals(data2.id, 1);

  const flag = await blocked;
  // Now frame2 can get it.
  assert_true(got_it);
  frame1.parentElement.removeChild(frame1);
  frame2.parentElement.removeChild(frame2);
}, 'Frame and Frame - exclusive mode');

promise_test(async t => {
  const res = uniqueName();

  const frame = await iframe('resources/iframe.html');
  const data = await postAndWait(
    frame, {op: 'request', id: 1, scope: res, mode: 'exclusive'});
  // Frame has the flag.
  assert_equals(data.ack, 'request');
  assert_equals(data.id, 1);

  // This request should be blocked.
  const blocked = requestFlag(res, 'exclusive');
  let got_it = false;
  blocked.then(f => { got_it = true; });

  await snooze(t, 100);
  // So we can't get it.
  assert_false(got_it);

  // Implicitly release it by terminating the frame.
  frame.remove();
  const flag = await blocked;
  // Now we've got it.
  assert_true(got_it);

}, 'Terminated Frame with held flag');

promise_test(async t => {
  const res1 = uniqueName();
  const res2 = uniqueName();

  // frame1 requests and holds [r1] - should be granted immediately
  // frame2 requests [r1, r2] - should be blocked
  // frame3 requests [r2] - should be blocked
  // frame2 is terminated
  // frame3's request should be granted

  const frame1 = await iframe('resources/iframe.html');
  const frame2 = await iframe('resources/iframe.html');
  const frame3 = await iframe('resources/iframe.html');
  t.add_cleanup(() => { frame1.remove(); });
  // frame2 is removed as part of the test below
  t.add_cleanup(() => { frame3.remove(); });

  // frame1 requests and holds [r1] - should be granted immediately
  const data = await postAndWait(
    frame1, {op: 'request', id: 1, scope: res1, mode: 'exclusive'});

  assert_equals(data.ack, 'request');
  assert_equals(data.id, 1);

  // frame2 requests [r1, r2] - should be blocked
  const never = postAndWait(
    frame2, {op: 'request', id: 1, scope: [res1, res2], mode: 'exclusive'});
  never.then(t.unreached_func('frame2 should never acquire res1+res2'));

  // frame3 requests [r2] - should be blocked
  let got_it = false;
  const blocked = postAndWait(
    frame3, {op: 'request', id: 1, scope: res2, mode: 'exclusive'});
  blocked.then(f => { got_it = true; });

  await snooze(t, 100);

  assert_false(got_it);

  // frame2 is terminated
  frame2.remove();

  // TODO(jsbell): Remove this timeout once it's passing.
  t.step_timeout(() => {
    assert_true(got_it, 'Removed frame did not release held flags');
  }, 100);

  // frame3's request should be granted
  await blocked;
  assert_true(got_it);

}, 'Terminated Frame with pending request');

</script>
