This is a testharness.js-based test.
Harness Error. harness_status.status = 1 , harness_status.message = 30 duplicate test names: "Aborting a WritableStream should cause the writer's unsettled ready promise to reject", "Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one", "abort() on a released writer rejects", "Aborting a WritableStream immediately prevents future writes", "Aborting a WritableStream prevents further writes after any that are in progress", "Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value", "WritableStream if sink's abort throws, the promise returned by writer.abort() rejects", "WritableStream if sink's abort throws, the promise returned by ws.abort() rejects", "WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects", "Aborting a WritableStream passes through the given reason", "Aborting a WritableStream puts it in an errored state, with a TypeError as the stored error", "Aborting a WritableStream causes any outstanding write() promises to be rejected with a TypeError", "Closing but then immediately aborting a WritableStream causes the stream to error", "Closing a WritableStream and aborting it while it closes causes the stream to error", "Aborting a WritableStream after it is closed is a no-op", "WritableStream should NOT call underlying sink's close if no abort is supplied (historical)", "returning a thenable from abort() should work", ".closed should not resolve before fulfilled write()", ".closed should not resolve before rejected write(); write() error should overwrite abort() error", "writes should be satisfied in order when aborting", "writes should be satisfied in order after rejected write when aborting", "close() should use error from underlying write() on abort", "underlying abort() should not be called until underlying write() completes", "underlying abort() should not be called if underlying close() has started", "if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason", "underlying abort() should be called while closing if underlying close() has not started yet", "writer close() promise should resolve before abort() promise", "writer.ready should reject on controller error without waiting for underlying write", "releaseLock() while aborting should reject the original closed promise", "releaseLock() during delayed async abort() should create a new rejected closed promise"
PASS Aborting a WritableStream should cause the writer's unsettled ready promise to reject 
PASS Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one 
PASS abort() on a released writer rejects 
PASS Aborting a WritableStream immediately prevents future writes 
PASS Aborting a WritableStream prevents further writes after any that are in progress 
PASS Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value 
PASS WritableStream if sink's abort throws, the promise returned by writer.abort() rejects 
PASS WritableStream if sink's abort throws, the promise returned by ws.abort() rejects 
PASS WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects 
PASS Aborting a WritableStream passes through the given reason 
PASS Aborting a WritableStream puts it in an errored state, with a TypeError as the stored error 
PASS Aborting a WritableStream causes any outstanding write() promises to be rejected with a TypeError 
PASS Closing but then immediately aborting a WritableStream causes the stream to error 
PASS Closing a WritableStream and aborting it while it closes causes the stream to error 
PASS Aborting a WritableStream after it is closed is a no-op 
PASS WritableStream should NOT call underlying sink's close if no abort is supplied (historical) 
PASS returning a thenable from abort() should work 
PASS .closed should not resolve before fulfilled write() 
PASS .closed should not resolve before rejected write(); write() error should overwrite abort() error 
PASS writes should be satisfied in order when aborting 
PASS writes should be satisfied in order after rejected write when aborting 
PASS close() should use error from underlying write() on abort 
PASS underlying abort() should not be called until underlying write() completes 
PASS underlying abort() should not be called if underlying close() has started 
PASS if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason 
PASS underlying abort() should be called while closing if underlying close() has not started yet 
PASS writer close() promise should resolve before abort() promise 
PASS writer.ready should reject on controller error without waiting for underlying write 
PASS releaseLock() while aborting should reject the original closed promise 
PASS releaseLock() during delayed async abort() should create a new rejected closed promise 
PASS Untitled 
PASS Aborting a WritableStream should cause the writer's unsettled ready promise to reject 
PASS Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one 
PASS abort() on a released writer rejects 
PASS Aborting a WritableStream immediately prevents future writes 
PASS Aborting a WritableStream prevents further writes after any that are in progress 
PASS Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value 
PASS WritableStream if sink's abort throws, the promise returned by writer.abort() rejects 
PASS WritableStream if sink's abort throws, the promise returned by ws.abort() rejects 
PASS WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects 
PASS Aborting a WritableStream passes through the given reason 
PASS Aborting a WritableStream puts it in an errored state, with a TypeError as the stored error 
PASS Aborting a WritableStream causes any outstanding write() promises to be rejected with a TypeError 
PASS Closing but then immediately aborting a WritableStream causes the stream to error 
PASS Closing a WritableStream and aborting it while it closes causes the stream to error 
PASS Aborting a WritableStream after it is closed is a no-op 
PASS WritableStream should NOT call underlying sink's close if no abort is supplied (historical) 
PASS returning a thenable from abort() should work 
PASS .closed should not resolve before fulfilled write() 
PASS .closed should not resolve before rejected write(); write() error should overwrite abort() error 
PASS writes should be satisfied in order when aborting 
PASS writes should be satisfied in order after rejected write when aborting 
PASS close() should use error from underlying write() on abort 
PASS underlying abort() should not be called until underlying write() completes 
PASS underlying abort() should not be called if underlying close() has started 
PASS if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason 
PASS underlying abort() should be called while closing if underlying close() has not started yet 
PASS writer close() promise should resolve before abort() promise 
PASS writer.ready should reject on controller error without waiting for underlying write 
PASS releaseLock() while aborting should reject the original closed promise 
PASS releaseLock() during delayed async abort() should create a new rejected closed promise 
PASS Aborting a WritableStream should cause the writer's unsettled ready promise to reject 
PASS Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one 
PASS abort() on a released writer rejects 
PASS Aborting a WritableStream immediately prevents future writes 
PASS Aborting a WritableStream prevents further writes after any that are in progress 
PASS Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value 
PASS WritableStream if sink's abort throws, the promise returned by writer.abort() rejects 
PASS WritableStream if sink's abort throws, the promise returned by ws.abort() rejects 
PASS WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects 
PASS Aborting a WritableStream passes through the given reason 
PASS Aborting a WritableStream puts it in an errored state, with a TypeError as the stored error 
PASS Aborting a WritableStream causes any outstanding write() promises to be rejected with a TypeError 
PASS Closing but then immediately aborting a WritableStream causes the stream to error 
PASS Closing a WritableStream and aborting it while it closes causes the stream to error 
PASS Aborting a WritableStream after it is closed is a no-op 
PASS WritableStream should NOT call underlying sink's close if no abort is supplied (historical) 
PASS returning a thenable from abort() should work 
PASS .closed should not resolve before fulfilled write() 
PASS .closed should not resolve before rejected write(); write() error should overwrite abort() error 
PASS writes should be satisfied in order when aborting 
PASS writes should be satisfied in order after rejected write when aborting 
PASS close() should use error from underlying write() on abort 
PASS underlying abort() should not be called until underlying write() completes 
PASS underlying abort() should not be called if underlying close() has started 
PASS if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason 
PASS underlying abort() should be called while closing if underlying close() has not started yet 
PASS writer close() promise should resolve before abort() promise 
PASS writer.ready should reject on controller error without waiting for underlying write 
PASS releaseLock() while aborting should reject the original closed promise 
PASS releaseLock() during delayed async abort() should create a new rejected closed promise 
PASS Aborting a WritableStream should cause the writer's unsettled ready promise to reject 
PASS Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one 
PASS abort() on a released writer rejects 
PASS Aborting a WritableStream immediately prevents future writes 
PASS Aborting a WritableStream prevents further writes after any that are in progress 
PASS Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value 
PASS WritableStream if sink's abort throws, the promise returned by writer.abort() rejects 
PASS WritableStream if sink's abort throws, the promise returned by ws.abort() rejects 
PASS WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects 
PASS Aborting a WritableStream passes through the given reason 
PASS Aborting a WritableStream puts it in an errored state, with a TypeError as the stored error 
PASS Aborting a WritableStream causes any outstanding write() promises to be rejected with a TypeError 
PASS Closing but then immediately aborting a WritableStream causes the stream to error 
PASS Closing a WritableStream and aborting it while it closes causes the stream to error 
PASS Aborting a WritableStream after it is closed is a no-op 
PASS WritableStream should NOT call underlying sink's close if no abort is supplied (historical) 
PASS returning a thenable from abort() should work 
PASS .closed should not resolve before fulfilled write() 
PASS .closed should not resolve before rejected write(); write() error should overwrite abort() error 
PASS writes should be satisfied in order when aborting 
PASS writes should be satisfied in order after rejected write when aborting 
PASS close() should use error from underlying write() on abort 
PASS underlying abort() should not be called until underlying write() completes 
PASS underlying abort() should not be called if underlying close() has started 
PASS if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason 
PASS underlying abort() should be called while closing if underlying close() has not started yet 
PASS writer close() promise should resolve before abort() promise 
PASS writer.ready should reject on controller error without waiting for underlying write 
PASS releaseLock() while aborting should reject the original closed promise 
PASS releaseLock() during delayed async abort() should create a new rejected closed promise 
Harness: the test ran to completion.

