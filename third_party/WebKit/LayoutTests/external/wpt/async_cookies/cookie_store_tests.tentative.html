<!DOCTYPE html>
<meta charset="utf-8">
<title>Async Cookes: Basic tests for cookieStore</title>
<meta name="help" href="https://github.com/WICG/async-cookies-api/blob/gh-pages/explainer.md">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/testharness-helpers.js"></script>
<!--
 ! Document-based polyfill for bootstrapping; current version here:
 ! https://github.com/WICG/async-cookies-api/raw/gh-pages/cookies.js
 !-->
<script src="resources/cookie-store-polyfill.js"></script>
<script>
'use strict';

let savedExceptions = [];

const includeTest = testName => {
  assert_equals(!!testName.match(/^test\w+/), true, 'includeTest: ' + testName);
  assert_equals(typeof eval(testName), 'function', 'includeTest: ' + testName);
  let testParams =
        (location.hash || '#').substr(1).split('&').filter(
            x => x.match(/^test=/)).map(x => decodeURIComponent(x));
  if (!testParams.length) testParams = ['test=all'];
  const filterSet =
        testParams.map(x => x.split('=', 2)[1]).join(',').split(',').reduce(
            (set, name) => Object.assign(set, {[name]: true}), {});
  for (let name in filterSet) {
    if (name === 'all' || !filterSet.hasOwnProperty(name)) continue;
    assert_equals(!!name.match(/^test\w+/), true, '#test=' + testName);
    assert_equals(typeof eval(name), 'function', '#test=' + testName);
  }
  return filterSet.all ||
      filterSet.hasOwnProperty(testName) && filterSet[testName];
}

const IS_UNSECURED = location.protocol !== 'https:';

const IS_STATIC = !!(location.hash || '#').match(/(^#|&)static=true(&|$)/);

const COOKIE_HELPER_CGI = 'resources/cookie_helper.py';

const promise_rejects_when_unsecured = async (
    testCase,
    code,
    promise,
    message = 'Feature unavailable from unsecured contexts'
) => {
  if (IS_UNSECURED) await promise_rejects(testCase, code, promise, message);
  else await promise;
};

// These cases were initially based on the async cookies API interactive tests:
//
// https://raw.githubusercontent.com/WICG/async-cookies-api/gh-pages/cookies_test.js

function getOneSimpleOriginCookie() {
  return cookieStore.get('__Host-COOKIENAME').then(function(cookie) {
    if (!cookie) return undefined;
    return cookie.value;
  });
}

// Converts a list of cookie records {name, value} to [name=]value; ... as
// seen in Cookie: and document.cookie.
const cookieString = cookies => cookies.length ? cookies.map((
    {name, value}) => (name ? (name + '=') : '') + value).join('; ') :
      undefined;

// Approximate async equivalent to the document.cookie getter but with
// important differences: optional additional getAll arguments are
// forwarded, and an empty cookie jar returns undefined.
//
// This is intended primarily for verification against expected cookie
// jar contents. It should produce more readable messages using
// assert_equals in failing cases than assert_object_equals would
// using parsed cookie jar contents and also allows expectations to be
// written more compactly.
const getCookieString = async(...args) => {
  return cookieString(await cookieStore.getAll(...args));
}

// Approximate async equivalent to the document.cookie getter but from
// the server's point of view. Returns UTF-8 interpretation. Allows
// sub-path to be specified.
//
// Unlike document.cookie, this returns undefined when no cookies are
// present.
const getCookieStringHttp = async(extraPath = null) => {
  if (IS_STATIC) throw 'CGI not available in static HTML test';
  const url =
        COOKIE_HELPER_CGI + ((extraPath == null) ? '' : ('/' + extraPath));
  const response = await fetch(url, { credentials: 'include' });
  const text = await response.text();
  assert_equals(
      response.ok,
      true,
      'CGI should have succeeded in getCookieStringHttp\n' + text);
  assert_equals(
      response.headers.get('content-type'),
      'text/plain; charset=utf-8',
      'CGI did not return UTF-8 text in getCookieStringHttp');
  if (text === '') return undefined;
  assert_equals(
      text.indexOf('cookie='),
      0,
      'CGI response did not begin with "cookie=" and was not empty: ' + text);
  return decodeURIComponent(text.replace(/^cookie=/, ''));
}

// Approximate async equivalent to the document.cookie getter but from
// the server's point of view. Returns binary string
// interpretation. Allows sub-path to be specified.
//
// Unlike document.cookie, this returns undefined when no cookies are
// present.
const getCookieBinaryHttp = async(extraPath = null) => {
  if (IS_STATIC) throw 'CGI not available in static HTML test';
  const url =
        COOKIE_HELPER_CGI +
        ((extraPath == null) ?
         '' :
         ('/' + extraPath)) + '?charset=iso-8859-1';
  const response = await fetch(url, { credentials: 'include' });
  const text = await response.text();
  assert_equals(
      response.ok,
      true,
      'CGI should have succeeded in getCookieBinaryHttp\n' + text);
  assert_equals(
      response.headers.get('content-type'),
      'text/plain; charset=iso-8859-1',
      'CGI did not return ISO 8859-1 text in getCookieBinaryHttp');
  if (text === '') return undefined;
  assert_equals(
      text.indexOf('cookie='),
      0,
      'CGI response did not begin with "cookie=" and was not empty: ' + text);
  return unescape(text.replace(/^cookie=/, ''));
}

// Approximate async equivalent to the document.cookie setter but from
// the server's point of view.
const setCookieStringHttp = async setCookie => {
  if (IS_STATIC) throw 'CGI not available in static HTML test';
  const encodedSetCookie = encodeURIComponent(setCookie);
  const url = COOKIE_HELPER_CGI;
  const headers = new Headers();
  headers.set(
      'content-type',
      'application/x-www-form-urlencoded; charset=utf-8');
  const response = await fetch(
      url,
      {
        credentials: 'include',
        method: 'POST',
        headers: headers,
        body: 'set-cookie=' + encodedSetCookie,
      });
  const text = await response.text();
  assert_equals(
      response.ok,
      true,
      'CGI should have succeeded in setCookieStringHttp set-cookie: ' +
        setCookie + '\n' + text);
  assert_equals(
      response.headers.get('content-type'),
      'text/plain; charset=utf-8',
      'CGI did not return UTF-8 text in setCookieStringHttp');
  assert_equals(
      text,
      'set-cookie=' + encodedSetCookie,
      'CGI did not faithfully echo the set-cookie value');
};

// Approximate async equivalent to the document.cookie setter but from
// the server's point of view. This version sets a binary cookie rather
// than a UTF-8 one.
const setCookieBinaryHttp = async setCookie => {
  if (IS_STATIC) throw 'CGI not available in static HTML test';
  const encodedSetCookie = escape(setCookie).split('/').join('%2F');
  const url = COOKIE_HELPER_CGI + '?charset=iso-8859-1';
  const headers = new Headers();
  headers.set(
      'content-type',
      'application/x-www-form-urlencoded; charset=iso-8859-1');
  const response = await fetch(url, {
    credentials: 'include',
    method: 'POST',
    headers: headers,
    body: 'set-cookie=' + encodedSetCookie
  });
  const text = await response.text();
  assert_equals(
      response.ok,
      true,
      'CGI should have succeeded in setCookieBinaryHttp set-cookie: ' +
        setCookie + '\n' + text);
  assert_equals(
      response.headers.get('content-type'),
      'text/plain; charset=iso-8859-1',
      'CGI did not return Latin-1 text in setCookieBinaryHttp');
  assert_equals(
      text,
      'set-cookie=' + encodedSetCookie,
      'CGI did not faithfully echo the set-cookie value');
};

// Approximate async equivalent to the document.cookie setter but using
// <meta http-equiv="set-cookie" content="...">
const setCookieStringMeta = async setCookie => {
  const meta = Object.assign(document.createElement('meta'), {
    httpEquiv: 'set-cookie',
    content: setCookie
  });
  document.head.appendChild(meta);
  await new Promise(resolve => requestAnimationFrame(resolve));
  meta.parentNode.removeChild(meta);
};

// Async document.cookie getter; converts '' to undefined which loses
// information in the edge case where a single ''-valued anonymous
// cookie is visible.
const getCookieStringDocument = async () => {
  return String(document.cookie || '') || undefined;
};

// Async document.cookie setter
const setCookieStringDocument = async setCookie => {
  document.cookie = setCookie;
};

// Observer-based document.cookie simulator
let observationLog = [];
let observedStore = [];

const getCookieStringObserved = async opt_name => {
  // Run two tasks later to ensure the cookie scanner (which runs one
  // task later) has a chance.
  observationLog.push(
      ['getCookieStringObserved:t0:document.cookie', document.cookie]);
  await new Promise(resolve => s\u0065tTimeout(resolve));
  observationLog.push(
      ['getCookieStringObserved:t1:document.cookie', document.cookie]);
  await new Promise(resolve => s\u0065tTimeout(resolve));
  observationLog.push(
      ['getCookieStringObserved:t2:document.cookie', document.cookie]);
  let filtered = observedStore;
  if (opt_name != null) filtered = filtered.filter(
      cookie => cookie.name === opt_name);
  return cookieString(filtered);
};

promise_test(async testCase => {
  savedExceptions = [];
  let observer;
  assert_equals(
      await getCookieString(),
      undefined,
      'No cookies at start of test');
  if (!IS_STATIC) assert_equals(
      await getCookieStringHttp(),
      undefined,
      'No HTTP cookies at start of test');
  assert_equals(
      await getCookieStringDocument(),
      undefined,
      'No document.cookie cookies at start of test');
  let unfinished = true;
  try {
    if (includeTest('testObservation')) {
      observer = await testObservation();
      assert_equals(
          await getCookieStringObserved(),
          undefined,
          'No observed cookies at start of test');
    }
    // These use the same cookie names and so cannot run interleaved
    if (includeTest('testNoNameAndNoValue')) {
      await testNoNameAndNoValue();
      assert_equals(
          await getCookieString(),
          undefined,
          'Empty cookie jar after testNoNameAndNoValue');
      if (!IS_STATIC) assert_equals(
          await getCookieStringHttp(),
          undefined,
          'Empty HTTP cookie jar after testNoNameAndNoValue');
      assert_equals(
          await getCookieStringDocument(),
          undefined,
          'Empty document.cookie cookie jar after testNoNameAndNoValue');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          undefined,
          'Empty observed cookie jar after testNoNameAndNoValue');
    }
    if (includeTest('testNoNameMultipleValues')) {
      await testNoNameMultipleValues();
      assert_equals(
          await getCookieString(),
          undefined,
          'Empty cookie jar after testNoNameMultipleValues');
      if (!IS_STATIC) assert_equals(
          await getCookieStringHttp(),
          undefined,
          'Empty HTTP cookie jar after testNoNameMultipleValues');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          undefined,
          'Empty observed cookie jar after testNoNameMultipleValues');
    }
    if (includeTest('testNoNameEqualsInValue')) {
      await testNoNameEqualsInValue();
      assert_equals(
          await getCookieString(),
          undefined,
          'Empty cookie jar after testNoNameEqualsInValue');
      if (!IS_STATIC) assert_equals(
          await getCookieStringHttp(),
          undefined,
          'Empty HTTP cookie jar after testNoNameEqualsInValue');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          undefined,
          'Empty observed cookie jar after testNoNameEqualsInValue');
    }
    await setCookieStringMeta('META-🍪=🔵; path=/');
    assert_equals(
        await getCookieString(),
        'META-🍪=🔵',
        'Cookie we wrote using META in cookie jar');
    if (!IS_STATIC) assert_equals(
        await getCookieStringHttp(),
        'META-🍪=🔵',
        'Cookie we wrote using META in HTTP cookie jar');
    if (includeTest('testObservation')) assert_equals(
        await getCookieStringObserved(),
        'META-🍪=🔵',
        'Cookie we wrote using META in observed cookie jar');
    await setCookieStringMeta('META-🍪=DELETED; path=/; max-age=0');
    assert_equals(
        await getCookieString(),
        undefined,
        'Empty cookie jar after META cookie-clearing using max-age=0');
    if (!IS_STATIC) assert_equals(
        await getCookieStringHttp(),
        undefined,
        'Empty HTTP cookie jar after META cookie-clearing using max-age=0');
    if (includeTest('testObservation')) assert_equals(
        await getCookieStringObserved(),
        undefined,
        'Empty observed cookie jar after META cookie-clearing using max-age=0');
    await setCookieStringDocument('DOCUMENT-🍪=🔵; path=/');
    assert_equals(
        await getCookieString(),
        'DOCUMENT-🍪=🔵',
        'Cookie we wrote using document.cookie in cookie jar');
    if (!IS_STATIC) assert_equals(
        await getCookieStringHttp(),
        'DOCUMENT-🍪=🔵',
        'Cookie we wrote using document.cookie in HTTP cookie jar');
    assert_equals(
        await getCookieStringDocument(),
        'DOCUMENT-🍪=🔵',
        'Cookie we wrote using document.cookie in document.cookie');
    if (includeTest('testObservation')) assert_equals(
        await getCookieStringObserved(),
        'DOCUMENT-🍪=🔵',
        'Cookie we wrote using document.cookie in observed cookie jar');
    await setCookieStringDocument('DOCUMENT-🍪=DELETED; path=/; max-age=0');
    assert_equals(
        await getCookieString(),
        undefined,
        'Empty cookie jar after document.cookie' +
          ' cookie-clearing using max-age=0');
    if (!IS_STATIC) assert_equals(
        await getCookieStringHttp(),
        undefined,
        'Empty HTTP cookie jar after document.cookie' +
          ' cookie-clearing using max-age=0');
    assert_equals(
        await getCookieStringDocument(),
        undefined,
        'Empty document.cookie cookie jar after document.cookie' +
          ' cookie-clearing using max-age=0');
    if (includeTest('testObservation')) assert_equals(
        await getCookieStringObserved(),
        undefined,
        'Empty observed cookie jar after document.cookie cookie-clearing' +
          ' using max-age=0');
    if (!IS_STATIC) {
      await setCookieStringHttp('HTTP-🍪=🔵; path=/');
      assert_equals(
          await getCookieString(),
          'HTTP-🍪=🔵',
          'Cookie we wrote using HTTP in cookie jar');
      assert_equals(
          await getCookieStringHttp(),
          'HTTP-🍪=🔵',
          'Cookie we wrote using HTTP in HTTP cookie jar');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          'HTTP-🍪=🔵',
          'Cookie we wrote using HTTP in observed cookie jar');
      await setCookieStringHttp('HTTP-🍪=DELETED; path=/; max-age=0');
      assert_equals(
          await getCookieString(),
          undefined,
          'Empty cookie jar after HTTP cookie-clearing using max-age=0');
      assert_equals(
          await getCookieStringHttp(),
          undefined,
          'Empty HTTP cookie jar after HTTP cookie-clearing using max-age=0');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          undefined,
          'Empty observed cookie jar after HTTP cookie-clearing' +
            ' using max-age=0');
      await setCookieStringHttp('HTTPONLY-🍪=🔵; path=/; httponly');
      assert_equals(
          await getCookieString(),
          undefined,
          'HttpOnly cookie we wrote using HTTP in cookie jar' +
            ' is invisible to script');
      assert_equals(
          await getCookieStringHttp(),
          'HTTPONLY-🍪=🔵',
          'HttpOnly cookie we wrote using HTTP in HTTP cookie jar');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          undefined,
          'HttpOnly cookie we wrote using HTTP is invisible to observer');
      await setCookieStringHttp(
          'HTTPONLY-🍪=DELETED; path=/; max-age=0; httponly');
      assert_equals(
          await getCookieString(),
          undefined,
          'Empty cookie jar after HTTP cookie-clearing using max-age=0');
      assert_equals(
          await getCookieStringHttp(),
          undefined,
          'Empty HTTP cookie jar after HTTP cookie-clearing using max-age=0');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          undefined,
          'Empty observed cookie jar after HTTP cookie-clearing' +
            ' using max-age=0');
      // TODO: determine why non-UTF-8 byte sequences cause the
      // Set-Cookie to be dropped and determine whether this is
      // always the case.
      await setCookieBinaryHttp(
          unescape(encodeURIComponent('HTTP-🍪=🔵')) + '\xef\xbf\xbd; path=/');
      assert_equals(
          await getCookieString(),
          'HTTP-🍪=🔵\ufffd',
          'Binary cookie we wrote using HTTP in cookie jar');
      assert_equals(
          await getCookieStringHttp(),
          'HTTP-🍪=🔵\ufffd',
          'Binary cookie we wrote using HTTP in HTTP cookie jar');
      assert_equals(
          decodeURIComponent(escape(await getCookieBinaryHttp())),
          'HTTP-🍪=🔵\ufffd',
          'Binary cookie we wrote in binary HTTP cookie jar');
      assert_equals(
          await getCookieBinaryHttp(),
          unescape(encodeURIComponent('HTTP-🍪=🔵')) + '\xef\xbf\xbd',
          'Binary cookie we wrote in binary HTTP cookie jar');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          'HTTP-🍪=🔵\ufffd',
          'Binary cookie we wrote using HTTP in observed cookie jar');
      await setCookieBinaryHttp(
          unescape(encodeURIComponent('HTTP-🍪=DELETED; path=/; max-age=0')));
      assert_equals(
          await getCookieString(),
          undefined,
          'Empty cookie jar after binary HTTP cookie-clearing using max-age=0');
      assert_equals(
          await getCookieStringHttp(),
          undefined,
          'Empty HTTP cookie jar after' +
            ' binary HTTP cookie-clearing using max-age=0');
      assert_equals(
          await getCookieBinaryHttp(),
          undefined,
          'Empty binary HTTP cookie jar after' +
            ' binary HTTP cookie-clearing using max-age=0');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          undefined,
          'Empty observed cookie jar after binary HTTP cookie-clearing' +
            ' using max-age=0');
    }
    await cookieStore.set('TEST', 'value0');
    assert_equals(
        await getCookieString(),
        'TEST=value0',
        'Cookie jar contains only cookie we set');
    if (!IS_STATIC) assert_equals(
        await getCookieStringHttp(),
        'TEST=value0',
        'HTTP cookie jar contains only cookie we set');
    if (includeTest('testObservation')) assert_equals(
        await getCookieStringObserved(),
        'TEST=value0',
        'Observed cookie jar contains only cookie we set');
    await cookieStore.set('TEST', 'value');
    assert_equals(
        await getCookieString(),
        'TEST=value',
        'Cookie jar contains only cookie we overwrote');
    if (!IS_STATIC) assert_equals(
        await getCookieStringHttp(),
        'TEST=value',
        'HTTP cookie jar contains only cookie we overwrote');
    if (includeTest('testObservation')) assert_equals(
        await getCookieStringObserved(),
        'TEST=value',
        'Observed cookie jar contains only cookie we overwrote');
    let allCookies = await cookieStore.getAll();
    assert_equals(
        allCookies[0].name,
        'TEST',
        'First entry in allCookies should be named TEST');
    assert_equals(
        allCookies[0].value,
        'value',
        'First entry in allCookies should have value "value"');
    assert_equals(
        allCookies.length,
        1,
        'Only one cookie should exist in allCookies');
    let firstCookie = await cookieStore.get();
    assert_equals(
        firstCookie.name,
        'TEST',
        'First cookie should be named TEST');
    assert_equals(
        firstCookie.value,
        'value',
        'First cookie should have value "value"');
    let allCookies_TEST = await cookieStore.getAll('TEST');
    assert_equals(
        allCookies_TEST[0].name,
        'TEST',
        'First entry in allCookies_TEST should be named TEST');
    assert_equals(
        allCookies_TEST[0].value,
        'value',
        'First entry in allCookies_TEST should have value "value"');
    assert_equals(
        allCookies_TEST.length,
        1,
        'Only one cookie should exist in allCookies_TEST');
    let firstCookie_TEST = await cookieStore.get('TEST');
    assert_equals(
        firstCookie_TEST.name,
        'TEST',
        'First TEST cookie should be named TEST');
    assert_equals(
        firstCookie_TEST.value,
        'value',
        'First TEST cookie should have value "value"');
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        setOneSimpleOriginSessionCookie(),
        '__Host- prefix only writable from' +
          ' secure contexts (setOneSimpleOriginSessionCookie)');
    if (!IS_UNSECURED) {
      assert_equals(
          await getOneSimpleOriginCookie(),
          'cookie-value',
          '__Host-COOKIENAME cookie should be found' +
            ' in a secure context (getOneSimpleOriginCookie)');
    } else {
      assert_equals(
          await getOneSimpleOriginCookie(),
          undefined,
          '__Host-COOKIENAME cookie should not be found' +
            ' in an unsecured context (getOneSimpleOriginCookie)');
    }
    if (!IS_UNSECURED) {
      assert_equals(
          await getOneSimpleOriginCookieAsync(),
          'cookie-value',
          '__Host-COOKIENAME cookie should be found' +
            ' in a secure context (getOneSimpleOriginCookieAsync)');
    } else {
      assert_equals(
          await getOneSimpleOriginCookieAsync(),
          undefined,
          '__Host-COOKIENAME cookie should not be found' +
            ' in an unsecured context (getOneSimpleOriginCookieAsync)');
    }
    if (IS_UNSECURED) {
      assert_equals(
          await countMatchingSimpleOriginCookies(),
          0,
          'No __Host-COOKIEN* cookies should be found' +
            ' in an unsecured context (countMatchingSimpleOriginCookies)');
    } else {
      assert_equals(
          await countMatchingSimpleOriginCookies(),
          1,
          'One __Host-COOKIEN* cookie should be found' +
            ' in a secur context (countMatchingSimpleOriginCookies)');
    }
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        setOneDaySecureCookieWithDate(),
        'Secure cookies only writable' +
          ' from secure contexts (setOneDaySecureCookieWithDate)');
    await setOneDayUnsecuredCookieWithMillisecondsSinceEpoch();
    assert_equals(
        await getCookieString('LEGACYCOOKIENAME'),
        'LEGACYCOOKIENAME=cookie-value',
        'Ensure unsecured cookie we set is visible');
    if (includeTest('testObservation')) assert_equals(
        await getCookieStringObserved('LEGACYCOOKIENAME'),
        'LEGACYCOOKIENAME=cookie-value',
        'Ensure unsecured cookie we set is visible to observer');
    await deleteUnsecuredCookieWithDomainAndPath();
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        setSecureCookieWithHttpLikeExpirationString(),
        'Secure cookies only writable from secure contexts' +
          ' (setSecureCookieWithHttpLikeExpirationString)');
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        setThreeSimpleOriginSessionCookiesSequentially(),
        '__Host- cookies only writable from secure contexts' +
          ' (setThreeSimpleOriginSessionCookiesSequentially)');
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        setThreeSimpleOriginSessionCookiesNonsequentially(),
        '__Host- cookies only writable from secure contexts' +
          ' (setThreeSimpleOriginSessionCookiesNonsequentially)');
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        setExpiredSecureCookieWithDomainPathAndFallbackValue(),
        'Secure cookies only writable from secure contexts' +
          ' (setExpiredSecureCookieWithDomainPathAndFallbackValue)');
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        deleteSimpleOriginCookie(),
        '__Host- cookies only writable from secure contexts' +
          ' (deleteSimpleOriginCookie)');
    await promise_rejects_when_unsecured(
        testCase,
        new SyntaxError(),
        deleteSecureCookieWithDomainAndPath(),
        'Secure cookies only writable from secure contexts' +
          ' (deleteSecureCookieWithDomainAndPath)');
    if (IS_UNSECURED) {
      assert_equals(
          await getCookieString(),
          'TEST=value',
          'Only one unsecured cookie before cleanup at end of test');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          'TEST=value',
          'Only one unsecured cookie before cleanup at end of test');
    } else {
      assert_equals(
          await getCookieString(),
          'TEST=value; ' +
            '__Host-🍪=🔵cookie-value1🔴; ' +
            '__Host-🌟=🌠cookie-value2🌠; ' +
            '__Host-🌱=🔶cookie-value3🔷; ' +
            '__Host-unordered🍪=🔵unordered-cookie-value1🔴; ' +
            '__Host-unordered🌟=🌠unordered-cookie-value2🌠; ' +
            '__Host-unordered🌱=🔶unordered-cookie-value3🔷',
          'All residual cookies before cleanup at end of test');
      if (includeTest('testObservation')) assert_equals(
          await getCookieStringObserved(),
          'TEST=value; ' +
            '__Host-🍪=🔵cookie-value1🔴; ' +
            '__Host-🌟=🌠cookie-value2🌠; ' +
            '__Host-🌱=🔶cookie-value3🔷; ' +
            '__Host-unordered🍪=🔵unordered-cookie-value1🔴; ' +
            '__Host-unordered🌟=🌠unordered-cookie-value2🌠; ' +
            '__Host-unordered🌱=🔶unordered-cookie-value3🔷',
          'All residual observed cookies before cleanup at end of test');
    }
    if (IS_UNSECURED) {
      if (!IS_STATIC) assert_equals(
          await getCookieStringHttp(),
          'TEST=value',
          'Only one unsecured HTTP cookie before cleanup at end of test');
    } else {
      if (!IS_STATIC) assert_equals(
          await getCookieStringHttp(),
          'TEST=value; ' +
            '__Host-🍪=🔵cookie-value1🔴; ' +
            '__Host-🌟=🌠cookie-value2🌠; ' +
            '__Host-🌱=🔶cookie-value3🔷; ' +
            '__Host-unordered🍪=🔵unordered-cookie-value1🔴; ' +
            '__Host-unordered🌟=🌠unordered-cookie-value2🌠; ' +
            '__Host-unordered🌱=🔶unordered-cookie-value3🔷',
          'All residual HTTP cookies before cleanup at end of test');
    }
    if (IS_UNSECURED) {
      assert_equals(
          await getCookieStringDocument(),
          'TEST=value',
          'Only one unsecured document.cookie cookie' +
            ' before cleanup at end of test');
    } else {
      assert_equals(
          await getCookieStringDocument(),
          'TEST=value; ' +
            '__Host-🍪=🔵cookie-value1🔴; ' +
            '__Host-🌟=🌠cookie-value2🌠; ' +
            '__Host-🌱=🔶cookie-value3🔷; ' +
            '__Host-unordered🍪=🔵unordered-cookie-value1🔴; ' +
            '__Host-unordered🌟=🌠unordered-cookie-value2🌠; ' +
            '__Host-unordered🌱=🔶unordered-cookie-value3🔷',
          'All residual document.cookie cookies before cleanup at end of test');
    }
    unfinished = false;
    assert_equals(
        savedExceptions.length,
        0,
        'Found saved exceptions: ' + savedExceptions);
  } finally {
    try {
      try {
        await cookieStore.delete('');
        await cookieStore.delete('TEST');
        await cookieStore.delete('META-🍪');
        await cookieStore.delete('DOCUMENT-🍪');
        await cookieStore.delete('HTTP-🍪');
        if (!IS_STATIC) await setCookieStringHttp(
            'HTTPONLY-🍪=DELETED; path=/; max-age=0; httponly');
        await promise_rejects_when_unsecured(
            testCase,
            new SyntaxError(),
            cookieStore.delete('__Host-COOKIENAME'));
        await promise_rejects_when_unsecured(
            testCase,
            new SyntaxError(),
            cookieStore.delete('__Host-🍪'));
        await promise_rejects_when_unsecured(
            testCase,
            new SyntaxError(),
            cookieStore.delete('__Host-🌟'));
        await promise_rejects_when_unsecured(
            testCase,
            new SyntaxError(),
            cookieStore.delete('__Host-🌱'));
        await promise_rejects_when_unsecured(
            testCase,
            new SyntaxError(),
            cookieStore.delete('__Host-unordered🍪'));
        await promise_rejects_when_unsecured(
            testCase,
            new SyntaxError(),
            cookieStore.delete('__Host-unordered🌟'));
        await promise_rejects_when_unsecured(
            testCase,
            new SyntaxError(),
            cookieStore.delete('__Host-unordered🌱'));
        assert_equals(
            await getCookieString(),
            undefined,
            'No cookies at end of test');
        if (!IS_STATIC) assert_equals(
            await getCookieStringHttp(),
            undefined,
            'No HTTP cookies at end of test');
        if (includeTest('testObservation')) assert_equals(
            await getCookieStringObserved(),
            undefined,
            'No observed cookies at end of test');
      } finally {
        if (includeTest('testObservation')) observer.disconnect();
      }
    } catch (e) {
      // only re-throw cleanup failures if finished to avoid masking earlier failures
      if (!unfinished) throw e;
    }
  }
}, 'All tests (async API)');

let getOneSimpleOriginCookieAsync = async() => {
  let cookie = await cookieStore.get('__Host-COOKIENAME');
  if (!cookie) return undefined;
  return cookie.value;
};

let countMatchingSimpleOriginCookies = async() => {
  let cookieList = await cookieStore.getAll({
    name: '__Host-COOKIEN',
    matchType: 'startsWith'
  });
  return cookieList.length;
};

let setOneSimpleOriginSessionCookie = async() => {
  await cookieStore.set('__Host-COOKIENAME', 'cookie-value');
};

let setOneDaySecureCookieWithDate = async() => {
  // one day ahead, ignoring a possible leap-second
  let inTwentyFourHours = new Date(Date.now() + 24 * 60 * 60 * 1000);
  await cookieStore.set('__Secure-COOKIENAME', 'cookie-value', {
    path: '/cgi-bin/',
    expires: inTwentyFourHours,
    secure: true,
    domain: 'example.org'
  });
};

// FIXME: remove this once IFRAME puppets and ServiceWorker support
// are implemented in the polyfill
setOneDaySecureCookieWithDate =
    eval(String(setOneDaySecureCookieWithDate).split(
        '/cgi-bin/').join(location.pathname.replace(/[^/]+$/, '')));
setOneDaySecureCookieWithDate =
    eval(String(setOneDaySecureCookieWithDate).split(
        'example.org').join(location.hostname));

let setOneDayUnsecuredCookieWithMillisecondsSinceEpoch = async() => {
  // one day ahead, ignoring a possible leap-second
  let inTwentyFourHours = Date.now() + 24 * 60 * 60 * 1000;
  await cookieStore.set('LEGACYCOOKIENAME', 'cookie-value', {
    path: '/cgi-bin/',
    expires: inTwentyFourHours,
    secure: false,
    domain: 'example.org'
  });
};

// FIXME: remove this once IFRAME puppets and ServiceWorker support
// are implemented in the polyfill
setOneDayUnsecuredCookieWithMillisecondsSinceEpoch =
    eval(String(setOneDayUnsecuredCookieWithMillisecondsSinceEpoch).split(
        '/cgi-bin/').join(location.pathname.replace(/[^/]+$/, '')));
setOneDayUnsecuredCookieWithMillisecondsSinceEpoch =
    eval(String(setOneDayUnsecuredCookieWithMillisecondsSinceEpoch).split(
        'example.org').join(location.hostname));

let deleteUnsecuredCookieWithDomainAndPath = async() => {
  await cookieStore.delete('LEGACYCOOKIENAME', {
    path: '/cgi-bin/',
    secure: false,
    domain: 'example.org'
  });
};

// FIXME: remove this once IFRAME puppets and ServiceWorker support
// are implemented in the polyfill
deleteUnsecuredCookieWithDomainAndPath =
    eval(String(deleteUnsecuredCookieWithDomainAndPath).split(
        '/cgi-bin/').join(location.pathname.replace(/[^/]+$/, '')));
deleteUnsecuredCookieWithDomainAndPath =
    eval(String(deleteUnsecuredCookieWithDomainAndPath).split(
        'example.org').join(location.hostname));

let setSecureCookieWithHttpLikeExpirationString = async() => {
  const year = (new Date()).getUTCFullYear() + 1;
  const date = new Date('07 Jun ' + year + ' 07:07:07 UTC');
  const day = ('Sun Mon Tue Wed Thu Fri Sat'.split(' '))[date.getUTCDay()];
  await cookieStore.set('__Secure-COOKIENAME', 'cookie-value', {
    path: '/cgi-bin/',
    expires: day + ', 07 Jun ' + year + ' 07:07:07 GMT',
    secure: true,
    domain: 'example.org'
  });
};

// FIXME: remove this once IFRAME puppets and ServiceWorker support
// are implemented in the polyfill
setSecureCookieWithHttpLikeExpirationString =
    eval(String(setSecureCookieWithHttpLikeExpirationString).split(
        '/cgi-bin/').join(location.pathname.replace(/[^/]+$/, '')));
setSecureCookieWithHttpLikeExpirationString =
    eval(String(setSecureCookieWithHttpLikeExpirationString).split(
        'example.org').join(location.hostname));

let setThreeSimpleOriginSessionCookiesSequentially = async() => {
  await cookieStore.set('__Host-🍪', '🔵cookie-value1🔴');
  await cookieStore.set('__Host-🌟', '🌠cookie-value2🌠');
  await cookieStore.set('__Host-🌱', '🔶cookie-value3🔷');
  // NOTE: this assumes no concurrent writes from elsewhere; it also
  // uses three separate cookie jar read operations where a single getAll
  // would be more efficient, but this way the CookieStore does the filtering
  // for us.
  let matchingValues = await Promise.all([ '🍪', '🌟', '🌱' ].map(
      async ಠ_ಠ => (await cookieStore.get('__Host-' + ಠ_ಠ)).value));
  let actual = matchingValues.join(';');
  let expected = '🔵cookie-value1🔴;🌠cookie-value2🌠;🔶cookie-value3🔷';
  if (actual !== expected) throw new Error(
      'Expected ' + JSON.stringify(expected) +
        ' but got ' + JSON.stringify(actual));
};

let setThreeSimpleOriginSessionCookiesNonsequentially = async() => {
  await Promise.all([
    cookieStore.set('__Host-unordered🍪', '🔵unordered-cookie-value1🔴'),
    cookieStore.set('__Host-unordered🌟', '🌠unordered-cookie-value2🌠'),
    cookieStore.set('__Host-unordered🌱', '🔶unordered-cookie-value3🔷')
  ]);
  // NOTE: this assumes no concurrent writes from elsewhere; it also
  // uses three separate cookie jar read operations where a single getAll
  // would be more efficient, but this way the CookieStore does the filtering
  // for us.
  let matchingCookies = await Promise.all([ '🍪', '🌟', '🌱' ].map(
      ಠ_ಠ => cookieStore.get('__Host-unordered' + ಠ_ಠ)));
  let actual = matchingCookies.map(({ value }) => value).join(';');
  let expected =
      '🔵unordered-cookie-value1🔴;' +
      '🌠unordered-cookie-value2🌠;' +
      '🔶unordered-cookie-value3🔷';
  if (actual !== expected) throw new Error(
      'Expected ' + JSON.stringify(expected) +
        ' but got ' + JSON.stringify(actual));
};

let setExpiredSecureCookieWithDomainPathAndFallbackValue = async() => {
  let theVeryRecentPast = Date.now();
  let expiredCookieSentinelValue = 'EXPIRED';
  await cookieStore.set('__Secure-COOKIENAME', expiredCookieSentinelValue, {
    path: '/cgi-bin/',
    expires: theVeryRecentPast,
    secure: true,
    domain: 'example.org'
  });
};

// FIXME: remove this once IFRAME puppets and ServiceWorker support
// are implemented in the polyfill
setExpiredSecureCookieWithDomainPathAndFallbackValue =
    eval(String(setExpiredSecureCookieWithDomainPathAndFallbackValue).split(
        '/cgi-bin/').join(location.pathname.replace(/[^/]+$/, '')));
setExpiredSecureCookieWithDomainPathAndFallbackValue =
    eval(String(setExpiredSecureCookieWithDomainPathAndFallbackValue).split(
        'example.org').join(location.hostname));

let deleteSimpleOriginCookie = async() => {
  await cookieStore.delete('__Host-COOKIENAME');
};

let deleteSecureCookieWithDomainAndPath = async() => {
  await cookieStore.delete('__Secure-COOKIENAME', {
    path: '/cgi-bin/',
    domain: 'example.org',
    secure: true
  });
};

// FIXME: remove this once IFRAME puppets and ServiceWorker support
// are implemented in the polyfill
deleteSecureCookieWithDomainAndPath =
    eval(String(deleteSecureCookieWithDomainAndPath).split(
        '/cgi-bin/').join(location.pathname.replace(/[^/]+$/, '')));
deleteSecureCookieWithDomainAndPath =
    eval(String(deleteSecureCookieWithDomainAndPath).split(
        'example.org').join(location.hostname));

let testObservation_ = (resolve, reject) => {
  observationLog.length = 0;
  observedStore.length = 0;
  // This will get invoked (asynchronously) shortly after the
  // observe(...) call to provide an initial snapshot; in that case
  // the length of cookieChanges may be 0, indicating no matching
  // script-visible cookies for any URL+cookieStore currently
  // observed. The CookieObserver instance is passed as the second
  // parameter to allow additional calls to observe or disconnect.
  let callback = (cookieChanges, observer) => {
    var logEntry = [];
    observationLog.push(logEntry);
    const cookieChangesStrings = changes => changes.map(
        ({type, name, value, index}) => cookieString(Object.assign(
            new Array(observedStore.length),
            {[index]: {
              name: ((type === 'visible') ? '+' : '-') + name,
              value: value
            }})));
    logEntry.push(['before', cookieString(observedStore)]);
    logEntry.push(['changes', cookieChangesStrings(cookieChanges)]);
    const newObservedStore = observedStore.slice(0);
    try {
      const insertions = [], deletions = [];
      cookieChanges.forEach(({
        cookieStore,
        type,
        url,
        name,
        value,
        index,
        all
      }) => {
        switch (type) {
          case 'visible':
            // Creation or modification (e.g. change in value, or
            // removal of HttpOnly), or appearance to script due to
            // change in policy or permissions
            insertions.push([index, {name: name, value: value}]);
            break;
          case 'hidden':
            // Deletion/expiration or disappearance (e.g. due to
            // modification adding HttpOnly), or disappearance from
            // script due to change in policy or permissions
            assert_object_equals(
                {name: name, value: value},
                observedStore[index],
                'Hidden cookie at index ' + index +
                  ' was not the expected one: ' + JSON.stringify({
                    got: {name: name, value: value},
                    expected: observedStore[index]
                  }));
            deletions.push(index);
            break;
          default:
            savedExceptions.push('Unexpected CookieChange type ' + type);
            if (reject) reject(savedExceptions[savedExceptions.length - 1]);
            throw savedExceptions[savedExceptions.length - 1];
        }
      });
      deletions.sort((a, b) => b - a).forEach(
          index => newObservedStore.splice(index, 1));
      let bias = 0;
      insertions.sort(([a], [b]) => a - b).forEach(([ index, cookie ]) => {
        if (newObservedStore[index + bias] !== undefined) {
          newObservedStore.splice(index, 0, cookie);
          --bias;
        } else {
          newObservedStore[index] = cookie;
        }
      });
      observedStore = newObservedStore.filter(entry => entry !== undefined);
      logEntry.push(['after', cookieString(observedStore)]);
      const reported =
            cookieChanges && cookieChanges.length ?
            cookieChanges[cookieChanges.length - 1].all :
            [];
      assert_equals(
          cookieString(reported),
          cookieString(observedStore),
          'Mismatch between observed store and reported store.' +
            '\n observed:\n ' + cookieString(observedStore) +
            '\n reported:\n ' + cookieString(reported) +
            '\n log:\n ' + observationLog.map(JSON.stringify).join('\n '));
    } catch (e) {
      logEntry.push([' *** ⚠ *** ERROR: EXCEPTION THROWN *** ⚠ *** ']);
      savedExceptions.push(e);
      if (reject) reject(e);
      throw e;
    }
    // Resolve promise after first callback
    if (resolve) resolve(observer);
    resolve = null;
    reject = null;
  };
  CookieObserver.startTimer_ = (handler, ignoredDelay) => {
    var timer = {shouldRun: true, fingerPrint: Math.random()};
    new Promise(resolve => s\u0065tTimeout(resolve)).then(() => {
      if (!timer.shouldRun) return;
      CookieObserver.stopTimer_(timer);
      handler();
    });
    return timer;
  };
  CookieObserver.stopTimer_ = timer => {
    timer.shouldRun = false;
  };
  let observer = new CookieObserver(callback);
  // If null or omitted this defaults to location.pathname up to and
  // including the final '/' in a document context, or worker scope up
  // to and including the final '/' in a service worker context.
  let url = (location.pathname).replace(/[^\/]+$/, '');
  // If null or omitted this defaults to interest in all
  // script-visible cookies.
  let interests = [
    // Interested in all secure cookies named '__Secure-COOKIENAME';
    // the default matchType is 'equals' at the given URL.
    { name: '__Secure-COOKIENAME', url: url },
    // Interested in all simple origin cookies named like
    // /^__Host-COOKIEN.*$/ at the default URL.
    { name: '__Host-COOKIEN', matchType: 'startsWith' },
    // Interested in all simple origin cookies named '__Host-🍪'
    // at the default URL.
    { name: '__Host-🍪' },
    // Interested in all cookies named 'OLDCOOKIENAME' at the given URL.
    { name: 'OLDCOOKIENAME', matchType: 'equals', url: url },
    // Interested in all simple origin cookies named like
    // /^__Host-AUTHTOKEN.*$/ at the given URL.
    { name: '__Host-AUTHTOKEN', matchType: 'startsWith', url: url + 'auth/' }
  ];
  observer.observe(cookieStore, interests);
  // Default interest: all script-visible changes, default URL
  observer.observe(cookieStore);
};

// FIXME: remove this once IFRAME puppets and ServiceWorker support
// are implemented in the polyfill
testObservation_ = eval(String(testObservation_).split('auth/').join('auth'));

let testObservation = () => new Promise(testObservation_);

let testNoNameAndNoValue = async() => {
  await cookieStore.set('', 'first-value');
  let actual1 =
      (await cookieStore.getAll('')).map(({ value }) => value).join(';');
  let expected1 = 'first-value';
  if (actual1 !== expected1) throw new Error(
      'Expected ' + JSON.stringify(expected1) +
        ' but got ' + JSON.stringify(actual1));
  await cookieStore.set('', '');
  let actual2 =
      (await cookieStore.getAll('')).map(({ value }) => value).join(';');
  let expected2 = '';
  if (actual2 !== expected2) throw new Error(
      'Expected ' + JSON.stringify(expected) +
        ' but got ' + JSON.stringify(actual));
  await cookieStore.delete('');
};

let testNoNameMultipleValues = async() => {
  await cookieStore.set('', 'first-value');
  let actual1 =
      (await cookieStore.getAll('')).map(({ value }) => value).join(';');
  let expected1 = 'first-value';
  if (actual1 !== expected1) throw new Error(
      'Expected ' + JSON.stringify(expected1) +
        ' but got ' + JSON.stringify(actual1));
  await cookieStore.set('', 'second-value');
  let actual2 =
      (await cookieStore.getAll('')).map(({ value }) => value).join(';');
  let expected2 = 'second-value';
  if (actual2 !== expected2) throw new Error(
      'Expected ' + JSON.stringify(expected2) +
        ' but got ' + JSON.stringify(actual2));
  await cookieStore.delete('');
};

let testNoNameEqualsInValue = async() => {
  await cookieStore.set('', 'first-value');
  let actual1 =
      (await cookieStore.getAll('')).map(({ value }) => value).join(';');
  let expected1 = 'first-value';
  if (actual1 !== expected1) throw new Error(
      'Expected ' + JSON.stringify(expected1) +
        ' but got ' + JSON.stringify(actual1));
  try {
    await cookieStore.set('', 'suspicious-value=resembles-name-and-value');
  } catch (expectedError) {
    let actual2 =
        (await cookieStore.getAll('')).map(({ value }) => value).join(';');
    let expected2 = 'first-value';
    if (actual2 !== expected2) throw new Error(
        'Expected ' + JSON.stringify(expected2) +
          ' but got ' + JSON.stringify(actual2));
    assert_equals(
        await getCookieString(),
        'first-value',
        'Earlier cookie jar after rejected part of testNoNameEqualsInValue');
    await cookieStore.delete('');
    assert_equals(
        await getCookieString(),
        undefined,
        'Empty cookie jar after cleanup in testNoNameEqualsInValue');
    return;
  }
  throw new Error(
      'Expected promise rejection' +
        ' when setting a cookie with no name and "=" in value');
};

</script>
