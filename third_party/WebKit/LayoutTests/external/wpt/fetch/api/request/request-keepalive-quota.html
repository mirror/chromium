<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Request Keepalive Quota Tests</title>
        <meta name="help" href="https://fetch.spec.whatwg.org/#request">
        <meta name="help" href="https://fetch.spec.whatwg.org/#body-mixin">
        <meta name="author" title="Microsoft Edge" href="https://www.microsoft.com">
        <meta name="timeout" content="long">
        <script src="/resources/testharness.js"></script>
        <script src="/resources/testharnessreport.js"></script>
    </head>
    <body>
        <script>
            "use strict";

            // We want to ensure that our keepalive requests hang slightly before completing so we can validate
            // the effects of a rolling quota. To do this we will utilize trickle.py with a 1s delay. This should
            // prevent any of the Fetch's from finishing in this window.
            const trickleURL = "../resources/trickle.py?count=1&ms=";
            const noDelay = 0;
            const standardDelay = 1000;
            function wait(ms) {
                return new Promise(resolve => step_timeout(resolve, ms));
            }

            // We should expect 64KiB of rolling quota for any type of keep-alive request sent.
            const expectedQuota = 65536;

            function CreateKeepAliveRequest(delay, bodySize) {
                // Create a body of the specified size that's filled with *'s
                var requestBody = "*".repeat(bodySize);
                return new Request(trickleURL+delay, {keepalive: true, body: requestBody, method: "POST"});
            }

            // Test 1 Byte
            promise_test(function(test) {
                return fetch(CreateKeepAliveRequest(noDelay, 1 /* bodySize */)).then((response) => {
                    return response.text();
                }).then(() => wait(1));
            }, "A Keep-Alive fetch() with a small body should succeed.");

            // Test Quota full limit
            promise_test(function(test) {
                return fetch(CreateKeepAliveRequest(noDelay, expectedQuota)).then((response) => {
                    return response.text();
                }).then(() => wait(1));
            }, "A Keep-Alive fetch() with a body at the Quota Limit should succeed.");

            // Test Quota + 1 Byte
            promise_test(function(test) {
                return promise_rejects(test, new TypeError(), fetch(CreateKeepAliveRequest(noDelay, expectedQuota + 1))).then(() => wait(1));
            }, "A Keep-Alive fetch() with a body over the Quota Limit should reject.");

            // Test the Quota becomes available upon promise completion.
            promise_test(function (test) {
                // Fill our Quota then try to send a second fetch.
                return fetch(CreateKeepAliveRequest(standardDelay, expectedQuota)).then(function(response) {
                    return response.text();
                }).then(() => {
                    // Now validate that we can send another Keep-Alive fetch for the full size of the quota.
                    return fetch(CreateKeepAliveRequest(noDelay, expectedQuota));
                }).then((response) => {
                    return response.text();
                }).then(() => wait(1));
            }, "A Keep-Alive fetch() should return its allocated Quota upon promise resolution.");

            // Ensure only the correct amount of Quota becomes available when a fetch completes.
            promise_test(function(test) {
                // Create a fetch that uses all but 1 Byte of the Quota and runs for 2x as long as the other requests.
                var first = fetch(CreateKeepAliveRequest(standardDelay * 2, expectedQuota - 1)).then(function(response) {
                    return response.text();
                });

                // Now create a single Byte request that will complete quicker.
                let second = fetch(CreateKeepAliveRequest(standardDelay, 1 /* bodySize */)).then(function(response) {
                    return response.text();
                }).then((response) => {
                    // We shouldn't be able to create a 2 Byte request right now as only 1 Byte should have freed up.
                    return promise_rejects(test, new TypeError(), fetch(CreateKeepAliveRequest(noDelay, 2 /* bodySize */)));
                }).then(() => {
                    // Now validate that we can send another Keep-Alive fetch for just 1 Byte.
                    return fetch(CreateKeepAliveRequest(noDelay, 1 /* bodySize */));
                }).then(function(response) {
                    return response.text();
                });

                return Promise.all([first, second]).then(() => wait(1));
            }, "A Keep-Alive fetch() should return only its allocated Quota upon promise resolution.");

            // Test rejecting a fetch() after the quota is used up.
            promise_test(function (test) {
                // Fill our Quota then try to send a second fetch.
                fetch(CreateKeepAliveRequest(standardDelay, expectedQuota));

                return promise_rejects(test, new TypeError(), fetch(CreateKeepAliveRequest(noDelay, 1 /* bodySize */))).then(() => wait(1));
            }, "A Keep-Alive fetch() should not be allowed if the Quota is used up.");

        </script>
    </body>
</html>
