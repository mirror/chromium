<!DOCTYPE html>
<meta charset="utf-8">
<title>NetInfo basic functionality</title>
<link rel="help" href="https://wicg.github.io/netinfo/">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>

<script>
test(function() {
      assert_in_array(navigator.connection.type,  ["bluetooth", "cellular",
        "ethernet", "mixed", "none", "other", "unknown", "wifi", "wimax"], 'type is unexpected');
}, "type attribute");

test(function() {
      assert_greater_than_equal(navigator.connection.downlinkMax, 0);
}, "downlinkMax attribute");

test(function() {
      assert_in_array(navigator.connection.effectiveType, ["slow-2g", "2g",
          "3g", "4g"], 'effectiveType is unexpected');
}, "effectiveType attribute");

test(function() {
      assert_greater_than_equal(navigator.connection.rtt, 0);
      assert_less_than_equal(navigator.connection.rtt % 50, 0.1,
        'rtt must be a multiple of 50 msec');
}, "rtt attribute");

test(function() {
  var downlink_kbps  = navigator.connection.downlink * 1000;
      assert_greater_than_equal(downlink_kbps, 0);

// First verify that downlink_kbps is a multiple of 50.
  var quotient = parseInt(downlink_kbps  / 50, 10);
  // mod is the remainder left after dividing downlink_kbps by 50 while
  // restricting the quotient to an integer.
  var mod = downlink_kbps - 50 * quotient;
  assert_less_than_equal(0.0, mod, 'mod outside the range');
  assert_greater_than(50.0, mod, 'mod outside the range');
  // It is possible that mod is not exactly 0 because of floating point
  // computations. e.g., downlink_kbps may be 99.999999, in which case mod
  // will be 49.999999.
  assert(mod < 0.0001 || mod > 49.9999, 'downlink must be a multiple of 50 kbps');
}, "downlink attribute");
</script>
