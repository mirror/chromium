This is a testharness.js-based test.
FAIL TransformStream can be constructed with a transform function TransformStream is not defined
FAIL TransformStream can be constructed with no transform function TransformStream is not defined
FAIL TransformStream instances must have writable and readable properties of the correct types TransformStream is not defined
FAIL TransformStream writable starts in the writable state TransformStream is not defined
FAIL Identity TransformStream: can read from readable what is put into writable TransformStream is not defined
FAIL Uppercaser sync TransformStream: can read from readable transformed version of what is put into writable TransformStream is not defined
FAIL Uppercaser-doubler sync TransformStream: can read both chunks put into the readable TransformStream is not defined
FAIL Uppercaser async TransformStream: can read from readable transformed version of what is put into writable TransformStream is not defined
FAIL Uppercaser-doubler async TransformStream: can read both chunks put into the readable TransformStream is not defined
FAIL TransformStream: by default, closing the writable closes the readable (when there are no queued writes) TransformStream is not defined
FAIL TransformStream: by default, closing the writable waits for transforms to finish before closing both TransformStream is not defined
FAIL TransformStream: by default, closing the writable closes the readable after sync enqueues and async done TransformStream is not defined
FAIL TransformStream: by default, closing the writable closes the readable after async enqueues and async done TransformStream is not defined
FAIL Transform stream should call transformer methods as methods TransformStream is not defined
FAIL methods should not not have .apply() or .call() called TransformStream is not defined
FAIL TransformStream start, transform, and flush should be strictly ordered TransformStream is not defined
FAIL it should be possible to call transform() synchronously TransformStream is not defined
FAIL closing the writable should close the readable when there are no queued chunks, even with backpressure TransformStream is not defined
FAIL enqueue() should throw after controller.terminate() TransformStream is not defined
FAIL enqueue() should throw after readable.cancel() TransformStream is not defined
FAIL controller.terminate() should do nothing the second time it is called TransformStream is not defined
FAIL terminate() should do nothing after readable.cancel() TransformStream is not defined
FAIL start() should not be called twice TransformStream is not defined
FAIL specifying a defined readableType should throw assert_throws: constructor should throw function "() => new TransformStream({ readableType: 'bytes' })" threw object "ReferenceError: TransformStream is not defined" ("ReferenceError") expected object "RangeError" ("RangeError")
FAIL specifying a defined writableType should throw assert_throws: constructor should throw function "() => new TransformStream({ writableType: 'bytes' })" threw object "ReferenceError: TransformStream is not defined" ("ReferenceError") expected object "RangeError" ("RangeError")
Harness: the test ran to completion.

