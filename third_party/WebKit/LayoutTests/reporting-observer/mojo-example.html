<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="file:///gen/layout_test_data/mojo/public/js/mojo_bindings.js"></script>
<script src="file:///gen/third_party/WebKit/public/platform/reporting.mojom.js"></script>
<script>
// Mock implementation of ReportingServiceProxy.
// |promise| property is always a promise for the next report to be queued.
// Grab the promise, then trigger the behavior, then wait on the promise.
class ReportingServiceProxyImpl {
  constructor() {
    this.bindingSet = new mojo.BindingSet(content.mojom.ReportingServiceProxy);
    this.bindingSet.setConnectionErrorHandler(() => {
      // TODO(jbroman): Fill this in if you need to handle this.
    });
    this.resetPromise();
  }

  bind(handle) {
    this.bindingSet.addBinding(this, handle);
  }

  resetPromise() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
    });
  }

  // Interface implementation.
  async queueReport(url, group, type, body) {
    this.resolve([url, group, type, body]);
    this.resetPromise();
  }
}

// Make an instance and have it receive the request.
var proxy = new ReportingServiceProxyImpl();
var interceptor = new MojoInterfaceInterceptor(
    content.mojom.ReportingServiceProxy.name);
interceptor.oninterfacerequest = e => proxy.bind(e.handle);
interceptor.start();

promise_test(async () => {
  let promise = proxy.promise;
  window.webkitStorageInfo;
  let [url, group, type, body] = await promise;
  assert_equals(url.url, "http://www.example.com/");
}, "expected report");
</script>
