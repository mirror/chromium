<!DOCTYPE html>
<title>IndexedDB: Verify "thennable" behavior of IDBRequest</title>
<script src="../../resources/testharness.js"></script>
<script src="../../resources/testharnessreport.js"></script>
<script src="resources/testharness-helpers.js"></script>
<script>

setup({ allow_uncaught_exception: true });

// func is called with the test object and an object store (containing key: 1)
// from a read-write transaction. It must return a promise. If the promise
// resolves successfully, the test passes.
function basic_test(func, description) {
  return indexeddb_test(
    (t, db) => {
      let store = db.createObjectStore('store');
      store.put('value', 1);
    },
    (t, db) => {
      let tx = db.transaction('store', 'readwrite');
      let store = tx.objectStore('store');
      Promise.resolve(func(t, store))
             .then(t.step_func(result => t.done()),
                   t.step_func(err =>
                     assert_unreached('failed: ' + err.message)));
    },
    description);
}

test(t => {
  assert_true('then' in IDBRequest.prototype, 'IDBRequest has then');
  assert_equals(typeof IDBRequest.prototype.then, 'function',
                'IDBRequest.then() is a function');
  assert_equals(IDBRequest.prototype.then.length, 1,
                'IDBRequest.then() has one required argument');

  assert_true('catch' in IDBRequest.prototype, 'IDBRequest has catch');
  assert_equals(typeof IDBRequest.prototype.catch, 'function',
                'IDBRequest.catch() is a function');
  assert_equals(IDBRequest.prototype.catch.length, 1,
                'IDBRequest.catch() has one required argument');

}, 'IDBRequest has then()/catch() methods');

basic_test((t, store) => {
  let req = store.get(1);
  assert_true(req.then(null) instanceof Promise,
              'then() returns a Promise');
  assert_true(req.then(null, null) instanceof Promise,
              'then() with 2 args returns a Promise');
  assert_true(req.catch(null) instanceof Promise,
              'catch() returns a Promise');
}, 'IDBRequest.then() and .catch() return Promises');

basic_test((t, store) => {
  let req = store.get(1);
  return req
    .then(result => {
      assert_equals(result, req.result,
                    'then() yields the result of the request');
    });
}, 'IDBRequest.then() with one arg, successful request');

basic_test((t, store) => {
  let req = store.get(1);
  return req
    .then(result => {
      assert_equals(result, req.result,
                    'then() yields the result of the request');
    }, error => {
      assert_unreached('Request rejected: ' + error.message);
    });
}, 'IDBRequest.then() with two args, successful request');

basic_test((t, store) => {
  let req = store.get(1);
  return req
    .catch(error => {
      assert_unreached('Request rejected: ' + error.mesage);
    });
}, 'IDBRequest.catch(), successful request');

basic_test((t, store) => {
  let req = store.add('duplicate', 1);
  return req
    .then(result => {
      assert_unreached('Request should have failed');
    })
    .catch(error => {
      assert_equals(error.name, 'ConstraintError',
                    'Request should reject with ConstraintError');
      assert_equals(error.name, req.error.name,
                    'catch() yields the error of the request');
    });
}, 'IDBRequest.then() with one arg, failed request');

basic_test((t, store) => {
  let req = store.add('duplicate', 1);
  return req
    .then(result => {
      assert_unreached('Request should have failed');
    }, error => {
      assert_equals(error.name, 'ConstraintError',
                    'Request should reject with ConstraintError');
      assert_equals(error.name, req.error.name,
                    'catch() yields the error of the request');
    });
}, 'IDBRequest.then() with two args, failed request');

basic_test((t, store) => {
  let req = store.add('duplicate', 1);
    req.then(t.step_func(result =>
      assert_unreached('Request should have failed')));
  return req
    .catch(error => {
      assert_equals(error.name, 'ConstraintError',
                    'Request should reject with ConstraintError');
      assert_equals(error.name, req.error.name,
                    'catch() yields the error of the request');
    });
}, 'IDBRequest.catch(), failed request');

basic_test((t, store) => {
  let req = store.get(1);
  return Promise
    .all([req.then(r => r), req.then(r => r)])
    .then(results => {
      assert_array_equals(results, ['value', 'value'],
                          'results should match');
    });
}, 'IDBRequest.then() called multiple times');

basic_test((t, store) => {
  let req = store.add('duplicate', 1);
  return Promise
    .all([req.catch(e => e.name), req.catch(e => e.name)])
    .then(results => {
      assert_array_equals(results,
                          ['ConstraintError', 'ConstraintError'],
                          'results should match');
    });
}, 'IDBRequest.catch() called multiple times');

basic_test((t, store) => {
  return new Promise(resolve => {
    let req = store.get(1);
    req.onerror = t.unreached_func('Request should succeed');
    req.onsuccess = t.step_func(e => {
            assert_equals(e.type, 'success', 'Request should succeed');
      resolve(req.then(result => {
        assert_equals(result, req.result,
                      'then() yields the result of the request');
      }));
    });
  });
}, 'IDBRequest.then() called after success event fires');

basic_test((t, store) => {
  return new Promise(resolve => {
    let req = store.add('duplicate', 1);
    req.onsuccess = t.unreached_func('Request should fail');
    req.onerror = t.step_func(e => {
      assert_equals(e.type, 'error', 'Request should fail');
      assert_equals(req.error.name, 'ConstraintError',
                    'Request should fail with ConstraintError');
      resolve(req.catch(error => {
        assert_equals(error.name, req.error.name,
                      'catch() yields the error of the request');
      }));
    });
  });
}, 'IDBRequest.catch() called after error event fires');

</script>
