<!DOCTYPE html>
<title>IndexedDB: Verify "thennable" behavior of IDBTransaction</title>
<script src="../../resources/testharness.js"></script>
<script src="../../resources/testharnessreport.js"></script>
<script src="resources/testharness-helpers.js"></script>
<script>

setup({ allow_uncaught_exception: true });

// func is called with the test object, a read-write transaction, and an
// object store (containing key: 1). It must return a promise. If the
// promise resolves successfully, the test passes.
function basic_test(func, description) {
  return indexeddb_test(
    (t, db) => {
      let store = db.createObjectStore('store');
      store.put('value', 1);
    },
    (t, db) => {
      let tx = db.transaction('store', 'readwrite');
      let store = tx.objectStore('store');
      Promise.resolve(func(t, tx, store))
             .then(t.step_func(result => t.done()),
                   t.step_func(err =>
                     assert_unreached('failed: ' + err.message)));
    },
    description);
}

test(t => {
  assert_true('then' in IDBTransaction.prototype,
              'IDBTransaction has then');
  assert_equals(typeof IDBTransaction.prototype.then, 'function',
                'IDBTransaction.then() is a function');
  assert_equals(IDBTransaction.prototype.then.length, 1,
                'IDBTransaction.then() has one required argument');

  assert_true('catch' in IDBTransaction.prototype,
              'IDBTransaction has catch');
  assert_equals(typeof IDBTransaction.prototype.catch, 'function',
                'IDBTransaction.catch() is a function');
  assert_equals(IDBTransaction.prototype.catch.length, 1,
                'IDBTransaction.catch() has one required argument');

}, 'IDBTransaction has then()/catch() methods');

basic_test((t, tx, store) => {
  assert_true(tx.then(null) instanceof Promise,
              'then() returns a Promise');
  assert_true(tx.then(null, null) instanceof Promise,
              'then() with 2 args returns a Promise');
  assert_true(tx.catch(null) instanceof Promise,
              'catch() returns a Promise');
}, 'IDBTransaction.then() and .catch() return Promises');

// Completed

basic_test((t, tx, store) => {
  store.get(1);
  return tx
    .then(result => {
      assert_equals(
        result, undefined,
        'then() yields undefined if the transaction commits');
    });
}, 'IDBTransaction.then() with one arg, completed transaction');

basic_test((t, tx, store) => {
  store.get(1);
  return tx
    .then(result => {
      assert_equals(
        result, undefined,
        'then() yields undefined if the transaction commits');
    }, t.step_func(error => {
      assert_unreached('Transaction rejected: ' + error.message);
    }));
}, 'IDBTransaction.then() with two args, completed transaction');

basic_test((t, tx, store) => {
  store.get(1);
  return tx
    .catch(t.step_func(error => {
      assert_unreached('Transaction aborted: ' + error.mesage);
    }));
}, 'IDBTransaction.catch(), completed transaction');

// Aborted Implicitly

basic_test((t, tx, store) => {
  store.add('duplicate', 1);
  return tx
    .then(t.unreached_func('Transaction should have aborted'))
    .catch(error => {
      assert_equals(error.name, 'ConstraintError',
                    'Transaction should reject with ConstraintError');
      assert_equals(error.name, tx.error.name,
                    'catch() yields the error of the transaction');
    });
}, 'IDBTransaction.then() with one arg, implicitly aborted transaction');

basic_test((t, tx, store) => {
  store.add('duplicate', 1);
  return tx
    .then(
      t.unreached_func('Transaction should have aborted'),
      error => {
        assert_equals(error.name, 'ConstraintError',
                      'Transaction should reject with ConstraintError');
        assert_equals(error.name, tx.error.name,
                      'catch() yields the error of the transaction');
      });
}, 'IDBTransaction.then() with two args, implicitly aborted transaction');

basic_test((t, tx, store) => {
  store.add('duplicate', 1);
  tx.then(t.unreached_func('Transaction should have aborted'));
  return tx
    .catch(error => {
      assert_equals(error.name, 'ConstraintError',
                    'Transaction should reject with ConstraintError');
      assert_equals(error.name, tx.error.name,
                    'catch() yields the error of the transaction');
    });
}, 'IDBTransaction.catch(), implicitly aborted transaction');

// Aborted Explicitly

basic_test((t, tx, store) => {
  tx.abort();
  return tx
    .then(t.unreached_func('Transaction should have aborted'))
    .catch(error => {
      assert_equals(error, null,
                    'Explicitly aborted transaction yields null');
      assert_equals(error, tx.error,
                    'catch() yields the error of the transaction');
    });
}, 'IDBTransaction.then() with one arg, explicitly aborted transaction');

basic_test((t, tx, store) => {
  tx.abort();
  return tx
    .then(
      t.unreached_func('Transaction should have aborted'),
      error => {
        assert_equals(error, null,
                      'Explicitly aborted transaction yields null');
        assert_equals(error, tx.error,
                      'catch() yields the error of the transaction');
      });
}, 'IDBTransaction.then() with two args, explicitly aborted transaction');

basic_test((t, tx, store) => {
  tx.abort();
  tx.then(t.unreached_func('Transaction should have aborted'));
  return tx
    .catch(error => {
      assert_equals(error, null,
                    'Explicitly aborted transaction yields null');
      assert_equals(error, tx.error,
                    'catch() yields the error of the transaction');
    });
}, 'IDBTransaction.catch(), explicitly aborted transaction');

// Other

basic_test((t, tx, store) => {
  store.get(1);
  return Promise
    .all([tx.then(r => r), tx.then(r => r)])
    .then(results => {
      assert_array_equals(results, [undefined, undefined],
                          'results should match');
    });
}, 'IDBTransaction.then() called multiple times');

basic_test((t, tx, store) => {
  store.add('duplicate', 1);
  return Promise
    .all([tx.catch(e => e.name), tx.catch(e => e.name)])
    .then(results => {
      assert_array_equals(results,
                          ['ConstraintError', 'ConstraintError'],
                          'results should match');
    });
}, 'IDBTransaction.catch() called multiple times');

basic_test((t, tx, store) => {
  return new Promise(resolve => {
    store.get(1);
    tx.onabort = t.unreached_func('Transaction should complete');
    tx.oncomplete = t.step_func(e => {
      assert_equals(e.type, 'complete', 'Transaction should complete');
      resolve(tx.then(result => {
        assert_equals(result, undefined, 'then() yields undefined');
      }));
    });
  });
}, 'IDBTransaction.then() called after complete event fires');

basic_test((t, tx, store) => {
  return new Promise(resolve => {
    store.add('duplicate', 1);
    tx.oncomplete = t.unreached_func('Transaction should abort');
    tx.onabort = t.step_func(e => {
      assert_equals(e.type, 'abort', 'Transaction should abort');
      assert_equals(tx.error.name, 'ConstraintError',
                    'Transaction should abort with ConstraintError');
      resolve(tx.catch(error => {
        assert_equals(error.name, tx.error.name,
                      'catch() yields the error of the transaction');
      }));
    });
  });
}, 'IDBTransaction.catch() called after error event fires');

</script>
