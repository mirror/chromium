<!DOCTYPE html>
<script src="../../../../resources/testharness.js"></script>
<script src="../../../../resources/testharnessreport.js"></script>
<meta name="viewport" content="width=device-width">
<style>
  body, html {
    width: 100%;
    height: 100%;
    margin: 0;
  }
  div {
    background-color: green;
    width: 100px;
    height: 100px;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
</style>

<script>
  const kScaleEpsilon = 0.0001;
  const kOffsetEpsilon = 1;

  const t = async_test(
      "This tests that gpuBenchmarking.pinchBy is relatively accurate.");

  function performZoom(scale, anchorX, anchorY, speed, callback) {
    chrome.gpuBenchmarking.pinchBy(scale, anchorX, anchorY, callback, speed);
  }

  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;

  // TODO(bokan): Add more variations (speed, anchor location, etc.) but it's
  // difficult right now as pinchBy is badly broken on desktops:
  // https://crbug.com/787615.
  const tests = [
    { starting_scale: 1, scale: 3, speed: 1000, msg: "Zooming in quickly is accurate." },
    { starting_scale: 4, scale: 0.5, speed: 1000, msg: "Zooming out quickly is accurate." },
    { starting_scale: 1, scale: 3, speed: 100, msg: "Zooming in slowly is accurate." },
    { starting_scale: 4, scale: 0.5, speed: 100, msg: "Zooming out slowly is accurate." },
    { starting_scale: 1, scale: 3, speed: 50000, msg: "Zooming in instantly is accurate." },
    { starting_scale: 4, scale: 0.5, speed: 50000, msg: "Zooming out instantly is accurate." },
  ];

  function runTest(testIx) {
    if (testIx >= tests.length) {
      t.done();
      return;
    }

    const test = tests[testIx];
    window.internals.setPageScaleFactor(test.starting_scale);
    window.internals.setVisualViewportOffset(
        window.innerWidth * (1 - (1 / test.starting_scale)) / 2,
        window.innerHeight * (1 - (1 / test.starting_scale)) / 2);

    chrome.gpuBenchmarking.pinchBy(test.scale, centerX, centerY, () => {
      t.step(() => {
          const expectedScale = test.starting_scale * test.scale;
          assert_approx_equals(
              window.visualViewport.scale,
              expectedScale,
              kScaleEpsilon,
              test.msg);
          assert_approx_equals(
              window.visualViewport.offsetLeft,
              window.innerWidth * (1 - (1 / expectedScale)) / 2,
              kOffsetEpsilon,
              test.msg + " Test offsetLeft");
          assert_approx_equals(
              window.visualViewport.offsetTop,
              window.innerHeight * (1 - (1 / expectedScale)) / 2,
              kOffsetEpsilon,
              test.msg + " Test offsetTop");

          runTest(testIx + 1);
      });
    }, test.speed);
  }

  runTest(0);
</script>
