<!DOCTYPE html>
<html>
  <head>
    <title>
      Test Constructor: DynamicsCompressor
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
    <script src="../resources/audit.js"></script>
    <script src="audionodeoptions.js"></script>
  </head>
  <body>
    <script id="layout-test-code">
      let context;

      let audit = Audit.createTaskRunner();

      audit.define('initialize', (task, should) => {
        context = initializeContext(should);
        task.done();
      });

      audit.define('invalid constructor', (task, should) => {
        testInvalidConstructor(should, 'DynamicsCompressorNode', context);
        task.done();
      });

      audit.define('default constructor', (task, should) => {
        let prefix = 'node0';
        let node =
            testDefaultConstructor(should, 'DynamicsCompressorNode', context, {
              prefix: prefix,
              numberOfInputs: 1,
              numberOfOutputs: 1,
              channelCount: 2,
              channelCountMode: 'max',
              channelInterpretation: 'speakers'
            });

        testDefaultAttributes(should, node, prefix, [
          {name: 'threshold', value: -24}, {name: 'knee', value: 30},
          {name: 'ratio', value: 12}, {name: 'reduction', value: 0},
          {name: 'attack', value: Math.fround(0.003)},
          {name: 'release', value: 0.25}
        ]);

        task.done();
      });

      audit.define('test AudioNodeOptions', (task, should) => {
        // Can't use testAudioNodeOptions because the constraints for this node
        // are not supported there.
        let node;

        // Test that we can set the channel count to 1 or 2.
        let options = {channelCount: 1};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .notThrow();
        should(node.channelCount, 'node.channelCount').beEqualTo(1);

        options = {channelCount: 2};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .notThrow();
        should(node.channelCount, 'node.channelCount').beEqualTo(2);

        // Test that other channel counts throw an error
        options = {channelCount: 0};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .throw('NotSupportedError');

        options = {channelCount: 3};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .throw('NotSupportedError');

        options = {channelCount: 99};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .throw('NotSupportedError');

        // Test channelCountMode
        options = {channelCountMode: 'clamped-max'};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .notThrow();
        should(node.channelCountMode, 'node.channelCountMode')
            .beEqualTo(options.channelCountMode);

        options = {channelCountMode: 'explicit'};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .notThrow();
        should(node.channelCountMode, 'node.channelCountMode')
            .beEqualTo(options.channelCountMode);

        options = {channelCountMode: 'max'};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .throw('NotSupportedError');

        options = {channelCountMode: 'foobar'};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .throw('TypeError');

        // Test channelInterpretation.
        options = {channelInterpretation: 'speakers'};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .notThrow();
        should(node.channelInterpretation, 'node.channelInterpretation')
            .beEqualTo(options.channelInterpretation);

        options = {channelInterpretation: 'discrete'};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .notThrow();
        should(node.channelInterpretation, 'node.channelInterpretation')
            .beEqualTo(options.channelInterpretation);

        options = {channelInterpretation: 'foobar'};
        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'new DynamicsCompressorNode(c, ' + JSON.stringify(options) + ')')
            .throw('TypeError');
        task.done();
      });

      audit.define('constructor with options', (task, should) => {
        let node;
        let options =
            {threshold: -33, knee: 15, ratio: 7, attack: 0.625, release: 0.125};

        should(
            () => {
              node = new DynamicsCompressorNode(context, options);
            },
            'node1 = new DynamicsCompressorNode(c, ' + JSON.stringify(options) +
                ')')
            .notThrow();
        should(
            node instanceof DynamicsCompressorNode,
            'node1 instanceof DynamicsCompressorNode')
            .beEqualTo(true);

        should(node.threshold.value, 'node1.threshold.value')
            .beEqualTo(options.threshold);
        should(node.knee.value, 'node1.knee.value').beEqualTo(options.knee);
        should(node.ratio.value, 'node1.ratio.value').beEqualTo(options.ratio);
        should(node.attack.value, 'node1.attack.value')
            .beEqualTo(options.attack);
        should(node.release.value, 'node1.release.value')
            .beEqualTo(options.release);

        should(node.channelCount, 'node1.channelCount').beEqualTo(2);
        should(node.channelCountMode, 'node1.channelCountMode')
            .beEqualTo('max');
        should(node.channelInterpretation, 'node1.channelInterpretation')
            .beEqualTo('speakers');

        task.done();
      });

      audit.run();
    </script>
  </body>
</html>
