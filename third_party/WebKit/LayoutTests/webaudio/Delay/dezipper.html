<!DOCTYPE html>
<html>
  <head>
    <title>
      Test DelayNode Has No Dezippering
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
    <script src="../resources/audit.js"></script>
  </head>
  <body>
    <script id="layout-test-code">
      // The sample rate must be a power of two to avoid any round-off errors in
      // computing when to suspend a context on a rendering quantum boundary.
      // Otherwise this is pretty arbitrary.
      let sampleRate = 16384;

      let audit = Audit.createTaskRunner();

      audit.define(
          {
            label: 'test',
            description: 'Test DelayNode has no dezippering'
          },
          (task, should) => {
            let context = new OfflineAudioContext(1, sampleRate, sampleRate);

            // Simple integer ramp for testing delay node
            let buffer = new AudioBuffer({length: context.length, sampleRate: context.sampleRate});
            let data = buffer.getChannelData(0);
            for (let k = 0; k < data.length; ++k) {
              data[k] = k + 1;
            }

            let delay0 = 64;
            let delay1 = 16;
            let src = new AudioBufferSourceNode(context, {buffer: buffer});
            let delay = new DelayNode(context, {delayTime: delay0 / context.sampleRate});

            src.connect(delay).connect(context.destination);0

            // After a render quantum, change the delay.
            context.suspend(RENDER_QUANTUM_FRAMES / context.sampleRate)
                .then(() => {
                  delay.delayTime.value = delay1 / context.sampleRate;
                  //delay.delayTime.setValueAtTime(delay1 / context.sampleRate, context.currentTime);
                })
                .then(() => context.resume());

            src.start();
            context.startRendering()
                .then(renderedBuffer => {
                  let renderedData = renderedBuffer.getChannelData(0);

                  console.log(renderedData);

                  // The first |delay0| frames should be zero.
                  should(renderedData.slice(0, delay0),
                    'output[0:' + (delay0 - 1) + ']')
                    .beConstantValueOf(0);

                  // Now we have the ramp should show up.
                  let ramp0 = new Float32Array(RENDER_QUANTUM_FRAMES - delay0);
                  for (let k = 0; k < ramp0.length; ++k) {
                    ramp0[k] = k + 1;
                  }
                  should(renderedData.slice(delay0, RENDER_QUANTUM_FRAMES),
                    'output[' + delay0 + ':' + (RENDER_QUANTUM_FRAMES - 1) + ']')
                    .beEqualToArray(ramp0);

                  // After one rendering quantum, the delay is changed to
                  // |delay1|.
                  let ramp1 = new Float32Array(context.length - RENDER_QUANTUM_FRAMES);
                  for (let k = 0; k < ramp1.length; ++k) {
                    ramp1[k] = 1 + k + RENDER_QUANTUM_FRAMES - delay1;
                  }
                  should(renderedData.slice(RENDER_QUANTUM_FRAMES),
                    'output[' + RENDER_QUANTUM_FRAMES + ':]')
                    .beEqualToArray(ramp1);
                })
                .then(() => task.done());
          });

      audit.run();

    </script>
  </body>
</html>
