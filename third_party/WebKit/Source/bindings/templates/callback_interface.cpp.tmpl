{% filter format_blink_cpp_source_code %}

{% include 'copyright_block.txt' %}

#include "{{v8_class}}.h"

{% for filename in cpp_includes %}
#include "{{filename}}"
{% endfor %}

namespace blink {

{% for method in methods %}

{% set return_type = 'void' if method.cpp_type == 'void' else 'v8::Maybe<%s>' % method.cpp_type %}
{% set return_nothing = 'return' if method.cpp_type == 'void' else 'return v8::Nothing<%s>()' % method.cpp_type %}

// 
// https://heycam.github.io/webidl/#call-a-user-objects-operation
{{return_type}} {{v8_class}}::{{method.name}}({{method.argument_declarations | join(', ')}}) {
  {# TODO(yukishiino): Add |ScriptWrappable* callback_this_value| as the first
     argument of the IDL operations. The callsites must pass callback_this_value
     explicitly. #}
  ScriptWrappable* callback_this_value = nullptr;

  if (!IsCallbackInterfaceRunnable(CallbackRelevantContext(),
                                   IncumbentContext())) {
    V8ThrowException::ThrowError(
        GetIsolate(),
        ExceptionMessages::FailedToExecute(
            "{{method.name}}",
            "{{cpp_class}}",
            "The provided callback is no longer runnable."));
    {{return_nothing}};
  }

  // step 7. Prepare to run script with relevant settings.
  ScriptState::Scope callback_relevant_context_scope(CallbackRelevantContext());
  // step 8. Prepare to run a callback with stored settings.
  v8::Context::BackupIncumbentScope backup_incumbent_scope(
      IncumbentContext()->GetContext());

  // 
  v8::TryCatch tryCatch(GetIsolate());
  tryCatch.SetVerbose(true);

  v8::Local<v8::Function> function;
  if (IsCallbackObjectCallable()) {
    // step 9.1. If value's interface is a single operation callback interface
    //   and !IsCallable(O) is true, then set X to O.
    function = CallbackObject().As<v8::Function>();
  } else {
    // step 9.2.1. Let getResult be Get(O, opName).
    // step 9.2.2. If getResult is an abrupt completion, set completion to
    //   getResult and jump to the step labeled return.
    v8::Local<v8::Value> value;
    if (!CallbackObject()->Get(CallbackRelevantContext()->GetContext(),
                               V8String(GetIsolate(), "{{method.name}}"))
        .ToLocal(&value)) {
      {{return_nothing}};
    }
    // step 10. If !IsCallable(X) is false, then set completion to a new
    //   Completion{[[Type]]: throw, [[Value]]: a newly created TypeError
    //   object, [[Target]]: empty}, and jump to the step labeled return.
    if (!value->IsFunction()) {
      V8ThrowException::ThrowTypeError(
          GetIsolate(),
          ExceptionMessages::FailedToExecute(
              "{{method.name}}",
              "{{cpp_class}}",
              "The provided callback is not callable."));
      {{return_nothing}};
    }
  }

  v8::Local<v8::Value> this_arg;
  if (!IsCallbackObjectCallable()) {
    // step 11. If value's interface is not a single operation callback
    //   interface, or if !IsCallable(O) is false, set thisArg to O (overriding
    //   the provided value).
    this_arg = CallbackObject();
  } else if (!callback_this_value) {
    // step 2. If thisArg was not given, let thisArg be undefined.
    this_arg = v8::Undefined(GetIsolate());
  } else {
    this_arg = ToV8(callback_this_value, CallbackRelevantContext());
  }

  // step 12. Let esArgs be the result of converting args to an ECMAScript
  //   arguments list. If this throws an exception, set completion to the
  //   completion value representing the thrown exception and jump to the step
  //   labeled return.
  v8::Local<v8::Object> argument_creation_context =
      CallbackRelevantContext()->GetContext()->Global();
  ALLOW_UNUSED_LOCAL(argument_creation_context);
  {% for argument in method.arguments %}
  v8::Local<v8::Value> {{argument.handle}} = {{argument.cpp_value_to_v8_value}};
  {% endfor %}
  {% if method.arguments %}
  v8::Local<v8::Value> argv[] = { {{method.arguments | join(', ', 'handle')}} };
  {% else %}
  {# Zero-length arrays are ill-formed in C++. #}
  v8::Local<v8::Value> *argv = nullptr;
  {% endif %}

  // step 13. Let callResult be Call(X, thisArg, esArgs).
  v8::MaybeLocal<v8::Value> maybe_call_result = V8ScriptRunner::CallFunction(
      function,
      ExecutionContext::From(CallbackRelevantContext()),
      this_arg,
      {{method.arguments | length}},
      argv,
      GetIsolate());

  // step 14. If callResult is an abrupt completion, set completion to
  //   callResult and jump to the step labeled return.
  v8::Local<v8::Value> call_result;
  if (!maybe_call_result.ToLocal(&call_result)) {
    {{return_nothing}};
  }
  // step 15. Set completion to the result of converting callResult.[[Value]] to
  //   an IDL value of the same type as the operation's return type.
  {% if method.idl_type == 'void' %}
  return;
  {% else %}
  {
    ExceptionState exception_state(GetIsolate(),
                                   ExceptionState::kExecutionContext,
                                   "{{cpp_class}}",
                                   "{{method.name}}");
    {% set idl_return_type = 'IDLBoolean' if method.cpp_type == 'bool' %}
    auto native_result =
        NativeValueTraits<{{idl_return_type}}>::NativeValue(
            GetIsolate(), call_result, exception_state);
    return exception_state.HadException() ?
        v8::Nothing<{{method.cpp_type}}>() :
        v8::Just<{{method.cpp_type}}>(native_result);
  }
  {% endif %}
}

{% endfor %}

}  // namespace blink

{% endfilter %}{# format_blink_cpp_source_code #}
