{% filter format_blink_cpp_source_code %}

{% include 'copyright_block.txt' %}

#include "{{v8_class}}.h"

{% for filename in cpp_includes %}
#include "{{filename}}"
{% endfor %}

namespace blink {

{% for method in methods if not method.is_custom %}
{% if not (method.idl_type == 'void' or
           method.idl_type == 'boolean') %}
#error Operations in a callback interface with return type {{method.idl_type}} are not supported.
{% endif %}

{{method.cpp_type}} {{v8_class}}::{{method.name}}(ScriptWrappable* callback_this_value{% if method.arguments %}, {% endif %}{{method.argument_declarations | join(', ')}}) {
  if (!IsCallbackInterfaceRunnable(CallbackRelevantContext(),
                                   IncumbentContext())) {
    return{% if method.idl_type == 'boolean' %} true{% endif %};
  }

  {% set return_on_failure = 'return false;' if method.idl_type == 'boolean'
      else 'return;' %}

  // https://heycam.github.io/webidl/#call-a-user-objects-operation
  // step 7. Prepare to run script with relevant settings.
  ScriptState::Scope callback_relevant_context_scope(CallbackRelevantContext());
  // step 8. Prepare to run a callback with stored settings.
  v8::Context::BackupIncumbentScope backup_incumbent_scope(
      IncumbentContext()->GetContext());

  v8::TryCatch tryCatch(GetIsolate());
  tryCatch.SetVerbose(true);

  v8::Local<v8::Function> function;
  if (IsCallbackObjectCallable()) {
    // step 9.1. If value's interface is a single operation callback interface
    //   and !IsCallable(O) is true, then set X to O.
    function = CallbackObject().As<v8::Function>();
  } else {
    // step 9.2.1. Let getResult be Get(O, opName).
    // step 9.2.2. If getResult is an abrupt completion, set completion to
    //   getResult and jump to the step labeled return.
    v8::Local<v8::Value> value;
    if (!CallbackObject()->Get(CallbackRelevantContext()->GetContext(),
                               V8String(GetIsolate(), "{{method.name}}"))
        .ToLocal(&value)) {
      {{return_on_failure}}
    }
    // step 10. If !IsCallable(X) is false, then set completion to a new
    //   Completion{[[Type]]: throw, [[Value]]: a newly created TypeError
    //   object, [[Target]]: empty}, and jump to the step labeled return.
    if (!value->IsFunction()) {
      V8ThrowException::ThrowTypeError(
          GetIsolate(),
          ExceptionMessages::FailedToExecute(
              "{{method.name}}",
              "{{cpp_class}}",
              "The provided callback is not callable."));
      {{return_on_failure}}
    }
  }

  v8::Local<v8::Value> this_arg;
  if (!IsCallbackObjectCallable()) {
    // step 11. If value's interface is not a single operation callback
    //   interface, or if !IsCallable(O) is false, set thisArg to O (overriding
    //   the provided value).
    this_arg = CallbackObject();
  } else if (!callback_this_value) {
    // step 2. If thisArg was not given, let thisArg be undefined.
    this_arg = v8::Undefined(GetIsolate());
  } else {
    this_arg = ToV8(callback_this_value, CallbackRelevantContext());
  }

  // step 12. Let esArgs be the result of converting args to an ECMAScript
  //   arguments list. If this throws an exception, set completion to the
  //   completion value representing the thrown exception and jump to the step
  //   labeled return.
  v8::Local<v8::Object> argument_creation_context =
      CallbackRelevantContext()->GetContext()->Global();
  ALLOW_UNUSED_LOCAL(argument_creation_context);
  {% for argument in method.arguments %}
  v8::Local<v8::Value> {{argument.handle}} = {{argument.cpp_value_to_v8_value}};
  {% endfor %}
  {% if method.arguments %}
  v8::Local<v8::Value> argv[] = { {{method.arguments | join(', ', 'handle')}} };
  {% else %}
  {# Empty array initializers are illegal, and don\'t compile in MSVC. #}
  v8::Local<v8::Value> *argv = nullptr;
  {% endif %}

  // step 13. Let callResult be Call(X, thisArg, esArgs).
  v8::MaybeLocal<v8::Value> maybe_call_result = V8ScriptRunner::CallFunction(
      function,
      ExecutionContext::From(CallbackRelevantContext()),
      this_arg,
      {{method.arguments | length}},
      argv,
      GetIsolate());

  // step 14. If callResult is an abrupt completion, set completion to
  //   callResult and jump to the step labeled return.
  v8::Local<v8::Value> call_result;
  if (!maybe_call_result.ToLocal(&call_result)) {
    {{return_on_failure}}
  }
  // step 15. Set completion to the result of converting callResult.[[Value]] to
  //   an IDL value of the same type as the operation's return type.
  {% if method.idl_type == 'boolean' %}
  {
    ExceptionState exception_state(GetIsolate(),
                                   ExceptionState::kExecutionContext,
                                   "{{cpp_class}}",
                                   "{{method.name}}");
    return NativeValueTraits<IDLBoolean>::NativeValue(
        GetIsolate(), call_result, exception_state);
  }
  {% endif %}
}

{% endfor %}

}  // namespace blink

{% endfilter %}{# format_blink_cpp_source_code #}
