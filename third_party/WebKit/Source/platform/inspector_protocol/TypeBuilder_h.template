// This file is generated

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef {{class_name}}_h
#define {{class_name}}_h

#include "platform/JSONValues.h"
#include "platform/PlatformExport.h"
#include "wtf/Assertions.h"
#include "wtf/PassOwnPtr.h"
#include "wtf/PassRefPtr.h"
#include "wtf/text/WTFString.h"

namespace blink {
namespace protocol {

template<typename T>
class OptionalValue {
public:
    OptionalValue() : m_hasValue(false) { }
    OptionalValue(const T& value) : m_hasValue(true), m_value(value) { }

    void operator=(T value)
    {
        m_value = value;
        m_hasValue = true;
    }

    T get() const
    {
        ASSERT(m_hasValue);
        return m_value;
    }

    T get(const T& defaultValue) const
    {
        return m_hasValue ? m_value : defaultValue;
    }

    bool hasValue() const
    {
        return m_hasValue;
    }

private:
    bool m_hasValue;
    T m_value;
};

template<typename T>
OptionalValue<T> optional(const T* value)
{
    return value ? OptionalValue<T>(*value) : OptionalValue<T>();
}

PLATFORM_EXPORT OptionalValue<String> optional(const String& value);

template<typename T>
OptionalValue<T> optional(const T& value)
{
    return OptionalValue<T>(value);
}

template<typename T> class Array;

template<typename T>
bool hasValue(const protocol::OptionalValue<T>& t) { return t.hasValue(); }

template<typename T>
bool hasValue(T* value) { return !!value; }

template<typename T>
bool hasValue(const OwnPtr<T>& value) { return !!value; }

template<typename T>
bool hasValue(const PassOwnPtr<T>& value) { return !!value; }

template<typename T>
bool hasValue(const RefPtr<T>& value) { return !!value; }

template<typename T>
PassRefPtr<JSONValue> toValue(const T& param)
{
    return JSONBasicValue::create(param);
}

template<>
PLATFORM_EXPORT PassRefPtr<JSONValue> toValue(const String& param);

template<typename T>
PassRefPtr<JSONValue> toValue(PassRefPtr<T> param)
{
    return param;
}

template<typename T>
PassRefPtr<JSONValue> toValue(const PassOwnPtr<protocol::Array<T>> param)
{
    return param->asValue();
}

template<typename T>
PassRefPtr<JSONValue> toValue(PassOwnPtr<T> param)
{
    return param->asValue();
}

template<typename T>
struct FromValue
{
    static PassOwnPtr<T> convert(RefPtr<JSONValue> value)
    {
        return T::runtimeCast(JSONObject::cast(value.release()));
    }
};

template<>
struct FromValue<bool>
{
    static bool convert(RefPtr<JSONValue> value)
    {
        bool result;
        bool success = value->asBoolean(&result);
        ASSERT_UNUSED(success, success);
        return result;
    }
};

template<>
struct FromValue<int>
{
    static int convert(RefPtr<JSONValue> value)
    {
        int result;
        bool success = value->asNumber(&result);
        ASSERT_UNUSED(success, success);
        return result;
    }
};

template<>
struct FromValue<double>
{
    static double convert(RefPtr<JSONValue> value)
    {
        double result;
        bool success = value->asNumber(&result);
        ASSERT_UNUSED(success, success);
        return result;
    }
};

template<>
struct FromValue<String>
{
    static String convert(RefPtr<JSONValue> value)
    {
        String result;
        bool success = value->asString(&result);
        ASSERT_UNUSED(success, success);
        return result;
    }
};

template<typename T>
struct FromValue<RefPtr<T>>
{
    static PassRefPtr<T> convert(RefPtr<T> value)
    {
        return value.release();
    }
};

template<typename T>
struct FromValue<protocol::Array<T>>
{
    static PassOwnPtr<protocol::Array<T>> convert(RefPtr<JSONValue> value)
    {
        return protocol::Array<T>::runtimeCast(JSONArray::cast(value));
    }
};

template<typename T>
class ArrayBase {
public:
    static PassOwnPtr<Array<T>> create()
    {
        OwnPtr<Array<T>> result = adoptPtr(new Array<T>());
        result->m_array = JSONArray::create();
        return result.release();
    }

    static PassOwnPtr<Array<T>> runtimeCast(PassRefPtr<JSONValue> array)
    {
        if (!array || array->type() != JSONValue::TypeArray)
            return nullptr;
        OwnPtr<Array<T>> result = adoptPtr(new Array<T>());
        result->m_array = JSONArray::cast(array);
        return result.release();
    }

    void addItem(const T& value)
    {
        m_array->pushValue(toValue(value));
    }

    size_t length() { return m_array->length(); }

    T get(size_t index) { return FromValue<T>::convert(m_array->get(index)); }
    PassRefPtr<JSONArray> asValue() { return m_array; }

private:
    RefPtr<JSONArray> m_array;
};

template<> class Array<String> : public ArrayBase<String> {};
template<> class Array<int> : public ArrayBase<int> {};
template<> class Array<double> : public ArrayBase<double> {};
template<> class Array<bool> : public ArrayBase<bool> {};
template<typename T> class Array<RefPtr<T>> : public ArrayBase<RefPtr<T>> {};

template<typename T>
class Array {
public:
    static PassOwnPtr<Array<T>> create()
    {
        OwnPtr<Array<T>> result = adoptPtr(new Array<T>());
        result->m_array = JSONArray::create();
        return result.release();
    }

    static PassOwnPtr<Array<T>> runtimeCast(PassRefPtr<JSONValue> array)
    {
        if (!array || array->type() != JSONValue::TypeArray)
            return nullptr;
        OwnPtr<Array<T>> result = adoptPtr(new Array<T>());
        result->m_array = JSONArray::cast(array);
        return result.release();
    }

    void addItem(PassOwnPtr<T> value)
    {
        m_array->pushValue(toValue(value));
    }

    size_t length() { return m_array->length(); }

    PassOwnPtr<T> get(size_t index) { return FromValue<T>::convert(m_array->get(index)); }
    PassRefPtr<JSONArray> asValue() { return m_array; }

private:
    RefPtr<JSONArray> m_array;
};

{% for domain in api.domains %}

// ------------- Forward declarations and typedefs.

namespace {{domain.domain}} {
  {% for type in domain.types %}
    {% if type.type == "object" %}
// {{type.description}}
class {{type.id}};
    {% elif type.type != "array" %}
// {{type.description}}
using {{type.id}} = {{resolve_type(type).type}};
    {% endif %}
  {% endfor %}
} // {{domain.domain}}
{% endfor %}

// ------------- Enum values from types.
{% for domain in api.domains %}
  {% for type in domain.types %}
    {% if "enum" in type %}

namespace {{domain.domain}} {
namespace {{type.id}}Enum {
      {% for literal in type.enum %}
PLATFORM_EXPORT extern const char* {{ literal | dash_to_camelcase}};
      {% endfor %}
} // {{type.id}}Enum
} // {{domain.domain}}
    {% endif %}
  {% endfor %}
{% endfor %}

// ------------- Enum values from params.
{% for domain in api.domains %}
  {% for command in join_arrays(domain, ["commands", "events"]) %}
    {% for param in join_arrays(command, ["parameters", "returns"]) %}
      {% if "enum" in param %}

namespace {{domain.domain}} {
namespace {{command.name | to_title_case}} {
namespace {{param.name | to_title_case}}Enum {
        {% for literal in param.enum %}
PLATFORM_EXPORT extern const char* {{ literal | dash_to_camelcase}};
        {% endfor %}
} // {{param.name | to_title_case}}Enum
} // {{command.name | to_title_case }}
} // {{domain.domain}}
      {% endif %}
    {% endfor %}
  {% endfor %}
{% endfor %}

// ------------- Type and builder declarations.
{% for domain in api.domains %}

namespace {{domain.domain}} {
  {% for type in domain.types %}
    {% if type.type == "object" %}
      {% set type_def = type_definition(domain.domain + "." + type.id)%}

// {{type.description}}
class PLATFORM_EXPORT {{type.id}} {
public:
    static PassOwnPtr<{{type.id}}> runtimeCast(PassRefPtr<JSONValue> value)
    {
        if (!value || value->type() != JSONValue::TypeObject)
            return nullptr;
        return adoptPtr(new {{type.id}}(JSONObject::cast(value)));
    }

    {{type.id}}() : m_object(JSONObject::create()) { }

    ~{{type.id}}() { }
      {% for property in type.properties %}

        {% if "enum" in property %}
    struct PLATFORM_EXPORT {{property.name | to_title_case}}Enum {
          {% for literal in property.enum %}
        static const char* {{ literal | dash_to_camelcase}};
          {% endfor %}
    }; // {{property.name | to_title_case}}Enum
        {% endif %}

    bool has{{property.name | to_title_case}}()
    {
        RefPtr<JSONValue> value = m_object->get("{{property.name}}");
        {% if resolve_type(property).json_type %}
        return value && value->type() == JSONValue::{{resolve_type(property).json_type}};
        {% else %}
        return !!value;
        {% endif %}
    }

        {% if property.optional %}
    {{resolve_type(property).return_type}} get{{property.name | to_title_case}}({{resolve_type(property).return_type}} defaultValue)
    {
        RefPtr<JSONValue> value = m_object->get("{{property.name}}");
        return value ? FromValue<{{resolve_type(property).raw_type}}>::convert(value) : defaultValue;
    }
        {% else %}
    {{resolve_type(property).return_type}} get{{property.name | to_title_case}}()
    {
        ASSERT(has{{property.name | to_title_case}}());
        RefPtr<JSONValue> value = m_object->get("{{property.name}}");
        return FromValue<{{resolve_type(property).raw_type}}>::convert(value);
    }
        {% endif %}

    void set{{property.name | to_title_case}}({{resolve_type(property).pass_type}} value)
    {
        {% if property.optional and resolve_type(property).nullable %}
        if (value)
            m_object->setValue("{{property.name}}", toValue(value));
        {% else %}
        m_object->setValue("{{property.name}}", toValue(value));
        {% endif %}
    }
      {% endfor %}

    PassRefPtr<JSONObject> asValue() { return m_object; }

    PassOwnPtr<{{type.id}}> clone() { return adoptPtr(new {{type.id}}(m_object)); }

    template<int STATE>
    class {{type.id}}Builder {
    public:
        enum {
            NoFieldsSet = 0,
      {% set count = 0 %}
      {% for property in type.properties %}
        {% if not(property.optional) %}
          {% set count = count + 1 %}
            {{property.name | to_title_case}}Set = 1 << {{count}},
        {% endif %}
      {% endfor %}
            AllFieldsSet = (
      {%- for property in type.properties %}
        {% if not(property.optional) %}{{property.name | to_title_case}}Set | {%endif %}
      {% endfor %}0)};

      {% for property in type.properties %}

        {% if property.optional %}
        {{type.id}}Builder<STATE>& set{{property.name | to_title_case}}({{resolve_type(property).pass_type}} value)
        {
          {% if resolve_type(property).nullable%}
            if (!value)
                return *this;
          {% endif %}
            m_result->set{{property.name | to_title_case}}(value);
            return *this;
        }
        {% else %}
        {{type.id}}Builder<STATE | {{property.name | to_title_case}}Set>& set{{property.name | to_title_case}}({{resolve_type(property).pass_type}} value)
        {
            static_assert(!(STATE & {{property.name | to_title_case}}Set), "property {{property.name}} should not be set yet");
            m_result->set{{property.name | to_title_case}}(value);
            return castState<{{property.name | to_title_case}}Set>();
        }
        {% endif %}
      {% endfor %}

        PassOwnPtr<{{type.id}}> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return m_result.release();
        }

    private:
        friend class {{type.id}};
        {{type.id}}Builder() : m_result({{type_def.create_type}}) { }

        template<int STEP> {{type.id}}Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<{{type.id}}Builder<STATE | STEP>*>(this);
        }

        {{type_def.type}} m_result;
    };

    static {{type.id}}Builder<0> create()
    {
        return {{type.id}}Builder<0>();
    }

private:
    explicit {{type.id}}(PassRefPtr<JSONObject> object) : m_object(object) { }
    RefPtr<JSONObject> m_object;
};

    {% endif %}
  {% endfor %}

} // {{domain.domain}}
{% endfor %}

} // namespace protocol
} // namespace blink

#endif // !defined({{class_name}}_h)
