// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef ObjectPaintInvalidator_h
#define ObjectPaintInvalidator_h

#include "platform/graphics/PaintInvalidationReason.h"
#include "wtf/Allocator.h"

namespace blink {

class LayoutObject;
class LayoutRect;
struct PaintInvalidatorContext;

class ObjectPaintInvalidator {
    STACK_ALLOCATED();
public:
    ObjectPaintInvalidator(const LayoutObject& object, const PaintInvalidatorContext& context)
        : m_object(object), m_context(context) { }

    static void objectWillBeDestroyed(const LayoutObject&);

    PaintInvalidationReason invalidatePaintIfNeeded() { return invalidatePaintIfNeededWithComputedReason(computePaintInvalidationReason()); }

    PaintInvalidationReason computePaintInvalidationReason();
    PaintInvalidationReason invalidatePaintIfNeededWithComputedReason(PaintInvalidationReason);

private:
    void invalidateSelectionIfNeeded(PaintInvalidationReason);

    // This function tries to minimize the amount of invalidation generated by invalidating the "difference" between
    // |m_context.oldBounds| and |m_context.newBounds|. This means invalidating the union of the previous rectangles
    // but not their intersection. The use case is when an element only requires a paint invalidation (which means
    // that its content didn't change) and its bounds changed but its location didn't.
    // If we don't meet the criteria for an incremental paint, the alternative is a full paint invalidation.
    void incrementallyInvalidatePaint();

    // This function generates a full invalidation, which means invalidating both |oldBounds| and |newBounds|.
    // This is the default choice when generating an invalidation, as it is always correct, albeit it may force some extra painting.
    void fullyInvalidatePaint(PaintInvalidationReason, const LayoutRect& oldBounds, const LayoutRect& newBounds);

    const LayoutObject& m_object;
    const PaintInvalidatorContext& m_context;
};

} // namespace blink

#endif
