{
  "comments": [
    {
      "key": {
        "uuid": "90d2a4a8_319d4949",
        "filename": "net/quic/chromium/quic_chromium_client_session_test.cc",
        "patchSetId": 8
      },
      "lineNbr": 237,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-12-01T16:22:53Z",
      "side": 1,
      "message": "This test actually reveals a surprising behaviour that I\u0027m not sure is correct. I\u0027m unclear from the original implementation whether this is simply maintaining a pre-existing behaviour, but the other fields in the SSLInfo (for SSLClientSocket and for QUIC) represent \u0027point in time\u0027 statements, generally related to connection establishment. By computing this on the fly, we end up in a position where mutations might happen - the very thing you\u0027re testing.\n\nI would think we only set this state when we compute the proof details (or when we verify the certificate). \n\nIt looked like the old code would set it in the SSLErrorNavigationThrottle (thus computing it at that time), but I found that slightly more easier to reason about, because that would only be called once for the connection.\n\nEmily, I think you\u0027ve got a lot of mental state on the error handling - what\u0027s your take on what the behaviour would/should be?",
      "revId": "26003f59539428e2a1fc197b9c894eced99a5742",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db67d496_56e2dbb2",
        "filename": "net/quic/chromium/quic_chromium_client_session_test.cc",
        "patchSetId": 8
      },
      "lineNbr": 237,
      "author": {
        "id": 1126726
      },
      "writtenOn": "2017-12-01T16:42:00Z",
      "side": 1,
      "message": "Hmm, yes, that is a bit odd. I don\u0027t *think* anything will go terribly wrong from computing it on the fly, but I agree it would be cleaner to compute it once per connection. I think that would mean doing something more like how |pkp_bypassed_| works: have a |is_fatal_cert_error_| member on QuicChromiumClientSession and SSLClientSocketImpl. In the former, set it on OnProofVerifyDetailsAvailable, and in the latter in DoVerifyCertComplete, and then copy it into the SSLInfo in GetSSLInfo(). Does that sound okay to you, Ryan?",
      "parentUuid": "90d2a4a8_319d4949",
      "revId": "26003f59539428e2a1fc197b9c894eced99a5742",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3007864b_25176f5b",
        "filename": "net/quic/chromium/quic_chromium_client_session_test.cc",
        "patchSetId": 8
      },
      "lineNbr": 237,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-12-01T16:50:21Z",
      "side": 1,
      "message": "Yup, exactly where I was thinking if we wanted to precompute - whenever we validate a cert (and populate the cert_status) is when we should populate the fatal error bit.",
      "parentUuid": "db67d496_56e2dbb2",
      "revId": "26003f59539428e2a1fc197b9c894eced99a5742",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}