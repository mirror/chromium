{
  "comments": [
    {
      "key": {
        "uuid": "3afe535e_e2d91161",
        "filename": "content/browser/frame_host/frame_tree.cc",
        "patchSetId": 13
      },
      "lineNbr": 272,
      "author": {
        "id": 1001216
      },
      "writtenOn": "2017-08-31T22:00:34Z",
      "side": 1,
      "message": "I still haven\u0027t quite wrapped my head around the recovering-from-crash case, but I haven\u0027t thought of a place it\u0027s broken yet.  :)  The first navigation in the recreated process may be slow or not succeed, but I can\u0027t seem to think of a way for another frame to commit first *and* expect a proxy here.  I guess we\u0027re ok with skipping the proxy, if you think it\u0027s just unnecessary work.",
      "revId": "fd2b0dae3b52a87eefa501a06acfbe062de8e1fd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8258202d_3a47ecef",
        "filename": "content/browser/frame_host/frame_tree.cc",
        "patchSetId": 13
      },
      "lineNbr": 272,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-09-07T17:35:26Z",
      "side": 1,
      "message": "I *think* it\u0027s just unnecessary work.  For a cross-site navigation via GetFrameHostForNavigation/UpdateStateForNavigate, we will hit this path:\n\n    if (!render_frame_host_-\u003eIsRenderFrameLive()) {\n      // The current RFH is not live.  There\u0027s no reason to sit around with a\n      // sad tab or a newly created RFH while we wait for the pending RFH to\n      // navigate.  Just switch to the pending RFH now and go back to normal.\n      // (Note that we don\u0027t care about on{before}unload handlers if the current\n      // RFH isn\u0027t live.)\n      //\n      // If the corresponding RenderFrame is currently associated with a proxy,\n      // send a SwapIn message to ensure that the RenderFrame swaps into the\n      // frame tree and replaces that proxy on the renderer side.  Normally\n      // this happens at navigation commit time, but in this case this must be\n      // done earlier to keep browser and renderer state in sync.  This is\n      // important to do before CommitPending(), which destroys the\n      // corresponding proxy. See https://crbug.com/487872.\n      if (GetRenderFrameProxyHost(new_instance.get())) {\n        pending_render_frame_host_-\u003eSend(\n            new FrameMsg_SwapIn(pending_render_frame_host_-\u003eGetRoutingID()));\n      }\n      CommitPending();\n      return render_frame_host_.get();\n    }\n\nCommitPending destroys the RFPH we\u0027ve just created, and FrameMsg_SwapIn will remove the proxy on the renderer side (unnecessary work).\n\nThere are also a few entrypoints into this function outside of creating the pending/speculative RFH, via CreateOpenerProxies, that are worth reasoning through:\n\n- WebContentsImpl::EnsureOpenerProxiesExist doesn\u0027t pass a |source|, so this won\u0027t matter.\n\n- RFHI/RFPH::UpdateOpener passes frame_tree_node_ as |source|, and the ChangeOpener IPC won\u0027t be received if the source SiteInstance\u0027s process is dead.\n\n- RenderFrameHostManager::ReinitializeRenderFrame: I think we can get here if we are navigating and staying in the same RFH, which isn\u0027t live.  In that case, there\u0027s no cross-process navigation and hence no need for a proxy anyway.\n\nIt seems we will hit this for opening brand new tabs for the initial non-live RFH and the first navigation in it, and it\u0027d be nice to avoid the overhead (if it\u0027s safe!).",
      "parentUuid": "3afe535e_e2d91161",
      "revId": "fd2b0dae3b52a87eefa501a06acfbe062de8e1fd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ab3c6f7_4e0e9f75",
        "filename": "content/browser/frame_host/frame_tree.cc",
        "patchSetId": 13
      },
      "lineNbr": 278,
      "author": {
        "id": 1001216
      },
      "writtenOn": "2017-08-31T22:00:34Z",
      "side": 1,
      "message": "I can see the reasoning for this, but I think I found a case where it\u0027s wrong.  :)\n\nWhen going to a new BrowsingInstance, we won\u0027t need any proxies.  But you can go back into an existing BrowsingInstance as well, and then you might.  Repro steps:\n1) Visit http://csreis.github.io/tests/window-open.html\n2) Click \"Open simple window\".  Check that there\u0027s a window.opener in DevTools.\n3) Navigate the second window to chrome://chrome-urls.\n4) Verify it has no window.opener anymore in DevTools.\n5) Run \"w \u003d window.open();\" in the second window, which itself will have a window.opener.\n6) Go back in the second window.  It now has a window.opener again, after the cross-BrowsingInstance navigation.\n\nThus, proxies may be needed in some of these cases.  Maybe we should try to fix the WebUI crashes a different way?\n\n(For some real fun, look what happens when you check the opener of the about:blank popup after going back in step 6.  The opener is kind of half there, being shown as a structured object but of type \"undefined\" instead of \"Window.\")",
      "revId": "fd2b0dae3b52a87eefa501a06acfbe062de8e1fd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70adc629_bfbe493f",
        "filename": "content/browser/frame_host/frame_tree.cc",
        "patchSetId": 13
      },
      "lineNbr": 278,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-09-05T17:47:15Z",
      "side": 1,
      "message": "Yeah, coming back into a BrowsingInstance indeed brings back openers, so yes, we need to deal with that case as well.  Good catch!  And indeed, the third tab (window.open\u0027ed from chrome-urls) will also have a valid opener to the second tab, across BrowsingInstances!  But it still can\u0027t send it postMessages, thanks to our BrowsingInstance checks in OnRouteMessageEvent.\n\nI tried removing the related SiteInstance check and just fixing the GetMainFrame usage in RenderViewHostImpl::SetWebUIProperty(), but that wasn\u0027t enough and revealed a few other problems that we should probably discuss before I continue implementing anything.\n\nTurns out several WebUI tests also rely on test setup done on RenderViewCreated, and it\u0027s too late to generate that at commit time, when the RVH transitions to active, as WebUITestHandler::PreloadJavaScript() wants to inject JS into the RFH before anything runs there.  And moreover, it also relies on rvh-\u003eGetMainFrame() being correct at RenderViewCreated time.  So this is one case that\u0027s broken by not dispatching RenderViewCreated properly anymore, which I\u0027m actually happy about, because it gives us a concrete reason to fix it.\n\nHere are a few ideas/alternatives I\u0027m considering.  Let me know what you think:\n\n1. Dispatch RenderViewCreated as soon as a new pending/speculative main frame RFH is created, even for inactive RVHs.  The navigation may never commit, but that matches the old behavior where we could also send a RenderViewCreated for a rvh that wouldn\u0027t commit the main frame navigation.\n\n2. Change RenderViewHostImpl::GetMainFrame() to internally know about pending main frame navigations, and return the pending RFH if the rvh is inactive.\n\n3. Alternatively, introduce a new method, GetNavigatingMainFrame(), which would do this, similarly to RenderFrameHostManager::GetNavigatingWebUI().\n\n4. Refactor everything on WebUITestHandler::PreloadJavaScript path to use RenderFrameCreated instead.  Also change RenderViewHostImpl::SetWebUIProperty to use the pending RFH if one exists.\n\n5. Disable proxy creation only when transitioning into a WebUI SiteInstance if we didn\u0027t want to deal with any of this. \n\nSome more data:\n6.  There are 20 uses of RenderViewHost::GetMainFrame() outside of content/, and only one is a non-test use (in MemoryDetails::CollectChildInfoOnUIThread, where it can easily be replaced with looking up the main frame from WebContents).  So we could change RenderViewHost::GetMainFrame to RenderViewHost::GetMainFrameForTesting() in a followup.\n\n7.  Inside content/, the non-test uses of RVHI::GetMainFrame() are:\n - RenderViewHostImpl::SetWebUIProperty mentioned above\n - three in interstitials\n - SpeechRecognitionDispatcherHost::OnStartRequest\n - WebContentsImpl::OnMessageReceived to let webUI handle messages if needed.\nFor the last three, it might be safer to have GetMainFrame() return the pending RFH in the inactive case, unless we can prove that it doesn\u0027t matter.\n\n8.  There are 27 mostly non-test uses of WCO::RenderViewCreated, with a lot of what sound like less commonly used features (AnswerCardWebContents, ChromeKeyboardUI, DevToolsEyeDropper, etc.).  There are also 3 uses of NOTIFICATION_WEB_CONTENTS_RENDER_VIEW_HOST_CREATED (auth, prerender, thumbnail_tab_helper), which also currently fires from WebContentsImpl::RenderViewCreated only for active RVHs.  To not miss these notifications, let\u0027s decide whether doing (1) is ok.",
      "parentUuid": "4ab3c6f7_4e0e9f75",
      "revId": "fd2b0dae3b52a87eefa501a06acfbe062de8e1fd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2e7aca3_b6366a8c",
        "filename": "content/browser/frame_host/frame_tree.cc",
        "patchSetId": 13
      },
      "lineNbr": 278,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-09-07T17:35:26Z",
      "side": 1,
      "message": "After discussing offline, I went ahead and implemented 1+2.  Please take a look :)\n\nI ended up exposing GetPendingMainFrame from WebContentsImpl so RenderViewHostImpl can access it.  Since we already had this in unit tests, I unified the two, though that required some minor refactoring/cleanup in some tests.\n\nI tried also dispatching RenderViewCreated for inactive RVH being used for subframes in PS17 - even though that failed only one test, BrowserActionApiTest.BrowserActionPopupWithIframe, it pointed to a larger problem, where places like ExtensionHost assume RenderViewCreated will be fired only for both current and pending main frame RVHs; it even has a comment:\n  // A weak pointer to the current or pending RenderViewHost. We don\u0027t access\n  // this through the host_contents because we want to deal with the pending\n  // host, so we can send messages to it before it finishes loading.\n  content::RenderViewHost* render_view_host_;\n\nFiring this for OOPIFs overwrites its render_view_host_ with the subframe\u0027s RVH, and then things get confused on resize behavior, etc.\n\nUntil we can move all these off to RenderFrameCreated, I think it\u0027s safest to keep dispatching it in just the main frame cases.\n\nIf we agree on this approach, I\u0027ll file a followup bug for the other cleanup I mentioned above.\n\n(Sorry for the mess with PSes - PS18 and PS19 were supposed to go into a separate CL but didn\u0027t thanks to a gerrit screw-up.)",
      "parentUuid": "70adc629_bfbe493f",
      "revId": "fd2b0dae3b52a87eefa501a06acfbe062de8e1fd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af85024e_6c652b70",
        "filename": "third_party/WebKit/Source/core/dom/DocumentInit.cpp",
        "patchSetId": 13
      },
      "lineNbr": 76,
      "author": {
        "id": 1118209
      },
      "writtenOn": "2017-08-31T20:59:57Z",
      "side": 1,
      "message": "Daniel, does this seem reasonable?  The behavior should be equivalent AFAIK, and this will work properly for provisional frames, fixing https://crbug.com/760403. (see that bug for background on this - it turned out to break a bunch more tests here, because of extensions::ResourceRequestPolicy::CanRequestResource, which gives empty URL, but not \"about:blank\", a free pass for WAR checks.)",
      "range": {
        "startLine": 76,
        "startChar": 26,
        "endLine": 76,
        "endChar": 41
      },
      "revId": "fd2b0dae3b52a87eefa501a06acfbe062de8e1fd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c0c73dd_8652944b",
        "filename": "third_party/WebKit/Source/core/dom/DocumentInit.cpp",
        "patchSetId": 13
      },
      "lineNbr": 76,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2017-09-01T03:14:06Z",
      "side": 1,
      "message": "Hmm. I guess it\u0027s unavoidable. I have a longstanding Blink intent which got blocked on extensions (for the same reason...)\n\nI\u0027m hoping to fix the extensions code one day still \u003d/",
      "parentUuid": "af85024e_6c652b70",
      "range": {
        "startLine": 76,
        "startChar": 26,
        "endLine": 76,
        "endChar": 41
      },
      "revId": "fd2b0dae3b52a87eefa501a06acfbe062de8e1fd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}