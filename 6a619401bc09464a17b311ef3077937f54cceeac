{
  "comments": [
    {
      "key": {
        "uuid": "e6193f62_a94bc9be",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-08T19:43:15Z",
      "side": 1,
      "message": "Why is this handling the case where ScopedBlockingCallIsInitialized() has not been initialized?\n\nAlso, if we do need to handle that consider unconditionally initializing blocking_observer_ and previous_scoped_blocking_call_ and is_will_block_ to nullptr and then properly initializing them after this line, rather than repeatedly checking ScopedBlockingCallIsInitialized(). That would improve readability.",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56372385_42660a62",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "Would be preferable to DCHECK(ScopedBlockingCallIsInitialized()) but I assume you need this conditional because some APIs use ScopedBlockingCall outside the scope of TaskScheduler? If so checking for if (!tls_blocking_observer) seems more readable to me",
      "parentUuid": "e6193f62_a94bc9be",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80ecccd6_ae51619d",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-08T19:43:15Z",
      "side": 1,
      "message": "Assert that we\u0027re on the main thread?",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c7906230_b9460c0b",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "There\u0027s no way to assert this AFAIK? Can assert thread priority but that\u0027s about it. (don\u0027t have access to DCHECK_CURRENTLY_ON(BrowserThread::UI) in //base).",
      "parentUuid": "80ecccd6_ae51619d",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67ecb188_61336a76",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "How about making BlockingObserver a base class which registers self in its scope. Then this works so long as the observer is instatianted on the main thread before any ScopedBlockingCalls (and when there isn\u0027t one registered we know to ignore ScopedBlockingCalls -- see other comment).\n\nThen we have a scoped object and don\u0027t need to explicitly Init/ClearForTesting.",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}