{
  "comments": [
    {
      "key": {
        "uuid": "e6193f62_a94bc9be",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-08T19:43:15Z",
      "side": 1,
      "message": "Why is this handling the case where ScopedBlockingCallIsInitialized() has not been initialized?\n\nAlso, if we do need to handle that consider unconditionally initializing blocking_observer_ and previous_scoped_blocking_call_ and is_will_block_ to nullptr and then properly initializing them after this line, rather than repeatedly checking ScopedBlockingCallIsInitialized(). That would improve readability.",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56372385_42660a62",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "Would be preferable to DCHECK(ScopedBlockingCallIsInitialized()) but I assume you need this conditional because some APIs use ScopedBlockingCall outside the scope of TaskScheduler? If so checking for if (!tls_blocking_observer) seems more readable to me",
      "parentUuid": "e6193f62_a94bc9be",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0650502c_2b44594d",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-10T01:09:26Z",
      "side": 1,
      "message": "I\u0027m confused. You \"assume you need this conditional\" - shouldn\u0027t we know whether the conditional is needed or not?\n\n\u003e If so checking for if (!tls_blocking_observer) seems more readable to me\n\nHmmm? I\u0027m suggesting:\n\n: blocking_observer_(nullptr), previous_scope_blocking_call_(nullptr), is_will_block_(false) {\n  if (!ScopedBlockingCallIsInitialized())\n    return;\n\n  blocking_observer_ \u003d tls_blocking_observer-\u003eGet();\n  previous_scoped_blocking_call_ \u003d tls_last_scoped_blocking_call-\u003eGet();\n  is_will_block_ \u003d ...\n\nAnytime you can get rid of that many ?: operators it seems like a readability win.",
      "parentUuid": "56372385_42660a62",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "131335bf_743baa5d",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-10T10:26:13Z",
      "side": 1,
      "message": "Ah, well the ternary operations in the initializer list allows the members to be const (I like as much const as possible and am not against a little ternary to keep it that way).\n\nAs far as my \"assumption\" goes. It\u0027s mostly about the fact that I\u0027d like this to be a DCHECK but am \"assuming\" Francois tried this and the DCHECK hit because the APIs that use ScopedBlockingCall can do so outside of a TaskScheduler instance (e.g. in unit tests or non-chrome embedders without a registered BlockingObserver (TaskScheduler)). In that case the ScopedBlockingCall should be a no-op but shouldn\u0027t crash/dcheck.",
      "parentUuid": "0650502c_2b44594d",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80ecccd6_ae51619d",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-08T19:43:15Z",
      "side": 1,
      "message": "Assert that we\u0027re on the main thread?",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c7906230_b9460c0b",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "There\u0027s no way to assert this AFAIK? Can assert thread priority but that\u0027s about it. (don\u0027t have access to DCHECK_CURRENTLY_ON(BrowserThread::UI) in //base).",
      "parentUuid": "80ecccd6_ae51619d",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5c7e9be_ea61b9e7",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-10T01:09:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7906230_b9460c0b",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "67ecb188_61336a76",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "How about making BlockingObserver a base class which registers self in its scope. Then this works so long as the observer is instatianted on the main thread before any ScopedBlockingCalls (and when there isn\u0027t one registered we know to ignore ScopedBlockingCalls -- see other comment).\n\nThen we have a scoped object and don\u0027t need to explicitly Init/ClearForTesting.",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c645bf3a_3972041a",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-11T08:40:27Z",
      "side": 1,
      "message": "This is my favorite option (upgrade BlockingObserver to a scoped class which sets/resets this state in its scope).",
      "parentUuid": "67ecb188_61336a76",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}