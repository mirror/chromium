{
  "comments": [
    {
      "key": {
        "uuid": "e6193f62_a94bc9be",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-08T19:43:15Z",
      "side": 1,
      "message": "Why is this handling the case where ScopedBlockingCallIsInitialized() has not been initialized?\n\nAlso, if we do need to handle that consider unconditionally initializing blocking_observer_ and previous_scoped_blocking_call_ and is_will_block_ to nullptr and then properly initializing them after this line, rather than repeatedly checking ScopedBlockingCallIsInitialized(). That would improve readability.",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56372385_42660a62",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "Would be preferable to DCHECK(ScopedBlockingCallIsInitialized()) but I assume you need this conditional because some APIs use ScopedBlockingCall outside the scope of TaskScheduler? If so checking for if (!tls_blocking_observer) seems more readable to me",
      "parentUuid": "e6193f62_a94bc9be",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0650502c_2b44594d",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-10T01:09:26Z",
      "side": 1,
      "message": "I\u0027m confused. You \"assume you need this conditional\" - shouldn\u0027t we know whether the conditional is needed or not?\n\n\u003e If so checking for if (!tls_blocking_observer) seems more readable to me\n\nHmmm? I\u0027m suggesting:\n\n: blocking_observer_(nullptr), previous_scope_blocking_call_(nullptr), is_will_block_(false) {\n  if (!ScopedBlockingCallIsInitialized())\n    return;\n\n  blocking_observer_ \u003d tls_blocking_observer-\u003eGet();\n  previous_scoped_blocking_call_ \u003d tls_last_scoped_blocking_call-\u003eGet();\n  is_will_block_ \u003d ...\n\nAnytime you can get rid of that many ?: operators it seems like a readability win.",
      "parentUuid": "56372385_42660a62",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "131335bf_743baa5d",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-10T10:26:13Z",
      "side": 1,
      "message": "Ah, well the ternary operations in the initializer list allows the members to be const (I like as much const as possible and am not against a little ternary to keep it that way).\n\nAs far as my \"assumption\" goes. It\u0027s mostly about the fact that I\u0027d like this to be a DCHECK but am \"assuming\" Francois tried this and the DCHECK hit because the APIs that use ScopedBlockingCall can do so outside of a TaskScheduler instance (e.g. in unit tests or non-chrome embedders without a registered BlockingObserver (TaskScheduler)). In that case the ScopedBlockingCall should be a no-op but shouldn\u0027t crash/dcheck.",
      "parentUuid": "0650502c_2b44594d",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80ecccd6_ae51619d",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-08T19:43:15Z",
      "side": 1,
      "message": "Assert that we\u0027re on the main thread?",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c7906230_b9460c0b",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "There\u0027s no way to assert this AFAIK? Can assert thread priority but that\u0027s about it. (don\u0027t have access to DCHECK_CURRENTLY_ON(BrowserThread::UI) in //base).",
      "parentUuid": "80ecccd6_ae51619d",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5c7e9be_ea61b9e7",
        "filename": "base/threading/scoped_blocking_call.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1128439
      },
      "writtenOn": "2018-01-10T01:09:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7906230_b9460c0b",
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "67ecb188_61336a76",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-09T15:51:33Z",
      "side": 1,
      "message": "How about making BlockingObserver a base class which registers self in its scope. Then this works so long as the observer is instatianted on the main thread before any ScopedBlockingCalls (and when there isn\u0027t one registered we know to ignore ScopedBlockingCalls -- see other comment).\n\nThen we have a scoped object and don\u0027t need to explicitly Init/ClearForTesting.",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c645bf3a_3972041a",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-11T08:40:27Z",
      "side": 1,
      "message": "This is my favorite option (upgrade BlockingObserver to a scoped class which sets/resets this state in its scope).",
      "parentUuid": "67ecb188_61336a76",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad101021_f9fb5db1",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-11T13:49:09Z",
      "side": 1,
      "message": "That would be nice, but it doesn\u0027t work with SchedulerWorkerPoolImpl::SchedulerWorkerDelegateImpl, which is instantiated on the main thread and registers itself as a BlockingObserver on a worker thread.",
      "parentUuid": "67ecb188_61336a76",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6bb83e3e_8ecbf908",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-11T14:08:01Z",
      "side": 1,
      "message": "I see, how about keeping the LazyInstance and everything as-is but poking LazyInstance::Get() in BlockingObserver\u0027s constructor. That way we kill the race so long as a BlockingObserver is created early on the main thread (which is generally the case).\n\nKeeping the LazyInstance allows us to not have to worry about embedders doing it differently and us needing overkill synchronization.",
      "parentUuid": "ad101021_f9fb5db1",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "597411ac_72750d00",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-11T15:56:48Z",
      "side": 1,
      "message": "There are at least 2 //base APIs that don\u0027t work unless they have been initialized with external synchronization:\n- base::CommandLine\n- base::AtExitManager (on which LazyInstance::DestructorAtExit and Singleton depend)\nThey are commonly initialized together at the beginning of main() functions (e.g. https://cs.chromium.org/chromium/src/mash/runner/main.cc?l\u003d42\u0026rcl\u003d71dc85fdef6c994ce379c087f2ed5b6d6144f4fe).\n\nHow would you feel about a base::Environment class that initializes CommandLine, AtExitManager and BlockingObserver pointers within a scope? It would be mandatory for anyone who wants to use CommandLine, LazyInstance, Singleton, WaitableEvent, ConditionVariable...\n\nI don\u0027t like the idea of keeping the LazyInstances in scoped_blocking_call.cc, because there are easy ways to avoid them.",
      "parentUuid": "6bb83e3e_8ecbf908",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c474fc07_f7702dda",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-12T09:45:32Z",
      "side": 1,
      "message": "Why WaitableEvent and ConditionVariable?\n\nFor this to work we\u0027d have to make CommandLine::Init private somehow I think (to force callers to use the new thing or every other embedder will forget).\n\nBut for ScopedBlockingCall if we init the LazyInstance early, then it\u0027s essentially free after that isn\u0027t it? I\u0027m not saying it\u0027s ideal but it addresses 99% of the problem in a simple manner, no?",
      "parentUuid": "597411ac_72750d00",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8cee25d7_c945bfb7",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-12T18:36:50Z",
      "side": 1,
      "message": "\u003e Why WaitableEvent and ConditionVariable?\n\nBecause they use ScopedBlockingCall, which requires initialization.\n\n\u003e \n\u003e For this to work we\u0027d have to make CommandLine::Init private somehow I think (to force callers to use the new thing or every other embedder will forget).\n\nMaybe we could keep CommandLine separate, but rename AtExitManager -\u003e BaseEnvironment and make it handle both ScopedBlockingCall pointers initialization and AtExit destructors?\n\n\u003e \n\u003e But for ScopedBlockingCall if we init the LazyInstance early, then it\u0027s essentially free after that isn\u0027t it? I\u0027m not saying it\u0027s ideal but it addresses 99% of the problem in a simple manner, no?\n\nIt feels hacky to \"initialize\" a LazyInstance. Also, accesses are not free since they involve an atomic read+barrier [1]. But since it\u0027s a quick solution and doing a more complex solution wouldn\u0027t help users that much, we can do it.\n\n[1] I know, we can say that it doesn\u0027t matter since they happen before/after blocking calls.",
      "parentUuid": "c474fc07_f7702dda",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c76b0a85_845717dd",
        "filename": "base/threading/scoped_blocking_call.h",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-15T11:54:36Z",
      "side": 1,
      "message": "I like changing AtExitManager into ScopedBaseEnvironmentManager (or something like that) which would enforce initialization and tear down semantics of base APIs.\n\nThat guarantees we (and embedders) are forced to replace AtExitManager with the new hotness.\n\nI think it would also make sense to have this API take in the command-line string as a parameter and be in charge of CommandLine::Init (since we now properly force all callers to be updated that sounds reasonable to me). Not required though if you find out the two are initialized in different places in different embedders and it\u0027s hard to coalesce.",
      "parentUuid": "8cee25d7_c945bfb7",
      "range": {
        "startLine": 85,
        "startChar": 4,
        "endLine": 85,
        "endChar": 20
      },
      "revId": "6a619401bc09464a17b311ef3077937f54cceeac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}