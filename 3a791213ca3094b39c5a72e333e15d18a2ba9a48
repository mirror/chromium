{
  "comments": [
    {
      "key": {
        "uuid": "36a3f1b9_1cdb2304",
        "filename": "content/browser/gpu/gpu_client.cc",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-04T19:07:31Z",
      "side": 1,
      "message": "I assume this will only apply to Android. If we fail creating the channel, the following things happen in the renderer:\n1- compositor will retry forever (assuming it\u0027s visible)\n2- 2D canvas will fail and fallback to software\n3- WebGL will fail, reporting failure (not supported) to the app\n4- media will, mmh, crash, I think. RenderThreadImpl::GetStreamTexureFactory() will return null, that\u0027s used in MediaFactory::CreateRendererFactorySelector (called from  MediaFactory::CreateMediaPlayer) to pass to StreamTextureWrapperImpl::Create which will liberally pass a null pointer to StreamTextureWrapperImpl which expects it to be non-null.  (This is all Android-specific code, so I assume it\u0027s used, but I\u0027m not 100% up-to-date on the media story). Some other places also assume success (e.g. VEAEncoder which will crash if fail to create a channel, but I don\u0027t know that it\u0027s used on Android). I haven\u0027t tried to exhaustively find all places that this may impact.\n\nIOW, moderately annoying to really bad things will happen if we actually run into this. Do we have reason to believe we avoid those issues? In particular I\u0027m wondering about the transition from foreground to background or vice versa when the renderer might run while we believe in the browser that we are backgrounded? (I\u0027m not sure how the renderer interacts with that).",
      "revId": "3a791213ca3094b39c5a72e333e15d18a2ba9a48",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73ee8d0e_647ab323",
        "filename": "content/browser/gpu/gpu_client.cc",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-12-04T19:36:48Z",
      "side": 1,
      "message": "\u003e I assume this will only apply to Android.\n\nYes, implemented on android only.\n\n\u003e If we fail creating the channel, the following things happen in the renderer:\n\u003e 1- compositor will retry forever (assuming it\u0027s visible)\n\nThis is ok because we don\u0027t actually prevent launches in this CL. But definitely need to do something about this when we prevent all launches; there are corner cases where renderer visibility does not converge to match AllowGpuLaunchRetryOnIOThread.\n\n\u003e 2- 2D canvas will fail and fallback to software\n\u003e 3- WebGL will fail, reporting failure (not supported) to the app\n\nThese two should treat this the same way as a context loss near creation, right? At least I didn\u0027t find any specific code that treats establish channel failure differently?\n\n\u003e 4- media will, mmh, crash, I think. RenderThreadImpl::GetStreamTexureFactory() will return null, that\u0027s used in MediaFactory::CreateRendererFactorySelector (called from  MediaFactory::CreateMediaPlayer) to pass to StreamTextureWrapperImpl::Create which will liberally pass a null pointer to StreamTextureWrapperImpl which expects it to be non-null.  (This is all Android-specific code, so I assume it\u0027s used, but I\u0027m not 100% up-to-date on the media story). Some other places also assume success (e.g. VEAEncoder which will crash if fail to create a channel, but I don\u0027t know that it\u0027s used on Android). I haven\u0027t tried to exhaustively find all places that this may impact.\n\nI\u0027ll get back to you on this.. crashing would be bad.\n\n\u003e \n\u003e IOW, moderately annoying to really bad things will happen if we actually run into this. Do we have reason to believe we avoid those issues? In particular I\u0027m wondering about the transition from foreground to background or vice versa when the renderer might run while we believe in the browser that we are backgrounded? (I\u0027m not sure how the renderer interacts with that).\n\nThat\u0027s definitely possible. Some tabs can remain in visible state even when the app is in the background (eg if tab is playing music).\n\nFor this CL, I was hoping everything treats establish channel failure like it\u0027s a recoverable context loss. If that\u0027s not the case, then that would be a problem.",
      "parentUuid": "36a3f1b9_1cdb2304",
      "revId": "3a791213ca3094b39c5a72e333e15d18a2ba9a48",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ed4ce7e_5f62ee31",
        "filename": "content/browser/gpu/gpu_client.cc",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-04T21:28:16Z",
      "side": 1,
      "message": "\u003e \u003e I assume this will only apply to Android.\n\u003e \n\u003e Yes, implemented on android only.\n\u003e \n\u003e \u003e If we fail creating the channel, the following things happen in the renderer:\n\u003e \u003e 1- compositor will retry forever (assuming it\u0027s visible)\n\u003e \n\u003e This is ok because we don\u0027t actually prevent launches in this CL. But definitely need to do something about this when we prevent all launches; there are corner cases where renderer visibility does not converge to match AllowGpuLaunchRetryOnIOThread.\n\nOK.\n\n\u003e \n\u003e \u003e 2- 2D canvas will fail and fallback to software\n\u003e \u003e 3- WebGL will fail, reporting failure (not supported) to the app\n\u003e \n\u003e These two should treat this the same way as a context loss near creation, right? At least I didn\u0027t find any specific code that treats establish channel failure differently?\n\nThat\u0027s fair, but you\u0027re changing the race from something that almost never happens (GPU process dies during context creation) into something that should be expected to happen a lot more often (creating a context when the GPU process has just died).\n\n\u003e \n\u003e \u003e 4- media will, mmh, crash, I think. RenderThreadImpl::GetStreamTexureFactory() will return null, that\u0027s used in MediaFactory::CreateRendererFactorySelector (called from  MediaFactory::CreateMediaPlayer) to pass to StreamTextureWrapperImpl::Create which will liberally pass a null pointer to StreamTextureWrapperImpl which expects it to be non-null.  (This is all Android-specific code, so I assume it\u0027s used, but I\u0027m not 100% up-to-date on the media story). Some other places also assume success (e.g. VEAEncoder which will crash if fail to create a channel, but I don\u0027t know that it\u0027s used on Android). I haven\u0027t tried to exhaustively find all places that this may impact.\n\u003e \n\u003e I\u0027ll get back to you on this.. crashing would be bad.\n\u003e \n\u003e \u003e \n\u003e \u003e IOW, moderately annoying to really bad things will happen if we actually run into this. Do we have reason to believe we avoid those issues? In particular I\u0027m wondering about the transition from foreground to background or vice versa when the renderer might run while we believe in the browser that we are backgrounded? (I\u0027m not sure how the renderer interacts with that).\n\u003e \n\u003e That\u0027s definitely possible. Some tabs can remain in visible state even when the app is in the background (eg if tab is playing music).\n\u003e \n\u003e For this CL, I was hoping everything treats establish channel failure like it\u0027s a recoverable context loss. If that\u0027s not the case, then that would be a problem.\n\nThat\u0027s not what this CL does. When AllowGpuLaunchRetryOnIOThread is false, it makes all transient failures (races on restart, which the renderer never sees for channel creation) into fatal ones (Renderer treats EstablishGpuChannel failures as authoritative).",
      "parentUuid": "73ee8d0e_647ab323",
      "revId": "3a791213ca3094b39c5a72e333e15d18a2ba9a48",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28d89f6f_76c71cee",
        "filename": "content/browser/gpu/gpu_client.cc",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-12-05T14:55:05Z",
      "side": 1,
      "message": "\u003e That\u0027s fair, but you\u0027re changing the race from something that almost never happens (GPU process dies during context creation) into something that should be expected to happen a lot more often (creating a context when the GPU process has just died).\n\n\u003e That\u0027s not what this CL does. When AllowGpuLaunchRetryOnIOThread is false, it makes all transient failures (races on restart, which the renderer never sees for channel creation) into fatal ones (Renderer treats EstablishGpuChannel failures as authoritative).\n\nActually this race I\u0027m not really clear. What\u0027s the race here exactly? Is it only racy if GPU crashes unexpectedly, so if crash happens at around the same time as EstablishChannel, then that comes up as a EstablishChannel failure after this CL. Or this is something other race I\u0027m not understanding that does not involve unexpected GPU crashes?",
      "parentUuid": "9ed4ce7e_5f62ee31",
      "revId": "3a791213ca3094b39c5a72e333e15d18a2ba9a48",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9c01329_8653fe58",
        "filename": "content/browser/gpu/gpu_client.cc",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-12-06T01:22:54Z",
      "side": 1,
      "message": "\u003e \u003e That\u0027s fair, but you\u0027re changing the race from something that almost never happens (GPU process dies during context creation) into something that should be expected to happen a lot more often (creating a context when the GPU process has just died).\n\u003e \n\u003e \u003e That\u0027s not what this CL does. When AllowGpuLaunchRetryOnIOThread is false, it makes all transient failures (races on restart, which the renderer never sees for channel creation) into fatal ones (Renderer treats EstablishGpuChannel failures as authoritative).\n\u003e \n\u003e Actually this race I\u0027m not really clear. What\u0027s the race here exactly? Is it only racy if GPU crashes unexpectedly, so if crash happens at around the same time as EstablishChannel, then that comes up as a EstablishChannel failure after this CL. Or this is something other race I\u0027m not understanding that does not involve unexpected GPU crashes?\n\nOh! When you say \"renderer treats EstablishGpuChannel failures as authoritative\", did you mean the connection_error parameter to EstablishGpuChannelSync?\n\nIncidentally, I think that\u0027s never set to true since https://chromium-review.googlesource.com/c/chromium/src/+/753938/12/services/ui/public/cpp/gpu/gpu.cc, and probably needs to fixed separately",
      "parentUuid": "28d89f6f_76c71cee",
      "revId": "3a791213ca3094b39c5a72e333e15d18a2ba9a48",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72778718_d77fe213",
        "filename": "content/browser/gpu/gpu_client.cc",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-12-06T01:47:55Z",
      "side": 1,
      "message": "Sorry, meant to reply here and got busy...\n\nWhat I mean by authoritative is that in most places where we try to get a GpuChannelHost in RenderThreadImpl, we fail if we get a null channel (see e.g. RenderThreadImpl::GetGpuFactories, RenderThreadImpl::SharedMainThreadContextProvider, RenderThreadImpl::SharedCompositorWorkerContextProvider, etc.). RenderThreadImpl::RequestNewLayerTreeFrameSink is the exception (we let the compositor retry rather than fall back to software), but I\u0027m not even sure it\u0027s legitimate.\n\nThe race I\u0027m talking about is if the gpu process (hence the channel gets lost) dies as we create a context, depending on when it happens exactly, we may return a null context (i.e. fatal failure) as opposed to, say, a lost one. It\u0027s really a bug, but not exactly worth extensive complexity to fix because it\u0027s a very rare condition.\n\nBut this patch would cause one new cause of failure... if the GPU process dies there is a race between the renderer re-creating a channel and the browser detecting that the GPU process is dead. If the former happens before the latter we might reuse the \"old\" GpuProcessHost, and fail to establish the channel (the sync message is the first thing that will detect the GPU process failure). At that point we will return GPU_HOST_INVALID, and expect the client to retry. But if it doesn\u0027t (like with your patch), and report failure to the renderer, the renderer will fail to create things (and may never retry).",
      "parentUuid": "c9c01329_8653fe58",
      "tag": "mailMessageId\u003d\u003cCAMeTaZfh\u003dKhcoeEUMSwcVC98wF0zNJUdo1ZZkQa_KQ+tme1vmg@mail.gmail.com\u003e",
      "revId": "3a791213ca3094b39c5a72e333e15d18a2ba9a48",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2a04b45_5055587c",
        "filename": "content/browser/gpu/gpu_client.cc",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-12-07T19:52:18Z",
      "side": 1,
      "message": "So in my own words, most renderer clients do not retry if EstablishChannel fails, which is a problem if EstablishChannel can fail in a transient way.\n\nI have some ideas how to proceed, but they probably don\u0027t look anything like this CL, so I\u0027ll put those ideas on the bug for your feedback, and abandon this CL.",
      "parentUuid": "72778718_d77fe213",
      "revId": "3a791213ca3094b39c5a72e333e15d18a2ba9a48",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}