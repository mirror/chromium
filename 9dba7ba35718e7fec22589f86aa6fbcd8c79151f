{
  "comments": [
    {
      "key": {
        "uuid": "9f80737a_53915cf5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "Could you make this \"SVG \u003cimage\u003e elements\" (or \"SVG \u003cimage\u003es\" if you prefer a shorter form) or something that disambiguates from an SVG \"image\" as a whole?",
      "range": {
        "startLine": 7,
        "startChar": 40,
        "endLine": 7,
        "endChar": 50
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf7dbaa8_18df3a29",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9f80737a_53915cf5",
      "range": {
        "startLine": 7,
        "startChar": 40,
        "endLine": 7,
        "endChar": 50
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ee7a0ab_6a57a90d",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "If you intended to fill this in I guess you could add it back when it actually references something useful?",
      "range": {
        "startLine": 6,
        "startChar": 0,
        "endLine": 6,
        "endChar": 23
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b6d2910_a90e9d13",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "I\u0027ve removed this one. I meant to add a link to the spec here. I\u0027ve done this for the \u003cimg\u003e tests, and I\u0027ll add it here once we have a link to reference.",
      "parentUuid": "6ee7a0ab_6a57a90d",
      "range": {
        "startLine": 6,
        "startChar": 0,
        "endLine": 6,
        "endChar": 23
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6fa7e07a_82ff1971",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-26T10:57:23Z",
      "side": 1,
      "message": "I guess that\u0027d be the same ref as in the HTML, but yeah fine to wait.",
      "parentUuid": "5b6d2910_a90e9d13",
      "range": {
        "startLine": 6,
        "startChar": 0,
        "endLine": 6,
        "endChar": 23
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6600dec1_bf1a78d3",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "You shouldn\u0027t need this.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 9,
        "endChar": 19
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47b0d857_343e2991",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Removed.",
      "parentUuid": "6600dec1_bf1a78d3",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 9,
        "endChar": 19
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2cdd7cf_12c91557",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-26T10:57:23Z",
      "side": 1,
      "message": "(marking as resolved)",
      "parentUuid": "47b0d857_343e2991",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 9,
        "endChar": 19
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e7ca08ba_300253d7",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 22,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "You could make the document title slightly longer instead - maybe \"SVGImageElement.decode(), \u0027href\u0027 mutations\" or something like that - and then do document.title+\u0027, fail decode\u0027 et.c. Should make it obvious that this is testing stuff from the SVGImageElement interface (\u0027img\u0027 is kind of associated with HTML \u003cimg\u003e.)\n\nAlso (hidden above), using \"Path\" here seems unspecific - using \"URL\" or \u0027href\u0027 (like above) seems to better describe the test. (A URL may have a path, but in all these cases I would refer to them as \"(relative) URLs\".)",
      "range": {
        "startLine": 22,
        "startChar": 4,
        "endLine": 22,
        "endChar": 22
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "570422e5_d719dc6e",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 22,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Thanks, I really like this suggestion. I\u0027ve updated all of the related tests descriptions. Let me know if it looks better now.",
      "parentUuid": "e7ca08ba_300253d7",
      "range": {
        "startLine": 22,
        "startChar": 4,
        "endLine": 22,
        "endChar": 22
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3d17845_dfd573b9",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 22,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-26T10:57:23Z",
      "side": 1,
      "message": "Thanks, looks better now.",
      "parentUuid": "570422e5_d719dc6e",
      "range": {
        "startLine": 22,
        "startChar": 4,
        "endLine": 22,
        "endChar": 22
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f66e012f_16d72864",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "assert_not_equals? (ditto below)",
      "range": {
        "startLine": 30,
        "startChar": 2,
        "endLine": 30,
        "endChar": 47
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58b60baa_9f9620d1",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-path-changes-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f66e012f_16d72864",
      "range": {
        "startLine": 30,
        "startChar": 2,
        "endLine": 30,
        "endChar": 47
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b328cab1_4d8eb629",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "rel\u003dhelp, div#log and \u003ctitle\u003e/naming suggestions like above.",
      "range": {
        "startLine": 6,
        "startChar": 0,
        "endLine": 10,
        "endChar": 0
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "709cf02c_ebfd8eb6",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b328cab1_4d8eb629",
      "range": {
        "startLine": 6,
        "startChar": 0,
        "endLine": 10,
        "endChar": 0
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8405ecac_eb84908a",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "\"data: URL\"? (or \"data URL\")",
      "range": {
        "startLine": 34,
        "startChar": 14,
        "endLine": 34,
        "endChar": 17
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f816de49_5328406f",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8405ecac_eb84908a",
      "range": {
        "startLine": 34,
        "startChar": 14,
        "endLine": 34,
        "endChar": 17
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "742a9531_5a5d3227",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 49,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "URL",
      "range": {
        "startLine": 49,
        "startChar": 23,
        "endLine": 49,
        "endChar": 27
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1675313_b3bda7bd",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 49,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "742a9531_5a5d3227",
      "range": {
        "startLine": 49,
        "startChar": 23,
        "endLine": 49,
        "endChar": 27
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e3c8e614_c28053b7",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "\"Image without a \u0027href\u0027 (attribute)...\"",
      "range": {
        "startLine": 62,
        "startChar": 10,
        "endLine": 62,
        "endChar": 25
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1985026_6cf6a418",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e3c8e614_c28053b7",
      "range": {
        "startLine": 62,
        "startChar": 10,
        "endLine": 62,
        "endChar": 25
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb454ad1_377f6a3c",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "assert_not_equals?",
      "range": {
        "startLine": 69,
        "startChar": 2,
        "endLine": 69,
        "endChar": 47
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89a4f3d2_0a50fc76",
        "filename": "third_party/WebKit/LayoutTests/external/wpt/image-decodes/image-decode-svg.html",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "eb454ad1_377f6a3c",
      "range": {
        "startLine": 69,
        "startChar": 2,
        "endLine": 69,
        "endChar": 47
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb8586d1_9d476e0a",
        "filename": "third_party/WebKit/Source/core/loader/ImageLoader.cpp",
        "patchSetId": 1
      },
      "lineNbr": 664,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "This shouldn\u0027t be needed. (If there could be an exception signaled already, you would need to check for that, but that shouldn\u0027t be the case here. Yes, I realize this code was just moved, but this is an operation you\u0027d only need on rare occasions...)",
      "range": {
        "startLine": 664,
        "startChar": 2,
        "endLine": 664,
        "endChar": 34
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "83290068_9161f9a9",
        "filename": "third_party/WebKit/Source/core/loader/ImageLoader.cpp",
        "patchSetId": 1
      },
      "lineNbr": 664,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Done. I\u0027ve added this during initial development because it seemed to resolve whatever problem I had. However, removing it now passes all of the tests, so I think the problem I was having was unrelated. Thanks!",
      "parentUuid": "cb8586d1_9d476e0a",
      "range": {
        "startLine": 664,
        "startChar": 2,
        "endLine": 664,
        "endChar": 34
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e4501e0_8494f9c7",
        "filename": "third_party/WebKit/Source/core/loader/ImageLoader.cpp",
        "patchSetId": 1
      },
      "lineNbr": 664,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-26T10:57:23Z",
      "side": 1,
      "message": "(marking resolved)",
      "parentUuid": "83290068_9161f9a9",
      "range": {
        "startLine": 664,
        "startChar": 2,
        "endLine": 664,
        "endChar": 34
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b9b5c13d_a7201d2b",
        "filename": "third_party/WebKit/Source/core/loader/ImageLoader.cpp",
        "patchSetId": 1
      },
      "lineNbr": 701,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "IIRC, this never returns null (it returns the broken image if an error occurred or the \"null image\".) Maybe you want HasImage() or ErrorOccurred() instead? (Does this have test coverage?)",
      "range": {
        "startLine": 701,
        "startChar": 32,
        "endLine": 701,
        "endChar": 54
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70d9d1db_27462f1d",
        "filename": "third_party/WebKit/Source/core/loader/ImageLoader.cpp",
        "patchSetId": 1
      },
      "lineNbr": 701,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Changed to GetImage()-\u003eErrorOccurred(). I think that can be null if the image hasn\u0027t loaded yet, but then this function wouldn\u0027t be called.\n\nThe wpt tests cover the broken/corrupt image and image without a src set, so I think this is covered. If you have suggestions for other tests, I\u0027m happy to put those in as well.",
      "parentUuid": "b9b5c13d_a7201d2b",
      "range": {
        "startLine": 701,
        "startChar": 32,
        "endLine": 701,
        "endChar": 54
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd061c98_fc526e54",
        "filename": "third_party/WebKit/Source/core/loader/ImageLoader.cpp",
        "patchSetId": 1
      },
      "lineNbr": 701,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-26T10:57:23Z",
      "side": 1,
      "message": "I suspect this is generally \"saved\" by calling code checking a similar predicate (ErrorOccurred being checked in ImageNotifyFinished for example.)\n\nI sifted through the tests and didn\u0027t see one that invoked decode() after the image load had \u0027completed\u0027 (become completely available) with an error (\u0027error\u0027 being dispatched.) So maybe a test (or two) like that would be useful (i.e calling decode() from onerror), but maybe I just missed those in my quick scan.",
      "parentUuid": "70d9d1db_27462f1d",
      "range": {
        "startLine": 701,
        "startChar": 32,
        "endLine": 701,
        "endChar": 54
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "89fed522_e93fe762",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.cpp",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "This acts on unresolved URL - which seems wrong [1] - and since the spec seems to be written in terms of the \u0027current request\u0027 it would seem better if this was handled by the ImageLoader (since it should be closer to the things the spec talks about. This would probably also make other cases easier to manage - like the element moving between documents?) This would also allow getting rid of last_decode_href_. The same naturally also applies to HTMLImageElement.\n\n[1] Inferring things about the resolved URL based on the unresolved representation. The same (relative) URL could resolve to two different URLs, and an absolute URL would differ from a potential relative representation of itself (resolved against the document base URL.)",
      "range": {
        "startLine": 148,
        "startChar": 8,
        "endLine": 149,
        "endChar": 56
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b04a2121_0e8b7281",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.cpp",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "89fed522_e93fe762",
      "range": {
        "startLine": 148,
        "startChar": 8,
        "endLine": 149,
        "endChar": 56
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42e38ecf_1cd034ab",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-25T20:44:44Z",
      "side": 1,
      "message": "That would require us to re-materialize the String in certain cases - which we don\u0027t want to do, so no this is not something we \"to do\" I think. See below though.",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dcebe436_f5d36ceb",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T00:19:14Z",
      "side": 1,
      "message": "Can you elaborate on this a bit? What do you mean by \"re-materialize the String\" here?\n\nFWIW, I think this was a premature optimization on my part. I\u0027ve changed both the SVG image case and the HTML image case to always invalidate pending requests when the source is updated. I\u0027ve removed the tests that verify that if it\u0027s the same string, then they still succeed. This simplifies the code and makes it easier to reason about... My reasoning here is that 1. it\u0027s likely to be an extremely rare case that the src would change to the same thing while the decode is still in flight 2. this can be checked by the calling script to avoid unnecessary source url mutations and 3. the spec doesn\u0027t mention anything about setting the value to the same thing and whether that should succeed or fail.",
      "parentUuid": "42e38ecf_1cd034ab",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88fe1efc_3b10f434",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-26T10:57:23Z",
      "side": 1,
      "message": "\u003e Can you elaborate on this a bit? What do you mean by \"re-materialize the String\" here?\n\nWe don\u0027t necessarily have a String representation of the value in question available when SvgAttributeChanged() is called, so then we\u0027d need to serialize the value just to provide the String - which would be a waste of cycles. (This notifier is called for instance by SMIL animations and when updating SVG DOM attributes, and not really a generic thing but has a strong affinity towards the SVG DOM implementation.)\n \n\u003e FWIW, I think this was a premature optimization on my part. I\u0027ve changed both the SVG image case and the HTML image case to always invalidate pending requests when the source is updated. I\u0027ve removed the tests that verify that if it\u0027s the same string, then they still succeed. This simplifies the code and makes it easier to reason about...\n\nThis is however not in line with what the spec says. The spec could be updated, but I think the spec makes more sense than the (updated) implementation in that regard \u003d)\n\n\u003e My reasoning here is that 1. it\u0027s likely to be an extremely rare case that the src would change to the same thing while the decode is still in flight\n\nOn the web, what one would think no one would do, someone most definitely will do...\n\n\u003e 2. this can be checked by the calling script to avoid unnecessary source url mutations and\n\n...and to follow the same train, this will definitely not be checked by author code.\n\n\u003e 3. the spec doesn\u0027t mention anything about setting the value to the same thing and whether that should succeed or fail.\n\nIt does say:\n\n  \"This img element\u0027s current request changes or is mutated\"\n\nwhich is pretty much saying that. The algorithm for \"updating the image data\" [1] is not the most approachable (much like it\u0027s implementation in ImageLoader... surprisingly), but I think the relevant step here is step 12 (rough correspondence implementation-wise would be ImageLoader::DoUpdateFromElement, probably checking if new_image !\u003d old_image or so.)\nAs mentioned elsewhere did would also help address the node adoption case (didn\u0027t see a test for that):\n\nI.e something like:\n\n\u003ciframe id\u003dfoo src\u003dsame-origin\u003e\u003c/iframe\u003e\n\u003cscript\u003e\nvar img \u003d new Image();\nimg.src \u003d ....;\nimg.onload \u003d function() {\n  img.decode().then(...);\n  foo.contentDocument.appendChild(img);\n};\n\u003c/script\u003e\n\n(or variants thereof), which may end up mutating \u0027current request\u0027. (Called in \"relevant mutations\" of \u0027img\u0027 as \"The element\u0027s adopting steps are run.\" In Blink this would correspond to the DidMoveToNewDocument method on Node - as overridden by HTML/SVGImageElement.) \n\n[1] https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data",
      "parentUuid": "dcebe436_f5d36ceb",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c95e6bbb_11238604",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-26T22:23:42Z",
      "side": 1,
      "message": "\u003e \u003e Can you elaborate on this a bit? What do you mean by \"re-materialize the String\" here?\n\u003e \n\u003e We don\u0027t necessarily have a String representation of the value in question available when SvgAttributeChanged() is called, so then we\u0027d need to serialize the value just to provide the String - which would be a waste of cycles. (This notifier is called for instance by SMIL animations and when updating SVG DOM attributes, and not really a generic thing but has a strong affinity towards the SVG DOM implementation.)\n\u003e  \n\nOh I see what you mean. I was only looking at the spot that already had this string, I didn\u0027t realize there are other callers.\n\n\u003e It does say:\n\u003e \n\u003e   \"This img element\u0027s current request changes or is mutated\"\n\u003e \n\u003e which is pretty much saying that. The algorithm for \"updating the image data\" [1] is not the most approachable (much like it\u0027s implementation in ImageLoader... surprisingly), but I think the relevant step here is step 12 (rough correspondence implementation-wise would be ImageLoader::DoUpdateFromElement, probably checking if new_image !\u003d old_image or so.)\n\u003e As mentioned elsewhere did would also help address the node adoption case (didn\u0027t see a test for that):\n\u003e \n\nIn theory, I agree that this is the correct check. In practice, I have to figure out how to actually do this.\n\nThe problem is that DoUpdateFromElement can be run from a posted task, so the stack unwinds before running it. In practice, this means in a situation where you have:\nimg.src \u003d \"...\";\nimg.decode().then(...);\n\nOne order of operations that is possible is:\n1. ImageLoader::UpdateFromElement. This schedules a task to run.\n2. ImageLoader::Decode. This pushes a promise resolver onto the vector, but doesn\u0027t actually request a decode since ImageComplete is false (there is a pending task).\n3. ImageLoader::DoUpdateFromElement. This finds that new image !\u003d old image, and invalidates any pending decode requests. Specifically it invalidates the promise in 2. and the decode promise rejects.\n\nConceptually when the request comes in and there is a pending task, then the request is really for the new image whose source hasn\u0027t been updated yet, so it shouldn\u0027t be invalidated. \n\nTo make matters worse, we could have two source changes in a row, so\n0. Say an image already has some source, then\n1. UpdateFromElement would create a task\n2. Then we might get a Decode, then\n3. UpdateFromElement runs again which destroys the task and creates a new one\n4. Then we might get a Decode, then\n5. DoUpdateFromElement runs.\n\nIn any situation, decode from 4 should run because it was for the latest source. However, should decode in 2 run? Well, it depends. If this is coming from:\n\n// 0\nimg.src \u003d \"a\";\n// 1\nimg.src \u003d \"a\";\n// 2\nimg.decode().then(...);\n// 3\nimg.src \u003d \"a\";\n// 4\nimg.decode().then(...);\n\nThen yes, 2 should run. But if you have this:\n\n// 0\nimg.src \u003d \"a\";\n// 1\nimg.src \u003d \"definitely not a\";\n// 2\nimg.decode().then(...);\n// 3\nimg.src \u003d \"a\";\n// 4\nimg.decode().then(...);\n\nThen the decode should not run (it was enqueued for a different source). But due to the fact that the DoUpdateFromElement only runs at the end of all these steps, it will find that old_image \u003d\u003d new_image. The only knowledge that it ever _wasn\u0027t_ the same is lost when the task created in 1 is destroyed by 3.\n\nIn reading https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data, I can\u0027t find a reference to src being changed to the same value and how that should be treated. Is it feasible to interpret src \u003d src as indeed mutating the the current request for the purposes of the decode? I\u0027m happy to move the invalidation step to be in UpdateFromElement (although relying on a specific UpdateFromElementBehavior to detect a src change seems iffy).\n\nAgain, to clarify, I\u0027m speaking from the point of view that the complexity this adds seems to outweigh what seems to be an optimization of \"do no work if last src \u003d\u003d new src\".\n\nIf you think this should still be implemented, then I\u0027ll have to think more on how to do this (ie how to handle both the cases outlined above) and without introducing other timing bugs. TBH, I\u0027m not too sure how to go about it without violating steps outlined in what should happen when src changes.\n\n\u003e I.e something like:\n\u003e \n\u003e \u003ciframe id\u003dfoo src\u003dsame-origin\u003e\u003c/iframe\u003e\n\u003e \u003cscript\u003e\n\u003e var img \u003d new Image();\n\u003e img.src \u003d ....;\n\u003e img.onload \u003d function() {\n\u003e   img.decode().then(...);\n\u003e   foo.contentDocument.appendChild(img);\n\u003e };\n\u003e \u003c/script\u003e\n\u003e \n\u003e (or variants thereof), which may end up mutating \u0027current request\u0027. (Called in \"relevant mutations\" of \u0027img\u0027 as \"The element\u0027s adopting steps are run.\" In Blink this would correspond to the DidMoveToNewDocument method on Node - as overridden by HTML/SVGImageElement.) \n\u003e \n\u003e [1] https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data",
      "parentUuid": "88fe1efc_3b10f434",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cb6e201_6c6de1ab",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-27T00:22:25Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Can you elaborate on this a bit? What do you mean by \"re-materialize the String\" here?\n\u003e \u003e \n\u003e \u003e We don\u0027t necessarily have a String representation of the value in question available when SvgAttributeChanged() is called, so then we\u0027d need to serialize the value just to provide the String - which would be a waste of cycles. (This notifier is called for instance by SMIL animations and when updating SVG DOM attributes, and not really a generic thing but has a strong affinity towards the SVG DOM implementation.)\n\u003e \u003e  \n\u003e \n\u003e Oh I see what you mean. I was only looking at the spot that already had this string, I didn\u0027t realize there are other callers.\n\u003e \n\u003e \u003e It does say:\n\u003e \u003e \n\u003e \u003e   \"This img element\u0027s current request changes or is mutated\"\n\u003e \u003e \n\u003e \u003e which is pretty much saying that. The algorithm for \"updating the image data\" [1] is not the most approachable (much like it\u0027s implementation in ImageLoader... surprisingly), but I think the relevant step here is step 12 (rough correspondence implementation-wise would be ImageLoader::DoUpdateFromElement, probably checking if new_image !\u003d old_image or so.)\n\u003e \u003e As mentioned elsewhere did would also help address the node adoption case (didn\u0027t see a test for that):\n\u003e \u003e \n\u003e \n\u003e In theory, I agree that this is the correct check. In practice, I have to figure out how to actually do this.\n\u003e \n\u003e The problem is that DoUpdateFromElement can be run from a posted task, so the stack unwinds before running it. In practice, this means in a situation where you have:\n\u003e img.src \u003d \"...\";\n\u003e img.decode().then(...);\n\u003e \n\u003e One order of operations that is possible is:\n\u003e 1. ImageLoader::UpdateFromElement. This schedules a task to run.\n\u003e 2. ImageLoader::Decode. This pushes a promise resolver onto the vector, but doesn\u0027t actually request a decode since ImageComplete is false (there is a pending task).\n\u003e 3. ImageLoader::DoUpdateFromElement. This finds that new image !\u003d old image, and invalidates any pending decode requests. Specifically it invalidates the promise in 2. and the decode promise rejects.\n\u003e \n\u003e Conceptually when the request comes in and there is a pending task, then the request is really for the new image whose source hasn\u0027t been updated yet, so it shouldn\u0027t be invalidated. \n\u003e \n\u003e To make matters worse, we could have two source changes in a row, so\n\u003e 0. Say an image already has some source, then\n\u003e 1. UpdateFromElement would create a task\n\u003e 2. Then we might get a Decode, then\n\u003e 3. UpdateFromElement runs again which destroys the task and creates a new one\n\u003e 4. Then we might get a Decode, then\n\u003e 5. DoUpdateFromElement runs.\n\u003e \n\u003e In any situation, decode from 4 should run because it was for the latest source. However, should decode in 2 run? Well, it depends. If this is coming from:\n\u003e \n\u003e // 0\n\u003e img.src \u003d \"a\";\n\u003e // 1\n\u003e img.src \u003d \"a\";\n\u003e // 2\n\u003e img.decode().then(...);\n\u003e // 3\n\u003e img.src \u003d \"a\";\n\u003e // 4\n\u003e img.decode().then(...);\n\u003e \n\u003e Then yes, 2 should run. But if you have this:\n\u003e \n\u003e // 0\n\u003e img.src \u003d \"a\";\n\u003e // 1\n\u003e img.src \u003d \"definitely not a\";\n\u003e // 2\n\u003e img.decode().then(...);\n\u003e // 3\n\u003e img.src \u003d \"a\";\n\u003e // 4\n\u003e img.decode().then(...);\n\u003e \n\u003e Then the decode should not run (it was enqueued for a different source). But due to the fact that the DoUpdateFromElement only runs at the end of all these steps, it will find that old_image \u003d\u003d new_image. The only knowledge that it ever _wasn\u0027t_ the same is lost when the task created in 1 is destroyed by 3.\n\nWell, the way the decode() spec text is currently written (or, the way I interpret it at least) it doesn\u0027t really \"associate\" with any source, but rather observes the \u0027current request\u0027. So, by that interpretation both of the above sequences would be equal, and maybe that is not a useful behavior (or maybe it is?). So a spec adjustment is probably needed?\n\n\u003e In reading https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data, I can\u0027t find a reference to src being changed to the same value and how that should be treated. Is it feasible to interpret src \u003d src as indeed mutating the the current request for the purposes of the decode?\n\nThe first to \"bullets\" of step 12 reads:\n\n * If the pending request is not null, and urlString is the same as the pending request\u0027s current URL, then abort these steps.\n\n * If urlString is the same as the current request\u0027s current URL, and current request is in the partially available state, then abort the image request for the pending request, queue a task to restart the animation if restart animation is set, and abort these steps.\n\n(where \u0027urlString\u0027 is the resolved URL from the previous step)\n\nThe first one basically says that if we have pending request and it\u0027s the same (resolved) URL, then do nothing.\nThe second says that animations should be restarted, but no new request should be made (and if there\u0027s a pending request then it should be aborted.)\n\nSo, src \u003d src could in certain cases (at least in theory) end up mutating the current request.\n\n\u003e I\u0027m happy to move the invalidation step to be in UpdateFromElement (although relying on a specific UpdateFromElementBehavior to detect a src change seems iffy).\n\nI would even go as far as saying that UpdateFromElementBehavior is iffy (and a blister of legacy) - but one is a strictly external signal (\u0027Reload\u0027) and should probably be handled from a decode() standpoint (i.e if the user requests a reload of the image it seems reasonable to reject the promise, no?) If \u0027SizeChanged\u0027 ends up changing the current request I don\u0027t see why it would be ignored. The remaining two are the non-weird ones and should be handled. So I don\u0027t think that\u0027s really an issue.\n\n\u003e Again, to clarify, I\u0027m speaking from the point of view that the complexity this adds seems to outweigh what seems to be an optimization of \"do no work if last src \u003d\u003d new src\".\n\u003e\n\u003e If you think this should still be implemented, then I\u0027ll have to think more on how to do this (ie how to handle both the cases outlined above) and without introducing other timing bugs. TBH, I\u0027m not too sure how to go about it without violating steps outlined in what should happen when src changes.\n\nWell, the option of changing the spec is not off the table - not that something that compares \u0027src\u0027 (or \u0027href\u0027) would be likely to be part of that change, because that\u0027s frankly a bad idea.\nThe current spec formulation is fairly simple, and I suspect that changing (\u003d\u003dadding complexity to) the spec will not simplify the implementation.\n\nIt is certainly difficult to working within (or extend) the updating-the-image-data algorithm, and the way things are written at the moment that is dodged in a somewhat elegant way. The best way forward could be to figure out an additional condition to add to step 3 of the decode() algorithm (i.e maybe the type of mutations to \u0027current request\u0027 that reject the promise could be limited.) Otherwise it\u0027ll probably need a hook (or two) added to updating-the-image-data...\n\nCould just implement the current spec while pondering how to change it though.",
      "parentUuid": "c95e6bbb_11238604",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ec620ef0_2e3d1938",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-27T18:34:57Z",
      "side": 1,
      "message": "\u003e \u003e \u003e \u003e Can you elaborate on this a bit? What do you mean by \"re-materialize the String\" here?\n\u003e \u003e \u003e \n\u003e \u003e \u003e We don\u0027t necessarily have a String representation of the value in question available when SvgAttributeChanged() is called, so then we\u0027d need to serialize the value just to provide the String - which would be a waste of cycles. (This notifier is called for instance by SMIL animations and when updating SVG DOM attributes, and not really a generic thing but has a strong affinity towards the SVG DOM implementation.)\n\u003e \u003e \u003e  \n\u003e \u003e \n\u003e \u003e Oh I see what you mean. I was only looking at the spot that already had this string, I didn\u0027t realize there are other callers.\n\u003e \u003e \n\u003e \u003e \u003e It does say:\n\u003e \u003e \u003e \n\u003e \u003e \u003e   \"This img element\u0027s current request changes or is mutated\"\n\u003e \u003e \u003e \n\u003e \u003e \u003e which is pretty much saying that. The algorithm for \"updating the image data\" [1] is not the most approachable (much like it\u0027s implementation in ImageLoader... surprisingly), but I think the relevant step here is step 12 (rough correspondence implementation-wise would be ImageLoader::DoUpdateFromElement, probably checking if new_image !\u003d old_image or so.)\n\u003e \u003e \u003e As mentioned elsewhere did would also help address the node adoption case (didn\u0027t see a test for that):\n\u003e \u003e \u003e \n\u003e \u003e \n\u003e \u003e In theory, I agree that this is the correct check. In practice, I have to figure out how to actually do this.\n\u003e \u003e \n\u003e \u003e The problem is that DoUpdateFromElement can be run from a posted task, so the stack unwinds before running it. In practice, this means in a situation where you have:\n\u003e \u003e img.src \u003d \"...\";\n\u003e \u003e img.decode().then(...);\n\u003e \u003e \n\u003e \u003e One order of operations that is possible is:\n\u003e \u003e 1. ImageLoader::UpdateFromElement. This schedules a task to run.\n\u003e \u003e 2. ImageLoader::Decode. This pushes a promise resolver onto the vector, but doesn\u0027t actually request a decode since ImageComplete is false (there is a pending task).\n\u003e \u003e 3. ImageLoader::DoUpdateFromElement. This finds that new image !\u003d old image, and invalidates any pending decode requests. Specifically it invalidates the promise in 2. and the decode promise rejects.\n\u003e \u003e \n\u003e \u003e Conceptually when the request comes in and there is a pending task, then the request is really for the new image whose source hasn\u0027t been updated yet, so it shouldn\u0027t be invalidated. \n\u003e \u003e \n\u003e \u003e To make matters worse, we could have two source changes in a row, so\n\u003e \u003e 0. Say an image already has some source, then\n\u003e \u003e 1. UpdateFromElement would create a task\n\u003e \u003e 2. Then we might get a Decode, then\n\u003e \u003e 3. UpdateFromElement runs again which destroys the task and creates a new one\n\u003e \u003e 4. Then we might get a Decode, then\n\u003e \u003e 5. DoUpdateFromElement runs.\n\u003e \u003e \n\u003e \u003e In any situation, decode from 4 should run because it was for the latest source. However, should decode in 2 run? Well, it depends. If this is coming from:\n\u003e \u003e \n\u003e \u003e // 0\n\u003e \u003e img.src \u003d \"a\";\n\u003e \u003e // 1\n\u003e \u003e img.src \u003d \"a\";\n\u003e \u003e // 2\n\u003e \u003e img.decode().then(...);\n\u003e \u003e // 3\n\u003e \u003e img.src \u003d \"a\";\n\u003e \u003e // 4\n\u003e \u003e img.decode().then(...);\n\u003e \u003e \n\u003e \u003e Then yes, 2 should run. But if you have this:\n\u003e \u003e \n\u003e \u003e // 0\n\u003e \u003e img.src \u003d \"a\";\n\u003e \u003e // 1\n\u003e \u003e img.src \u003d \"definitely not a\";\n\u003e \u003e // 2\n\u003e \u003e img.decode().then(...);\n\u003e \u003e // 3\n\u003e \u003e img.src \u003d \"a\";\n\u003e \u003e // 4\n\u003e \u003e img.decode().then(...);\n\u003e \u003e \n\u003e \u003e Then the decode should not run (it was enqueued for a different source). But due to the fact that the DoUpdateFromElement only runs at the end of all these steps, it will find that old_image \u003d\u003d new_image. The only knowledge that it ever _wasn\u0027t_ the same is lost when the task created in 1 is destroyed by 3.\n\u003e \n\u003e Well, the way the decode() spec text is currently written (or, the way I interpret it at least) it doesn\u0027t really \"associate\" with any source, but rather observes the \u0027current request\u0027. So, by that interpretation both of the above sequences would be equal, and maybe that is not a useful behavior (or maybe it is?). So a spec adjustment is probably needed?\n\nIf we interpret the \u0027current request\u0027 strictly by https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data (which we should of course), then that means that the new request is not actually created until this task runs. This, in turn means that\n\nimg.src \u003d \u0027...\u0027; // 1\n// 2\nimg.decode().then(...); // 3\n// 4\n\nis not deterministic in whether the decode promise resolves or rejects, since the task that runs, and thus changes the \u0027current request\u0027 can run before or after the decode() call.\n\nThat is, 1.4 of the updating-the-image-data creates the task at at line 1. That task can run at line 2. and according to 12/5 creates a new \u0027current request\u0027. Then line 3 acts on the \u0027current request\u0027 and eventually resolves.\n\nHowever, the task created on line 1 can also run at line 4. This means that the decode requested on line 3 acts on a null \u0027current request\u0027 and furthermore that current request changes to a new \u0027current request\u0027 when 12/5 is applied at line 4. This means that the decode rejects.\n\nI don\u0027t think that\u0027s an acceptable behavior, although strictly standard compliant. I think wording the decode spec in terms of \u0027current request\u0027 yields this interpretation however. Since updating-the-image-data seems to be the term that corresponds strictly to line 1 above (ie src \u003d ... line), would you be comfortable with the decode spec stating that \"If update to the image data is requested, then ... promise rejects\". This would imply that as soon as the first step of https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data is allowed to be applied, then we reject any pending requests. Furthermore, that means the current patch set is compliant to that spec (ie src \u003d src is indeed going to hit the first step of updating-the-image-data, albeit never making it to 12/5 due to 12/1)\n\n\u003e \n\u003e \u003e In reading https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data, I can\u0027t find a reference to src being changed to the same value and how that should be treated. Is it feasible to interpret src \u003d src as indeed mutating the the current request for the purposes of the decode?\n\u003e \n\u003e The first to \"bullets\" of step 12 reads:\n\u003e \n\u003e  * If the pending request is not null, and urlString is the same as the pending request\u0027s current URL, then abort these steps.\n\u003e \n\u003e  * If urlString is the same as the current request\u0027s current URL, and current request is in the partially available state, then abort the image request for the pending request, queue a task to restart the animation if restart animation is set, and abort these steps.\n\u003e \n\u003e (where \u0027urlString\u0027 is the resolved URL from the previous step)\n\u003e \n\u003e The first one basically says that if we have pending request and it\u0027s the same (resolved) URL, then do nothing.\n\u003e The second says that animations should be restarted, but no new request should be made (and if there\u0027s a pending request then it should be aborted.)\n\u003e \n\u003e So, src \u003d src could in certain cases (at least in theory) end up mutating the current request.\n\u003e \n\u003e \u003e I\u0027m happy to move the invalidation step to be in UpdateFromElement (although relying on a specific UpdateFromElementBehavior to detect a src change seems iffy).\n\u003e \n\u003e I would even go as far as saying that UpdateFromElementBehavior is iffy (and a blister of legacy) - but one is a strictly external signal (\u0027Reload\u0027) and should probably be handled from a decode() standpoint (i.e if the user requests a reload of the image it seems reasonable to reject the promise, no?) If \u0027SizeChanged\u0027 ends up changing the current request I don\u0027t see why it would be ignored. The remaining two are the non-weird ones and should be handled. So I don\u0027t think that\u0027s really an issue.\n\u003e \n\u003e \u003e Again, to clarify, I\u0027m speaking from the point of view that the complexity this adds seems to outweigh what seems to be an optimization of \"do no work if last src \u003d\u003d new src\".\n\u003e \u003e\n\u003e \u003e If you think this should still be implemented, then I\u0027ll have to think more on how to do this (ie how to handle both the cases outlined above) and without introducing other timing bugs. TBH, I\u0027m not too sure how to go about it without violating steps outlined in what should happen when src changes.\n\u003e \n\u003e Well, the option of changing the spec is not off the table - not that something that compares \u0027src\u0027 (or \u0027href\u0027) would be likely to be part of that change, because that\u0027s frankly a bad idea.\n\u003e The current spec formulation is fairly simple, and I suspect that changing (\u003d\u003dadding complexity to) the spec will not simplify the implementation.\n\u003e \n\u003e It is certainly difficult to working within (or extend) the updating-the-image-data algorithm, and the way things are written at the moment that is dodged in a somewhat elegant way. The best way forward could be to figure out an additional condition to add to step 3 of the decode() algorithm (i.e maybe the type of mutations to \u0027current request\u0027 that reject the promise could be limited.) Otherwise it\u0027ll probably need a hook (or two) added to updating-the-image-data...\n\u003e \n\u003e Could just implement the current spec while pondering how to change it though.",
      "parentUuid": "7cb6e201_6c6de1ab",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "426f03c3_c6654d29",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-27T20:21:41Z",
      "side": 1,
      "message": "\u003e \u003e \u003e \u003e \u003e Can you elaborate on this a bit? What do you mean by \"re-materialize the String\" here?\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e We don\u0027t necessarily have a String representation of the value in question available when SvgAttributeChanged() is called, so then we\u0027d need to serialize the value just to provide the String - which would be a waste of cycles. (This notifier is called for instance by SMIL animations and when updating SVG DOM attributes, and not really a generic thing but has a strong affinity towards the SVG DOM implementation.)\n\u003e \u003e \u003e \u003e  \n\u003e \u003e \u003e \n\u003e \u003e \u003e Oh I see what you mean. I was only looking at the spot that already had this string, I didn\u0027t realize there are other callers.\n\u003e \u003e \u003e \n\u003e \u003e \u003e \u003e It does say:\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e   \"This img element\u0027s current request changes or is mutated\"\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e which is pretty much saying that. The algorithm for \"updating the image data\" [1] is not the most approachable (much like it\u0027s implementation in ImageLoader... surprisingly), but I think the relevant step here is step 12 (rough correspondence implementation-wise would be ImageLoader::DoUpdateFromElement, probably checking if new_image !\u003d old_image or so.)\n\u003e \u003e \u003e \u003e As mentioned elsewhere did would also help address the node adoption case (didn\u0027t see a test for that):\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \n\u003e \u003e \u003e In theory, I agree that this is the correct check. In practice, I have to figure out how to actually do this.\n\u003e \u003e \u003e \n\u003e \u003e \u003e The problem is that DoUpdateFromElement can be run from a posted task, so the stack unwinds before running it. In practice, this means in a situation where you have:\n\u003e \u003e \u003e img.src \u003d \"...\";\n\u003e \u003e \u003e img.decode().then(...);\n\u003e \u003e \u003e \n\u003e \u003e \u003e One order of operations that is possible is:\n\u003e \u003e \u003e 1. ImageLoader::UpdateFromElement. This schedules a task to run.\n\u003e \u003e \u003e 2. ImageLoader::Decode. This pushes a promise resolver onto the vector, but doesn\u0027t actually request a decode since ImageComplete is false (there is a pending task).\n\u003e \u003e \u003e 3. ImageLoader::DoUpdateFromElement. This finds that new image !\u003d old image, and invalidates any pending decode requests. Specifically it invalidates the promise in 2. and the decode promise rejects.\n\u003e \u003e \u003e \n\u003e \u003e \u003e Conceptually when the request comes in and there is a pending task, then the request is really for the new image whose source hasn\u0027t been updated yet, so it shouldn\u0027t be invalidated. \n\u003e \u003e \u003e \n\u003e \u003e \u003e To make matters worse, we could have two source changes in a row, so\n\u003e \u003e \u003e 0. Say an image already has some source, then\n\u003e \u003e \u003e 1. UpdateFromElement would create a task\n\u003e \u003e \u003e 2. Then we might get a Decode, then\n\u003e \u003e \u003e 3. UpdateFromElement runs again which destroys the task and creates a new one\n\u003e \u003e \u003e 4. Then we might get a Decode, then\n\u003e \u003e \u003e 5. DoUpdateFromElement runs.\n\u003e \u003e \u003e \n\u003e \u003e \u003e In any situation, decode from 4 should run because it was for the latest source. However, should decode in 2 run? Well, it depends. If this is coming from:\n\u003e \u003e \u003e \n\u003e \u003e \u003e // 0\n\u003e \u003e \u003e img.src \u003d \"a\";\n\u003e \u003e \u003e // 1\n\u003e \u003e \u003e img.src \u003d \"a\";\n\u003e \u003e \u003e // 2\n\u003e \u003e \u003e img.decode().then(...);\n\u003e \u003e \u003e // 3\n\u003e \u003e \u003e img.src \u003d \"a\";\n\u003e \u003e \u003e // 4\n\u003e \u003e \u003e img.decode().then(...);\n\u003e \u003e \u003e \n\u003e \u003e \u003e Then yes, 2 should run. But if you have this:\n\u003e \u003e \u003e \n\u003e \u003e \u003e // 0\n\u003e \u003e \u003e img.src \u003d \"a\";\n\u003e \u003e \u003e // 1\n\u003e \u003e \u003e img.src \u003d \"definitely not a\";\n\u003e \u003e \u003e // 2\n\u003e \u003e \u003e img.decode().then(...);\n\u003e \u003e \u003e // 3\n\u003e \u003e \u003e img.src \u003d \"a\";\n\u003e \u003e \u003e // 4\n\u003e \u003e \u003e img.decode().then(...);\n\u003e \u003e \u003e \n\u003e \u003e \u003e Then the decode should not run (it was enqueued for a different source). But due to the fact that the DoUpdateFromElement only runs at the end of all these steps, it will find that old_image \u003d\u003d new_image. The only knowledge that it ever _wasn\u0027t_ the same is lost when the task created in 1 is destroyed by 3.\n\u003e \u003e \n\u003e \u003e Well, the way the decode() spec text is currently written (or, the way I interpret it at least) it doesn\u0027t really \"associate\" with any source, but rather observes the \u0027current request\u0027. So, by that interpretation both of the above sequences would be equal, and maybe that is not a useful behavior (or maybe it is?). So a spec adjustment is probably needed?\n\u003e \n\u003e If we interpret the \u0027current request\u0027 strictly by https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data (which we should of course), then that means that the new request is not actually created until this task runs. This, in turn means that\n\u003e \n\u003e img.src \u003d \u0027...\u0027; // 1\n\u003e // 2\n\u003e img.decode().then(...); // 3\n\u003e // 4\n\u003e \n\u003e is not deterministic in whether the decode promise resolves or rejects, since the task that runs, and thus changes the \u0027current request\u0027 can run before or after the decode() call.\n\nNo, the (micro)task that setting .src queues (by \"await a stable state\" in step 6 of updating-the-image-data) will run after the current task has completed (so after [4] if [4] is to be considered a sequence of statements within the same task.) Hence it (the task/synchronous section of updating-the-image-data - which handles request setup) will always run after the sequence above has completed.\n\n\u003e That is, 1.4 of the updating-the-image-data creates the task at at line 1. That task can run at line 2. and according to 12/5 creates a new \u0027current request\u0027. Then line 3 acts on the \u0027current request\u0027 and eventually resolves.\n\u003e \n\u003e However, the task created on line 1 can also run at line 4. This means that the decode requested on line 3 acts on a null \u0027current request\u0027 and furthermore that current request changes to a new \u0027current request\u0027 when 12/5 is applied at line 4. This means that the decode rejects.\n\u003e \n\u003e I don\u0027t think that\u0027s an acceptable behavior, although strictly standard compliant. I think wording the decode spec in terms of \u0027current request\u0027 yields this interpretation however. Since updating-the-image-data seems to be the term that corresponds strictly to line 1 above (ie src \u003d ... line), would you be comfortable with the decode spec stating that \"If update to the image data is requested, then ... promise rejects\". This would imply that as soon as the first step of https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data is allowed to be applied, then we reject any pending requests. Furthermore, that means the current patch set is compliant to that spec (ie src \u003d src is indeed going to hit the first step of updating-the-image-data, albeit never making it to 12/5 due to 12/1)\n\nWell, that would add an ordering issue (decode() -\u003e .src vs. .src -\u003e decode() behaving differently) without really making much difference (without removing/changing other parts of decode()\u0027s parallel section.) If depending on ordering I guess we could as well just have decode() await a stable state itself...\nI.e when the microtask later mutates \u0027current request\u0027 the promise(s) are rejected. (And this piece is still missing from the current implementation.)\nTo keep the current behavior (sans the attribute mutation rejection) I guess there would need to be a list of promises that gets associated with a (possibly new) request. Sounds kind of thorny from a spec perspective, so hopefully someone has a better idea...",
      "parentUuid": "ec620ef0_2e3d1938",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24a10704_bfd51880",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-31T15:52:27Z",
      "side": 1,
      "message": "\u003e \u003e \n\u003e \u003e If we interpret the \u0027current request\u0027 strictly by https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data (which we should of course), then that means that the new request is not actually created until this task runs. This, in turn means that\n\u003e \u003e \n\u003e \u003e img.src \u003d \u0027...\u0027; // 1\n\u003e \u003e // 2\n\u003e \u003e img.decode().then(...); // 3\n\u003e \u003e // 4\n\u003e \u003e \n\u003e \u003e is not deterministic in whether the decode promise resolves or rejects, since the task that runs, and thus changes the \u0027current request\u0027 can run before or after the decode() call.\n\u003e \n\u003e No, the (micro)task that setting .src queues (by \"await a stable state\" in step 6 of updating-the-image-data) will run after the current task has completed (so after [4] if [4] is to be considered a sequence of statements within the same task.) Hence it (the task/synchronous section of updating-the-image-data - which handles request setup) will always run after the sequence above has completed.\n\u003e \n\u003e \u003e That is, 1.4 of the updating-the-image-data creates the task at at line 1. That task can run at line 2. and according to 12/5 creates a new \u0027current request\u0027. Then line 3 acts on the \u0027current request\u0027 and eventually resolves.\n\u003e \u003e \n\u003e \u003e However, the task created on line 1 can also run at line 4. This means that the decode requested on line 3 acts on a null \u0027current request\u0027 and furthermore that current request changes to a new \u0027current request\u0027 when 12/5 is applied at line 4. This means that the decode rejects.\n\u003e \u003e \n\u003e \u003e I don\u0027t think that\u0027s an acceptable behavior, although strictly standard compliant. I think wording the decode spec in terms of \u0027current request\u0027 yields this interpretation however. Since updating-the-image-data seems to be the term that corresponds strictly to line 1 above (ie src \u003d ... line), would you be comfortable with the decode spec stating that \"If update to the image data is requested, then ... promise rejects\". This would imply that as soon as the first step of https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data is allowed to be applied, then we reject any pending requests. Furthermore, that means the current patch set is compliant to that spec (ie src \u003d src is indeed going to hit the first step of updating-the-image-data, albeit never making it to 12/5 due to 12/1)\n\u003e \n\u003e Well, that would add an ordering issue (decode() -\u003e .src vs. .src -\u003e decode() behaving differently) without really making much difference (without removing/changing other parts of decode()\u0027s parallel section.) If depending on ordering I guess we could as well just have decode() await a stable state itself...\n\u003e I.e when the microtask later mutates \u0027current request\u0027 the promise(s) are rejected. (And this piece is still missing from the current implementation.)\n\u003e To keep the current behavior (sans the attribute mutation rejection) I guess there would need to be a list of promises that gets associated with a (possibly new) request. Sounds kind of thorny from a spec perspective, so hopefully someone has a better idea...\n\nSo, it gets thorny from both the spec and the implementation perspective to be honest. The basic decode case of \"img.src \u003d ...; img.decode();\" should produce a valid promise that resolves. However, with the microtask running after the decode, it does mutate the current request thus rejecting the promise. It\u0027s not that I ran into this accidentally, I did actually implement the new_image !\u003d old_image -\u003e invalidate everything logic in DoUpdateFromElement. And that caused the basic decode tests to fail. \n\nI then thought of implementing a separate queue that puts requests on it when there is a microtask pending. That becomes a bit unwieldy when you consider that a microtask can be cancelled and a new one enqueued, it\u0027s unclear what to do with the orphaned tasks there.\n\nThe current implementation does invalidate things on request change. It just happens before the microtask runs with the assumption that the microtask will mutate the request (of course src \u003d src violates this assumption and still invalidates the requests).\n\nFrom the pragmatic perspective, this means \"img.src \u003d ...\" img.decode()\" works as expected. Typical \"src \u003d a; decode() src \u003d b; decode()\" works as expected (first promise is rejected, second is resolved). However, src \u003d a; decode() src \u003d a; decode() also works in the same way, which isn\u0027t perfect.\n\nDo you mind if I file a bug to address this in a follow-up?",
      "parentUuid": "426f03c3_c6654d29",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb5584c0_94b2c146",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-31T17:30:50Z",
      "side": 1,
      "message": "\u003e \u003e \u003e \n\u003e \u003e \u003e If we interpret the \u0027current request\u0027 strictly by https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data (which we should of course), then that means that the new request is not actually created until this task runs. This, in turn means that\n\u003e \u003e \u003e \n\u003e \u003e \u003e img.src \u003d \u0027...\u0027; // 1\n\u003e \u003e \u003e // 2\n\u003e \u003e \u003e img.decode().then(...); // 3\n\u003e \u003e \u003e // 4\n\u003e \u003e \u003e \n\u003e \u003e \u003e is not deterministic in whether the decode promise resolves or rejects, since the task that runs, and thus changes the \u0027current request\u0027 can run before or after the decode() call.\n\u003e \u003e \n\u003e \u003e No, the (micro)task that setting .src queues (by \"await a stable state\" in step 6 of updating-the-image-data) will run after the current task has completed (so after [4] if [4] is to be considered a sequence of statements within the same task.) Hence it (the task/synchronous section of updating-the-image-data - which handles request setup) will always run after the sequence above has completed.\n\u003e \u003e \n\u003e \u003e \u003e That is, 1.4 of the updating-the-image-data creates the task at at line 1. That task can run at line 2. and according to 12/5 creates a new \u0027current request\u0027. Then line 3 acts on the \u0027current request\u0027 and eventually resolves.\n\u003e \u003e \u003e \n\u003e \u003e \u003e However, the task created on line 1 can also run at line 4. This means that the decode requested on line 3 acts on a null \u0027current request\u0027 and furthermore that current request changes to a new \u0027current request\u0027 when 12/5 is applied at line 4. This means that the decode rejects.\n\u003e \u003e \u003e \n\u003e \u003e \u003e I don\u0027t think that\u0027s an acceptable behavior, although strictly standard compliant. I think wording the decode spec in terms of \u0027current request\u0027 yields this interpretation however. Since updating-the-image-data seems to be the term that corresponds strictly to line 1 above (ie src \u003d ... line), would you be comfortable with the decode spec stating that \"If update to the image data is requested, then ... promise rejects\". This would imply that as soon as the first step of https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data is allowed to be applied, then we reject any pending requests. Furthermore, that means the current patch set is compliant to that spec (ie src \u003d src is indeed going to hit the first step of updating-the-image-data, albeit never making it to 12/5 due to 12/1)\n\u003e \u003e \n\u003e \u003e Well, that would add an ordering issue (decode() -\u003e .src vs. .src -\u003e decode() behaving differently) without really making much difference (without removing/changing other parts of decode()\u0027s parallel section.) If depending on ordering I guess we could as well just have decode() await a stable state itself...\n\u003e \u003e I.e when the microtask later mutates \u0027current request\u0027 the promise(s) are rejected. (And this piece is still missing from the current implementation.)\n\u003e \u003e To keep the current behavior (sans the attribute mutation rejection) I guess there would need to be a list of promises that gets associated with a (possibly new) request. Sounds kind of thorny from a spec perspective, so hopefully someone has a better idea...\n\u003e \n\u003e So, it gets thorny from both the spec and the implementation perspective to be honest. The basic decode case of \"img.src \u003d ...; img.decode();\" should produce a valid promise that resolves. However, with the microtask running after the decode, it does mutate the current request thus rejecting the promise. It\u0027s not that I ran into this accidentally, I did actually implement the new_image !\u003d old_image -\u003e invalidate everything logic in DoUpdateFromElement. And that caused the basic decode tests to fail. \n\nYes, that\u0027s what the spec say should happen though...\n\n\u003e I then thought of implementing a separate queue that puts requests on it when there is a microtask pending. That becomes a bit unwieldy when you consider that a microtask can be cancelled and a new one enqueued, it\u0027s unclear what to do with the orphaned tasks there.\n\u003e \n\u003e The current implementation does invalidate things on request change. It just happens before the microtask runs with the assumption that the microtask will mutate the request (of course src \u003d src violates this assumption and still invalidates the requests).\n\nCan we start by recognizing that \u0027request change\u0027 !\u003d \u0027attribute change\u0027? This seems to be one of the issues that are at the core of this, and really an important piece of the mechanics involved.\n\n\u003e From the pragmatic perspective, this means \"img.src \u003d ...\" img.decode()\" works as expected. Typical \"src \u003d a; decode() src \u003d b; decode()\" works as expected (first promise is rejected, second is resolved). However, src \u003d a; decode() src \u003d a; decode() also works in the same way, which isn\u0027t perfect.\n\nTo reiterate my comment from above: \"as expected\" !\u003d \"as specified\". This is my main gripe.\n\n\u003e Do you mind if I file a bug to address this in a follow-up?\n\nI\u0027d be fine with that, but I\u0027d also expect that bug to block shipping.",
      "parentUuid": "24a10704_bfd51880",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24ead28f_d213d3a5",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-07-31T20:41:30Z",
      "side": 1,
      "message": "\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e If we interpret the \u0027current request\u0027 strictly by https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data (which we should of course), then that means that the new request is not actually created until this task runs. This, in turn means that\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e img.src \u003d \u0027...\u0027; // 1\n\u003e \u003e \u003e \u003e // 2\n\u003e \u003e \u003e \u003e img.decode().then(...); // 3\n\u003e \u003e \u003e \u003e // 4\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e is not deterministic in whether the decode promise resolves or rejects, since the task that runs, and thus changes the \u0027current request\u0027 can run before or after the decode() call.\n\u003e \u003e \u003e \n\u003e \u003e \u003e No, the (micro)task that setting .src queues (by \"await a stable state\" in step 6 of updating-the-image-data) will run after the current task has completed (so after [4] if [4] is to be considered a sequence of statements within the same task.) Hence it (the task/synchronous section of updating-the-image-data - which handles request setup) will always run after the sequence above has completed.\n\u003e \u003e \u003e \n\u003e \u003e \u003e \u003e That is, 1.4 of the updating-the-image-data creates the task at at line 1. That task can run at line 2. and according to 12/5 creates a new \u0027current request\u0027. Then line 3 acts on the \u0027current request\u0027 and eventually resolves.\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e However, the task created on line 1 can also run at line 4. This means that the decode requested on line 3 acts on a null \u0027current request\u0027 and furthermore that current request changes to a new \u0027current request\u0027 when 12/5 is applied at line 4. This means that the decode rejects.\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e I don\u0027t think that\u0027s an acceptable behavior, although strictly standard compliant. I think wording the decode spec in terms of \u0027current request\u0027 yields this interpretation however. Since updating-the-image-data seems to be the term that corresponds strictly to line 1 above (ie src \u003d ... line), would you be comfortable with the decode spec stating that \"If update to the image data is requested, then ... promise rejects\". This would imply that as soon as the first step of https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data is allowed to be applied, then we reject any pending requests. Furthermore, that means the current patch set is compliant to that spec (ie src \u003d src is indeed going to hit the first step of updating-the-image-data, albeit never making it to 12/5 due to 12/1)\n\u003e \u003e \u003e \n\u003e \u003e \u003e Well, that would add an ordering issue (decode() -\u003e .src vs. .src -\u003e decode() behaving differently) without really making much difference (without removing/changing other parts of decode()\u0027s parallel section.) If depending on ordering I guess we could as well just have decode() await a stable state itself...\n\u003e \u003e \u003e I.e when the microtask later mutates \u0027current request\u0027 the promise(s) are rejected. (And this piece is still missing from the current implementation.)\n\u003e \u003e \u003e To keep the current behavior (sans the attribute mutation rejection) I guess there would need to be a list of promises that gets associated with a (possibly new) request. Sounds kind of thorny from a spec perspective, so hopefully someone has a better idea...\n\u003e \u003e \n\u003e \u003e So, it gets thorny from both the spec and the implementation perspective to be honest. The basic decode case of \"img.src \u003d ...; img.decode();\" should produce a valid promise that resolves. However, with the microtask running after the decode, it does mutate the current request thus rejecting the promise. It\u0027s not that I ran into this accidentally, I did actually implement the new_image !\u003d old_image -\u003e invalidate everything logic in DoUpdateFromElement. And that caused the basic decode tests to fail. \n\u003e \n\u003e Yes, that\u0027s what the spec say should happen though...\n\nYep I agree. That\u0027s definitely not the intent. The basic case as stated should not reject, hence I think \"current request\" is probably not what we meant to say.\n\n\u003e \n\u003e \u003e I then thought of implementing a separate queue that puts requests on it when there is a microtask pending. That becomes a bit unwieldy when you consider that a microtask can be cancelled and a new one enqueued, it\u0027s unclear what to do with the orphaned tasks there.\n\u003e \u003e \n\u003e \u003e The current implementation does invalidate things on request change. It just happens before the microtask runs with the assumption that the microtask will mutate the request (of course src \u003d src violates this assumption and still invalidates the requests).\n\u003e \n\u003e Can we start by recognizing that \u0027request change\u0027 !\u003d \u0027attribute change\u0027? This seems to be one of the issues that are at the core of this, and really an important piece of the mechanics involved.\n\u003e \n\u003e \u003e From the pragmatic perspective, this means \"img.src \u003d ...\" img.decode()\" works as expected. Typical \"src \u003d a; decode() src \u003d b; decode()\" works as expected (first promise is rejected, second is resolved). However, src \u003d a; decode() src \u003d a; decode() also works in the same way, which isn\u0027t perfect.\n\u003e \n\u003e To reiterate my comment from above: \"as expected\" !\u003d \"as specified\". This is my main gripe.\n\nI guess my question is whether you agree that \"as expected\" is good behavior? We almost certainly would have to change the spec due to the fact that this feature becomes somewhat unusable in the basic case. I\u0027m just wondering if that will be a sufficient change.\n\n\u003e \n\u003e \u003e Do you mind if I file a bug to address this in a follow-up?\n\u003e \n\u003e I\u0027d be fine with that, but I\u0027d also expect that bug to block shipping.\n\nThat\u0027s fair.",
      "parentUuid": "fb5584c0_94b2c146",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3c6064c_7e9bd6f3",
        "filename": "third_party/WebKit/Source/core/svg/SVGImageElement.h",
        "patchSetId": 1
      },
      "lineNbr": 105,
      "author": {
        "id": 1115594
      },
      "writtenOn": "2017-07-31T21:05:37Z",
      "side": 1,
      "message": "\u003e \u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e \u003e If we interpret the \u0027current request\u0027 strictly by https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data (which we should of course), then that means that the new request is not actually created until this task runs. This, in turn means that\n\u003e \u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e \u003e img.src \u003d \u0027...\u0027; // 1\n\u003e \u003e \u003e \u003e \u003e // 2\n\u003e \u003e \u003e \u003e \u003e img.decode().then(...); // 3\n\u003e \u003e \u003e \u003e \u003e // 4\n\u003e \u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e \u003e is not deterministic in whether the decode promise resolves or rejects, since the task that runs, and thus changes the \u0027current request\u0027 can run before or after the decode() call.\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e No, the (micro)task that setting .src queues (by \"await a stable state\" in step 6 of updating-the-image-data) will run after the current task has completed (so after [4] if [4] is to be considered a sequence of statements within the same task.) Hence it (the task/synchronous section of updating-the-image-data - which handles request setup) will always run after the sequence above has completed.\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e \u003e That is, 1.4 of the updating-the-image-data creates the task at at line 1. That task can run at line 2. and according to 12/5 creates a new \u0027current request\u0027. Then line 3 acts on the \u0027current request\u0027 and eventually resolves.\n\u003e \u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e \u003e However, the task created on line 1 can also run at line 4. This means that the decode requested on line 3 acts on a null \u0027current request\u0027 and furthermore that current request changes to a new \u0027current request\u0027 when 12/5 is applied at line 4. This means that the decode rejects.\n\u003e \u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e \u003e I don\u0027t think that\u0027s an acceptable behavior, although strictly standard compliant. I think wording the decode spec in terms of \u0027current request\u0027 yields this interpretation however. Since updating-the-image-data seems to be the term that corresponds strictly to line 1 above (ie src \u003d ... line), would you be comfortable with the decode spec stating that \"If update to the image data is requested, then ... promise rejects\". This would imply that as soon as the first step of https://html.spec.whatwg.org/multipage/images.html#updating-the-image-data is allowed to be applied, then we reject any pending requests. Furthermore, that means the current patch set is compliant to that spec (ie src \u003d src is indeed going to hit the first step of updating-the-image-data, albeit never making it to 12/5 due to 12/1)\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e Well, that would add an ordering issue (decode() -\u003e .src vs. .src -\u003e decode() behaving differently) without really making much difference (without removing/changing other parts of decode()\u0027s parallel section.) If depending on ordering I guess we could as well just have decode() await a stable state itself...\n\u003e \u003e \u003e \u003e I.e when the microtask later mutates \u0027current request\u0027 the promise(s) are rejected. (And this piece is still missing from the current implementation.)\n\u003e \u003e \u003e \u003e To keep the current behavior (sans the attribute mutation rejection) I guess there would need to be a list of promises that gets associated with a (possibly new) request. Sounds kind of thorny from a spec perspective, so hopefully someone has a better idea...\n\u003e \u003e \u003e \n\u003e \u003e \u003e So, it gets thorny from both the spec and the implementation perspective to be honest. The basic decode case of \"img.src \u003d ...; img.decode();\" should produce a valid promise that resolves. However, with the microtask running after the decode, it does mutate the current request thus rejecting the promise. It\u0027s not that I ran into this accidentally, I did actually implement the new_image !\u003d old_image -\u003e invalidate everything logic in DoUpdateFromElement. And that caused the basic decode tests to fail. \n\u003e \u003e \n\u003e \u003e Yes, that\u0027s what the spec say should happen though...\n\u003e \n\u003e Yep I agree. That\u0027s definitely not the intent. The basic case as stated should not reject, hence I think \"current request\" is probably not what we meant to say.\n\u003e \n\u003e \u003e \n\u003e \u003e \u003e I then thought of implementing a separate queue that puts requests on it when there is a microtask pending. That becomes a bit unwieldy when you consider that a microtask can be cancelled and a new one enqueued, it\u0027s unclear what to do with the orphaned tasks there.\n\u003e \u003e \u003e \n\u003e \u003e \u003e The current implementation does invalidate things on request change. It just happens before the microtask runs with the assumption that the microtask will mutate the request (of course src \u003d src violates this assumption and still invalidates the requests).\n\u003e \u003e \n\u003e \u003e Can we start by recognizing that \u0027request change\u0027 !\u003d \u0027attribute change\u0027? This seems to be one of the issues that are at the core of this, and really an important piece of the mechanics involved.\n\u003e \u003e \n\u003e \u003e \u003e From the pragmatic perspective, this means \"img.src \u003d ...\" img.decode()\" works as expected. Typical \"src \u003d a; decode() src \u003d b; decode()\" works as expected (first promise is rejected, second is resolved). However, src \u003d a; decode() src \u003d a; decode() also works in the same way, which isn\u0027t perfect.\n\u003e \u003e \n\u003e \u003e To reiterate my comment from above: \"as expected\" !\u003d \"as specified\". This is my main gripe.\n\u003e \n\u003e I guess my question is whether you agree that \"as expected\" is good behavior? We almost certainly would have to change the spec due to the fact that this feature becomes somewhat unusable in the basic case. I\u0027m just wondering if that will be a sufficient change.\n\nIt certainly seems like a convenient behavior (not having to explicitly wait for \u0027load\u0027 which seems to be the most useful way with the current spec formulation.) Changing one thing will have consequences though, and likely mean the whole spec will need rewriting.\nConsider for example the case where one request has been issued - and failed [dispatching \u0027error\u0027 and setting the state to \u0027broken\u0027] - what would happen to a new decode() in that case. Current spec says \u0027reject\u0027 but that should presumably not be the case. Similarly for other states that the image could be in when decode() is called. So what is \"good behavior\" has to considered with the \"model\" as a whole.",
      "parentUuid": "24ead28f_d213d3a5",
      "range": {
        "startLine": 103,
        "startChar": 69,
        "endLine": 105,
        "endChar": 18
      },
      "revId": "9dba7ba35718e7fec22589f86aa6fbcd8c79151f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}