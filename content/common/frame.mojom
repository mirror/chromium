// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module content.mojom;

import "content/common/page_state.mojom";
import "content/common/url_loader_factory_bundle.mojom";
import "content/public/common/url_loader.mojom";
import "content/public/common/window_container_type.mojom";
import "mojo/common/time.mojom";
import "mojo/common/unguessable_token.mojom";
import "services/service_manager/public/interfaces/interface_provider.mojom";
import "third_party/WebKit/public/platform/referrer.mojom";
import "third_party/WebKit/public/web/window_features.mojom";
import "ui/base/mojo/window_open_disposition.mojom";
import "url/mojo/origin.mojom";
import "url/mojo/url.mojom";

// The name of the InterfaceProviderSpec in service manifests used by the
// frame tree to expose frame-specific interfaces between renderer and browser.
const string kNavigation_FrameSpec = "navigation:frame";

// Implemented by the frame provider (e.g. renderer processes).
interface Frame {
  GetInterfaceProvider(service_manager.mojom.InterfaceProvider& interfaces);
};

// See src/content/common/navigation_params.h
[Native]
struct CommonNavigationParams;

// See src/content/common/navigation_params.h
[Native]
struct RequestNavigationParams;

// Implemented by the frame provider and currently must be associated with the
// legacy IPC channel.
interface FrameNavigationControl {
  // Tells the renderer that a navigation is ready to commit.  The renderer
  // should request |body_url| to get access to the stream containing the body
  // of the response. When the Network Service is enabled, |body_url| is not
  // used and instead the data is passed to the renderer via |body_data|. In
  // that case |subresource_loader_factories| may also be provided by the
  // browser as a a means for the renderer to load subresources where
  // applicable.
  CommitNavigation(URLResponseHead head,
                   url.mojom.Url body_url,
                   CommonNavigationParams common_params,
                   RequestNavigationParams request_params,
                   handle<data_pipe_consumer>? body_data,
                   URLLoaderFactoryBundle? subresource_loader_factories);
};

// Implemented by the frame (e.g. renderer processes).
// Instances of this interface must be associated with (i.e., FIFO with) the
// legacy IPC channel.
interface FrameBindingsControl {
  // Used to tell a render frame whether it should expose various bindings
  // that allow JS content extended privileges. See BindingsPolicy for valid
  // flag values.
  AllowBindings(int32 enabled_bindings_flags);
};

// Implemented by a service that provides implementations of the Frame
// interface. (e.g. renderer processes).
interface FrameFactory {
  CreateFrame(int32 frame_routing_id, Frame& frame);
};

struct CreateNewWindowParams {
  // True if this open request came in the context of a user gesture.
  bool user_gesture;

  // Type of window requested.
  WindowContainerType window_container_type;

  // The session storage namespace ID this window should use.
  int64 session_storage_namespace_id;

  // The name of the resulting frame that should be created (empty if none
  // has been specified). UTF8 encoded string.
  string frame_name;

  // Whether the opener will be suppressed in the new window, in which case
  // scripting the new window is not allowed.
  bool opener_suppressed;

  // Whether the window should be opened in the foreground, background, etc.
  ui.mojom.WindowOpenDisposition disposition;

  // The URL that will be loaded in the new window (empty if none has been
  // specified).
  url.mojom.Url target_url;

  // The referrer that will be used to load |target_url| (empty if none has
  // been specified).
  blink.mojom.Referrer referrer;

  // The window features to use for the new window.
  blink.mojom.WindowFeatures features;
};

// Operation result when the renderer asks the browser to create a new window.
enum CreateNewWindowStatus {
  // Ignore creation of the new window. This can happen because creation is
  // blocked or because the new window should have no opener relationship.
  kIgnore,
  // Reuse the current window rather than creating a new window.
  kReuse,
  // Create a new window using the corresponding params in |reply|.
  kSuccess,
};

// All routing IDs in this struct must be set to a valid routing ID.
struct CreateNewWindowReply {
  // The ID of the view to be created.
  int32 route_id;

  // The ID of the main frame hosted in the view.
  int32 main_frame_route_id;

  // The ID of the widget for the main frame.
  int32 main_frame_widget_route_id;

  // The InterfaceProvider through which the main RenderFrame can access
  // services exposed by its RenderFrameHost.
  service_manager.mojom.InterfaceProvider main_frame_interface_provider;

  // Duplicated from CreateNewWindowParams because legacy code.
  int64 cloned_session_storage_namespace_id;

  // Used for devtools instrumentation and trace-ability. The token is
  // propagated to Blink's LocalFrame and both Blink and content/
  // can tag calls and requests with this instrumentation token in order to
  // attribute them to the context frame.
  // |devtools_frame_token| is only defined by the browser and is never
  // sent back from the renderer in the control calls.
  mojo.common.mojom.UnguessableToken devtools_main_frame_token;
};

// An opaque handle that keeps alive the associated render process even after
// the frame is detached. Used by resource requests with "keepalive" specified.
interface KeepAliveHandle {};

[Native]
enum NavigationGesture;

[Native]
enum WebInsecureRequestPolicy;

[Native]
struct HostPortPair;

[Native]
struct PageState;

[Native]
enum UILoadMetricsReportType;

[Native]
enum PageTransition;

struct DidCommitProvisionalLoadParams {
  // The unique ID of the NavigationEntry for browser-initiated navigations.
  // This value was given to the render process in the HistoryNavigationParams
  // and is being returned by the renderer without it having any idea what it
  // means. If the navigation was renderer-initiated, this value is 0.
  int32 nav_entry_id;

  // The item sequence number identifies each stop in the session history.  It
  // is unique within the renderer process and makes a best effort to be unique
  // across browser sessions (using a renderer process timestamp).
  int64 item_sequence_number;

  // The document sequence number is used to identify cross-document navigations
  // in session history.  It increments for each new document and is unique in
  // the same way as |item_sequence_number|.  In-page navigations get a new item
  // sequence number but the same document sequence number.
  int64 document_sequence_number;

  // URL of the page being loaded.
  url.mojom.Url url;

  // The base URL for the page's document when the frame was committed. Empty if
  // similar to 'url' above. Note that any base element in the page has not been
  // parsed yet and is therefore not reflected.
  // This is of interest when a MHTML file is loaded, as the base URL has been
  // set to original URL of the site the MHTML represents.
  url.mojom.Url base_url;

  // URL of the referrer of this load. WebKit generates this based on the
  // source of the event that caused the load.
  blink.mojom.Referrer referrer;

  // The type of transition.
  PageTransition transition;

  // Lists the redirects that occurred on the way to the current page. This
  // vector has the same format as reported by the WebDataSource in the glue,
  // with the current page being the last one in the list (so even when
  // there's no redirect, there will be one entry in the list.
  array<url.mojom.Url> redirects;

  // Set to false if we want to update the session history but not update
  // the browser history.  E.g., on unreachable urls.
  bool should_update_history;

  // Contents MIME type of main frame.
  string contents_mime_type;

  // Remote address of the socket which fetched this resource.
  HostPortPair socket_address;

  // This is the value from the browser (copied from the navigation request)
  // indicating whether it intended to make a new entry. TODO(avi): Remove this
  // when the pending entry situation is made sane and the browser keeps them
  // around long enough to match them via nav_entry_id.
  bool intended_as_new_entry;

  // Whether this commit created a new entry.
  bool did_create_new_entry;

  // Whether this commit should replace the current entry.
  bool should_replace_current_entry;

  // The gesture that initiated this navigation.
  NavigationGesture gesture;

  // The HTTP method used by the navigation.
  string method;

  // The POST body identifier. -1 if it doesn't exist.
  int64 post_id;

  // Whether the frame navigation resulted in no change of the document within
  // the frame. For example, the navigation may have just resulted in
  // scrolling to a named anchor.
  bool was_within_same_document;

  // The status code of the HTTP request.
  int32 http_status_code;

  // This flag is used to warn if the renderer is displaying an error page,
  // so that we can set the appropriate page type.
  bool url_is_unreachable;

  // Serialized history item state to store in the navigation entry.
  PageState page_state;

  // Original request's URL.
  url.mojom.Url original_request_url;

  // User agent override used to navigate.
  bool is_overriding_user_agent;

  // Notifies the browser that for this navigation, the session history was
  // successfully cleared.
  bool history_list_was_cleared;

  // The routing_id of the render view associated with the navigation.
  // We need to track the RenderViewHost routing_id because of downstream
  // dependencies (crbug.com/392171 DownloadRequestHandle, SaveFileManager,
  // ResourceDispatcherHostImpl, MediaStreamUIProxy,
  // SpeechRecognitionDispatcherHost and possibly others). They look up the view
  // based on the ID stored in the resource requests. Once those dependencies
  // are unwound or moved to RenderFrameHost (crbug.com/304341) we can move the
  // client to be based on the routing_id of the RenderFrameHost.
  int32 render_view_routing_id;

  // Origin of the frame.  This will be replicated to any associated
  // RenderFrameProxies.
  url.mojom.Origin origin;

  // How navigation metrics starting on UI action for this load should be
  // reported.
  UILoadMetricsReportType report_type;

  // Timestamp at which the UI action that triggered the navigation originated.
  mojo.common.mojom.TimeTicks ui_timestamp;

  // The insecure request policy the document for the load is enforcing.
  WebInsecureRequestPolicy insecure_request_policy;

  // True if the document for the load is a unique origin that should be
  // considered potentially trustworthy.
  bool has_potentially_trustworthy_unique_origin;

  // See WebSearchableFormData for a description of these.
  // Not used by PlzNavigate: in that case these fields are sent to the browser
  // in BeginNavigationParams.
  url.mojom.Url searchable_form_url;
  string searchable_form_encoding;

  // This is a non-decreasing value that the browser process can use to
  // identify and discard compositor frames that correspond to now-unloaded
  // web content.
  uint32 content_source_id;
};

// Implemented by the frame server (i.e. the browser process). For messages that
// must be associated with the IPC channel.
interface FrameHost {
  // Sent by the renderer to request the browser to create a new window. |reply|
  // is only non-null on when status == CreateNewWindowStatus::kSuccess.
  [Sync] CreateNewWindow(CreateNewWindowParams params)
      => (CreateNewWindowStatus status, CreateNewWindowReply? reply);

  // Creates and returns a KeepAliveHandle.
  IssueKeepAliveHandle(KeepAliveHandle& keep_alive_handle);

  // Sent by the renderer when a navigation commits in the frame.
  DidCommitProvisionalLoad(
      DidCommitProvisionalLoadParams params);
};
