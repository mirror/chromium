// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/common/unique_name_helper.h"

#include <algorithm>

#include "base/logging.h"
#include "base/macros.h"
#include "base/strings/string_number_conversions.h"
#include "base/strings/string_util.h"
#include "crypto/sha2.h"

namespace content {

namespace {

using FrameAdapter = UniqueNameHelper::FrameAdapter;

class PendingChildFrameAdapter : public UniqueNameHelper::FrameAdapter {
 public:
  explicit PendingChildFrameAdapter(const FrameAdapter* parent)
      : parent_(parent) {}

  // FrameAdapter overrides:
  bool IsMainFrame() const override { return false; }
  bool IsCandidateUnique(const std::string& name) const override {
    return parent_->IsCandidateUnique(name);
  }
  int GetSiblingCount() const override {
    // Note: no adjustment is required here: since this adapter is an internal
    // helper, the parent FrameAdapter it delegates to won't know about this
    // child to include it in the count.
    return parent_->GetChildCount();
  }
  int GetChildCount() const override {
    NOTREACHED();
    return 0;
  }
  std::vector<base::StringPiece> CollectAncestorNames(
      BeginPoint begin_point,
      bool (*should_stop)(base::StringPiece)) const override {
    DCHECK_EQ(BeginPoint::kParentFrame, begin_point);
    return parent_->CollectAncestorNames(BeginPoint::kThisFrame, should_stop);
  }
  std::vector<int> GetFramePosition(BeginPoint begin_point) const override {
    DCHECK_EQ(BeginPoint::kParentFrame, begin_point);
    return parent_->GetFramePosition(BeginPoint::kThisFrame);
  }

 private:
  const FrameAdapter* const parent_;
};

constexpr char kFramePathPrefix[] = "<!--framePath /";
constexpr int kFramePathPrefixLength = 15;
constexpr int kFramePathSuffixLength = 3;

bool IsNameWithFramePath(base::StringPiece name) {
  return name.starts_with(kFramePathPrefix) && name.ends_with("-->") &&
         (kFramePathPrefixLength + kFramePathSuffixLength) < name.size();
}

base::StringPiece UnwrapNameWithFramePath(base::StringPiece name) {
  return name.substr(
      kFramePathPrefixLength,
      name.size() - kFramePathPrefixLength - kFramePathSuffixLength);
}

std::string GenerateCandidate(const FrameAdapter* frame) {
  std::string new_name(kFramePathPrefix);
  std::vector<base::StringPiece> ancestor_names = frame->CollectAncestorNames(
      FrameAdapter::BeginPoint::kParentFrame, &IsNameWithFramePath);
  std::reverse(ancestor_names.begin(), ancestor_names.end());
  // Note: This checks ancestor_names[0] twice, but it's nicer to do the name
  // extraction here rather than passing another function pointer to
  // CollectAncestorNames().
  if (!ancestor_names.empty() && IsNameWithFramePath(ancestor_names[0]))
    ancestor_names[0] = UnwrapNameWithFramePath(ancestor_names[0]);
  new_name += base::JoinString(ancestor_names, "/");

  new_name += "/<!--frame";
  new_name += base::IntToString(frame->GetSiblingCount());
  new_name += "-->-->";

  // NOTE: This name might not be unique - see http://crbug.com/588800.
  return new_name;
}

std::string GenerateFramePosition(const FrameAdapter* frame) {
  std::string position_string("<!--framePosition");
  std::vector<int> positions =
      frame->GetFramePosition(FrameAdapter::BeginPoint::kParentFrame);
  for (int position : positions) {
    position_string += '-';
    position_string += base::IntToString(position);
  }

  // NOTE: The generated string is not guaranteed to be unique, but should
  // have a better chance of being unique than the string generated by
  // GenerateCandidate, because we embed extra information into the string:
  // 1) we walk the full chain of ancestors, all the way to the main frame
  // 2) we use frame-position-within-parent (aka |position_in_parent|)
  //    instead of sibling-count.
  return position_string;
}

std::string AppendUniqueSuffix(const FrameAdapter* frame,
                               const std::string& prefix,
                               const std::string& likely_unique_suffix) {
  // This should only be called if the |prefix| isn't unique, as this is
  // otherwise pointless work.
  DCHECK(!frame->IsCandidateUnique(prefix));

  // We want unique name to be stable across page reloads - this is why
  // we use a deterministic |number_of_tries| rather than a random number
  // (a random number would be more likely to avoid a collision, but
  // would change after every page reload).
  int number_of_retries = 0;

  // Keep trying |prefix| + |likely_unique_suffix| + |number_of_tries|
  // concatenations until we get a truly unique name.
  std::string candidate(prefix);
  candidate += likely_unique_suffix;
  candidate += '/';
  while (true) {
    size_t current_length = candidate.size();
    candidate += base::IntToString(number_of_retries++);
    candidate += "-->";
    if (frame->IsCandidateUnique(candidate))
      break;
    candidate.resize(current_length);
  }
  return candidate;
}

std::string CalculateLegacyName(const FrameAdapter* frame,
                                const std::string& name) {
  if (!name.empty() && frame->IsCandidateUnique(name) && name != "_blank")
    return name;

  std::string candidate = GenerateCandidate(frame);
  if (frame->IsCandidateUnique(candidate))
    return candidate;

  std::string likely_unique_suffix = GenerateFramePosition(frame);
  return AppendUniqueSuffix(frame, candidate, likely_unique_suffix);
}

std::string CalculateHashedName(const std::string& name) {
  uint8_t result[crypto::kSHA256Length];
  crypto::SHA256HashString(name, result, arraysize(result));
  std::string hashed_candidate;
  hashed_candidate.reserve(
      // '<!--framePath /'
      kFramePathPrefixLength +
      // '/ <!--frameHash '
      16 +
      // each byte takes two characters in hexadecimal
      arraysize(result) * 2 +
      // '-->'
      3 +
      // '-->'
      kFramePathSuffixLength);
  hashed_candidate += kFramePathPrefix;
  hashed_candidate += "/<!--frameHash ";
  hashed_candidate += base::HexEncode(result, arraysize(result));
  hashed_candidate += "-->-->";
  return hashed_candidate;
}

std::string CalculateNewName(const FrameAdapter* frame,
                             const std::string& name) {
  std::string candidate = CalculateLegacyName(frame, name);
  if (candidate.size() < UniqueNameHelper::kMaxSize)
    return candidate;
  do
    candidate = CalculateHashedName(candidate);
  while (!frame->IsCandidateUnique(candidate));
  return candidate;
}

}  // namespace

UniqueNameHelper::FrameAdapter::~FrameAdapter() {}

UniqueNameHelper::UniqueNameHelper(const FrameAdapter* frame) : frame_(frame) {}

UniqueNameHelper::~UniqueNameHelper() {}

std::string UniqueNameHelper::GenerateNameForNewChildFrame(
    const std::string& name) const {
  PendingChildFrameAdapter adapter(frame_);
  return CalculateNewName(&adapter, name);
}

void UniqueNameHelper::UpdateName(const std::string& name) {
  // The unique name of the main frame is always the empty string.
  if (frame_->IsMainFrame())
    return;
  // It's important to clear this before calculating a new name, as the
  // calculation checks for collisions with existing unique names.
  unique_name_.clear();
  unique_name_ = CalculateNewName(frame_, name);
}

bool UniqueNameHelper::AdjustLegacyNameForMaxSize(
    std::string legacy_name,
    const Replacement* last_replacement,
    std::string* new_name,
    base::Optional<Replacement>* new_replacement) {
  // Simplest case: nothing required since the legacy name is under the max
  // size limit.
  if (legacy_name.size() < kMaxSize)
    return false;

  // If there's a replacement that matches, apply it.
  if (IsNameWithFramePath(legacy_name) && last_replacement) {
    size_t replaced_index = legacy_name.find(last_replacement->original_path);
    if (replaced_index != std::string::npos) {
      std::string name_with_replacement;
      name_with_replacement.reserve(
          // Length from the replacement index to the end
          legacy_name.size() - replaced_index -
          // Adjusted by the difference in the size of the replacement
          (last_replacement->original_path.size() -
           last_replacement->hashed_path.size()) +
          // Plus space for the frame path prefix.
          kFramePathPrefixLength);
      name_with_replacement += kFramePathPrefix;
      name_with_replacement += last_replacement->hashed_path;
      name_with_replacement += legacy_name.substr(
          replaced_index + last_replacement->original_path.size());
      // If the name with the replacement is under the max size limit, use it as
      // the updated name. Note that no new replacement needs to be generated in
      // this case, as there the unique name generated for this frame did not
      // need to be hashed to bring it under the size limit.
      if (name_with_replacement.size() < kMaxSize) {
        *new_name = std::move(name_with_replacement);
        return true;
      }
      // If it's still over the max size limit, use the name with the
      // replacement as the basis for calculating the hashed name.
      legacy_name = std::move(name_with_replacement);
    }
  }

  // While normal unique name calculation will re-hash in case there's a
  // collision, this doesn't bother: if ExplodedFrameState isn't deserialized in
  // the same order as the frames originally loaded, it's not going to match
  // anyway.
  *new_name = CalculateHashedName(legacy_name);
  // Since this hashed a portion of the frame path, generate a new Replacement
  // object for adjusting descendant's unique names.
  new_replacement->emplace();
  if (IsNameWithFramePath(legacy_name)) {
    (*new_replacement)->original_path =
        UnwrapNameWithFramePath(legacy_name).as_string();
  } else {
    // If the legacy name was simply an extremely long unique name, it will
    // become the root of the frame path for any descendant frames. Prepend '/'
    // to match the convention used by frame path.
    (*new_replacement)->original_path = '/';
    (*new_replacement)->original_path += legacy_name;
  }
  // Unconditionally include a trailing slash as part of the replacement string.
  // The returned replacement will only be used for adjusting unique names of
  // descendants: any descendant that includes the frame path will necessarily
  // include '/' as a delimiter after the portion of the frame path that has
  // already been seen.
  (*new_replacement)->original_path += '/';
  (*new_replacement)->hashed_path =
      UnwrapNameWithFramePath(*new_name).as_string();
  (*new_replacement)->hashed_path += '/';
  return true;
}

std::string UniqueNameHelper::CalculateLegacyNameForTest(
    const FrameAdapter* adapter,
    const std::string& name) {
  return CalculateLegacyName(adapter, name);
}

}  // namespace content
