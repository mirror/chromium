// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module content.mojom;

import "ui/gfx/geometry/mojo/geometry.mojom";

// Provides extra capabilities required for DevTools frontend to function.
// This includes communication channel from/to inspected target which implements
// remote debugging protocol. Protocol messages go through browser process.
//
// Instances of this interface must be associated with navigation-related
// interface, since we should setup DevToolsFrontend before the navigation
// commits in the frame.
interface DevToolsFrontend {
  // Sets up a main frame as a DevTools frontend. This exposes DevToolsHost
  // object (see DevToolsHost.idl for details). The |api_script| is executed
  // on each navigation in the frame before the DevTools frontend starts
  // loading. It makes use of DevToolsHost to expose embedder capabilities to
  // DevTools (e.g. connection to the inspected target).
  SetupDevToolsFrontend(string api_script,
                        associated DevToolsFrontendHost host);

  // Sets up a child frame to expose DevTools extension API by executing script
  // |extension_api| on each navigation in the frame. This script provides
  // required capabilities for DevTools extensions to function, implementing
  // chrome.devtools extension API.
  SetupDevToolsExtensionAPI(string extension_api);
};

// Provides embedder functionality to a frame serving as DevTools frontend.
interface DevToolsFrontendHost {
  // Sends a message to DevTools frontend embedder.
  DispatchEmbedderMessage(string message);
};


// Used to send large messages in chunks from session to a host.
struct DevToolsMessageChunk {
  // Whether this is a first chunk in a message.
  bool is_first;

  // Whether this chunk is last.
  bool is_last;

  // The total size of the message being sent in chunks, only comes in
  // a first chunk.
  uint32 message_size;

  // Chunk data itself.
  string data;

  // Call id as defined in DevTools protocol, only comes for responses.
  int32 call_id;

  // State for future reattach, only comes for responses in a last chunk.
  string post_state;
};

// Implemented by debugging targets which expose remote debugging protocol.
// Examples are local frame roots and service workers.
//
// Note that frame instances of this interface must be associated with
// navigation-related interface, since we should reattach sessions before
// the navigation commits in the frame.
interface DevToolsAgent {
  // Attaches a new debugging session. This session speaks remote debugging
  // protocol and restores all the changes to original state once destroyed.
  //
  // If |reattach_state| is present, restores the state of the session to
  // previously saved one (see DevToolsMessageChunk). This is useful when
  // transferring a session from one agent to another while preserving the
  // state. For example, cross-process navigation in a frame creates a new
  // DevToolsAgent (in a different process), but we preserve the state of
  // debugging session by copying it from one agent to another.
  AttachDevToolsSession(DevToolsSessionHost host,
                        DevToolsSession& session,
                        string? reattach_state);
};

// Represents an attached session which exposes remote debugging protocol.
interface DevToolsSession {
  // Dispatches protocol message from a client to a debugging target.
  // |method| is a method name as defined in protocol (e.g. "Runtime.evaluate").
  // |call_id| is a command id as defined in protocol, and is going to be
  // reported back to host in response (see DevToolsMessageChunk).
  DispatchProtocolMessage(int32 call_id, string method, string message);

  // Requests an element at specific position to be inspected.
  InspectElement(gfx.mojom.Point point);
};

// A peer of DevToolsSession, which receives notifications and responses from
// a session, representing a remote debugging client.
interface DevToolsSessionHost {
  // Dispatches protocol message from a debugging target to a client.
  DispatchProtocolMessage(DevToolsMessageChunk chunk);

  // Requests a new DevTools window for a frame with given routing id.
  // TODO(dgozman): get rid of routing id when possible.
  RequestNewWindow(int32 frame_routing_id) => (bool success);
};
