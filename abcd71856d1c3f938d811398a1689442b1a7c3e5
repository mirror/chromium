{
  "comments": [
    {
      "key": {
        "uuid": "31bf406e_4c0d20f7",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeApplication.java",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1001618
      },
      "writtenOn": "2018-01-23T13:37:20Z",
      "side": 1,
      "message": "So this is still arguably a bit problematic in that it forces all chrome starts and processes (regardless of flag setting) to read shared preference on startup and earlier than our existing \"warm up\" logic. I see what we\u0027re trying to do by caching through shared prefs but it\u0027s still not \"free\" :/\n\nI need to think about this cause I don\u0027t have a great suggestion. If we wanted to move forward with this approach (one could argue that the impact is likely minimal but we should grab startup trace to see as I suspect we block main thread a bit cause of the IO where previously it was happening async). More importantly though I\u0027d want us to rip out the \"warmup\" ChromeBrowserInitializer.warmUpSharedPrefs cause it\u0027s moot and confusing at that point.\n\nOne option I\u0027m wondering about is perhaps the issue is that we\u0027re trying to set the command line \"early enough\" and it\u0027s forcing us to do it too early. If we instead switched to a pull-model such that the first time someone actually tries to read a flag we ensure it\u0027s init\u0027d that might solve the issue (granted it\u0027s a larger refactoring).",
      "range": {
        "startLine": 106,
        "startChar": 49,
        "endLine": 106,
        "endChar": 81
      },
      "revId": "abcd71856d1c3f938d811398a1689442b1a7c3e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fae82029_6a6b2cd3",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeApplication.java",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1126674
      },
      "writtenOn": "2018-01-23T16:46:20Z",
      "side": 1,
      "message": "How about we only read the shared pref if a command-line file exists?",
      "parentUuid": "31bf406e_4c0d20f7",
      "range": {
        "startLine": 106,
        "startChar": 49,
        "endLine": 106,
        "endChar": 81
      },
      "revId": "abcd71856d1c3f938d811398a1689442b1a7c3e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c561e1c_0a195ffe",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeApplication.java",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1001618
      },
      "writtenOn": "2018-01-23T18:39:49Z",
      "side": 1,
      "message": "sure that could mitigate my concerns. I think our startup flows would still be rather complex but we could clean it up in similar manner as you suggested in https://chromium-review.googlesource.com/c/chromium/src/+/804215/3",
      "parentUuid": "fae82029_6a6b2cd3",
      "range": {
        "startLine": 106,
        "startChar": 49,
        "endLine": 106,
        "endChar": 81
      },
      "revId": "abcd71856d1c3f938d811398a1689442b1a7c3e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "61c68136_448f24da",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeApplication.java",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2018-01-24T17:31:40Z",
      "side": 1,
      "message": "If we want to make progress, it seems like we should convert this from passing a boolean to passing a Callable\u003cBoolean\u003e into the base component.  Then we could defer reading this until we deemed it was necessary.\n\nA meta question again, why do we read command line this early?  What in java land do we care about having in the command line before native?   I see things in ChromeSwitches that seem relevant (like strict mode and the like), but are these things we really need to be doing?  Could they be deferred till later?  I thought we had something that would force the waitForDebugger, but I only see that called in ChildProcessService in base.\n\nIf we could force all of our shared pref access through a single point, we could potentially introduce the warmup if we made all the other points crash in debug to catch regressions if we wanted to prevent the slow leak here.\n\nI actually think we need shared prefs earlier than we do commandline for many things (in prod code), so it would be good to find some balance here.",
      "parentUuid": "8c561e1c_0a195ffe",
      "range": {
        "startLine": 106,
        "startChar": 49,
        "endLine": 106,
        "endChar": 81
      },
      "revId": "abcd71856d1c3f938d811398a1689442b1a7c3e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51fedb99_10d2070d",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeApplication.java",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1126674
      },
      "writtenOn": "2018-01-24T17:55:36Z",
      "side": 1,
      "message": "I added the callback idea to the other review.\n\nI don\u0027t like the idea of command-line being lazily initialized, because that means blocking IO at points where you\u0027re not expecting it, and the \"work-around\" is that you check every flag using a background thread (super annoying).\n\nWe currently check for --startup-tracing right in ChromeApplication, which I can\u0027t see a good way around.\n\nAgree that we should warm prefs earlier than we do now though, but hopefully we can do so via a background thread rather than blocking.",
      "parentUuid": "61c68136_448f24da",
      "range": {
        "startLine": 106,
        "startChar": 49,
        "endLine": 106,
        "endChar": 81
      },
      "revId": "abcd71856d1c3f938d811398a1689442b1a7c3e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ed79ba9_191bf46e",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeApplication.java",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2018-01-24T18:04:23Z",
      "side": 1,
      "message": "I\u0027ll defer to Yaron as he\u0027s the owner, but I think passing in the a Callable is clearer than the Callback in your CL.  The check to see if it was init\u0027d by calling the callback seems scary to me.  I\u0027d prefer not to make methods reentrant if we can avoid it (especially if you wouldn\u0027t expect it to be at first glance).\n\nGranted, there is nothing to keep the Callable from doing the same, it just won\u0027t be the expected flow.",
      "parentUuid": "51fedb99_10d2070d",
      "range": {
        "startLine": 106,
        "startChar": 49,
        "endLine": 106,
        "endChar": 81
      },
      "revId": "abcd71856d1c3f938d811398a1689442b1a7c3e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0aa15df8_1ffcfc01",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ChromeApplication.java",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1126674
      },
      "writtenOn": "2018-01-24T19:40:39Z",
      "side": 1,
      "message": "I went to do that first, but then it wanted me to add try/catch since Callable throws Exception. Maybe worth just adding a new interface to base for NoThrowingCallable?",
      "parentUuid": "7ed79ba9_191bf46e",
      "range": {
        "startLine": 106,
        "startChar": 49,
        "endLine": 106,
        "endChar": 81
      },
      "revId": "abcd71856d1c3f938d811398a1689442b1a7c3e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}