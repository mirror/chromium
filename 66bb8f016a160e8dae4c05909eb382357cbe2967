{
  "comments": [
    {
      "key": {
        "uuid": "00b3e389_27f24457",
        "filename": "extensions/renderer/ipc_message_sender.cc",
        "patchSetId": 3
      },
      "lineNbr": 135,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "Are these last two reachable yet? If not, maybe they should be left NOTIMPLEMENTED() until the CL that adds usage and test coverage?",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1139f91c_518cc72c",
        "filename": "extensions/renderer/ipc_message_sender.cc",
        "patchSetId": 3
      },
      "lineNbr": 135,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-10-05T21:47:49Z",
      "side": 1,
      "message": "Test coverage of IPCSender is tricky.  I\u0027d like it to be a simple enough class that it\u0027s test coverage can be in the form of end-to-end browser tests, and then have unittests for the components calling into it.  The main reason is because certain things here (most specifically the RenderFrame) are very hard to mock in testing (read: I have no idea how to do it short of creating a new test class that inherits content::RenderFrame and implements all of its virtual methods).\n\nI\u0027m happy to remove these for now, if you prefer, but I don\u0027t know how much more unit test coverage we\u0027ll have later.",
      "parentUuid": "00b3e389_27f24457",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e701a1c_4c93328e",
        "filename": "extensions/renderer/ipc_message_sender.cc",
        "patchSetId": 3
      },
      "lineNbr": 135,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-05T22:03:45Z",
      "side": 1,
      "message": "Are they reachable in browser tests either yet? At the moment it didn\u0027t seem to me like this was reachable by any production or test code at all yet.",
      "parentUuid": "1139f91c_518cc72c",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59c2947d_6bb2b810",
        "filename": "extensions/renderer/ipc_message_sender.cc",
        "patchSetId": 3
      },
      "lineNbr": 135,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-10-05T22:40:00Z",
      "side": 1,
      "message": "Nope, they\u0027re not yet.  I can remove them.  Just trying to make future changes smaller. :)  But, I can see your point.  NOTIMPLEMENTED()\u0027ified.",
      "parentUuid": "0e701a1c_4c93328e",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a1145e09_06094dc4",
        "filename": "extensions/renderer/message_target.cc",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "nit: might be simpler to just have a private constructor that just takes the type and have these do the heavy lifting:\n\nMessageTarget MessageTarget::ForTab(int tab_id, int frame_id) {\n  MessageTarget target(TAB);\n  target.tab_id \u003d tab_id;\n  target.frame_id \u003d frame_id;\n  return target;\n}\n\nMakes the constructors below a little simpler (especially the slightly odd extension_id_or_app_name construct).",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "78c67d25_c5a98ba7",
        "filename": "extensions/renderer/message_target.cc",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-10-05T21:47:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a1145e09_06094dc4",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "11e92d87_4a7c096f",
        "filename": "extensions/renderer/message_target.h",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-10-04T20:31:59Z",
      "side": 1,
      "message": "I thought about having fun and using a union here, or going with a full class hierarchy (ExtensionMessageTarget, AppMessageTarget, TabMessageTarget), but both came out significantly over-architected.  This was far simpler, even though the \"valid only for TYPE::\" comments are a bit of a shame.",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0b02400_325d444d",
        "filename": "extensions/renderer/message_target.h",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "Oh, how I wish we had nice tagged-union types in C++, or at least std::variant. When we have variants, this could be something like:\n\nstruct ExtensionTarget { std::string id; };\nstruct NativeAppTarget { std::string name; };\nstruct TabTarget { int tab_id, frame_id; };\n// probably operator\u003d\u003d overloads, too, but meh\n\nusing MessageTarget \u003d std::variant\u003cExtensionTarget, NativeAppTarget, TabTarget\u003e;\n\nif (auto* extension \u003d std::get_if\u003cExtensionTarget\u003e(target))\n  DoSomethingWith(extension-\u003eid);\nelse if (auto* native_app \u003d std::get_if\u003cNativeAppTarget\u003e(target))\n  DoSomethingWith(native_app-\u003ename);\n// ...\n\nor, depending on call site, a use of std::visit.\n\nI\u0027m okay with this as-is.",
      "parentUuid": "11e92d87_4a7c096f",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11f8a4d2_87930cfd",
        "filename": "extensions/renderer/message_target.h",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "Oh, how I wish we had nice tagged-union types in C++, or at least std::variant. When we have variants, this could be something like:\n\nstruct ExtensionTarget { std::string id; };\nstruct NativeAppTarget { std::string name; };\nstruct TabTarget { int tab_id, frame_id; };\n// probably operator\u003d\u003d overloads, too, but meh\n\nusing MessageTarget \u003d std::variant\u003cExtensionTarget, NativeAppTarget, TabTarget\u003e;\n\nif (auto* extension \u003d std::get_if\u003cExtensionTarget\u003e(target))\n  DoSomethingWith(extension-\u003eid);\nelse if (auto* native_app \u003d std::get_if\u003cNativeAppTarget\u003e(target))\n  DoSomethingWith(native_app-\u003ename);\n// ...\n\nor, depending on call site, a use of std::visit.\n\nSince we don\u0027t, I\u0027m okay with this as-is.",
      "parentUuid": "11e92d87_4a7c096f",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5693ea0_8c2eb8f3",
        "filename": "extensions/renderer/message_target.h",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-10-05T21:47:49Z",
      "side": 1,
      "message": "One day, we\u0027ll be able to use all the nice C++ toys the other kids get. :)",
      "parentUuid": "a0b02400_325d444d",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}