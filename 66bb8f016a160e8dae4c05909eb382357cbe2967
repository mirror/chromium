{
  "comments": [
    {
      "key": {
        "uuid": "00b3e389_27f24457",
        "filename": "extensions/renderer/ipc_message_sender.cc",
        "patchSetId": 3
      },
      "lineNbr": 135,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "Are these last two reachable yet? If not, maybe they should be left NOTIMPLEMENTED() until the CL that adds usage and test coverage?",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1145e09_06094dc4",
        "filename": "extensions/renderer/message_target.cc",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "nit: might be simpler to just have a private constructor that just takes the type and have these do the heavy lifting:\n\nMessageTarget MessageTarget::ForTab(int tab_id, int frame_id) {\n  MessageTarget target(TAB);\n  target.tab_id \u003d tab_id;\n  target.frame_id \u003d frame_id;\n  return target;\n}\n\nMakes the constructors below a little simpler (especially the slightly odd extension_id_or_app_name construct).",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11e92d87_4a7c096f",
        "filename": "extensions/renderer/message_target.h",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-10-04T20:31:59Z",
      "side": 1,
      "message": "I thought about having fun and using a union here, or going with a full class hierarchy (ExtensionMessageTarget, AppMessageTarget, TabMessageTarget), but both came out significantly over-architected.  This was far simpler, even though the \"valid only for TYPE::\" comments are a bit of a shame.",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0b02400_325d444d",
        "filename": "extensions/renderer/message_target.h",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "Oh, how I wish we had nice tagged-union types in C++, or at least std::variant. When we have variants, this could be something like:\n\nstruct ExtensionTarget { std::string id; };\nstruct NativeAppTarget { std::string name; };\nstruct TabTarget { int tab_id, frame_id; };\n// probably operator\u003d\u003d overloads, too, but meh\n\nusing MessageTarget \u003d std::variant\u003cExtensionTarget, NativeAppTarget, TabTarget\u003e;\n\nif (auto* extension \u003d std::get_if\u003cExtensionTarget\u003e(target))\n  DoSomethingWith(extension-\u003eid);\nelse if (auto* native_app \u003d std::get_if\u003cNativeAppTarget\u003e(target))\n  DoSomethingWith(native_app-\u003ename);\n// ...\n\nor, depending on call site, a use of std::visit.\n\nI\u0027m okay with this as-is.",
      "parentUuid": "11e92d87_4a7c096f",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11f8a4d2_87930cfd",
        "filename": "extensions/renderer/message_target.h",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1002854
      },
      "writtenOn": "2017-10-04T21:07:20Z",
      "side": 1,
      "message": "Oh, how I wish we had nice tagged-union types in C++, or at least std::variant. When we have variants, this could be something like:\n\nstruct ExtensionTarget { std::string id; };\nstruct NativeAppTarget { std::string name; };\nstruct TabTarget { int tab_id, frame_id; };\n// probably operator\u003d\u003d overloads, too, but meh\n\nusing MessageTarget \u003d std::variant\u003cExtensionTarget, NativeAppTarget, TabTarget\u003e;\n\nif (auto* extension \u003d std::get_if\u003cExtensionTarget\u003e(target))\n  DoSomethingWith(extension-\u003eid);\nelse if (auto* native_app \u003d std::get_if\u003cNativeAppTarget\u003e(target))\n  DoSomethingWith(native_app-\u003ename);\n// ...\n\nor, depending on call site, a use of std::visit.\n\nSince we don\u0027t, I\u0027m okay with this as-is.",
      "parentUuid": "11e92d87_4a7c096f",
      "revId": "66bb8f016a160e8dae4c05909eb382357cbe2967",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}