{
  "comments": [
    {
      "key": {
        "uuid": "7d612748_7fb73860",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 198,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-08-23T19:01:40Z",
      "side": 1,
      "message": "nit: inline the unicode string with hebrew characters, like this:\n// show the character position. For example, the bi-directional logical string\n// \"abc+\\x05d0\\x05d1\\x05d2\" (visual string \"abc+◊ê◊ë◊í\") yields \"[0-\u003e2][3][6\u003c-4]\".",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0cc41137_53cf88b8",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 198,
      "author": {
        "id": 1115963
      },
      "writtenOn": "2017-08-24T00:52:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7d612748_7fb73860",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "09481c55_5687d61d",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 200,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-08-23T19:01:40Z",
      "side": 1,
      "message": "All callers pass in the GetHarfBuzzRunList() result. Maybe make this a RenderTextTest class member function near GetRuns() that starts like:\n  std::string GetRunListDebugString() {\n     const internal::TextRunList* run_list \u003d GetHarfBuzzRunList();",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3590251f_fff1e067",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 200,
      "author": {
        "id": 1115963
      },
      "writtenOn": "2017-08-24T00:52:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "09481c55_5687d61d",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "72568f06_6d66588f",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-08-23T19:01:40Z",
      "side": 1,
      "message": "aside: GetRuns and ToString16Vec are also pretty nice.",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74100616_646a86a2",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1115963
      },
      "writtenOn": "2017-08-24T00:52:12Z",
      "side": 1,
      "message": "Oh, I didn\u0027t actually notice what that line was doing. Do you think I should remove the following line then? (It\u0027s kind of redundant.)\n\nTechnically these are testing slightly different code paths; GetRuns uses GetFontSpansForTesting, which conditionally uses UTF16OffsetToIndex and apparently in this case that does nothing (from my brief testing); ultimately this just returns the run ranges. The only thing RunListDebugString adds is testing reordering due to RTL characters (as well as showing the directionality of the runs), which is important in the above tests, but not here.\n\nThe previous code that explicitly tests the 3 ranges doesn\u0027t actually test anything that GetRuns() isn\u0027t testing.\n\nOh well, leaving this for now, since redundancy doesn\u0027t hurt in a test.",
      "parentUuid": "72568f06_6d66588f",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1dcd8672_dcadd3db",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-08-24T06:05:01Z",
      "side": 1,
      "message": "There\u0027s no harm in slightly redundant testing of run content and run structure. Leave both, but consider renaming your new function to GetRun[Structure|Layout|Info] or similar, to call attention to the similarity to GetRuns. (or rename GetRuns?)\n\nGetFontSpansForTesting has a RenderTextMac implementation, whereas GetHarfBuzzRunList is (obviously) exclusive to RenderTextHarfBuzz. Maybe your helper should support Mac, but that\u0027s being deprecated for HarfBuzz on Mac, and you\u0027re only using it HarfBuzz fixtures anyway, so it\u0027s not imperative.\n\nFYI, I forget the precise terminology, but UTF16OffsetToIndex and UTF16IndexToOffset are used to handle index conversions around multi-character glyphs, like surrogate pairs. I\u0027m not quite sure how that comes into play here, since runs seem to simply use logical character indices, disregarding code point positions.",
      "parentUuid": "74100616_646a86a2",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4033f5fb_c2908ba2",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1115963
      },
      "writtenOn": "2017-08-24T06:49:30Z",
      "side": 1,
      "message": "OK renamed them both.\n\n\u003e FYI, I forget the precise terminology, but UTF16OffsetToIndex and UTF16IndexToOffset are used to handle index conversions around multi-character glyphs, like surrogate pairs.\n\nYes, sorry I didn\u0027t go into much detail but I checked it out and ran some tests. UTF16OffsetToIndex does indeed convert code unit index to code point index (it would be best if it was named that way), which means in the case of \"xüòÅy‚ú®\" it should convert 0-\u003e0, 1-\u003e1, 2-\u003e1, 3-\u003e2, etc. It seems that DisplayIndexToTextIndex for some reason only calls UTF16OffsetToIndex if the text is \"obscured\"; if it isn\u0027t, it returns code unit indices. And this text is not \"obscured\". GetRuns assumes that it\u0027s dealing with code unit indices, so everything works out fine here, if you totally ignore the call to UTF16OffsetToIndex. I don\u0027t know why this is all the case, so I decided to ignore it.",
      "parentUuid": "1dcd8672_dcadd3db",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f6f132b_7c7d4480",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1115963
      },
      "writtenOn": "2017-08-24T06:49:53Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4033f5fb_c2908ba2",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4b63aeaa_40a6be7f",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-08-24T14:26:03Z",
      "side": 1,
      "message": "Just for more context, obscured\u003d\u003dpassword, and that\u0027s treated differently (iirc) because we paint an asterisk or bullet for each code unit, even if multiple code units would comprise a single code point in unobscured (plain) display text. (ie. we approximately want to paint an asterisk for each key pressed, so (eg.) an accent \u0027¬¥\u0027 that would normally change a neighboring glyph renders as a separate \u0027*\u0027 instead of invisibly altering a existing asterisk\u0027s underlying value from \u0027e\u0027 to \u0027√©\u0027).",
      "parentUuid": "4f6f132b_7c7d4480",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "26a2979a_0b4296a6",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1115963
      },
      "writtenOn": "2017-08-25T01:24:36Z",
      "side": 1,
      "message": "Ah that makes sense (I didn\u0027t know what obscured meant).\n\nMinor correction: your \"eÃÅ\" example is actually considered 2 characters (2 asterisks) in a password field in Chrome. This code doesn\u0027t collapse combining character sequences (multiple code points), only surrogate pairs (single code point).\n\nA code point is a combination of one or more code units (e.g., U+1F601 is comprised of D83D,DE01 in UTF-16), while a combining character sequence is a combination of one or more code points (e.g., eÃÅ is comprised of U+0065,U+0301). So if you enter \"üòÅ\" into a password field (I\u0027m testing with HTTP basic authentication --- the only password field I can find that uses RenderText as opposed to Blink), it shows as a single \"*\". But if you enter \"eÃÅ\", it shows as \"**\". Not sure if this is intended, but I think it\u0027s reasonable behaviour. The actual display of asterisks, and this run breaking logic, are internally consistent.\n\nCuriously, I just noticed that when using a *web* password field (i.e., rendered by Blink, not RenderText), it does actually show a bullet for each *UTF-16 code unit* (not code point) --- it doesn\u0027t correctly count characters. I filed a bug: https://crbug.com/758794.",
      "parentUuid": "4b63aeaa_40a6be7f",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ae5283d1_43e194cf",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3725,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-08-25T14:35:19Z",
      "side": 1,
      "message": "Cool, thanks for the explanation and filing the Blink bug.",
      "parentUuid": "26a2979a_0b4296a6",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f78a1207_6cd2fcfe",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3744,
      "author": {
        "id": 1001118
      },
      "writtenOn": "2017-08-23T19:01:40Z",
      "side": 1,
      "message": "nit: one-liner like line 3757: \" // U+1F601 is represented as a surrogate pair in UTF-16.\"",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8eeb55e_257d1c8f",
        "filename": "ui/gfx/render_text_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 3744,
      "author": {
        "id": 1115963
      },
      "writtenOn": "2017-08-24T00:52:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f78a1207_6cd2fcfe",
      "revId": "36ef7a12161d525d8294a93315fc2f1bb8e33600",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}