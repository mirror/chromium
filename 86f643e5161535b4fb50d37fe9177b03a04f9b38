{
  "comments": [
    {
      "key": {
        "uuid": "213ba328_254a867c",
        "filename": "content/browser/service_manager/service_manager_context.cc",
        "patchSetId": 8
      },
      "lineNbr": 482,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-12-18T18:34:21Z",
      "side": 1,
      "message": "Just curious, does the service need to be running on its own thread? We already have a dedicated thread for the underlying video capture. Would it avoid the issue in EmbeddedInstanceManager if the service is not using its own thread?",
      "range": {
        "startLine": 482,
        "startChar": 40,
        "endLine": 482,
        "endChar": 44
      },
      "revId": "86f643e5161535b4fb50d37fe9177b03a04f9b38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e335c30_9a69518f",
        "filename": "content/browser/service_manager/service_manager_context.cc",
        "patchSetId": 8
      },
      "lineNbr": 482,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-12-18T19:19:29Z",
      "side": 1,
      "message": "I am not sure. It might work.\nWhich exact thread are you referring to that we already have for the underlying video capture?\n\nIn the pre-service legacy code path of video capture, on Android and Linux, we were using a thread from the audio manager to run the equivalent code. I thought about using that one here, too, but I did not see an easy way to plumb access to a corresponding TaskRunner from the code that knows the audio manager to this location here.",
      "parentUuid": "213ba328_254a867c",
      "range": {
        "startLine": 482,
        "startChar": 40,
        "endLine": 482,
        "endChar": 44
      },
      "revId": "86f643e5161535b4fb50d37fe9177b03a04f9b38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d61231c_04709fdb",
        "filename": "content/browser/service_manager/service_manager_context.cc",
        "patchSetId": 8
      },
      "lineNbr": 482,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-12-18T20:49:47Z",
      "side": 1,
      "message": "I was actually referring to the \"driver\" layer code for the underlying video capture, for example, https://cs.corp.google.com/eureka_internal/chromium/src/media/capture/video/linux/video_capture_device_linux.cc?l\u003d41. My thinking is that the service code is fairly lightweight, so maybe it can just run on the thread that the service is created on (https://cs.corp.google.com/eureka_internal/chromium/src/services/service_manager/embedder/embedded_instance_manager.cc?l\u003d28), to avoid threading issues.\n\nI don\u0027t know enough to know if that would work or not :)",
      "parentUuid": "9e335c30_9a69518f",
      "range": {
        "startLine": 482,
        "startChar": 40,
        "endLine": 482,
        "endChar": 44
      },
      "revId": "86f643e5161535b4fb50d37fe9177b03a04f9b38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70079f3b_a8202e82",
        "filename": "content/browser/service_manager/service_manager_context.cc",
        "patchSetId": 8
      },
      "lineNbr": 482,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-12-18T21:36:01Z",
      "side": 1,
      "message": "It is true that most of the service code is fairly lightweight. I think the thread that the service gets created on in the Browser process when not choosing a dedicated thread or task runner is the \"IO\" thread.\n\nUnfortunately, some implementations, e.g. the one for Linux, do blocking file IO, e.g. when enumerating devices, and this is not allowed on the IO thread. In theory, we could try to find all such blocking calls and refactor things to move them to background tasks. But this would require some API changes at the level of media::VideoCaptureDeviceFactory, where currently all the methods have synchronous signatures.\n\nIt seems the assumption for all implementations of media::VideoCaptureDeviceFactory was that they are allowed to do blocking operations, so it might be quite a bit of work to change that. I was going to shy away from that and go with a dedicated thread instead.",
      "parentUuid": "8d61231c_04709fdb",
      "range": {
        "startLine": 482,
        "startChar": 40,
        "endLine": 482,
        "endChar": 44
      },
      "revId": "86f643e5161535b4fb50d37fe9177b03a04f9b38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3abcdcbe_afee9c7a",
        "filename": "services/service_manager/embedder/embedded_instance_manager.cc",
        "patchSetId": 8
      },
      "lineNbr": 121,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-12-08T00:51:48Z",
      "side": 1,
      "message": "I do not think this is OK. This does not necessarily only happen at (and in fact almost certainly does happen at times other than) process shutdown. We should join the thread from a blocking background task instead. That should be easy enough to implement.",
      "revId": "86f643e5161535b4fb50d37fe9177b03a04f9b38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0edd1972_90ef2dcc",
        "filename": "services/video_capture/service_impl.cc",
        "patchSetId": 8
      },
      "lineNbr": 26,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-12-18T18:34:21Z",
      "side": 1,
      "message": "std::make_unique",
      "range": {
        "startLine": 26,
        "startChar": 9,
        "endLine": 26,
        "endChar": 25
      },
      "revId": "86f643e5161535b4fb50d37fe9177b03a04f9b38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}