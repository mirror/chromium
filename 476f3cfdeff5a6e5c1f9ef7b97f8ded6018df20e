{
  "comments": [
    {
      "key": {
        "uuid": "9eacc13a_a646085d",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 116,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "Chrome needs this behavior, or has to emulate it using virtual contexts (or explicit synchronization, but it doesn\u0027t do that today) to ensure security.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49a96427_754708bb",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 116,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9eacc13a_a646085d",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4c3657c5_d4fb4960",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 133,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "Be careful, \"stream\" is an overloaded term here, and so this is not really true.\n\nAn IPC channel has multiple \"streams\", each of which has multiple command buffers. Command buffers in the same share group must be in the same stream. A stream is the granularity of scheduling.\n\nMultiple command buffers within the same stream can use an ordering barrier to order their commands, but command buffers in different streams need a sync token. If the 2 streams are on the same IPC channel (i.e. same client process), they can use unverified sync tokens, but if they are on different channels, the token needs to be verified.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6656588_060cd1fb",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 133,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Thank you for the explanation! I\u0027ve updated and expanded the text. Can you sanity check that I got it right? (FWIW, one reason for me to write this was that I couldn\u0027t find a clear explanation in existing docs and was unclear on it myself.)",
      "parentUuid": "4c3657c5_d4fb4960",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5e669858_122691b3",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 133,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "\u003e Thank you for the explanation! I\u0027ve updated and expanded the text. Can you sanity check that I got it right?\n\nThanks! Looks mostly right, added a couple of nits below.\n\n\u003e (FWIW, one reason for me to write this was that I couldn\u0027t find a clear explanation in existing docs and was unclear on it myself.)\n\nThanks a ton for writing this up!",
      "parentUuid": "b6656588_060cd1fb",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f72edf4_27329bb0",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 133,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "5e669858_122691b3",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d786a00f_4c944926",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 173,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "note: this is on Mac, which guarantees that glFlush is sufficient to ensure ordering.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97fbc2ea_1493357a",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 173,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done, and added a note on the performance cost of glFlush on tiling GPUs. (I don\u0027t think we\u0027d want this approach on phone EGL.)",
      "parentUuid": "d786a00f_4c944926",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a0fb1987_e8928ea6",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 189,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "GLX effectively ensures this. On Windows we use ANGLE, which also uses a single D3D device underneath all contexts, ensuring strong ordering.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77ad77d2_f7e6db50",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 46
      },
      "lineNbr": 189,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a0fb1987_e8928ea6",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4c0b3cc9_97766fba",
        "filename": "gpu/GLES2/extensions/CHROMIUM/CHROMIUM_fence.txt",
        "patchSetId": 46
      },
      "lineNbr": 3,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2017-11-17T19:04:07Z",
      "side": 1,
      "message": "Can you rename this file to CHROMIUM_gpu_fence to match the extension name?",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 22
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0707358_2698ec51",
        "filename": "gpu/GLES2/extensions/CHROMIUM/CHROMIUM_fence.txt",
        "patchSetId": 46
      },
      "lineNbr": 3,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done, now using CHROMIUM_gpu_fence everywhere.\n\nreveman@ had originally requested that I rename the extension to CHROMIUM_fence, but I think this got very confusing in documentation since CHROMIUM_sync_point already uses the name \"fence sync\".",
      "parentUuid": "4c0b3cc9_97766fba",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 22
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6f460ad0_63af0d17",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 419,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "Where is this id destroyed? Shouldn\u0027t DestroyGpuFenceCHROMIUM do that?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2eaa98e_45845198",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 419,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Added, I was using the wrong build type which had bypassed this.",
      "parentUuid": "6f460ad0_63af0d17",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d732c1c_001810dd",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 419,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "FYI, I\u0027ve added a ShallowFlushCHROMIUM here also to help ensure that a GetGpuFenceHandle will (eventually) succeed even if the caller forgets to flush.",
      "parentUuid": "d2eaa98e_45845198",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "101329cf_053fd5ea",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "If we fix DestroyGpuFenceCHROMIUM, we have to be careful around reuse, though, otherwise with the following sequence:\n\nGLuint fence \u003d gl-\u003eInsertGpuFenceCHROMIUM();\ngl-\u003eDestroyGpuFenceCHROMIUM(fence);\n// ...\nGLuint fence \u003d gl-\u003eInsertClientGpuFenceCHROMIUM(client_fence);\n\nThe value for fence could be reused, and the SendGpuFence might arrive to the service before DestroyGpuFenceCHROMIUM is handled, which will not behave as you would expect.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5611231_74df620a",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "I\u0027ve changed it to use GetIdAllocator(IdNamespaces::kGpuFences)-\u003eAllocateIDAtOrAbove(last_gpu_fence_id_ + 1) which should prevent recycling of frame IDs. It\u0027ll wrap once it\u0027s allocated 2^32 of them which should be ok for a per-command-buffer counter.",
      "parentUuid": "101329cf_053fd5ea",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b2c273df_756aaef1",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "A good rule-of-thumb to decide if it\u0027s enough is imagining the worst case of a browser submitting frames continuously for the duration of a full stable release (i.e. up to 8 weeks). How many fences do you expect to create per frame? If more than 15, then it could wrap (15*60*86400*56 \u003e 2^32). Otherwise, that seems fine, in which case we should add a CHECK that we don\u0027t wrap (explicitly crashing is better than random corruption).",
      "parentUuid": "d5611231_74df620a",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d520f793_3a651039",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Currently it\u0027s two fences per frame, so that should be fine. It should also deal with wraparound in normal use. A collision would require that someone intentionally hangs on to an old fence for weeks while waiting for the wraparound to happen, and even in that case the effects don\u0027t seem very bad - I think it would just cause tearing on a frame due to bad sync or potentially a GL error, but not memory corruption. Unless I\u0027m missing something, a wrap prevention CHECK seems like overkill.",
      "parentUuid": "b2c273df_756aaef1",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd1352a5_0e4c252e",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T22:05:44Z",
      "side": 1,
      "message": "Sorry, I\u0027ve removed the flush in InsertClientGpuFenceCHROMIUM again, it was a major performance hit. (Drop from ~52fps to ~44fps in a synthetic WebVR example.) Let me know if you still think this is a risk beyond occasional tearing frames if intentionally misused.",
      "parentUuid": "d520f793_3a651039",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dd3ccd4e_94b307f8",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T01:02:34Z",
      "side": 1,
      "message": "I think I\u0027d prefer a clear CHECK so that:\n1- we don\u0027t have to make incorrect assumptions all over the code, possibly causing (if not now, maybe in the future) security issues\n2- we don\u0027t have to debug a very strange bug that takes months to reproduce\n3- we\u0027ll get crash reports if we messed up our estimate assumptions.",
      "parentUuid": "cd1352a5_0e4c252e",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f45a1e4_fda8853c",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-29T06:35:43Z",
      "side": 1,
      "message": "Added a CHECK, but I\u0027m still not convinced that it\u0027s necessary. In this scenario:\n\nGLuint fence1 \u003d gl-\u003eInsertGpuFenceCHROMIUM();\ngl-\u003eDestroyGpuFenceCHROMIUM(fence1);\n// ...\nGLuint fence2 \u003d gl-\u003eInsertClientGpuFenceCHROMIUM(client_fence);\n\nthe potential concern was that a SendGpuFence might arrive at the service before DestroyGpuFenceCHROMIUM is handled.\n\nHowever, now that it\u0027s allocating IDs sequentially, it looks as if the only way for fence1 and fence2 to be equal is if there are 2^32-1 intervening Insert/Delete calls so that fence2 ends up equal to fence1 after wraparound, but the Destroy(fence1) still hasn\u0027t been executed yet. Would the command buffer even support keeping that many commands queued and unflushed?",
      "parentUuid": "dd3ccd4e_94b307f8",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee79c452_d1b96c51",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 435,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T20:52:22Z",
      "side": 1,
      "message": "\u003e Added a CHECK, but I\u0027m still not convinced that it\u0027s necessary. In this scenario:\n\u003e \n\u003e GLuint fence1 \u003d gl-\u003eInsertGpuFenceCHROMIUM();\n\u003e gl-\u003eDestroyGpuFenceCHROMIUM(fence1);\n\u003e // ...\n\u003e GLuint fence2 \u003d gl-\u003eInsertClientGpuFenceCHROMIUM(client_fence);\n\u003e \n\u003e the potential concern was that a SendGpuFence might arrive at the service before DestroyGpuFenceCHROMIUM is handled.\n\u003e \n\u003e However, now that it\u0027s allocating IDs sequentially, it looks as if the only way for fence1 and fence2 to be equal is if there are 2^32-1 intervening Insert/Delete calls so that fence2 ends up equal to fence1 after wraparound, but the Destroy(fence1) still hasn\u0027t been executed yet. Would the command buffer even support keeping that many commands queued and unflushed?\n\nIf you move your \"//...\" to before the DestroyGpuFenceCHROMIUM maybe it makes it clearer why this could happen after a wrap? Nothing says/guarantees fences are created\u0026destroyed in order.",
      "parentUuid": "9f45a1e4_fda8853c",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5b1e294e_b870ce42",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 445,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "This sends an IPC out-of-order. Which means you could pick up the handle from a previous fence that used the same id. I think you should instead do a shallow flush to ensure IPC ordering, which would eliminate a bunch of the complex/problematic tracking code on the service side - the request for the handle would always arrive after the fence is created.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9c6c4d1_12ed70e7",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 445,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "What do you think of the new approach which avoids recycling? I\u0027d prefer to avoid adding extra flushes to reduce the IPCs needed. A shallow flush wouldn\u0027t remove the need for service side tracking since the callback can only be run after the actual fence got created, and that would only happen on a full flush.",
      "parentUuid": "5b1e294e_b870ce42",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed7f5b3b_6dd03cf7",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 445,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "ShallowFlush would be enough to create the fence. Otherwise you\u0027d have an issue anyway because you run the callbacks on the glInsert(Client)GpuFenceCHROMIUM command execution (which is what calls GpuFenceManager::CreateNewGpuFence), not on the next glFlush command.\nSince the GLFence creation explicitly calls glFlush, there\u0027s no need for a full flush.\n\nEither way, avoiding extra IPCs seems fine if we want to pay for the complexity (and assuming it\u0027s safe, see above), but I would recommend documenting on GpuControl that this happens out-of-order wrt commands, because it is the exception rather than the rule, as well as documenting the interaction with the reuse avoidance, and maybe writing a test, because this could break on a refactor.",
      "parentUuid": "f9c6c4d1_12ed70e7",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "973617a7_3ab6efee",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 46
      },
      "lineNbr": 445,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "You\u0027ve convinced me, I\u0027ve added a ShallowFlushCHROMIUM here to avoid surprises.",
      "parentUuid": "ed7f5b3b_6dd03cf7",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "78f6881a_03979661",
        "filename": "gpu/command_buffer/common/gles2_cmd_format.h",
        "patchSetId": 46
      },
      "lineNbr": 43,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "Did you mean gpu fence ids to be shared across context groups? This is inconsistent with the fact that the GLES2DecoderImpl owns the GpuFenceManager - it should be owned by the ContextGroup instead. Alternatively, move kGpuFences to IdNamespaces below.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3bdd2112_071e21c8",
        "filename": "gpu/command_buffer/common/gles2_cmd_format.h",
        "patchSetId": 46
      },
      "lineNbr": 43,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Moved to IdNamespaces.",
      "parentUuid": "78f6881a_03979661",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2f8ea916_75d62d47",
        "filename": "gpu/command_buffer/common/gles2_cmd_format.h",
        "patchSetId": 46
      },
      "lineNbr": 71,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "typo: \"kGpuFences should equal 6\"",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b8d0b33_71496f66",
        "filename": "gpu/command_buffer/common/gles2_cmd_format.h",
        "patchSetId": 46
      },
      "lineNbr": 71,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done (It is now 4.)",
      "parentUuid": "2f8ea916_75d62d47",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "12a23b93_f615a8c9",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 46
      },
      "lineNbr": 5156,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "This DCHECK is not valid, because a compromised renderer could send arbitrary ids.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa5dc491_74b3a349",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 46
      },
      "lineNbr": 5156,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "I\u0027ve changed this to return kInvalidArguments instead, and generally updated the related code to use an error status instead of DCHECK for cases of API misuse by clients.",
      "parentUuid": "12a23b93_f615a8c9",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "69966bed_3d6e4202",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 46
      },
      "lineNbr": 5161,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "ditto",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ee56d4e_ad526bd1",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 46
      },
      "lineNbr": 5161,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "69966bed_3d6e4202",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e83746b7_6a22ebd9",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc",
        "patchSetId": 46
      },
      "lineNbr": 4634,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2017-11-20T16:49:04Z",
      "side": 1,
      "message": "Can you please implement these too?  This command decoder is now used by 50% of our Canary users on Windows (dev/beta soon too)",
      "range": {
        "startLine": 4634,
        "startChar": 2,
        "endLine": 4634,
        "endChar": 19
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e51736fd_e2caaa92",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc",
        "patchSetId": 46
      },
      "lineNbr": 4634,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done. FYI, this likely wouldn\u0027t work right on Android/Adreno as-is due to that currently requiring virtualized contexts as per driver blacklist, but that\u0027s a separate issue.",
      "parentUuid": "e83746b7_6a22ebd9",
      "range": {
        "startLine": 4634,
        "startChar": 2,
        "endLine": 4634,
        "endChar": 19
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "93c7ddd4_1041a8bd",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 48,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "It sounds like all the new commands need to be gated on gl::GLFence::IsGpuFenceSupported().\n\nThe best/normal way to do this is:\n- add a bool to FeatureFlags\n- use \u0027extension_flag\u0027 in  gpu/command_buffer/build_gles2_cmd_buffer.py\n- set the bool as appropriate from FeatureInfo::InitializeFeatures. Also add the extension string when enabling\n- (optional, but recommended): add a bool to gpu::Capabilities (don\u0027t forget to add it to gpu/ipc/common/gpu_command_buffer_traits_multi.h), and set this flag from the FeatureFlags value in GLES2DecoderImpl::GetCapabilities()",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8225fe3_c4760710",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 48,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done, including gpu::Capabilities.",
      "parentUuid": "93c7ddd4_1041a8bd",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5609ec38_dc037709",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 55,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "What makes this true? Can\u0027t a malicious client call InsertGpuFenceINTERNAL(id) twice in a row with the same id?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88c58811_c5791708",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 55,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Replaced with a \"bool success\" return, and it now forces a context loss in gpu_command_buffer_stub\u0027s OnSendGpuFenceHandle if it fails. (That\u0027s a bit harsh, but this shouldn\u0027t happen unless there\u0027s a logic bug or compromised client.)",
      "parentUuid": "5609ec38_dc037709",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7edb704_7a83b08f",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 107,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "Should this raise a GL error?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03ac192f_5008867d",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 107,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b7edb704_7a83b08f",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4f13f7e8_8c8d9347",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 112,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "Should this raise a GL error?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b53a3fc5_c5420545",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 112,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4f13f7e8_8c8d9347",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "934f71bf_c350a3c5",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 123,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "nit: the whole thing can be gpu_fence_entries_.erase(client_id);",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ccf775e5_d8c424eb",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 123,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "934f71bf_c350a3c5",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3ad80863_04ba375a",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 123,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "I don\u0027t see it :)\nYou can do \u0027return gpu_fence_entries_.erase(client_id) \u003d\u003d 1u;\u0027 to return success.",
      "parentUuid": "ccf775e5_d8c424eb",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d4323e3b_ab631813",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 123,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Ah, I had the 1-liner when I wrote \"Done\", then reverted that later when adding the bool return. Changed as suggested, I wasn\u0027t aware of the \"size_t erase(key)\" variant.",
      "parentUuid": "3ad80863_04ba375a",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b068400c_ae551e45",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 127,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "If have_context is false, we should Invalidate all the GLFences. It may not necessarily matter for GLFenceEGL ones, but all other types are context-specific.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9da513d_c40118ae",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.cc",
        "patchSetId": 46
      },
      "lineNbr": 127,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done, this required implementing GLFenceEGL::Invalidate().",
      "parentUuid": "b068400c_ae551e45",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cf93a37b_2cc45f82",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 46
      },
      "lineNbr": 43,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "nit: DISALLOW_COPY_AND_ASSIGN",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "765b563b_65844557",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 46
      },
      "lineNbr": 43,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cf93a37b_2cc45f82",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10fed049_582ce43c",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 46
      },
      "lineNbr": 70,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "nit: would it make sense to make GpuFenceEntry movable, and make this a flat_map\u003cuint32_t, GpuFenceEntry\u003e ?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e63871f5_eeb7473c",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 46
      },
      "lineNbr": 70,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "If I understand it right, flat_map is most efficient if it contains simple data types. While GpuFenceEntry has just two elements, one of them is itself a vector, and having those moved around as part of map insert/delete sounds inefficient, though it may not matter much in practice. I\u0027d prefer to keep the pointer indirection unless you feel strongly about it.",
      "parentUuid": "10fed049_582ce43c",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c2a6d623_943a4ee9",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 46
      },
      "lineNbr": 70,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "I suppose it depends if you do more insert/erase operations or lookups. Moving GpuFenceEntry is just copying 4 pointers instead of 1 with the indirection, but you gain the allocation costs (time \u0026 memory overhead) and the cache effects of the indirection.",
      "parentUuid": "e63871f5_eeb7473c",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcdc14bd_9ba2dca0",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 46
      },
      "lineNbr": 70,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "These are typically only used once or twice after insertion, typically for either ServerWait or callback handling. Keeping as the unique_ptr map for now. In any case, this should not be performance critical in normal use.",
      "parentUuid": "c2a6d623_943a4ee9",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cdd4d701_24263b92",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 46
      },
      "lineNbr": 990,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "Should this be a TODO?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2601921b_458165c2",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 46
      },
      "lineNbr": 990,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "I\u0027ve implemented it instead of making it a TODO :-)",
      "parentUuid": "cdd4d701_24263b92",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "231daa97_2e892f53",
        "filename": "ui/gfx/gpu_fence_handle.h",
        "patchSetId": 46
      },
      "lineNbr": 26,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "nit: also add operator\u003d (rule-of-3)",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff688ba2_fbc30f9a",
        "filename": "ui/gfx/gpu_fence_handle.h",
        "patchSetId": 46
      },
      "lineNbr": 26,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "231daa97_2e892f53",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "666dc4ee_ad283041",
        "filename": "ui/gl/gl_fence.cc",
        "patchSetId": 46
      },
      "lineNbr": 111,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "nit: isn\u0027t this NOTREACHED()? Clarifying because otherwise upstream code needs to handle the case.\n\nother nit: return nullptr;\nfallthrough from inside an ifdef is not very readable.",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "946efe64_d4e82aec",
        "filename": "ui/gl/gl_fence.cc",
        "patchSetId": 46
      },
      "lineNbr": 111,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done, using NOTREACHED.",
      "parentUuid": "666dc4ee_ad283041",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a649a00b_c9df928a",
        "filename": "ui/gl/gl_fence.h",
        "patchSetId": 46
      },
      "lineNbr": 16,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-28T16:02:10Z",
      "side": 1,
      "message": "this inheritance doesn\u0027t make sense to me. why is this needed?",
      "range": {
        "startLine": 16,
        "startChar": 24,
        "endLine": 16,
        "endChar": 46
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5afc82c_9248ad2f",
        "filename": "ui/gl/gl_fence.h",
        "patchSetId": 46
      },
      "lineNbr": 16,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T19:52:55Z",
      "side": 1,
      "message": "gfx::GpuFence is an interface class consisting of the GetGpuFenceHandle and AsClientGpuFence methods. A class that implements this interface is compatible with the CHROMIUM_gpu_fence mechanism, and a GpuFence object owns the resources backing a GpuFenceHandle and is responsible for cleaning them up.\n\nThe caller uses AsClientGpuFence for the InsertClientGpuFenceCHROMIUM argument, and the implementation will then use GetGpuFenceHandle on the underlying object for IPC transport.\n\nWe\u0027ve been through multiple variations of this in the course of the review, and this is-a implementation seemed cleanest overall.\n\nBasically, the choices are:\n\n- the current implementation: GLFence is-a GpuFence since it\u0027s basically directly usable as a ClientGpuFence for the API.\n\n- don\u0027t have a GpuFence class at all, and work with GpuFenceHandle directly throughout the API. This could work, but would make resource ownership rather nasty. GpuFenceHandle is copyable, but the underlying resource (file descriptor in this case) must be closed exactly once.\n\n- make GpuFence a pure container that owns a GpuFenceHandle. I had this implemented in PS42, see https://chromium-review.googlesource.com/c/chromium/src/+/680135/42/ui/gfx/gpu_fence.h and https://chromium-review.googlesource.com/c/chromium/src/+/680135/42/ui/gl/gl_fence.h . This was rather confusing since a GLFence conceptually owns the resource, so in this implementation GLFence::GetGpuFenceHandle passed ownership to the caller. The resulting code in https://chromium-review.googlesource.com/c/chromium/src/+/680135/42/docs/design/gpu_synchronization.md looked weird, where the \"send fence\" case needed to create a GLFence using a special CreateForGpuFence method and then use the GpuFenceHandle from it to construct a GpuFence. In review you had requested that I should rename CreateForGpuFence to CreateGpuFence which I think is evidence that it\u0027s a confusing API - this kind of GLFence isn\u0027t a GpuFence, just a specially constructed GLFence that can be used to create a GpuFence.\n\n- have GpuFence own a GLFence. This seems like a layering violation unless we make a EGLGpuFence subclass just for this purpose, and would involve a fair amount of boilerplate since we\u0027d need a GetUnderlyingGLFence method.\n\nI\u0027d be happy to discuss this more, but I think this seems to be the cleanest approach so far.",
      "parentUuid": "a649a00b_c9df928a",
      "range": {
        "startLine": 16,
        "startChar": 24,
        "endLine": 16,
        "endChar": 46
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c51b9197_ac094881",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 27,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "nit: maybe just use base::WrapUnique(new GLFenceAndroidNativeFenceSyncHelper()) ?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c2bad76_69d2a60f",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 27,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done, using base::WrapUnique(new GLFenceAndroidNativeFenceSync()) to avoid the need for the helper class.",
      "parentUuid": "c51b9197_ac094881",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0c3cdb82_2e84bfb5",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 27,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-28T16:02:10Z",
      "side": 1,
      "message": "this is an unusual pattern. why not make the ctor protected instead?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3033f69_9bb7bf42",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 27,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T19:52:55Z",
      "side": 1,
      "message": "MakeUnique can only use a public constructor, protected would still not work. I changed it to use WrapUnique at piman@\u0027s suggestion which works with a private constructor and doesn\u0027t need the helper class.",
      "parentUuid": "0c3cdb82_2e84bfb5",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a227ffa7_a79e006b",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 35,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-28T16:02:10Z",
      "side": 1,
      "message": "nit:\n\nif (!fence-\u003eInitialize(type, attribs))\n  return nullptr;\nreturn fence;",
      "range": {
        "startLine": 32,
        "startChar": 2,
        "endLine": 35,
        "endChar": 17
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a359428b_87695daf",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 35,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T19:52:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a227ffa7_a79e006b",
      "range": {
        "startLine": 32,
        "startChar": 2,
        "endLine": 35,
        "endChar": 17
      },
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "882c984e_f424ad91",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 44,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-28T16:02:10Z",
      "side": 1,
      "message": "why do this here? and not just in GetGpuFenceHandle and remove code here and in GetGpuFenceHandle?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84e614fd_b901f7ec",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 44,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T19:52:55Z",
      "side": 1,
      "message": "See the comment I added to gl_fence_android_native_fence_sync.h\u0027s owned_fd_ member. It\u0027s to avoid making EGL calls as part of command buffer IPC transport internals.",
      "parentUuid": "882c984e_f424ad91",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c8426c30_f0af76f3",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 59,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "It sounds like CreateInternal can fail. What makes this DCHECK valid? Do we need to handle failure at the call sites?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d48b329_0e47f238",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 46
      },
      "lineNbr": 59,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Yes, it can fail, i.e. if the file descriptor is invalid. I\u0027ve removed the DCHECK here and replaced a DCHECK in GpuFenceManager with an error return.",
      "parentUuid": "c8426c30_f0af76f3",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ec6772f8_8e421a20",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.h",
        "patchSetId": 46
      },
      "lineNbr": 29,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-28T16:02:10Z",
      "side": 1,
      "message": "why do we need this when we have a Initialize function for the what seems like the same purpose?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4cafb8e_d24feb24",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.h",
        "patchSetId": 46
      },
      "lineNbr": 29,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T19:52:55Z",
      "side": 1,
      "message": "I\u0027ve renamed the protected GLFenceEGL::Initialize to InitializeInternal to try to make it less confusing. GLFence is different from GLSurface and GLImage which have public Initialize methods that the caller must use after construction. The existing GLFence variants just build objects in the constructor, assuming it can\u0027t fail. The new types can have construction fail, so there needs to be a new mechanism to handle that.\n\nThe public API is to use the Create factory methods to get an initialized objects, it calls InitializeInternal to make this happen. I\u0027ve made this CreateInternal private since clients of this class should use one of the two public creation methods to ensure that the resulting object works as a non-null GpuFence. Clients could use GLFenceEGL::Create(type, attribs) to get an equivalent EGL object which may be useful for low-level code, but they shouldn\u0027t expect that to work as a GpuFence.\n\nAs per earlier discussions in the CL, I think changing the GLFence contract to require explicit client-side initialization would be a potential trap since in current usage a new GLFence is immediately usable. A private constructor with factory methods seemed cleanest.",
      "parentUuid": "ec6772f8_8e421a20",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5e46a084_3f181823",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.h",
        "patchSetId": 46
      },
      "lineNbr": 35,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-28T16:02:10Z",
      "side": 1,
      "message": "why is this needed here? isn\u0027t it enough with the ownership inside the EGLSync object instance?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15e180f3_103a9e77",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.h",
        "patchSetId": 46
      },
      "lineNbr": 35,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T19:52:55Z",
      "side": 1,
      "message": "I added a comment to explain. Basically, CommandBufferProxyImpl::SendGpuFence needs to call CloneHandleForIPC(GetGpuFenceHandle)), and it would seem fragile to do a eglDupNativeFenceFDANDROID call there as a side effect to get the file descriptor. I think currently it would work since it\u0027s all part of the same call stack where presumably nobody had a chance to manipulate the thread EGL context in between, but it seems weird.\n\n(This would not be an issue if the GLES call used a GpuFenceHandle as its ClientGpuFence type which I had initially intended, but IIRC you had vetoed that.)",
      "parentUuid": "5e46a084_3f181823",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "98d54869_0e1a2156",
        "filename": "ui/gl/gl_fence_egl.cc",
        "patchSetId": 46
      },
      "lineNbr": 35,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-20T20:29:19Z",
      "side": 1,
      "message": "nit: ditto, base::WrapUnique(new GLFenceEGL()) ?",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f92dceda_17d2a7d6",
        "filename": "ui/gl/gl_fence_egl.cc",
        "patchSetId": 46
      },
      "lineNbr": 35,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-21T21:25:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "98d54869_0e1a2156",
      "revId": "476f3cfdeff5a6e5c1f9ef7b97f8ded6018df20e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}