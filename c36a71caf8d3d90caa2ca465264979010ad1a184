{
  "comments": [
    {
      "key": {
        "uuid": "7ea2e489_c1cfdff0",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 44,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-08-10T21:07:15Z",
      "side": 1,
      "message": "memcpy should be fine with volatiles?",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e3a36ec0_1bcc3900",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 44,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T21:25:39Z",
      "side": 1,
      "message": "I\u0027m not really sure what the volatile member is buying us if we end up casting it away before any real access? Ie, memcpy internals are going to deal with non-volatile ptr after this, so I\u0027m not sure what guarantees it may or may not have wrt to access (ie, isn\u0027t the only place we access this memory, we end up casting away volatile?)\n\n(also we technically can rethink the whole AlignMemory bit on line 37 if we move to memcpy)",
      "parentUuid": "7ea2e489_c1cfdff0",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f7ffcedc_b9e65ed6",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 44,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-08-10T22:20:15Z",
      "side": 1,
      "message": "In theory, the compiler can inline memcpy (especially since it\u0027s constant size, it probably does), and decide that since the source is not volatile it can optimize (e.g. SIMD, that\u0027s ok) or it could, in theory, read it twice and/or use it as temporary storage and all sorts of weird things.\n\nOTOH It\u0027s extremely hard to be volatile-correct all the way through - especially without punishing code that operates on trusted data, or duplicating the code... I think at some points we will need to take it on faith that the compiler will not do overly crazy things (like store a temporary value in that memory) because it can\u0027t do the analysis to convince itself that it\u0027s safe.\nAt the very least, seeing the const_cast is a good opportunity at review time to ask questions and verify assumptions.\n\n\nIn this case though, is there anything wrong with *val \u003d *reinterpret_cast\u003cvolatile const T*\u003e(memory_)?\n\nFor other uses of memcpy, std::copy works on a volatile T* source, though it most likely prevents optimizations. I am fairly confident that a variable-size memcpy should be safe (and that\u0027s what we do in a few places in command buffer code).",
      "parentUuid": "e3a36ec0_1bcc3900",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "090e9e3d_854fd49e",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 44,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-08-11T18:25:33Z",
      "side": 1,
      "message": "\u003e *val \u003d *reinterpret_cast\u003cvolatile const T*\u003e(memory_)\n\nThis is not on the up and up for types like SkRect/SkIRect/SkMatrix, because there\u0027s no implicitly generated operator\u003d(const volatile T\u0026) function.\n\nI\u0027m going to const_cast away the volatile here, because toctou violations don\u0027t really matter for these types.  (Although maybe we can depend on the implicit operator\u003d to not have toctou violations?) At any rate, we check rect validity later.",
      "parentUuid": "f7ffcedc_b9e65ed6",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82ebef24_d2b52d24",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 64,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-08-10T22:20:15Z",
      "side": 1,
      "message": "Is SkValidatingDeserializeFlattenable safe wrt TOCTOU issues? Otherwise maybe we could copy the data first and run it on the copied data?",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2649cdb_614f57b6",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 64,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-08-11T18:25:33Z",
      "side": 1,
      "message": "I am pretty sure this is safe as it uses SkReadBuffer internally.",
      "parentUuid": "82ebef24_d2b52d24",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed8e1a3b_9b3b1980",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 132,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-08-10T22:20:15Z",
      "side": 1,
      "message": "ditto, is SkPath::readFromMemory safe?",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f780c0a_cf1f815d",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 132,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-08-11T18:25:33Z",
      "side": 1,
      "message": "Yes, I think this is safe.  I\u0027ll leave a comment about it, but it uses SkRBuffer in SkPath and indirectly in SkPathRef, which walks through the buffer linearly with ReadX functions much like PaintOpReader does.",
      "parentUuid": "ed8e1a3b_9b3b1980",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c4665e5_4090c868",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 181,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-08-10T22:20:15Z",
      "side": 1,
      "message": "I assume that just copies the data internally?",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa4819e7_243b1365",
        "filename": "cc/paint/paint_op_reader.cc",
        "patchSetId": 2
      },
      "lineNbr": 181,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-08-11T18:25:33Z",
      "side": 1,
      "message": "Yeah, it is just a memcpy.",
      "parentUuid": "6c4665e5_4090c868",
      "revId": "c36a71caf8d3d90caa2ca465264979010ad1a184",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}