{
  "comments": [
    {
      "key": {
        "uuid": "bbecd123_cf50a24e",
        "filename": "chrome/browser/extensions/extension_uninstall_dialog.cc",
        "patchSetId": 7
      },
      "lineNbr": 99,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-06-13T16:10:50Z",
      "side": 0,
      "message": "Would it make more sense to update ImageLoader to return the proper image?",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93912adc_ebf68e29",
        "filename": "chrome/browser/extensions/extension_uninstall_dialog.cc",
        "patchSetId": 7
      },
      "lineNbr": 99,
      "author": {
        "id": 1136695
      },
      "writtenOn": "2017-06-13T16:39:06Z",
      "side": 0,
      "message": "We have nice logic in IconImage that can select correct icon from the set and we can reuse. So it would be nice just reuse (in context of ChromeAppIcon). There is no benefit to LoadImagesAsync. We potentially may use IconImage but there is a mismatch what user see in app launcher and in uninstall dialog.",
      "parentUuid": "bbecd123_cf50a24e",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "29778a0d_50c6715b",
        "filename": "chrome/browser/extensions/extension_uninstall_dialog.cc",
        "patchSetId": 7
      },
      "lineNbr": 99,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-06-20T18:41:33Z",
      "side": 0,
      "message": "Sorry, I was a bit unclear - and meant IconImage rather than ImageLoader.  Right now, we have\nImageLoader\nIconImage\nChromeAppIcon\n\n(not to mention things like ExtensionActionIconFactory et al.)  It\u0027s getting tricky to know when to use which thing.  In particular, ChromeAppIcon and IconImage seem to be more-or-less trying to do the same thing - return an updating version of the extension icon.  I\u0027m wondering if we can/should consolidate those two into one class, so that we don\u0027t have to choose between them.\n\nPreviously, ChromeAppIcon was just used in app-like contexts, so the separation made sense.  If we\u0027re deciding that this is the right thing to do even for extensions, it seems like we should simplify things and have fewer classes.\n\nDoes that make sense?  If so, WDYT?  Would it make sense to do that, or is there a reason that IconImage and ChromeAppIcon should be kept separate?",
      "parentUuid": "93912adc_ebf68e29",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f16ca580_b6119d87",
        "filename": "chrome/browser/extensions/extension_uninstall_dialog.cc",
        "patchSetId": 7
      },
      "lineNbr": 99,
      "author": {
        "id": 1136695
      },
      "writtenOn": "2017-06-20T19:13:39Z",
      "side": 0,
      "message": "This makes sense, it is better to use ChromeAppIcon when we have app context.\nIt is hard to use only one (ideally ChromeAppIcon). ChromeAppIcon uses code from chrome/browser. IconImage exists in /extension. It is hard to refer /chrome/browser code from /extension. There is a code in /extension that uses IconImage. That is one problem. Another problem that changing everything might be too heavy to do in one CL. So I am trying to address cases that can easy found by user. This uninstall dialog is also used from app launcher, app context. Probably we may try to separate which icon to use based on context where uninstall dialog is used (looks bit crazy :)).",
      "parentUuid": "29778a0d_50c6715b",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2cdf0e2b_1a86ca27",
        "filename": "chrome/browser/extensions/extension_uninstall_dialog.cc",
        "patchSetId": 7
      },
      "lineNbr": 99,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-06-21T22:29:23Z",
      "side": 0,
      "message": "It looks like ChromeAppIcon needs relatively little from the //chrome layer, so I think we could probably hoist it up.\n\nI agree that it\u0027s not something we need to necessarily do in this CL, but I\u0027d like to investigate it.  Do you mind filing a bug to coalesce at least ChromeAppIcon + IconImage into one so that there\u0027s no ambiguity around which to use?",
      "parentUuid": "f16ca580_b6119d87",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6a2b335_ff07a9a6",
        "filename": "extensions/browser/extension_icon_image.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-06-20T18:41:33Z",
      "side": 0,
      "message": "gfx::Image is nice because it can store multiple representations of the image.  Why do we need to get rid of this?",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "111803be_03638a84",
        "filename": "extensions/browser/extension_icon_image.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1136695
      },
      "writtenOn": "2017-06-20T19:13:39Z",
      "side": 0,
      "message": "You mean representations for different scales? If yes then it is stored in gfx::ImageSkia; if no then functionality you refer did not work and gfx::Image was mechanically updated each time image_skia_ was changed, pure wrapper. There was only one consumer which called image(). In all other cases image_skia() was called. It looks redundant  and to make it clear + better performance it is better to get rid it here.",
      "parentUuid": "e6a2b335_ff07a9a6",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ebe4aeea_754a98e6",
        "filename": "extensions/browser/extension_icon_image.h",
        "patchSetId": 7
      },
      "lineNbr": 77,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-06-21T22:29:23Z",
      "side": 0,
      "message": "ImageSkia can contain different scales, but Image can contain different \"formats\".  i.e., it can hold ImageSkia, NSImage, etc.  The latter is important on Mac, where we have to reserialize ImageSkia to NSImage in order to use Cocoa elements.  By having a persistent Image that\u0027s returned, if something uses image.ToImage(), the gfx::Image will store that in its internal storage, thus saving the need to re-convert.  I\u0027d prefer we keep gfx::Image here.",
      "parentUuid": "111803be_03638a84",
      "revId": "248dae6e34da5e9526b079d9ca898b5f83bf2084",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}