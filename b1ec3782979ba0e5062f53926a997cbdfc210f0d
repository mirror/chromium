{
  "comments": [
    {
      "key": {
        "uuid": "34af06db_166d19eb",
        "filename": "chrome/browser/page_load_metrics/observers/core_page_load_metrics_observer.cc",
        "patchSetId": 1
      },
      "lineNbr": 329,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2018-01-23T16:27:31Z",
      "side": 1,
      "message": "if the first queued event is processed in an iframe on the page, do we want to use its timestamp here? we do this cross-frame merging for paint events. Perhaps we want a main-document-only version and also a page-wide version across all docs, mostly to see if they end up reporting very different values? I\u0027m fine with landing just this part for now - just want to understand what\u0027s useful / correct here in the longer term. We might call this one OnFirstEventQueueingTimeInMainFrameDocument just to be more precise (and consistent with FMP callback naming)",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6fd0adc_334afc96",
        "filename": "chrome/common/page_load_metrics/page_load_metrics.mojom",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2018-01-23T16:27:31Z",
      "side": 1,
      "message": "we also have a struct InteractiveTiming {} which contains the TTI-related timings. Do you think this belongs in that struct? The other timings in DocumentTiming are more related to events that are fired by the document, so this one feels a little bit out of place (first_layout is maybe the exception, but the intent is generally things associated with document life cycle, which FEQT isn\u0027t quite).",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e480341a_a88d6498",
        "filename": "chrome/common/page_load_metrics/page_load_metrics.mojom",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1116050
      },
      "writtenOn": "2018-01-24T14:38:34Z",
      "side": 1,
      "message": "Yeah, first layout is what made me think this was reasonable, but it did feel questionable.\n\nI\u0027ll go with InteractiveTiming.",
      "parentUuid": "d6fd0adc_334afc96",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b95afc30_c7710c76",
        "filename": "chrome/renderer/page_load_metrics/metrics_render_frame_observer.cc",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2018-01-23T16:27:31Z",
      "side": 1,
      "message": "nit: since this is a duration, could we be more precise and call it FirstEventQueuingDuration, or FirstEventQueuingDelay, everywhere? \"time\" is less clear - could be a timestamp for instance.",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "781b1b62_f01b7e92",
        "filename": "chrome/renderer/page_load_metrics/metrics_render_frame_observer.cc",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1116050
      },
      "writtenOn": "2018-01-24T14:38:34Z",
      "side": 1,
      "message": "How about \"First Input Delay\"?",
      "parentUuid": "b95afc30_c7710c76",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55196f97_9075e6e4",
        "filename": "third_party/WebKit/Source/core/dom/Document.h",
        "patchSetId": 1
      },
      "lineNbr": 1138,
      "author": {
        "id": 1116050
      },
      "writtenOn": "2018-01-19T20:20:40Z",
      "side": 1,
      "message": "Any thoughts on which approach is better here?",
      "range": {
        "startLine": 1138,
        "startChar": 62,
        "endLine": 1138,
        "endChar": 66
      },
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2fc72a8_a21da679",
        "filename": "third_party/WebKit/Source/core/dom/Document.h",
        "patchSetId": 1
      },
      "lineNbr": 1138,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2018-01-23T16:27:31Z",
      "side": 1,
      "message": "You\u0027re suggesting that instead of the caller doing:\ndocument().SetFirstEventQueueingTime(...) they\u0027d do document().GetMutableTiming()-\u003eSetFirstEventQueueingTime(...) or something similar? The latter seems better to me since we don\u0027t need to keep adding methods to document, but I\u0027m not a blink style/convention expert so I\u0027d defer to blink owners for guidance on the preferred approach here.",
      "parentUuid": "55196f97_9075e6e4",
      "range": {
        "startLine": 1138,
        "startChar": 62,
        "endLine": 1138,
        "endChar": 66
      },
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2c526f1_99f5b69b",
        "filename": "third_party/WebKit/Source/core/page/PageWidgetDelegate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 246,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2018-01-24T01:25:40Z",
      "side": 1,
      "message": "one more thought here - to make it harder to game this metric, could we test that the \u0027isTrusted\u0027 bit of the input event is true, to make sure it\u0027s not a fake input event synthesized by the application. Otherwise an app could create a fake input event at a time they know they have low latency, dispatch it and treat it as a no-op in JS, and score really well on this metric. WDYT about filtering to just isTrusted events?",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e8693dd_3b2de683",
        "filename": "third_party/WebKit/Source/core/page/PageWidgetDelegate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 246,
      "author": {
        "id": 1116050
      },
      "writtenOn": "2018-01-24T14:38:34Z",
      "side": 1,
      "message": "Great point, will do.",
      "parentUuid": "f2c526f1_99f5b69b",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1420081f_f9cd81b6",
        "filename": "third_party/WebKit/Source/core/page/PageWidgetDelegate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2018-01-23T16:27:31Z",
      "side": 1,
      "message": "re: taking the current timestamp, does this ReportFirstEventQueueingTime callback run before or after the application\u0027s JS code that handles the input event runs? in other words will we include the time the application spends in JS handling the input event in our first event queuing time calculation?\n\nIIUC event.TimeStampSeconds() is the timestamp that the event was generated ~at the hardware level (time user touched the glass, for instance), is that right?",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bab3b8c4_9be129b6",
        "filename": "third_party/WebKit/Source/core/page/PageWidgetDelegate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 1116050
      },
      "writtenOn": "2018-01-24T14:38:34Z",
      "side": 1,
      "message": "This executes before JS. We want to exclude time spent handling the input event, as it\u0027s trivially gameable (via setTimeout(0) and the like), and developers should be able to switch from delayed input processing to immediate input processing without seeing a regression.\n\nWe should have a test that this doesn\u0027t include processing time though.\n\nWe are using the hardware timestamp currently. The other option is to use the time we sent the event to the main thread. The other options has some pros and cons. It aligns better with the name \"queueing delay\" and better represents the part of the queueing delay the developer has control over.\n\nHowever, it can\u0027t be measured using existing APIs on the web and it\u0027s a bit less representative of user experience. In practice, in high percentiles, the time spent queued on the main thread dominates the total delay, so the practical impact of this decision isn\u0027t huge.\n\nI\u0027m inclined to go with the hardware timestamp, but there are good arguments in both directions.",
      "parentUuid": "1420081f_f9cd81b6",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f771e6d_7a56b633",
        "filename": "third_party/WebKit/Source/core/page/PageWidgetDelegate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2018-01-24T14:49:57Z",
      "side": 1,
      "message": "Thanks! Avoiding counting time spent in the handler makes sense to me, for the reasons you mention (setTimeout(0) etc).\n\nI\u0027m ok with deferring adding a test if it\u0027s hard to do so. You could file a bug for it.\n\nRE: hardware stamp vs main thread dispatch stamp, that\u0027s an interesting tradeoff. I\u0027m fine leaving it as is. If it\u0027s easy to do so we could consider recording UMA metrics for both, to see how different they are. If they are essentially the same then hardware stamp seems easier to explain, whereas if the hardware-\u003emain thread dispatch adds non-negligible variable latency we may need to be more thoughtful about how it\u0027s incorporated (since IIUC that delay is likely unrelated to the web app\u0027s performance and is outside of the developer\u0027s control). Do we already measure hardware-\u003emain thread dispatch delay and try to make sure our input pipeline is optimized to minimize it?",
      "parentUuid": "bab3b8c4_9be129b6",
      "revId": "b1ec3782979ba0e5062f53926a997cbdfc210f0d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}