{
  "comments": [
    {
      "key": {
        "uuid": "40eb7f2e_ad438892",
        "filename": "chrome/browser/chromeos/attestation/platform_verification_dialog.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1135824
      },
      "writtenOn": "2017-06-14T03:49:07Z",
      "side": 1,
      "message": "Where does this lead to a crash? It seems like this test avoids some condition that\u0027s actually an implementation detail deep within some other code. As such, this is fragile - the other code may change at any time, and nobody will know that this must be updated. I\u0027d rather make whatever dependency we require obvious in the API well call.",
      "range": {
        "startLine": 51,
        "startChar": 7,
        "endLine": 52,
        "endChar": 22
      },
      "revId": "f0ee5dd6eef30559b07104eec4ef1d384acdf683",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0756fb91_11b5780c",
        "filename": "chrome/browser/chromeos/attestation/platform_verification_dialog.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1002182
      },
      "writtenOn": "2017-06-14T04:33:13Z",
      "side": 1,
      "message": "Fair enough. I totally agree with you and that\u0027s what I originally did. But owners of constrained_window doesn\u0027t like that change and is concerned about changing the behavior of other dialogs.\n\n+wittman: I kinda agree with Mattias that users of the constrained_window::ShowWebModalDialogViews API won\u0027t necessarily know all these details and it\u0027s seem pretty easy to introduce crashes somewhere. Asking the caller to do some magic check won\u0027t really scale.",
      "parentUuid": "40eb7f2e_ad438892",
      "range": {
        "startLine": 51,
        "startChar": 7,
        "endLine": 52,
        "endChar": 22
      },
      "revId": "f0ee5dd6eef30559b07104eec4ef1d384acdf683",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97baacf3_8d298f2d",
        "filename": "chrome/browser/chromeos/attestation/platform_verification_dialog.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1002120
      },
      "writtenOn": "2017-06-14T16:53:15Z",
      "side": 1,
      "message": "The original change to constrained_window::ShowWebModalDialogViews was no less of a hack than this change is; the reason I suggested this change is because (1) it\u0027s more localized to the responsible code, (2) the code path is slated to be removed anyway, and (3) you\u0027re looking for a low effort/low risk fix for the release blocker. This is absolutely not the intended general way to solve this type of problem.\n\nMy understanding of the underlying issue from the bug is that extensions can request media key system access, which requires user approval, but we haven\u0027t wired things up to present the dialog to the user to request access. As I mentioned in the bug, the real solution to this problem would be to do this wiring by attaching a WebContentsModalDialogManager to the triggering WebContents (this may also require creating a WebContentsModalDialogManagerDelegate subclass to manage where the dialog will be shown).",
      "parentUuid": "0756fb91_11b5780c",
      "range": {
        "startLine": 51,
        "startChar": 7,
        "endLine": 52,
        "endChar": 22
      },
      "revId": "f0ee5dd6eef30559b07104eec4ef1d384acdf683",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "719d5561_309873ee",
        "filename": "chrome/browser/chromeos/attestation/platform_verification_dialog.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1002182
      },
      "writtenOn": "2017-06-14T17:28:24Z",
      "side": 1,
      "message": "(1) I agree the original change isn\u0027t a complete fix in the sense that the permission still doesn\u0027t work for the extension (we just failed the permission request without prompting users). With that I agree with your assessment about what the \"real solution\" should be. But as you described in (2) and (3), it doesn\u0027t make sense to pursue the \"real solution\" at this moment.\n\n(2) But even if we do the \"real solution\" as you proposed, it doesn\u0027t prevent all potential crashes like this one from happening again. Your suggestion indicates that whoever uses ShowWebModalDialogViews() (a public API) needs to make sure the WebContents is properly prepared by attaching WebContentsModalDialogManager etc, which developers will definitely do for the main use case. But given the fact that there are so many different ways of creating WebContents, it\u0027s very likely that some path is not covered and could cause a crash. This is basically how the crash I am fixing happened in the first place. With that, I feel the original change in constrained_window::ShowWebModalDialogViews still makes some sense. It will at least help prevent some crashes from happening. But again to make a complete fix, we probably also need to update the documentation on ShowWebModalDialogViews(), mentioning that it could return null (and/or add DCHECKs somewhere).\n\nSo, how about we land the current CL as is, and merge it back to M60. Then if wittman@ agrees with (2), we fix ShowWebModalDialogViews() (add checks, update comments and possibly fix callers) on ToT, after which we probably can remove this check here. WDYT?",
      "parentUuid": "97baacf3_8d298f2d",
      "range": {
        "startLine": 51,
        "startChar": 7,
        "endLine": 52,
        "endChar": 22
      },
      "revId": "f0ee5dd6eef30559b07104eec4ef1d384acdf683",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dcbd6160_a20f5154",
        "filename": "chrome/browser/chromeos/attestation/platform_verification_dialog.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1135824
      },
      "writtenOn": "2017-06-14T18:03:17Z",
      "side": 1,
      "message": "Mike, I disagree that this solution is more localized with responsible code. If there\u0027s an API that takes a \nWebContents*, but it\u0027ll just crash if that WebContents is in a state that the API doesn\u0027t expect, that\u0027s a problem of the API implementation and not a problem of the caller. So my argument would be that the check should live in the API implementation, for the very reason that it\u0027s more localized with the responsible code.\n\nIf you\u0027re worried about affecting other code paths, then how about making a function like \n\nbool SupportsWebModalDialogs(WebContents* web_contents)\n\nthat the consumers can call but that hides away the details of figuring out whether web modal dialogs work for the WebContents in question?\n\nI don\u0027t think it makes sense to fight this to death though - so I\u0027ll stop arguing and let the two of you figure this out among yourselves. Whatever solution you come up with, please file a bug to remove the hack once a proper solution is implemented.",
      "parentUuid": "719d5561_309873ee",
      "range": {
        "startLine": 51,
        "startChar": 7,
        "endLine": 52,
        "endChar": 22
      },
      "revId": "f0ee5dd6eef30559b07104eec4ef1d384acdf683",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e415270_fbcbb763",
        "filename": "chrome/browser/chromeos/attestation/platform_verification_dialog.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1002120
      },
      "writtenOn": "2017-06-14T18:04:43Z",
      "side": 1,
      "message": "\u003e (2) But even if we do the \"real solution\" as you proposed, it doesn\u0027t prevent all potential crashes like this one from happening again. Your suggestion indicates that whoever uses ShowWebModalDialogViews() (a public API) needs to make sure the WebContents is properly prepared by attaching WebContentsModalDialogManager etc, which developers will definitely do for the main use case. But given the fact that there are so many different ways of creating WebContents, it\u0027s very likely that some path is not covered and could cause a crash. This is basically how the crash I am fixing happened in the first place. With that, I feel the original change in constrained_window::ShowWebModalDialogViews still makes some sense. It will at least help prevent some crashes from happening. But again to make a complete fix, we probably also need to update the documentation on ShowWebModalDialogViews(), mentioning that it could return null (and/or add DCHECKs somewhere).\n\nI agree that the case you mention is a weakness of the web_modal API, but I don\u0027t think this is a good solution. As I mentioned in the bug, this would have the effect of implicitly making decisions with security and privacy implications on the user\u0027s behalf, decisions that we\u0027ve already recognized that we don\u0027t have the information to answer ourselves. In analogous fashion to the guidance to use CHECK() if the consequence of a failed assertion would be a security vulnerability, it\u0027s better to crash than to make a wrong decision with security implications. Crashing also provides visibility into the fact that there is a problem -- using a null check would just silently hide it.\n\nIMO a better approach to the general issue would be to either provide a more structured mechanism to create WebContents within Chrome that attaches a WebContentsModalDialogManager, or update the web_modal functionality to supply some WebContentsModalDialogManager-of-last-resort to handle cases where no manager was registered.",
      "parentUuid": "719d5561_309873ee",
      "range": {
        "startLine": 51,
        "startChar": 7,
        "endLine": 52,
        "endChar": 22
      },
      "revId": "f0ee5dd6eef30559b07104eec4ef1d384acdf683",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d62a44d8_6e1474f9",
        "filename": "chrome/browser/chromeos/attestation/platform_verification_dialog.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1002120
      },
      "writtenOn": "2017-06-14T18:27:19Z",
      "side": 1,
      "message": "\u003e Mike, I disagree that this solution is more localized with responsible code. If there\u0027s an API that takes a WebContents*, but it\u0027ll just crash if that WebContents is in a state that the API doesn\u0027t expect, that\u0027s a problem of the API implementation and not a problem of the caller. So my argument would be that the check should live in the API implementation, for the very reason that it\u0027s more localized with the responsible code. If you\u0027re worried about affecting other code paths, then how about making a function like bool SupportsWebModalDialogs(WebContents* web_contents) that the consumers can call but that hides away the details of figuring out whether web modal dialogs work for the WebContents in question? I don\u0027t think it makes sense to fight this to death though - so I\u0027ll stop arguing and let the two of you figure this out among yourselves. Whatever solution you come up with, please file a bug to remove the hack once a proper solution is implemented.\n\nUltimately, the bug here is that the creator of the WebContents did not set up the WebContents properly to account for the fact that it might trigger dialogs. And unfortunately, because of the decentralized management of WebContents in the application, we don\u0027t have a good way of detecting this case before attempting to display the dialog. I\u0027m reluctant to provide a SupportsWebModalDialogs-style interface for the security and privacy reasons I mentioned in my previous comment; I think one of the other two solutions mentioned would be much better.",
      "parentUuid": "9e415270_fbcbb763",
      "range": {
        "startLine": 51,
        "startChar": 7,
        "endLine": 52,
        "endChar": 22
      },
      "revId": "f0ee5dd6eef30559b07104eec4ef1d384acdf683",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}