{
  "comments": [
    {
      "key": {
        "uuid": "594f3946_2246dced",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 963,
      "author": {
        "id": 1115878
      },
      "writtenOn": "2018-01-31T01:06:13Z",
      "side": 1,
      "message": "What are all the use cases for copy requests? Is there any enforcement that they don\u0027t \naccidentally not have positive scale or translation?",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22d04dd7_7c736ef7",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 963,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2018-01-31T01:57:55Z",
      "side": 1,
      "message": "\u003e What are all the use cases for copy requests?\n\nThere are far too many to list! :) Essentially, copy requests made in the Layer tree are for \"snapshot\" use cases where the client wants a scaled+cropped SkBitmap result.\n\n\u003e Is there any enforcement that they don\u0027t accidentally not have positive scale or translation?\n\nThis is enforced in the display compositor, where all copy requests are executed. Validity of request parameters is checked as well as sanitizing the post-scaling coordinate calculations. Requests will fail gracefully if the copy cannot be made.",
      "parentUuid": "594f3946_2246dced",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c5dd5dec_ab0e8bed",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 984,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-31T00:24:47Z",
      "side": 1,
      "message": "Can you remind me which process is in control of setting these scales? Is it possible for excessively interesting values to be passed? I see the struct traits does check for \u003c\u003d 0, but I\u0027m wondering if overflow is something we\u0027d need to care about?",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41a4909f_639f1779",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 984,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2018-01-31T00:58:31Z",
      "side": 1,
      "message": "1. This code executes in the browser process.(*)\n\n2. Surfaces represent the compositing of a layer tree in another process/module. IIUC, this code should only be executed once on any given copy request since Surfaces cannot be put into layer trees again. Regardless, see #3 for why it would be safe anyway.\n\n3. gfx::ToRoundedInt() handles overflow by its use of base::saturated_cast\u003cint\u003e, to ensure the floatâ†’int conversion doesn\u0027t have a out-of-range problem. See: https://cs.chromium.org/chromium/src/ui/gfx/geometry/safe_integer_conversions.h?rcl\u003df24fdd9f84945a521665220d062544275932e246\u0026l\u003d38\n\n(*) Longer answer to #1: This code is executing in the same process as where the CopyOutputRequests originate. We know this because the entire layer tree (with their copy requests) is being \"compiled\" into a single CompositorFrame plus a list of RenderPasses (with the modified copy requests). It is the latter object graph that is being transferred to the display compositor via mojo structs/APIs.",
      "parentUuid": "c5dd5dec_ab0e8bed",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd1c2faf_fcb4dea4",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 984,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-31T01:42:02Z",
      "side": 1,
      "message": "Just to be clear: *this* block of code runs in the compositor service, but the inputs to this are *only* controlled by the browser? It\u0027s hard for me to tell that\u0027s the case currently (or that it will remain so for the forseeable future).\n\nAlso, it\u0027s not clear to me the same reasoning about overflow is true for lines 987-999: the output of the multiplication is an int, and it\u0027s not clear to me that it couldn\u0027t overflow in some way.",
      "parentUuid": "41a4909f_639f1779",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77192db6_b5a0b143",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 984,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2018-01-31T03:09:54Z",
      "side": 1,
      "message": "\u003e Just to be clear: *this* block of code runs in the compositor service...\n\nNo. This block of code here runs in the browser process. The copy requests originate in the browser process, are added to the layers in the browser process, and this function here runs in the browser process.\n\nThe modified copy requests will later be moved into RenderPasses, which then are serialized via mojo over to the display compositor. Today, the display compositor is also in the browser process, but in the VIZ-enabled world it will be in the GPU process.\n\n\u003e It\u0027s hard for me to tell that\u0027s the case currently (or that it will remain so for the forseeable future).\n\nI don\u0027t believe the compositing or GPU teams ever meant to make any guarantees about where src/cc code is run. OOC, why does it matter where this particular block of code runs?\n\n\u003e Also, it\u0027s not clear to me the same reasoning about overflow is true for lines 987-999...\n\nGood point. I\u0027ve re-examined this code and changed it to use checked math. I don\u0027t expect the values to ever be out-of-range; but if something really weird happens, the correct thing to do here is the same as what would happen downstream: When the scale ratio produces bad coordinates, we simply drop the copy request. (Note that, when the CopyOutputRequest goes out-of-scope, it auto-sends a \"failed\" response back to the client.)",
      "parentUuid": "bd1c2faf_fcb4dea4",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "768e7723_c76b181c",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 990,
      "author": {
        "id": 1115878
      },
      "writtenOn": "2018-01-31T01:06:13Z",
      "side": 1,
      "message": "Why does SetScaleTo have two vector parameters? Is the relative scale of the\nx coordinates of each vector (and y coordinates) all that matter? If so, why is\nit not two scalars?",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a75bef6a_221c16dc",
        "filename": "cc/trees/property_tree.cc",
        "patchSetId": 5
      },
      "lineNbr": 990,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2018-01-31T01:57:55Z",
      "side": 1,
      "message": "Late last Summer, there was a discussion on this when the new scaling API was introduced. OTOH, the outcome of those decisions are:\n\n1. Using integer ratios simplifies the heuristics where the copy requests are executed: The high-quality scalers are actually a multi-step rendering process where different shader programs are chosen at each step based on certain integer ratios.\n\n2. Using integers instead of floats leads to a code structure where any and all precision loss/trade-offs are very exposed (e.g., line 968 above). This prevents unintended rounding effects that are often impossible to detect during the development process (and unit testing) and then will unexpectedly show up in-the-wild.\n\n3. For quality reasons, there are times when the scale of X and Y need to be independent. For example, this can be used to correct for aspect ratio differences between devices. Or, it can be used to adjust for the client\u0027s output image format (e.g., I420 with its 2x2 subsampled chroma).",
      "parentUuid": "768e7723_c76b181c",
      "revId": "d594b34e1ce45bce0a41a9c401584443e229e3db",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}