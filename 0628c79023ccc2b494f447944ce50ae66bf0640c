{
  "comments": [
    {
      "key": {
        "uuid": "c06cc83d_4e00871a",
        "filename": "ui/compositor/layer_animator_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 2027,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-03T19:06:10Z",
      "side": 1,
      "message": "nit: please use std::unique_ptr",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0849086_871050a9",
        "filename": "ui/compositor/layer_animator_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 2027,
      "author": {
        "id": 1228419
      },
      "writtenOn": "2017-10-03T20:37:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c06cc83d_4e00871a",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65b53ab1_08bc9e7c",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-09-28T22:29:51Z",
      "side": 1,
      "message": "Is OnImplicitAnimationsCompleted guaranteed to be called? That\u0027s absolutely not obvious from the code. Otherwise it would leak the DeferredPaintObserver.\n\nIn particular, it looks to me that ~ScopedLayerAnimationSettings will remove it from animator_-\u003eobservers_, and so I don\u0027t think anything else will destroy it at that point.\n\nThe same is true of CacheRenderSurfaceObserver... I\u0027m super uncomfortable with the pattern, I would prefer if ScopedLayerAnimationSettings kept explicit ownership (unique_ptr) of the observers.",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ad9e808_d7882f0c",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1228419
      },
      "writtenOn": "2017-09-28T22:46:13Z",
      "side": 1,
      "message": "+ajuma@\n\nNot sure what is the original design, but ScopedLayerAnimationSettings will be out of scope and destroyed and set the ImplicitAnimationObserver active to start the animation.\n\nIt takes a while to know that all the observers are passed to animation sequence [1].\nI have written tests to verify that the child layer OnImplicitAnimationsCompleted is called [2].\n\n[1] https://cs.chromium.org/chromium/src/ui/compositor/layer_animator.cc?l\u003d875\u0026rcl\u003d1e608a56dad5dc35a4372a4179d5a82a4fdb0355\n[2] https://chromium-review.googlesource.com/c/chromium/src/+/685493/4/ui/compositor/layer_animator_unittest.cc#1900",
      "parentUuid": "65b53ab1_08bc9e7c",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f9e8b9c_c8569dde",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1002110
      },
      "writtenOn": "2017-09-29T14:47:25Z",
      "side": 1,
      "message": "Right, ScopedLayerAnimationSettings only sticks around for scheduling the animation, so it can\u0027t own the observer. Your explanation for why OnImplicitAnimationsCompleted will get called looks correct to me, but I also agree that this is pretty non-obvious. Would it make sense to have the Layer own these observers?",
      "parentUuid": "8ad9e808_d7882f0c",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7be2ed6b_b41fc502",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1228419
      },
      "writtenOn": "2017-09-29T17:05:48Z",
      "side": 1,
      "message": "+varkha@\n\nThe CacheRenderSurfaceObserver and DeferredPaintObserver are also subclass of LayerObserver, so it is easy to add the observer to current existing observer_list_ in ui::Layer.\n\nDo we also want to make current ScopedLayerAnimationSettings::AddObserver(ImplicitAnimationObserver* observer) to let the layer has the observers list? Then we might need to add a new observer_list_animation_ of type of base::ObserverList\u003cLayerAnimationObserver\u003e.\n\nAbout the ownership (unique_ptr), searching the code base, what I got is base::ObserverList\u003cObserverType\u003e. It seems all the ImplicitAnimationObserver will delete itself when the animation is finished. There is not usage of base::ObserverList\u003csdg::uqique_ptr\u003cObserverType\u003e\u003e, except this DelayedAnimationObserver [1], we use std::vector to maintain the list. But it is used for more complicated ownership concern [1]. It is also hard to track the when will it be called and maintain the observer list.\n\nWhat I can tell from the codebase is that OnImplicitAnimationsCompleted is guaranteed to be called. So the observer can delete itself. So the ownership is not required by design?\n\n[1] https://cs.chromium.org/chromium/src/ash/wm/overview/window_selector_controller.h?l\u003d78\u0026rcl\u003d3d27469c6dd35ec9a5a95702bc9158e1d5416062",
      "parentUuid": "3f9e8b9c_c8569dde",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af476312_b985cc31",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-09-29T23:08:50Z",
      "side": 1,
      "message": "What if the relevant classes (LayerAnimator, LayerAnimationSequence) are destroyed before the end of the animation? What if the animation is queued but never runs? What if no animation is started at all?\n\nI don\u0027t think that is well tested. But I don\u0027t think something as basic as ownership should rely on unit tests to prove correctness - it should be obvious from the code. We absolutely need to use smart pointers (unique_ptr) to make it obviously correct, instead of relying on explicit new/deletes.",
      "parentUuid": "7be2ed6b_b41fc502",
      "tag": "mailMessageId\u003d\u003cCAMeTaZdUDzP4pUawZtvSc9vqFsX9E8tkMFnB96wf4pATAGQk8Q@mail.gmail.com\u003e",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b01ad722_97661446",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1228419
      },
      "writtenOn": "2017-10-03T01:39:34Z",
      "side": 1,
      "message": "Thanks Antoine,\n\nI am assuming your suggestion to make observer has ownership is only applying to the CacheRenderSurfaceObserver and DeferredPaintObserver. For current ScopedLayerAnimationSettings::AddObserver(ImplicitAnimationObserver* observer), I will keep as it to not change existing behaviors. Because: 1) Some existing code may not want to transfer the ownership of observer. 2) This requires touching many codes, I prefer do it in another cl if necessary.\n\nTo make the CacheRenderSurfaceObserver and DeferredPaintObserver has ownership will work. Layer and LayerAnimator are both good candidates, but I am inclined to choose LayerAnimator. Since ScopedLayerAnimationSettings takes in the layer-\u003eanimator_. But layer could outlive animator, and animator could outlive layer, so we need special handing in either case. \n\nWhile I am making the above changes, I just want to understand more about current code. IIUC, current code will work most of the time if we use it correctly as expected as list bellow:\nWe are discussing several situations here. Some of them are covered by current code, but some not.\n0. Layer is destroyed first.\n1. LayerAnimator is destroyed first\n2. LayerAnimationSequence is destroyed first\n3. Animation is queued.\n4. Animation is not started.\n\n0. Layer is destroyed first (not covered by current code, is this intentional or a bug?).\nYou are right that the layer could be destroyed before the animation finish, that is what we have extra handling in the CacheRenderSurfaceObserver and DeferredPaintObserver.\nThe reason why OnImplicitAnimationsCompleted is not called on current running sequence when ~Layer(), is that [1] RequiresNotificationWhenAnimatorDestroyed is defaulted by false, so that OnDetachedFromSequence [2] is not called.\n[1] https://cs.chromium.org/chromium/src/ui/compositor/layer_animation_sequence.cc?l\u003d240\u0026rcl\u003d7b3e51dd9301ab842a64556df356b21a870fe7ed\n[2] https://cs.chromium.org/chromium/src/ui/compositor/layer_animation_observer.cc?l\u003d130\u0026rcl\u003dd6cc8b72e6cc0d79db438da47fda28971880eb87\n\n1. LayerAnimator is destroyed first (not covered by current code).\nSimilar to case 0, OnDetachedFromSequence is not called on current running sequence.\n\n2. LayerAnimationSequence is destroyed first (covered by current code).\n~LayerAnimationSequence() \u003d\u003e OnDetachedFromSequence() [3] \u003d\u003e OnImplicitAnimationsCompleted() will be called.\n[3] https://cs.chromium.org/chromium/src/ui/compositor/layer_animation_sequence.cc?l\u003d42\u0026rcl\u003d48858069622e424354bc9cbb63182bcc8e4b75ae\n\n3. Animation is queued (covered by current code).\nQueued animations will run eventually or called by ~Layer() \u003d\u003e ~LayerAnimator() \u003d\u003e ClearAnimationsInternal() \u003d\u003e ~LayerAnimationSequence() \u003d\u003e OnDetachedFromSequence() \u003d\u003e OnImplicitAnimationsCompleted() will be called.\n\n4. Animation is not started (covered by current code).\nIn ScopedLayerAnimation, animation will always start.\nWhen we LayerAnimator::Set##name (e.g. layer-\u003eSetOpacity()), we will call StartAnimation().\n[4] https://cs.chromium.org/chromium/src/ui/compositor/layer_animator.cc?l\u003d101\u0026rcl\u003de5071f38bb56c3f2b37cda0a5818efac26d8bb6b\n\nThanks,\nTao",
      "parentUuid": "af476312_b985cc31",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4d72c10_a48d9f28",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-03T19:06:10Z",
      "side": 1,
      "message": "#4 - if no Set##name is called, nothing would call StartAnimation",
      "parentUuid": "b01ad722_97661446",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "985748e8_68441857",
        "filename": "ui/compositor/scoped_layer_animation_settings.cc",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1228419
      },
      "writtenOn": "2017-10-03T20:37:09Z",
      "side": 1,
      "message": "#4, Right. plus the following case StartAnimation is not called.\nif (duration.is_zero() \u0026\u0026 delegate() \u0026\u0026 (preemption_strategy_ !\u003d ENQUEUE_NEW_ANIMATION))\nhttps://cs.chromium.org/chromium/src/ui/compositor/layer_animator.cc?l\u003d92\u0026rcl\u003d25dc0992a465742bf3a508d2f099e51fd56b1e15",
      "parentUuid": "d4d72c10_a48d9f28",
      "revId": "0628c79023ccc2b494f447944ce50ae66bf0640c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}