{
  "comments": [
    {
      "key": {
        "uuid": "d91d9209_d533e710",
        "filename": "cc/paint/paint_op_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-11-06T19:48:04Z",
      "side": 1,
      "message": "I think this needs to behave like the SerializeRecursive from GLES2Implementation, in that it inserts saves and restores around the draw record that you\u0027re inlining.\n\nThat GLES2Implementation code is suspiciously similar to this, except it has a different way of allocating more memory.  I don\u0027t like code duplication, but am not sure what to do about it here.  Templatizing a SerializeHelper/Recursive seems a bit \u003c_\u003c too.  What do you think?\n\nThe other missing piece here (but one that is also missing from GLES2Implementation) is that SetMatrix is incorrect when unfolding DrawRecords.  We need to do one of three things:\n(1) Save off the CTM locally when serializing whenever encountering a DrawRecord, and update all \"SetMatrix\" to concat that CTM on the client side, so that the service only gets the full \"SetMatrix\" and doesn\u0027t have to worry about this.\n(2) Add a bool to SaveOp that says \"I am a DrawRecord save, please remember my CTM\" and have the service side do the concat, just like PaintOpBuffer does recursively in Playback by storing the CTM locally.\n(3) We could revisit not serializing DrawRecordOps.  If we just serialized those directly, then the service side could recursively play them back, doing what playback does locally by saving off the CTM, at the expense of a more complicated service side.  One disadvantage (although maybe this is premature optimization) is that the client side must serialize PaintRecords in their entirety (so if a block runs out of space, then there\u0027s no way to just continue with where it was).",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f10f63bb_25f6161f",
        "filename": "cc/paint/paint_op_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-11-09T06:32:59Z",
      "side": 1,
      "message": "I pulled out the logic for save/restore balancing, op skipping and next alpha folding into a templated class. Initially I went with a FlatteningIterator and that took me down a rabbit hole which was much uglier. The templated class doesn\u0027t look so bad.\n\nI went with option 1). We need to replicate the transform/clip state tracking done during playback on the client side anyway, for decoding images so we might as well fix the matrix here.",
      "parentUuid": "d91d9209_d533e710",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a19a448d_c26e3e10",
        "filename": "cc/paint/paint_op_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1842,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-11-06T19:48:04Z",
      "side": 1,
      "message": "This is a lot of duplication from PaintOp::Deserialize.  Do you think PaintOp::Deserialize should take an optional buffer to allocate into?  Should PaintOp::Deserialize *always* take a PaintOpBuffer and users always have to deserialize into a PaintOpBuffer?  What do you think?",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fbaca915_b64bfb06",
        "filename": "cc/paint/paint_op_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1842,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-11-09T06:32:59Z",
      "side": 1,
      "message": "It was reading the header part which was duplicated, I moved that to a common function.",
      "parentUuid": "a19a448d_c26e3e10",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "047cac4f_8fa85601",
        "filename": "cc/paint/paint_op_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1849,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-11-06T19:48:04Z",
      "side": 1,
      "message": "This is unrelated cleanup thinking, but I think AllocatePaintOp no longer needs to return skip, by the way, now that vmpstr made it so that all ops have statically determined sizes and no longer have dynamic memory between ops.  I think skip is just the round up to align of size(T) just as UpdateTypeAndSkip uses it.",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cda1350_6d23481f",
        "filename": "cc/paint/paint_op_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1865,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-11-06T19:48:04Z",
      "side": 1,
      "message": "Maybe I\u0027m confused, but I think it\u0027s more complicated than this. There\u0027s an initial scale of that the shader is at, but inside that PaintRecord there could be additional scales.  It kind of seems like we need to have an SkNoDrawCanvas in SerializeOptions.  GLES2Implementation already needs such a canvas for exactly this reason, so maybe we just always need a canvas on serialize and every non-draw op always serializes itself as a part of serialization?  It seems like maybe we could share some code out of there.",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d594ea1a_5fe6885f",
        "filename": "cc/paint/paint_op_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1865,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-11-09T06:32:59Z",
      "side": 1,
      "message": "I think we can reuse PaintOpBufferSerializer for paint record shaders. I was making note that when we set up that serializer, we need to add the rasterization scale for the record when serializing that buffer. Its going to be similar to what we do here during regular raster (https://cs.chromium.org/chromium/src/cc/paint/paint_shader.cc?dr\u0026l\u003d15).",
      "parentUuid": "7cda1350_6d23481f",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8e652a3e_7586aa6e",
        "filename": "cc/paint/paint_op_buffer_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 2200,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-11-06T19:48:04Z",
      "side": 1,
      "message": "Can you update DeserializationFailures to additionally use the MakeFromMemory path?\n\nCan you also add paint record shaders to test_flags? (Maybe we need test_records as well.)",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a797ba0_6c999ef0",
        "filename": "cc/paint/paint_op_buffer_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 2218,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-11-06T19:48:04Z",
      "side": 1,
      "message": "You may want to look at DrawRecordOp::Deserialize.  I would have expected any serialized DrawRecordOp to fail without changing that function.",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "faac67f4_6a38a4a8",
        "filename": "cc/paint/paint_op_buffer_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 2218,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-11-09T06:32:59Z",
      "side": 1,
      "message": "This is to verify that we don\u0027t hit that function and unfurl the DrawRecord ops as we encounter them. PaintOpBufferSerializer does this.",
      "parentUuid": "9a797ba0_6c999ef0",
      "revId": "99b8eec6cc21ea94dcb43532a5bfe8fb3c70fd53",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}