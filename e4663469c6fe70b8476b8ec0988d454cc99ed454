{
  "comments": [
    {
      "key": {
        "uuid": "758bf9c1_a8d62735",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 15,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-07-19T23:23:44Z",
      "side": 1,
      "message": "If you want shutdown to proceed even if there\u0027s a pending file dialog then you need CONTINUE_ON_SHUTDOWN (I know the nomenclature is confusing, it comes from the old SequencedWorkerPool and will be reworked after we get rid of some shutdown issues that make us even require 3 states).\n\nCONTINUE_ON_SHUTDOWN is the loosest shutdown mode in that it skips tasks on shutdown but also doesn\u0027t block shutdown if the task is in progress (SKIP_ON_SHUTDOWN blocks shutdown if the task is in progress). CONTINUE_ON_SHUTDOWN comes with a caveat that you must not use any global/static/non-Leaky Singletons state as your task may still be running after main() unwinds and those things have been uninitialized.",
      "range": {
        "startLine": 13,
        "startChar": 3,
        "endLine": 15,
        "endChar": 38
      },
      "revId": "e4663469c6fe70b8476b8ec0988d454cc99ed454",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0201dc1d_dec62da8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 15,
      "author": {
        "id": 1001727
      },
      "writtenOn": "2017-07-19T23:58:57Z",
      "side": 1,
      "message": "Thanks! Replying and I have one question regarding this.\n\nI\u0027ve definitely considered CONTINUE_ON_SHUTDOWN in the beginning but that uninitialized singleton scenario made me, .. um uncomfortable.\n\nLet\u0027s assume a case where I\u0027m absolutely sure there isn\u0027t a global usage in any code path, I use CONTINUE_ON_SHUTDOWN.\nLater on, someone changes the code to start using global (they can be farther down in the callback from where CONTINUE_ON_SHUTDOWN is specified, so it wasn\u0027t immediately obvious). How do we prevent that? To me it sounds like we might start seeing harder to diagnose crash reports.",
      "parentUuid": "758bf9c1_a8d62735",
      "range": {
        "startLine": 13,
        "startChar": 3,
        "endLine": 15,
        "endChar": 38
      },
      "revId": "e4663469c6fe70b8476b8ec0988d454cc99ed454",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6cbd0e92_77225dfe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 15,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-07-20T00:27:24Z",
      "side": 1,
      "message": "Yeah, that\u0027s exactly why we want to get rid of this scenario altogether (ultimately we want to TerminateProcess() after TaskScheduler::Shutdown() so there wouldn\u0027t be this whole running-after-static-uninitialization thing). You can leave it like this for now, it won\u0027t really matter unless your task takes forever and appears in shutdown hang reports.\n\nWe currently mitigate this somewhat by having AssertSingletonAllowed() fire in CONTINUE_ON_SHUTDOWN contexts: https://cs.chromium.org/chromium/src/base/task_scheduler/task_tracker.cc?rcl\u003da1efdc3eec28f62fab81f4d9f6c224302675a7d5\u0026l\u003d289",
      "parentUuid": "0201dc1d_dec62da8",
      "range": {
        "startLine": 13,
        "startChar": 3,
        "endLine": 15,
        "endChar": 38
      },
      "revId": "e4663469c6fe70b8476b8ec0988d454cc99ed454",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}