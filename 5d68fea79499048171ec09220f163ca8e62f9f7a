{
  "comments": [
    {
      "key": {
        "uuid": "8b9141e4_09dd268e",
        "filename": "chrome/common/profiling/memlog_allocator_shim.cc",
        "patchSetId": 25
      },
      "lineNbr": 101,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T18:59:43Z",
      "side": 1,
      "message": "You\u0027re basically writing a version of AtomicFlag where non-zero has a semantic other than true. Should we just copy what they\u0027re doing?\n\nhttps://cs.chromium.org/chromium/src/base/synchronization/atomic_flag.cc?sq\u003dpackage:chromium\u0026l\u003d21\n\nAlso, this still a NoBarrier_Store.\n\nI think you want a ReleaseStore at the very least, but I\u0027m also not convinced you can get away with relaxed on the load.\n\nThread A (setting)\n   1: p \u003d allocate\n   2: initlaize(p)\n   3: release-store pointer \n\nThread B (using)\n   1: load-acquire p\n   2: use(p)\n\nIf in B1, we remove the load-acquire and replace with relaxed (aka no barrier), then I think the cache system is free to send the results A3 from thread A to thread B BEFORE it sends the results of A2 or A1...\n\nI think?",
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15f73d5f_ab72f33d",
        "filename": "chrome/common/profiling/memlog_allocator_shim.cc",
        "patchSetId": 25
      },
      "lineNbr": 101,
      "author": {
        "id": 1115906
      },
      "writtenOn": "2017-10-24T19:15:42Z",
      "side": 1,
      "message": "AtomicFlag doesn\u0027t really suit our needs. We need to atomically grab a stored pointer. The setter is also not guaranteed to be tied to a specific thread.\n\nI think we\u0027re not quite on the same page.\n\nB1: calls load-acquire p. It will either get some real pointer, let\u0027s say 0xBEEF, or nullptr. This operation is atomic. That\u0027s all we need - we don\u0027t need sequencing.\n\nIf B gets 0xBEEF, it will use it. If B gets nullptr, it will early out.",
      "parentUuid": "8b9141e4_09dd268e",
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "61b2a19e_0b338ab2",
        "filename": "chrome/common/profiling/memlog_allocator_shim.cc",
        "patchSetId": 25
      },
      "lineNbr": 101,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T20:44:05Z",
      "side": 1,
      "message": "Sorry...I was suggesting using AtomicFlag but rather pointing out that we can copy it\u0027s atomic ops since we\u0027re fundamentally doing the same thing (having one thread publish results to bunch of other threads).\n\nAs for memory order correctness, we\u0027re discussing off thread.",
      "parentUuid": "15f73d5f_ab72f33d",
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a9e91f2_65fdadf6",
        "filename": "chrome/common/profiling/memlog_allocator_shim.cc",
        "patchSetId": 25
      },
      "lineNbr": 101,
      "author": {
        "id": 1115906
      },
      "writtenOn": "2017-10-24T20:52:57Z",
      "side": 1,
      "message": "thanks, atomics are hard. Switched to Acquire_load and Release_Store semantics.",
      "parentUuid": "61b2a19e_0b338ab2",
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8c8c89b_4d7c91a9",
        "filename": "chrome/common/profiling/memlog_allocator_shim.cc",
        "patchSetId": 25
      },
      "lineNbr": 114,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T18:59:43Z",
      "side": 1,
      "message": "Do we need to static_assert that AtomicWord can hold a pointer without truncation? Or will compiler warnings catch that for us?",
      "range": {
        "startLine": 114,
        "startChar": 16,
        "endLine": 114,
        "endChar": 27
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "883da27f_d5fd5a36",
        "filename": "chrome/common/profiling/memlog_allocator_shim.cc",
        "patchSetId": 25
      },
      "lineNbr": 114,
      "author": {
        "id": 1115906
      },
      "writtenOn": "2017-10-24T19:15:42Z",
      "side": 1,
      "message": "compiler warning will catch it [I think], and also the definition says that AtomicWord is defined as being a machine-sized pointer:\nhttps://cs.chromium.org/chromium/src/base/atomicops.h?type\u003dcs\u0026q\u003dAtomicWord\u0026sq\u003dpackage:chromium\u0026l\u003d67",
      "parentUuid": "d8c8c89b_4d7c91a9",
      "range": {
        "startLine": 114,
        "startChar": 16,
        "endLine": 114,
        "endChar": 27
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "81b27cf6_61069ae2",
        "filename": "chrome/common/profiling/memlog_sender_pipe.h",
        "patchSetId": 25
      },
      "lineNbr": 23,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T20:44:05Z",
      "side": 1,
      "message": "move these behind functions?",
      "range": {
        "startLine": 23,
        "startChar": 15,
        "endLine": 23,
        "endChar": 36
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "943fbd8f_2e0c201b",
        "filename": "chrome/common/profiling/memlog_sender_pipe.h",
        "patchSetId": 25
      },
      "lineNbr": 23,
      "author": {
        "id": 1115906
      },
      "writtenOn": "2017-10-24T20:52:57Z",
      "side": 1,
      "message": "Is that going to improve readability? I\u0027d prefer to keep as is.",
      "parentUuid": "81b27cf6_61069ae2",
      "range": {
        "startLine": 23,
        "startChar": 15,
        "endLine": 23,
        "endChar": 36
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04915013_9fedd6a3",
        "filename": "chrome/common/profiling/memlog_sender_pipe_win.cc",
        "patchSetId": 25
      },
      "lineNbr": 29,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "I don\u0027t think I understand the synchronization of this variable. You are grabbing a lock here before resetting. How do you guarantee the write isn\u0027t going to be sheered?",
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ad081e7_644b26a0",
        "filename": "chrome/common/profiling/memlog_sender_pipe_win.cc",
        "patchSetId": 25
      },
      "lineNbr": 43,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "const?  Or just remove all these extra constants that have only one user?",
      "range": {
        "startLine": 43,
        "startChar": 8,
        "endLine": 43,
        "endChar": 18
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63531d3d_3a334ddb",
        "filename": "chrome/common/profiling/memlog_sender_pipe_win.cc",
        "patchSetId": 25
      },
      "lineNbr": 51,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "justfify with the rest of the // comments.",
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0272e357_e201c851",
        "filename": "chrome/common/profiling/memlog_sender_pipe_win.cc",
        "patchSetId": 25
      },
      "lineNbr": 56,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "Why bother with the constant here?\n\nIn fact, for most of these mode constants, I\u0027m not sure it\u0027s clearier with a const pulled out?",
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ca640b5_da5dec7f",
        "filename": "chrome/common/profiling/memlog_sender_pipe_win.cc",
        "patchSetId": 25
      },
      "lineNbr": 74,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "nit: use \u003d\u003d 0 if it\u0027s semantically supposed to return 0.",
      "range": {
        "startLine": 74,
        "startChar": 55,
        "endLine": 74,
        "endChar": 62
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c67bd88_03b9c066",
        "filename": "chrome/common/profiling/memlog_sender_pipe_win.cc",
        "patchSetId": 25
      },
      "lineNbr": 100,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "I *think* you\u0027re using g_waiting_for_write to synchronize with the global callback on the assumption that the lock serializes all callers. Thus, I think you should DCHECK this is false?\n\nAlso, can this timeout logic just be done via SetCommTimeouts() on the handle instead of moving to async writes?\n  https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v\u003dvs.85).aspx\n \n(FYI, I\u0027m just reading the docs so I have no experience here...)",
      "range": {
        "startLine": 100,
        "startChar": 5,
        "endLine": 100,
        "endChar": 11
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0fcacf61_bc5259e6",
        "filename": "chrome/common/profiling/memlog_sender_pipe_win.cc",
        "patchSetId": 25
      },
      "lineNbr": 120,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "What happens if you get woken up by a different AsyncIO on this thread?\n\nI think you need to check g_waiting_for_write here and loop?",
      "range": {
        "startLine": 120,
        "startChar": 8,
        "endLine": 120,
        "endChar": 21
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bee98495_626d29be",
        "filename": "chrome/common/profiling/profiling_client.cc",
        "patchSetId": 25
      },
      "lineNbr": 56,
      "author": {
        "id": 1000046
      },
      "writtenOn": "2017-10-24T21:03:45Z",
      "side": 1,
      "message": "10000 is a magic number. Make a constant?",
      "range": {
        "startLine": 56,
        "startChar": 62,
        "endLine": 56,
        "endChar": 63
      },
      "revId": "5d68fea79499048171ec09220f163ca8e62f9f7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}