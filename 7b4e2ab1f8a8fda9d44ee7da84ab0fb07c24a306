{
  "comments": [
    {
      "key": {
        "uuid": "c46df79c_e145ebd9",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 166,
      "author": {
        "id": 1001472
      },
      "writtenOn": "2017-12-11T08:23:31Z",
      "side": 1,
      "message": "DCHECK(callback \u0026\u0026 *callback); maybe",
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8de6225_c452af97",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 166,
      "author": {
        "id": 1234245
      },
      "writtenOn": "2017-12-12T01:37:59Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "c46df79c_e145ebd9",
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dcca00a6_abce65bc",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1116284
      },
      "writtenOn": "2017-12-11T18:11:08Z",
      "side": 1,
      "message": "RunAfterStartWorker is async. What\u0027s keeping callback alive? Same question with \u0026callback instances below.",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30083f8b_2ab31c76",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1234245
      },
      "writtenOn": "2017-12-12T01:37:59Z",
      "side": 1,
      "message": "Thanks for catching this!\nWe would need to have a shared container for callback which can be passed to OnStatusCallback to prevent the callback from going out of scope.\nI think we can use base::AdaptCallbackForRepeating here because everything else will most likely result in something similar to itâ€‹.",
      "parentUuid": "dcca00a6_abce65bc",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18f779ce_cd6b30fa",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1001472
      },
      "writtenOn": "2017-12-12T03:51:28Z",
      "side": 1,
      "message": "That\u0027s a good catch...\n\nReg: AdaptCallbackForRepeating: it returns a repeating callback, while we\u0027re trying to convert things to take oncecallback, how would it work?  Will we be creating a wrapped one, and then again doing BindOnce to something like OnStatusCallback...? It feels things are getting a bit convoluted. Hm.",
      "parentUuid": "30083f8b_2ab31c76",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "587a3da4_561241b1",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1116284
      },
      "writtenOn": "2017-12-12T12:48:25Z",
      "side": 1,
      "message": "AdaptedCallbackForRepeating seems reasonable. Something like:\n\nusing RepeatingStatusCallback \u003d\n    base::RepeatingCallback\u003cvoid(ServiceWorkerStatusCode)\u003e;\n\nvoid OnStatusCallback(const RepeatingStatusCallback\u0026 callback,\n                      ServiceWorkerStatusCode status) {\n  callback.Run(status);\n}\n\n// and then in DispatchSyncEvent...\n\nRepeatingStatusCallback repeating_callback \u003d\n    base::AdaptCallbackForRepeating(std::move(callback));\n\nactive_version-\u003eRunAfterStartWorker(\n    ServiceWorkerMetrics::EventType::SYNC,\n    base::BindOnce(\u0026BackgroundSyncManager::DispatchSyncEvent,\n                   weak_ptr_factory_.GetWeakPtr(),\n                   tag,\n                   active_version,\n                   last_chance,\n                   base::BindOnce(\u0026OnStatusCallback,\n                                  repeating_callback)),\n    base::BindOnce(\u0026OnStatusCallback, repeating_callback));",
      "parentUuid": "18f779ce_cd6b30fa",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "faaa8cb6_81d44dfc",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1234245
      },
      "writtenOn": "2017-12-12T13:38:57Z",
      "side": 1,
      "message": "It feels like this could be exactly what kinuko meant with things getting convoluted.\nWe can avoid adding OnStatusCallback if we do something like:\n\nauto repeating_callback \u003d base::AdaptCallbackForRepeating(std::move(callback));\n\nactive_version-\u003eRunAfterStartWorker(\n    ServiceWorkerMetrics::EventType::SYNC,\n    base::BindOnce(\u0026BackgroundSyncManager::DispatchSyncEvent,\n                   weak_ptr_factory_.GetWeakPtr(),\n                   tag,\n                   active_version,\n                   last_chance,\n                   repeating_callback),\n    repeating_callback);\n...\n\nThe other solution would be adding a shared container for the callback and pass that to OnStatusCallback, but if you take a look at how AdaptCallbackForRepeating is implemented, it feels like we would implement a specialized version of it:\n\nstruct StatusCallbackContainer {\n  ServiceWorkerVersion::StatusCallback callback;\n\n  StatusCallbackContainer(\n      ServiceWorkerVersion::StatusCallback callback)\n          : callback(std::move(callback)) {}\n  ~StatusCallbackContainer() {}\n}\n\nvoid OnStatusCallback(\n    std::shared_ptr\u003cStatusCallbackContainer\u003e container,\n    ServiceWorkerStatusCode status) {\n  DCHECK(container-\u003ecallback);\n  std::move(container-\u003ecallback).Run(status);\n}\n\n// and then in DispatchSyncEvent...\n\nauto callback_container \u003d\n    std::make_shared\u003cStatusCallbackContainer\u003e(std::move(callback));\n\nactive_version-\u003eRunAfterStartWorker(\n    ServiceWorkerMetrics::EventType::SYNC,\n    base::BindOnce(\u0026BackgroundSyncManager::DispatchSyncEvent,\n                   weak_ptr_factory_.GetWeakPtr(),\n                   tag,\n                   active_version,\n                   last_chance,\n                   base::BindOnce(\u0026OnStatusCallback,\n                                  callback_container)),\n    base::BindOnce(\u0026OnStatusCallback, callback_container));",
      "parentUuid": "587a3da4_561241b1",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c91f48d_dce0e0fa",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1116284
      },
      "writtenOn": "2017-12-12T14:08:29Z",
      "side": 1,
      "message": "The first option you propose requires RunAfterStartWorker to take RepeatingCallbacks as parameters.\n\nThe second, as you say, is similar to AdaptCallbackForRepeating.",
      "parentUuid": "faaa8cb6_81d44dfc",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9c2868d_efb8940f",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1234245
      },
      "writtenOn": "2017-12-12T14:27:37Z",
      "side": 1,
      "message": "Maybe I\u0027m wrong, but AFAIK RepeatingCallbacks can be passed to functions taking OnceCallbacks, but OnceCallbacks cannot be passed as RepeatingCallbacks.",
      "parentUuid": "8c91f48d_dce0e0fa",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d688ef5b_591aa7a0",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1116284
      },
      "writtenOn": "2017-12-12T16:35:53Z",
      "side": 1,
      "message": "My understanding is that when you convert a RepeatingCallback to a OnceCallback, the internal bind state of the RepeatingCallback is std::move\u0027d to the OnceCallback. So I don\u0027t think you could use it in this case as you want to pass the RepeatingCallback in multiple places.",
      "parentUuid": "c9c2868d_efb8940f",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02ee4dd8_1241f8a7",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1001349
      },
      "writtenOn": "2017-12-12T20:18:45Z",
      "side": 1,
      "message": "Drive by without context: If a function takes a OnceCallback you can safely pass a RepeatingCallback by value, i.e. you\u0027re making a copy of the RepeatingCallback, and only the copy is invalidated.\n\nSo this is safe:\n\nRepeatingCallback r \u003d ...;\nDoSomethingOnce(r); // gets a copy of f, which is then once-ified\nr.Run(); // still valid\n\nI\u0027d tossed some related notes in https://docs.google.com/document/d/1puS9pklOsPyk2CCRaCW3ZlEr8z30ruazAIJXHFHdB1s/edit\n\n(I didn\u0027t parse the whole thread, sorry if this is not helpful)",
      "parentUuid": "d688ef5b_591aa7a0",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9eef757_3bf783e8",
        "filename": "content/browser/background_sync/background_sync_manager.cc",
        "patchSetId": 4
      },
      "lineNbr": 779,
      "author": {
        "id": 1116284
      },
      "writtenOn": "2017-12-12T23:04:35Z",
      "side": 1,
      "message": "Ah, makes sense, thanks! For some reason I thought RepeatingCallback was ref counted.",
      "parentUuid": "02ee4dd8_1241f8a7",
      "range": {
        "startLine": 779,
        "startChar": 57,
        "endLine": 779,
        "endChar": 66
      },
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea6d909e_6246acdb",
        "filename": "content/browser/notifications/notification_event_dispatcher_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 52,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-12-11T05:39:59Z",
      "side": 1,
      "message": "Is this the same as \"const NotificationDispatchCompleteCallback*\"?\n\nconst* is rarely seen in Chromium codebase.",
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3400f408_90ef2a54",
        "filename": "content/browser/notifications/notification_event_dispatcher_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 52,
      "author": {
        "id": 1234245
      },
      "writtenOn": "2017-12-12T01:37:59Z",
      "side": 1,
      "message": "It\u0027s both a non-const pointer to a const callback, â€‹so yes, they are the same.\nBut let\u0027s leave this as \"const NotificationDispatchCompleteCallback\u0026\" for now because of what jkarlin@ brought up and deal with it when/if we migrate NotificationDispatchCompleteCallback.",
      "parentUuid": "ea6d909e_6246acdb",
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65c5fb63_4a71c766",
        "filename": "content/browser/notifications/notification_event_dispatcher_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 53,
      "author": {
        "id": 1001472
      },
      "writtenOn": "2017-12-11T08:23:31Z",
      "side": 1,
      "message": "DCHECK(dispatch_complete_callback \u0026\u0026 *dispatch_complete_callback);",
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30ab12bc_83fdf004",
        "filename": "content/browser/notifications/notification_event_dispatcher_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 53,
      "author": {
        "id": 1234245
      },
      "writtenOn": "2017-12-12T01:37:59Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "65c5fb63_4a71c766",
      "revId": "7b4e2ab1f8a8fda9d44ee7da84ab0fb07c24a306",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}