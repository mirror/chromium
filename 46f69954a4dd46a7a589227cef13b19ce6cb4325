{
  "comments": [
    {
      "key": {
        "uuid": "cf6c9e52_2267ea8e",
        "filename": "third_party/WebKit/Source/platform/wtf/ConstructTraits.h",
        "patchSetId": 12
      },
      "lineNbr": 25,
      "author": {
        "id": 1115916
      },
      "writtenOn": "2017-12-20T12:14:25Z",
      "side": 1,
      "message": "Why do we need to pass in VectorTraits\u003cT\u003e?",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3dca8c2_e3ec0c4a",
        "filename": "third_party/WebKit/Source/platform/wtf/ConstructTraits.h",
        "patchSetId": 12
      },
      "lineNbr": 25,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2017-12-20T12:24:07Z",
      "side": 1,
      "message": "Eager tracing requires traits.",
      "parentUuid": "cf6c9e52_2267ea8e",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6f99cb6c_da09ccc3",
        "filename": "third_party/WebKit/Source/platform/wtf/ConstructTraits.h",
        "patchSetId": 12
      },
      "lineNbr": 25,
      "author": {
        "id": 1115916
      },
      "writtenOn": "2017-12-20T15:08:11Z",
      "side": 1,
      "message": "How are you planning to handle HeapHashTable, HeapTerminatedArray, HeapListHashSet...?",
      "parentUuid": "a3dca8c2_e3ec0c4a",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c0319c2a_3c79bccd",
        "filename": "third_party/WebKit/Source/platform/wtf/ConstructTraits.h",
        "patchSetId": 12
      },
      "lineNbr": 25,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2017-12-20T22:37:32Z",
      "side": 1,
      "message": "They should just use the same approach (ConstructTraits). I will hold off with landing this one until I have at least a working HeapHashSet (which is using HashTable) CL including tests that shows that the approach is general enough to cover all cases.",
      "parentUuid": "6f99cb6c_da09ccc3",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "09dd0d41_1837be22",
        "filename": "third_party/WebKit/Source/platform/wtf/ConstructTraits.h",
        "patchSetId": 12
      },
      "lineNbr": 25,
      "author": {
        "id": 1115916
      },
      "writtenOn": "2017-12-21T07:24:01Z",
      "side": 1,
      "message": "I like the idea of dispatching an incremental marking only at the end of the event loop.\n\nHowever, in that case, doing an eager tracing here would be not safe at least potentially. What would happen if the eager tracing traces a not-fully constructed object?\n\nI think we should stick to the principle that an incremental marking does not run during an event loop.\n\ni.e., instead of tracing into the vector, we should add a write barrier to the backing store of the HeapVector.",
      "parentUuid": "c0319c2a_3c79bccd",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c2de6c5_1a2674ae",
        "filename": "third_party/WebKit/Source/platform/wtf/ConstructTraits.h",
        "patchSetId": 12
      },
      "lineNbr": 25,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2017-12-21T08:42:18Z",
      "side": 1,
      "message": "We are not tracing eagerly during construction here, we are only tracing after constructing an object in the container.\n\nFor in-place constructed objects that have no mark bits we need to do this as the other alternative would be adding the vector backing + index of the element to the marking deque. This  look completely ad hoc and non-uniform which is why I\u0027d like to avoid it.",
      "parentUuid": "09dd0d41_1837be22",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3bd003c8_022c97b3",
        "filename": "third_party/WebKit/Source/platform/wtf/ConstructTraits.h",
        "patchSetId": 12
      },
      "lineNbr": 25,
      "author": {
        "id": 1115916
      },
      "writtenOn": "2017-12-21T08:46:50Z",
      "side": 1,
      "message": "What happens in the following case?\n\nclass Y : public GarbageCollected\u003cY\u003e {\n  Y() {\n    vector_.push_back(...);  // This may cause the eager tracing and trace X being constructed.\n  }\n  HeapVector\u003cClassThatHasTrace\u003e vector_;\n};\n\nclass X : Y {\n  X(Z* z) :\n    Y(),\n    z_(z)  // Who traces z_?\n  { }\n  Member\u003cZ\u003e z_;\n};",
      "parentUuid": "7c2de6c5_1a2674ae",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e801e8dd_bb7dbb9e",
        "filename": "third_party/WebKit/Source/platform/wtf/Vector.h",
        "patchSetId": 12
      },
      "lineNbr": 170,
      "author": {
        "id": 1115916
      },
      "writtenOn": "2017-12-20T12:14:25Z",
      "side": 1,
      "message": "I\u0027m wondering if we can simply write this as:\n\n  Allocator::ConstructElement\u003cT\u003e(src, len);\n\nYou can put the \u0027new (NotNull, location) ...\u0027 statement to HeapAllocator\u003cT\u003e::ConstructElement and PartitionAllocator\u003cT\u003e::ConstructElement.\n\nThen you can inline NotifyNewObjects in HeapAllocator::ConstructElement.",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e584f8d_e6ef92ac",
        "filename": "third_party/WebKit/Source/platform/wtf/Vector.h",
        "patchSetId": 12
      },
      "lineNbr": 170,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2017-12-20T12:24:07Z",
      "side": 1,
      "message": "We could do that but then the specialization for Member\u003cT\u003e would involve HeapAllocator which does not seem like a good design.\n\nI got used to the concept of specializing on traits on not the allocator.\n\nLet me know if you feel strongly about this one.",
      "parentUuid": "e801e8dd_bb7dbb9e",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37af05a8_f27aa646",
        "filename": "third_party/WebKit/Source/platform/wtf/Vector.h",
        "patchSetId": 12
      },
      "lineNbr": 170,
      "author": {
        "id": 1115916
      },
      "writtenOn": "2017-12-20T15:08:11Z",
      "side": 1,
      "message": "Okay.\n\nI\u0027d just say that the common pattern in oilpan is to define IsMember in Member.h and use IsMember\u003cT\u003e::value in other places (like HeapAllocator).",
      "parentUuid": "0e584f8d_e6ef92ac",
      "revId": "46f69954a4dd46a7a589227cef13b19ce6cb4325",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}