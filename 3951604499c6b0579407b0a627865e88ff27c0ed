{
  "comments": [
    {
      "key": {
        "uuid": "27857af1_5a8bb466",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 82,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "Is this a situation we actually expect to have to handle at runtime? If not, we could consider making this a crashable offense by replacing it with a CHECK or DCHECK.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "109ecaf1_dd8f34d4",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 82,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done. Changed to DCHECK.",
      "parentUuid": "27857af1_5a8bb466",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c1e29ec9_2afe130e",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 87,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "Is this a situation that we actually expect to have to handle at runtime? If not, we could instead do a (much cheaper) CHECK or DCHECK in the constructor.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1fd4ac4_07626b78",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 87,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done. Changed to DCHECK.",
      "parentUuid": "c1e29ec9_2afe130e",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2912cb59_dd78ed48",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 96,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "location nit: Consider moving the comment closer to what it explains, i.e. directly above line 102.\n\nphrasing nit: \"... should keep alive\" -\u003e \"... must be kept alive\"",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "741d3e2a_16f0f353",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 96,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2912cb59_dd78ed48",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8342cbd1_23cea2e6",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 308,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "After having read the implementation, I realize that what this class does is very similar to what class VideoCaptureController does, i.e. maintaining buffer contexts and translating between buffer_ids used by the producer side and buffer_context_ids used by the consumer side. \n\nThe only difference seems to be that VideoCaptureController allows multiple clients, but it should be possible to abstract out that distinction. I recommend exploring whether or not we can find a way to do that and share the common functionality and tests between the two classes.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5932f301_47909289",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 308,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Yes, that is true. This is a simplified version of VideoCaptureController that only handles one device and one client. I actually tried both but finally decided with this way because it is not easy to move VideoCaptureController and VideoCaptureControllerEventHandler to content/public. But I agree that by using VideoCaptureController might be better for maintenance. So open to suggestions. :)\n \n+miu@",
      "parentUuid": "8342cbd1_23cea2e6",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "552b510c_0d8388be",
        "filename": "chrome/browser/media/single_client_video_capture_host.h",
        "patchSetId": 6
      },
      "lineNbr": 26,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "nit: Class name and description is already much better now. A minor improvement that could still be considered is to give the reader something more specific than just \"a single video capture device\", i.e. pointing to an actual interface name would be nice. In our case that would probably be content::LaunchedVideoCaptureDevice.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3368baff_c1f6e846",
        "filename": "chrome/browser/media/single_client_video_capture_host.h",
        "patchSetId": 6
      },
      "lineNbr": 26,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "552b510c_0d8388be",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e23a275b_0bb8832f",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "RunUntilIdle() is not a very robust way of waiting for an event. There should always be a way to explicitly wait for an event using base::RunLoop. If not, that typically indicates a design problem where an event to wait on is missing in the API.\n\nPlease check if you can find a way to replace with with a pair of base::RunLoop::Run() and base::RunLoop::Quit() calls.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea54891a_3ac3b942",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Will do in a later patch. Thanks.",
      "parentUuid": "e23a275b_0bb8832f",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9e87e3b_bb4bc2b0",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-02-01T00:24:25Z",
      "side": 1,
      "message": "Done. Changed to using base:RunLoop::Run() and base::RunLoop::Quit() to explicitly wait for an event.",
      "parentUuid": "ea54891a_3ac3b942",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "229a527a_303be55b",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 272,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "Is it valid in gmock that an expectation is set after it occurs?\nIf not, does this only work because FinishConsumingBuffer() leads to a call to OnUtilizationReport() asynchronously?",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d948a09_21531529",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 272,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Ah, yes, the expectation should be set before. Thanks for catching this. :)",
      "parentUuid": "229a527a_303be55b",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}