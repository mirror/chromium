{
  "comments": [
    {
      "key": {
        "uuid": "27857af1_5a8bb466",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 82,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "Is this a situation we actually expect to have to handle at runtime? If not, we could consider making this a crashable offense by replacing it with a CHECK or DCHECK.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "109ecaf1_dd8f34d4",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 82,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done. Changed to DCHECK.",
      "parentUuid": "27857af1_5a8bb466",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c1e29ec9_2afe130e",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 87,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "Is this a situation that we actually expect to have to handle at runtime? If not, we could instead do a (much cheaper) CHECK or DCHECK in the constructor.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1fd4ac4_07626b78",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 87,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done. Changed to DCHECK.",
      "parentUuid": "c1e29ec9_2afe130e",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2912cb59_dd78ed48",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 96,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "location nit: Consider moving the comment closer to what it explains, i.e. directly above line 102.\n\nphrasing nit: \"... should keep alive\" -\u003e \"... must be kept alive\"",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "741d3e2a_16f0f353",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 96,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2912cb59_dd78ed48",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8342cbd1_23cea2e6",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 308,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "After having read the implementation, I realize that what this class does is very similar to what class VideoCaptureController does, i.e. maintaining buffer contexts and translating between buffer_ids used by the producer side and buffer_context_ids used by the consumer side. \n\nThe only difference seems to be that VideoCaptureController allows multiple clients, but it should be possible to abstract out that distinction. I recommend exploring whether or not we can find a way to do that and share the common functionality and tests between the two classes.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5932f301_47909289",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 308,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Yes, that is true. This is a simplified version of VideoCaptureController that only handles one device and one client. I actually tried both but finally decided with this way because it is not easy to move VideoCaptureController and VideoCaptureControllerEventHandler to content/public. But I agree that by using VideoCaptureController might be better for maintenance. So open to suggestions. :)\n \n+miu@",
      "parentUuid": "8342cbd1_23cea2e6",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b56390f9_177eb441",
        "filename": "chrome/browser/media/single_client_video_capture_host.cc",
        "patchSetId": 6
      },
      "lineNbr": 308,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2018-02-01T06:34:35Z",
      "side": 1,
      "message": "One main issue is that VCC is currently private content code that can\u0027t easily be factored out into a more-common location, like src/media/capture. It has internal-to-content dependencies. Also, a public interface for a \"library class\" isn\u0027t appropriate since, generally, content/public/browser is supposed to just be an embedder interface.\n\nI think what\u0027s happened here is that we\u0027ve started re-using just enough of the video capture code (i.e., the mojo interfaces and VCBufferContext) to open up discussion about more re-use of other things. However, based on my personal experience, refactoring and setting everything up for that might add so much complexity as to negate the benefits of sharing the code in the first place. In other words, VCC is a lot of controller logic centered around juggling multiple consumers from one video capture device and tracking that they\u0027ve all seen and finished with each video frame (in any random order). But here, we don\u0027t need a \"controller\" at all because it\u0027s just one device\u0027s frames going to one consumer only. What we have here is just a simple \"adapter\" between two APIs.",
      "parentUuid": "5932f301_47909289",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "552b510c_0d8388be",
        "filename": "chrome/browser/media/single_client_video_capture_host.h",
        "patchSetId": 6
      },
      "lineNbr": 26,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "nit: Class name and description is already much better now. A minor improvement that could still be considered is to give the reader something more specific than just \"a single video capture device\", i.e. pointing to an actual interface name would be nice. In our case that would probably be content::LaunchedVideoCaptureDevice.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3368baff_c1f6e846",
        "filename": "chrome/browser/media/single_client_video_capture_host.h",
        "patchSetId": 6
      },
      "lineNbr": 26,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "552b510c_0d8388be",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e23a275b_0bb8832f",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "RunUntilIdle() is not a very robust way of waiting for an event. There should always be a way to explicitly wait for an event using base::RunLoop. If not, that typically indicates a design problem where an event to wait on is missing in the API.\n\nPlease check if you can find a way to replace with with a pair of base::RunLoop::Run() and base::RunLoop::Quit() calls.",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea54891a_3ac3b942",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Will do in a later patch. Thanks.",
      "parentUuid": "e23a275b_0bb8832f",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9e87e3b_bb4bc2b0",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-02-01T00:24:25Z",
      "side": 1,
      "message": "Done. Changed to using base:RunLoop::Run() and base::RunLoop::Quit() to explicitly wait for an event.",
      "parentUuid": "ea54891a_3ac3b942",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "229a527a_303be55b",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 272,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-31T20:06:07Z",
      "side": 1,
      "message": "Is it valid in gmock that an expectation is set after it occurs?\nIf not, does this only work because FinishConsumingBuffer() leads to a call to OnUtilizationReport() asynchronously?",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d948a09_21531529",
        "filename": "chrome/browser/media/single_client_video_capture_host_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 272,
      "author": {
        "id": 1157930
      },
      "writtenOn": "2018-01-31T22:26:00Z",
      "side": 1,
      "message": "Ah, yes, the expectation should be set before. Thanks for catching this. :)",
      "parentUuid": "229a527a_303be55b",
      "revId": "3951604499c6b0579407b0a627865e88ff27c0ed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}