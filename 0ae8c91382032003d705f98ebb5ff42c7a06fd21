{
  "comments": [
    {
      "key": {
        "uuid": "6e578548_92e23533",
        "filename": "third_party/WebKit/Source/core/dom/Element.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3096,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2017-12-07T09:52:54Z",
      "side": 1,
      "message": "What is the criteria for selecting these elements?\n\nI guess they require special treatment even when empty string is given for innerHTML\n- but the readers of this code are not sure whether they are exhaustive, or if anything\nchanges (e.g. spec requirement etc.) does this optimization break?\n\nEven we copy the behavior of Mozilla, it looks Firefox also sets \"HasWeirdParserInsertionMode\"\nin HTMLSharedElement class, which is inherited by various elements, which seems missing.\n\nWe have a different implementation of HTML parser than Mozilla\u0027s, and the requirements\ncould be different.\n\nHmm, how can we make sure the set of elements that are optimizable...?",
      "revId": "0ae8c91382032003d705f98ebb5ff42c7a06fd21",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1633624_9b0174b3",
        "filename": "third_party/WebKit/Source/core/dom/Element.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3096,
      "author": {
        "id": 1247388
      },
      "writtenOn": "2017-12-07T10:30:05Z",
      "side": 1,
      "message": "This if clause is basically what Mozilla\u0027s HasWeirdParserInsertionMode does. These elements might have an insertion mode that might add some elements eventhough the text itself doesn\u0027t contain any markups (https://html.spec.whatwg.org/multipage/parsing.html#reset-the-insertion-mode-appropriately), so we can\u0027t skip the parsing and only edit the text content.\n\nThis function will only return true (optimize, skip the parsing and just update text content) if the text contains no markup and does not add any elements that aren\u0027t in the given string, so it should be fine, I think.",
      "parentUuid": "6e578548_92e23533",
      "revId": "0ae8c91382032003d705f98ebb5ff42c7a06fd21",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41c7cdc9_aa689ede",
        "filename": "third_party/WebKit/Source/core/dom/Element.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3096,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2017-12-11T08:09:40Z",
      "side": 1,
      "message": "Thanks, I think I now understand what element can be optimized.\n\nI checked Mozilla\u0027s HasWeirdParserInsertionMode,\nhttps://dxr.mozilla.org/mozilla-central/search?q\u003d%2Bfunction-ref%3AnsINode%3A%3ASetHasWeirdParserInsertionMode%28%29\nand HTMLSharedElement class,\nhttps://dxr.mozilla.org/mozilla-central/source/dom/html/HTMLSharedElement.h\ncalls SetHasWeirdParserInsertionMode() when the element is \u003chtml\u003e or \u003chead\u003e.\nBut this function lacks check for IsHTMLHeadElement().\n\nImagine in the future someone adds a new HTML \u003cfoo\u003e element, which has some special\nparsing rule and cannot apply this optimization - how the implementer can notice\nthat this function has to be modified, in addition to adding HTMLFooElement.{h,cpp}?",
      "parentUuid": "f1633624_9b0174b3",
      "revId": "0ae8c91382032003d705f98ebb5ff42c7a06fd21",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2fcecdbe_75ea0999",
        "filename": "third_party/WebKit/Source/core/dom/Element.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3096,
      "author": {
        "id": 1247388
      },
      "writtenOn": "2017-12-12T00:04:14Z",
      "side": 1,
      "message": "I see, should I make a virtual function like SetHasWeirdParserInsertionMode/HasWeirdParserInsertionMode in HTMLElement then? But even then, the author of the new element still need to be aware that the function exists, hmmm...",
      "parentUuid": "41c7cdc9_aa689ede",
      "revId": "0ae8c91382032003d705f98ebb5ff42c7a06fd21",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52de0eb9_1a75910b",
        "filename": "third_party/WebKit/Source/core/dom/Element.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3096,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2017-12-13T01:57:11Z",
      "side": 1,
      "message": "That sounds a safer or scalable option than we have to maintain this if conditions\nin the future.\n\nProbably \"not optimize\" is the default safer option, so you could write\n\nclass BaseElement {\n  virtual bool IsOptimizable() { return false; }  // default\n}\n\nand\n\nclass OptimizableElement : BaseElement {\n  bool IsOptimizable() override { return true; }\n}\n\nBut Mozilla\u0027s approach is opposite, probably because elements that cannot be optimized\nis fewer and exceptional than optimizable elements.  But having an outstanding name\n(\"Weird\" in the function name) can draw the reader\u0027s attention, which compensates the\nrisk of overlooking.",
      "parentUuid": "2fcecdbe_75ea0999",
      "revId": "0ae8c91382032003d705f98ebb5ff42c7a06fd21",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "438be613_3a7b6d5f",
        "filename": "third_party/WebKit/Source/core/dom/Element.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3096,
      "author": {
        "id": 1247388
      },
      "writtenOn": "2017-12-14T07:51:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "52de0eb9_1a75910b",
      "revId": "0ae8c91382032003d705f98ebb5ff42c7a06fd21",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}