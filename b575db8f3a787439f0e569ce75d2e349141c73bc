{
  "comments": [
    {
      "key": {
        "uuid": "70aaf23f_2a45af37",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetArticleViewHolder.java",
        "patchSetId": 9
      },
      "lineNbr": 370,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "So we never cancel this callback? What if the viewholder gets rebound before the request returns?",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "014fea20_09c3e8b3",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetArticleViewHolder.java",
        "patchSetId": 9
      },
      "lineNbr": 370,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "We save the fetched image in the snippet article and can use it later. I don\u0027t think these article thumbnail fetches can currently be cancelled from the java side. The call is passed to the backend, which creates tasks and I am not sure how a cancellation is possible there.\n\nIn the download thumbnails cancellation is possible because there is a queue of requests which are served one by one (this is in the thumbnail provider). By cancelling, we remove the request from the queue. But for the article thumbnails the call is passed directly to the backend.\n\nAm I missing something?",
      "parentUuid": "70aaf23f_2a45af37",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96607873_f1702872",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetArticleViewHolder.java",
        "patchSetId": 9
      },
      "lineNbr": 370,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-14T11:13:14Z",
      "side": 1,
      "message": "Right now, rebinding the view holder will cancel the |mImageCallback|, which won\u0027t actually cancel the fetch in the backend (there\u0027s a TODO for that though), but it will invalidate the back-reference to the view holder in the callback, so that if the callback returns, it won\u0027t update a view holder that is now bound to a different article.\n\nLooking through your CL, I see now that you do have a check that the article hasn\u0027t changed, but it relies on using a non-static inner class and generally feels a bit brittle... It\u0027s surprisingly easy to forget about the implicit reference to the outer class and then end up with a memory leak (eg. https://crbug.com/708710).",
      "parentUuid": "014fea20_09c3e8b3",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74d49970_d3dbb06f",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetArticleViewHolder.java",
        "patchSetId": 9
      },
      "lineNbr": 370,
      "author": {
        "id": 1123275
      },
      "writtenOn": "2017-06-14T12:58:48Z",
      "side": 1,
      "message": "Do you mean making it static and cancelling to remove the reference to the view holder would be enough or should we also not propagate the fetched thumbnail to the suggestion? It won\u0027t stop concurrent requests for the same suggestion for now, but at least we would avoid a good number of fetches when scrolling all the way down then back up.\n\n(note: if we keep setting the thumbnail, we should check it has not been set by another completed callback first)",
      "parentUuid": "96607873_f1702872",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d7f0d67_3682fef8",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetArticleViewHolder.java",
        "patchSetId": 9
      },
      "lineNbr": 370,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-14T14:01:06Z",
      "side": 1,
      "message": "\u003e Do you mean making it static and cancelling to remove the reference to the view holder would be enough or should we also not propagate the fetched thumbnail to the suggestion? It won\u0027t stop concurrent requests for the same suggestion for now, but at least we would avoid a good number of fetches when scrolling all the way down then back up.\n\nThe former -- caching the thumbnail for the article is fine, as we assume the thumbnail is not going to change.\n\n\u003e (note: if we keep setting the thumbnail, we should check it has not been set by another completed callback first)\n\nTrue, although we\u0027d have to add a member just for the thumbnail _bitmap_ (so we can distinguish it from the placeholder drawable).",
      "parentUuid": "74d49970_d3dbb06f",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8101309d_19424ba1",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 80,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "Don\u0027t just blindly pepper |mIsDestroyed| checks everywhere, or you\u0027re going to end up with a whole bunch of objects that may or may not be alive at any given point and are just silently going to fail on misuse. It doesn\u0027t make sense for a client of this class to call a method on it after it has been destroyed -- the only time when the check makes sense is when a method in this class is being called from somewhere that doesn\u0027t know whether this object is still in use, for example in callbacks (e.g. from native code) that we can\u0027t cancel on destruction, and which could happen after the UI has been torn down.",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3df4fdb7_fe2700c9",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 80,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "How does a class know that the image fetcher is still in use or not? I thought the onDestroy method is called only when the activity is about to finish anyway?\n\nShould I leave the check in all the public methods and just put asserts in the private methods? And also do the check in the cancellation methods?",
      "parentUuid": "8101309d_19424ba1",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bef65027_9cdda3de",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 80,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-14T11:13:14Z",
      "side": 1,
      "message": "\u003e How does a class know that the image fetcher is still in use or not? I thought the onDestroy method is called only when the activity is about to finish anyway?\n\nSort of -- it\u0027s called when the SuggestionsUiDelegateImpl is destroyed, which happens when the NewTabPage is destroyed, or if ChromeHome is enabled, currently never. The point is though, if the UI is destroyed, how could it happen that someone calls a method on the ImageFetcher?\n\n\u003e Should I leave the check in all the public methods and just put asserts in the private methods? And also do the check in the cancellation methods?\n\nNo, if anything, assert in the public methods. Then you could also assert in the private methods, but you know from where those are called, so those asserts would be a bit redundant.",
      "parentUuid": "3df4fdb7_fe2700c9",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e84c0a0b_e866bbde",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 80,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T15:49:27Z",
      "side": 1,
      "message": "The only entry point to the ImageFetcher from the backend is in DownloadThumbnailRequest.onThumbnailRetreived(). Do you mean I should only have a check there (and asserts in public methods)? Doesn\u0027t that mean that the same should be done for LargeIconCallback.onLargeIconAvailable() and the FaviconCallback.onFaviconAvailable().\n\nWhat would happen if we don\u0027t do any checks? The UI is getting destroyed anyway.",
      "parentUuid": "bef65027_9cdda3de",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49f2038b_3413f8c4",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 80,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-14T16:46:15Z",
      "side": 1,
      "message": "Oh, if we can get rid of the |mIsDestroyed| flag, that would be the best option :) I do remember having had some issues though with callbacks being called after an object had its destroy() method being called, but I can\u0027t remember exactly what they were. Nicolas, do you remember?",
      "parentUuid": "e84c0a0b_e866bbde",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f60c5b2b_79138088",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 136,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "I don\u0027t think the ImageFetcher is actually ever registered as a DestructionObserver. What you should probably do though is have the SuggestionsUiDelegateImpl directly call this method instead of going through an interface -- it knows about the ImageFetcher class (so it\u0027s not a layering violation), and it creates the ImageFetcher instance, so it makes sense for it to destroy it too.",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73da4e39_226f042b",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 136,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f60c5b2b_79138088",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e5a5fe34_b3db4e0d",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 208,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "Be consistent with how you write these comments (equals sign or not, whitespace or no whitespace). My personal favorite is to use an equals sign and spaces around it and inside the comments, i.e. /* useLargeIcon \u003d */.",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9378e608_c0bb294a",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 208,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "Thanks. I just moved this code from another class and didn\u0027t notice the comments :)",
      "parentUuid": "e5a5fe34_b3db4e0d",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "23c39b79_8460e809",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 328,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "What happens if someone cancels the request after the ImageFetcher has been destroyed?",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbc57d27_e3a985d4",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 328,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "Will put a check there.",
      "parentUuid": "23c39b79_8460e809",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6c401f4_a1a10bc6",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 336,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "These classes do all their work in the constructor and are not used otherwise. You could just replace them with plain methods that return void.",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bf8394a_85117ad3",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 336,
      "author": {
        "id": 1123275
      },
      "writtenOn": "2017-06-13T16:11:06Z",
      "side": 1,
      "message": "The goal is to have them be cancellable. Then they would hold sufficient data for the caller to be able to just call `request.cancel()`",
      "parentUuid": "a6c401f4_a1a10bc6",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d576da38_0f664489",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 336,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T16:12:36Z",
      "side": 1,
      "message": "Okay... could we add an empty cancel() method with a TODO to make it work?",
      "parentUuid": "8bf8394a_85117ad3",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59393be1_f1c48f67",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 336,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-13T16:24:33Z",
      "side": 1,
      "message": "From what I understand, the only image that can be cancelled is a download thumbnail though, right? \nIf that\u0027s the case, then we can make them all simple void methods and only the makeDownloadThumbnailRequest() will return a DownloadThumbnailRequest, which will enable cancellation from the SnippetArticleViewHolder.",
      "parentUuid": "d576da38_0f664489",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08583842_a8de458a",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 376,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "Can you only wrap the URI parsing in this try-catch block?",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe1a6869_29557936",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 376,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "Sure. I assume that fetching a favicon will always require the url? So, in fetchFaviconFromLocalCacheOrGoogleServer(..) it will eventually also try to parse the url and fail if it\u0027s badly formed, so better to stop it here?",
      "parentUuid": "08583842_a8de458a",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95892eb2_68271850",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/ImageFetcher.java",
        "patchSetId": 9
      },
      "lineNbr": 376,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-14T16:46:15Z",
      "side": 1,
      "message": "fetchFaviconFromLocalCacheOrGoogleServer() seems to go through a different code path, which looks at existing GURLs on the native side, so maybe it\u0027s actually fair to assume that the URI will always be valid... in which case you could just assert false in the catch block.",
      "parentUuid": "fe1a6869_29557936",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3d4f0c1_3fafa1c7",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/SuggestionsUiDelegate.java",
        "patchSetId": 9
      },
      "lineNbr": 32,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "I might have already mentioned this somewhere else, but I forgot where: Do we actually need to expose the NativePageHost? It looks like this is only needed to get a WebContents for fetching favicons, so could we expose the WebContents instead?",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f407865_824ddaed",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/SuggestionsUiDelegate.java",
        "patchSetId": 9
      },
      "lineNbr": 32,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c3d4f0c1_3fafa1c7",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c57d5e26_6ea3bd7a",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/SuggestionsUiDelegateImpl.java",
        "patchSetId": 9
      },
      "lineNbr": 106,
      "author": {
        "id": 1001606
      },
      "writtenOn": "2017-06-13T15:06:16Z",
      "side": 1,
      "message": "Are these unused now?",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1ba05ae_2bddb522",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/suggestions/SuggestionsUiDelegateImpl.java",
        "patchSetId": 9
      },
      "lineNbr": 106,
      "author": {
        "id": 1195464
      },
      "writtenOn": "2017-06-14T09:52:36Z",
      "side": 1,
      "message": "Yes. Done and gone :)",
      "parentUuid": "c57d5e26_6ea3bd7a",
      "revId": "b575db8f3a787439f0e569ce75d2e349141c73bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}