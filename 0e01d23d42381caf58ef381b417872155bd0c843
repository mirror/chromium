{
  "comments": [
    {
      "key": {
        "uuid": "87c745d5_92cad780",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-14T14:16:25Z",
      "side": 1,
      "message": "So we\u0027re not interested in being able to texture or scanout from these buffers directly? Are renderer processes going to access these buffers using the CPU?",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "138ac6ec_cbe34e5b",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-14T14:33:39Z",
      "side": 1,
      "message": "On some platforms (at least on Intel Kabylake where this is going to be used initially) the buffer is using a format supported by hardware overlay. However, the current video capture service in Chrome does now allow us to pass the buffer from camera to GPU directly because there\u0027s a forced format conversion to I420.\n\nThe buffers may be accessed on CPU in the camera HAL. When the Chrome video capture service gets the camera buffer, the buffer will be converted to I420 and memcpy\u0027ed to a SharedMemory before sending to the renderer process. So currently no other places in Chrome will access this CAMERA_WRITE_CPU_READ_WRITE buffer, and the buffer is mainly used inside the camera HAL and by the camera driver.",
      "parentUuid": "87c745d5_92cad780",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0700a00_f4279646",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-14T19:34:53Z",
      "side": 1,
      "message": "hm, it sounds like SCANOUT_CAMERA_WRITE is what we want here. I can see how some devices might not have scanout support for the formats that the camera produces but that\u0027s not supposed to be a limiting factor with these usage modes. SCANOUT_ really means try to allocate a buffer that can be used for scanout but fallback to GPU read and texturing if necessary. GPU_READ is an implicit requirement for all SCANOUT usage modes as we need to be able to fallback to compositing. If we\u0027re not planning to use the buffer for scanout or gpu read (texturing) then I\u0027m not sure it makes sense as a GMB usage.\n\nWhat format is the camera producing? Are you sure we can\u0027t at least import it for GPU read and texturing? GPU drivers typically support many more formats than scanout hw.",
      "parentUuid": "138ac6ec_cbe34e5b",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "686816d3_2974389d",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-15T01:45:13Z",
      "side": 1,
      "message": "If we want to describe the capability of the camera buffer then it\u0027s SCANOUT_CPU_READ_WRITE_CAMERA_READ_WRITE.\n\n- The buffer is accessible by GPU. This should be a valid assumption on all platforms otherwise it\u0027d be a very bad hardware design. We\u0027ve also been thinking to send the buffer to GPU for processing, such as cropping, rotation, or scaling.\n- The buffer is accessible by CPU. The camera HAL may need to inspect / manipulate the buffer. In Chrome we need to map the buffer and convert the buffer to I420 and memcpy to another SharedMemory buffer.\n- The buffer is accessible by the camera subsystem. The actual format of the buffer is platform-dependent. We may have Intel using one format and some other ARM devices using another format, but in general the buffer should also be accessible by GPU and CPU.\n\nOn ChromeOS with ARC++, the camera HAL gets DMA-buf from cros-gralloc on Android side. Since the camera HAL is providing camera service to both Chrome and ARC++, we want to feed the same type of buffer from Chrome to the camera HAL. My understanding is that in Chrome we need to get the GPU buffers from the GPU process, thus I\u0027m doing these plumbing. Another option would be to let the media capture service to access the DRM render node directly and allocate buffer with minigbm.",
      "parentUuid": "b0700a00_f4279646",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}