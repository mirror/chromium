{
  "comments": [
    {
      "key": {
        "uuid": "87c745d5_92cad780",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-14T14:16:25Z",
      "side": 1,
      "message": "So we\u0027re not interested in being able to texture or scanout from these buffers directly? Are renderer processes going to access these buffers using the CPU?",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "138ac6ec_cbe34e5b",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-14T14:33:39Z",
      "side": 1,
      "message": "On some platforms (at least on Intel Kabylake where this is going to be used initially) the buffer is using a format supported by hardware overlay. However, the current video capture service in Chrome does now allow us to pass the buffer from camera to GPU directly because there\u0027s a forced format conversion to I420.\n\nThe buffers may be accessed on CPU in the camera HAL. When the Chrome video capture service gets the camera buffer, the buffer will be converted to I420 and memcpy\u0027ed to a SharedMemory before sending to the renderer process. So currently no other places in Chrome will access this CAMERA_WRITE_CPU_READ_WRITE buffer, and the buffer is mainly used inside the camera HAL and by the camera driver.",
      "parentUuid": "87c745d5_92cad780",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0700a00_f4279646",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-14T19:34:53Z",
      "side": 1,
      "message": "hm, it sounds like SCANOUT_CAMERA_WRITE is what we want here. I can see how some devices might not have scanout support for the formats that the camera produces but that\u0027s not supposed to be a limiting factor with these usage modes. SCANOUT_ really means try to allocate a buffer that can be used for scanout but fallback to GPU read and texturing if necessary. GPU_READ is an implicit requirement for all SCANOUT usage modes as we need to be able to fallback to compositing. If we\u0027re not planning to use the buffer for scanout or gpu read (texturing) then I\u0027m not sure it makes sense as a GMB usage.\n\nWhat format is the camera producing? Are you sure we can\u0027t at least import it for GPU read and texturing? GPU drivers typically support many more formats than scanout hw.",
      "parentUuid": "138ac6ec_cbe34e5b",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}