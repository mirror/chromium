{
  "comments": [
    {
      "key": {
        "uuid": "87c745d5_92cad780",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-14T14:16:25Z",
      "side": 1,
      "message": "So we\u0027re not interested in being able to texture or scanout from these buffers directly? Are renderer processes going to access these buffers using the CPU?",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "138ac6ec_cbe34e5b",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-14T14:33:39Z",
      "side": 1,
      "message": "On some platforms (at least on Intel Kabylake where this is going to be used initially) the buffer is using a format supported by hardware overlay. However, the current video capture service in Chrome does now allow us to pass the buffer from camera to GPU directly because there\u0027s a forced format conversion to I420.\n\nThe buffers may be accessed on CPU in the camera HAL. When the Chrome video capture service gets the camera buffer, the buffer will be converted to I420 and memcpy\u0027ed to a SharedMemory before sending to the renderer process. So currently no other places in Chrome will access this CAMERA_WRITE_CPU_READ_WRITE buffer, and the buffer is mainly used inside the camera HAL and by the camera driver.",
      "parentUuid": "87c745d5_92cad780",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0700a00_f4279646",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-14T19:34:53Z",
      "side": 1,
      "message": "hm, it sounds like SCANOUT_CAMERA_WRITE is what we want here. I can see how some devices might not have scanout support for the formats that the camera produces but that\u0027s not supposed to be a limiting factor with these usage modes. SCANOUT_ really means try to allocate a buffer that can be used for scanout but fallback to GPU read and texturing if necessary. GPU_READ is an implicit requirement for all SCANOUT usage modes as we need to be able to fallback to compositing. If we\u0027re not planning to use the buffer for scanout or gpu read (texturing) then I\u0027m not sure it makes sense as a GMB usage.\n\nWhat format is the camera producing? Are you sure we can\u0027t at least import it for GPU read and texturing? GPU drivers typically support many more formats than scanout hw.",
      "parentUuid": "138ac6ec_cbe34e5b",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "686816d3_2974389d",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-15T01:45:13Z",
      "side": 1,
      "message": "If we want to describe the capability of the camera buffer then it\u0027s SCANOUT_CPU_READ_WRITE_CAMERA_READ_WRITE.\n\n- The buffer is accessible by GPU. This should be a valid assumption on all platforms otherwise it\u0027d be a very bad hardware design. We\u0027ve also been thinking to send the buffer to GPU for processing, such as cropping, rotation, or scaling.\n- The buffer is accessible by CPU. The camera HAL may need to inspect / manipulate the buffer. In Chrome we need to map the buffer and convert the buffer to I420 and memcpy to another SharedMemory buffer.\n- The buffer is accessible by the camera subsystem. The actual format of the buffer is platform-dependent. We may have Intel using one format and some other ARM devices using another format, but in general the buffer should also be accessible by GPU and CPU.\n\nOn ChromeOS with ARC++, the camera HAL gets DMA-buf from cros-gralloc on Android side. Since the camera HAL is providing camera service to both Chrome and ARC++, we want to feed the same type of buffer from Chrome to the camera HAL. My understanding is that in Chrome we need to get the GPU buffers from the GPU process, thus I\u0027m doing these plumbing. Another option would be to let the media capture service to access the DRM render node directly and allocate buffer with minigbm.",
      "parentUuid": "b0700a00_f4279646",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e18a9c8e_2a333565",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-15T21:56:46Z",
      "side": 1,
      "message": "SCANOUT_CAMERA_READ_WRITE is good. It\u0027s fine that this also means CPU_READ_WRITE implicitly if you include a comment next to the enum value that makes this clear.\n\nThe format can\u0027t be different depending on the platform. However, what formats are supported for this usage can of course change and Chrome can be configured to use a different format depending on the platform and device. But allocating e.g. a YVU_420 buffer with usage SCANOUT_CAMERA_READ_WRITE should always give you a buffer with the same format.\n\nNote that a new usage is only needed for buffers that need to be allocated by Chrome. If a buffer is allocated on the ARC++ side then there\u0027s no need for a new usage to be able to display it in chrome. I assume this is going to be used to allocate buffers in Chrome, right?",
      "parentUuid": "686816d3_2974389d",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ec33a76_31993285",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-16T02:06:49Z",
      "side": 1,
      "message": "For the format: We will have functions that resolve the actual platform-dependent format for SCANOUT_CAMERA_READ_WRITE. On Chrome OS the function will basically try to allocate each possible format and see which one succeed. We can do this because we have only one format per platform that supports SCANOUT_CAMERA_READ_WRITE usage.\n\nFor buffer allocation: Right, Chrome is going to allocate the buffer. The camera HAL needs the client to provide the buffers.",
      "parentUuid": "e18a9c8e_2a333565",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dec22222_394a8693",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-16T14:43:35Z",
      "side": 1,
      "message": "Can we just tell chrome what format to use with a command line flag that can be set differently depending on the board instead of trying formats until we succeed? It\u0027s hard to understand if something is wrong or working as expected when we try and fail something at runtime until success..",
      "parentUuid": "1ec33a76_31993285",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2bbf12a8_7aa2604e",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-16T15:31:48Z",
      "side": 1,
      "message": "The need to resolve the buffer format is due to the flexible format used by Android camera HAL. The camera HAL has two flexible formats: HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED (for camera preview) and HAL_PIXEL_FORMAT_YUV420_888 (for generic YUV processing), which in Android world each board is free to choose a format that suits its needs.\n\nIn ARC++ we need to support multiple boards of different architecture, and each board may need a different buffer format to back the Android flexible formats. So we let the buffer allocator (i.e. cros-gralloc on Android / minigbm on CrOS) to hold the knowledge of the actual formats used on each platform. In all other places we query the buffer allocator to see which format is supported as camera buffer, but since we don\u0027t have a query interface in GpuMemoryBufferManager, I have to do query by actually allocating a buffer.\n\nWe\u0027ve thought about injecting the per-platform buffer format during build time, such as setting flags to some executables or creating an env var which can be consumed by packages that need to know the format. We decided not to do so because we want to consolidate the knowledge about the flexible buffer formats only in the buffer allocator.",
      "parentUuid": "dec22222_394a8693",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6136305_91dbe445",
        "filename": "ui/gfx/buffer_types.h",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-16T15:43:55Z",
      "side": 1,
      "message": "We should move this format to a place where it\u0027s easy to access by all code that needs to be aware of it. Can it be in a \"#define\" or static function of minigbm?",
      "parentUuid": "2bbf12a8_7aa2604e",
      "revId": "0e01d23d42381caf58ef381b417872155bd0c843",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}