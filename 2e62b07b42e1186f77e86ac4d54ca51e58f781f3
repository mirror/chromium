{
  "comments": [
    {
      "key": {
        "uuid": "25bda024_997721ef",
        "filename": "chrome/browser/extensions/extension_csp_bypass_browsertest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-07-12T15:08:47Z",
      "side": 1,
      "message": "nit: no (c)",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "363ec545_18a1824b",
        "filename": "chrome/browser/extensions/extension_csp_bypass_browsertest.cc",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-07-12T15:08:47Z",
      "side": 1,
      "message": "nit: prefer MakeUnique:\nauto dir \u003d base::MakeUnique\u003cTestExtensionDir\u003e();",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "647f8a0c_a4e9add5",
        "filename": "chrome/browser/extensions/extension_csp_bypass_browsertest.cc",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-07-12T15:08:47Z",
      "side": 1,
      "message": "nit: initialize extension (either start with nullptr or make this a ternary)",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1e5e3fc_beb49d9f",
        "filename": "chrome/browser/extensions/extension_csp_bypass_browsertest.cc",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-07-12T15:08:47Z",
      "side": 1,
      "message": "nit: const GURL webui_url(chrome::kChromeUIVersionURL);",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c8e36ac_153f114f",
        "filename": "chrome/renderer/extensions/chrome_extensions_renderer_client.cc",
        "patchSetId": 1
      },
      "lineNbr": 361,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-07-12T15:08:47Z",
      "side": 1,
      "message": "nit: I think this would be a bit cleaner as an early return, i.e.:\nCanScriptBypass...(...) {\n  if ((render_frame-\u003eGetEnabledBindings() \u0026 content::BINDINGS_POLICY_WEB_UI) \u003d\u003d 0) {\n    // Not a privileged WebUI page...\n    return true;\n  }\n\n  \u003cthe rest\u003e\n}",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f135488f_6a9aa7c7",
        "filename": "third_party/WebKit/Source/core/frame/csp/ContentSecurityPolicy.cpp",
        "patchSetId": 1
      },
      "lineNbr": 771,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-07-12T15:08:47Z",
      "side": 1,
      "message": "Hmm... to me, this is a bit weird.  In particular, we have the check above ShouldBypassContentSecurityPolicy(), followed by a check for CanScriptBypassContentSecurityPolicy().  The distinction between the two is a bit ambiguous, and leads to an unintuitive default result of `true` for CanScriptBypassContentSecurityPolicy() (by default, I\u0027d think the result would be false - most scripts can\u0027t bypass CSP).\n\nCan we combine these into one call?  Have ShouldBypassContentSecurityPolicy() call out to the embedder to check the url after determining if the url is in the allowed schemes?  That way, there\u0027s only one method we need to check here, and ShouldBypassContentSecurityPolicy returns the right answer.\n\nBonus: the UseCounter above would be correct again. :)  (Right now, we\u0027d errantly miscount blocked webui injections)",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99acd872_5bf06518",
        "filename": "third_party/WebKit/Source/core/frame/csp/ContentSecurityPolicy.cpp",
        "patchSetId": 1
      },
      "lineNbr": 771,
      "author": {
        "id": 1211509
      },
      "writtenOn": "2017-07-12T15:59:56Z",
      "side": 1,
      "message": "This suggestion makes sense to me, though you\u0027ll need to pass in the frame since it\u0027s a static method.\n\nI wonder, though, if all this plumbing is necessary. How granular do we need to be with the check? Could we add another scheme to the registry (`IsCSPBypassAllowedForScheme()`?), register `chrome:`, and convert the frame\u0027s client\u0027s check into a check on the page\u0027s URL?",
      "parentUuid": "f135488f_6a9aa7c7",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ac943a7_65d6a3ee",
        "filename": "third_party/WebKit/Source/core/frame/csp/ContentSecurityPolicy.cpp",
        "patchSetId": 1
      },
      "lineNbr": 771,
      "author": {
        "id": 1115745
      },
      "writtenOn": "2017-07-12T16:16:59Z",
      "side": 1,
      "message": "One potential issue with that is that it wouldn\u0027t allow component extensions to bypass CSP.  I\u0027m not sure if something like ChromeVox would rely on that or not.",
      "parentUuid": "99acd872_5bf06518",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89dd4571_5567ee8c",
        "filename": "third_party/WebKit/Source/core/frame/csp/ContentSecurityPolicy.cpp",
        "patchSetId": 1
      },
      "lineNbr": 771,
      "author": {
        "id": 1118699
      },
      "writtenOn": "2017-07-13T01:36:04Z",
      "side": 1,
      "message": "My current patch attempts to resolve the issue in a surgically precise way, to minimize the potential for breaking existing use cases, and to avoid performance regressions.\n\nI\u0027m all for Devlin\u0027s suggestion of combining the two in one call if there are no other concerns (such as performance). As a part of such a change, the bypass check would also be applied to other types, not just scripts.\n\nMike\u0027s suggestion of adding another scheme to the scheme registry may constrain component extensions too much. From the security perspective, component extensions are part of Chrome, so they are presumably equally privileged and therefore allowed to bypass CSP. Especially if the two requirements are satisfied: 1) resource needs to be whitelisted by the extension in web_accessible_resources and 2) extension has permission to script on any URL.\n\nSo there are three options here:\n1) Keep as-is (granular CSP enforcement for scripts, odd code).\n2) Combine the two (granular CSP enforcement for any type, nicer code)\n3) Replace patch with new bypass exception registry (inflexible CSP enforcement for any type, nicer code).\n\nWhat should I do?",
      "parentUuid": "5ac943a7_65d6a3ee",
      "revId": "2e62b07b42e1186f77e86ac4d54ca51e58f781f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}