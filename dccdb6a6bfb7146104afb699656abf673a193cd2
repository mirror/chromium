{
  "comments": [
    {
      "key": {
        "uuid": "537e1ed9_28c0c51d",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 50
      },
      "lineNbr": 179,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "nit: actually, verification has a side effect of forcing a flush, i.e. the following sequence is valid:\n\nRender1(glX);\nuint64 fence \u003d glX-\u003eInsertFenceSyncCHROMIUM();\nglX-\u003eOrderingBarrierCHROMIUM();\nglX-\u003eGenSyncTokenCHROMIUM(fence, out_sync_token);",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa894017_9f6e53a9",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 50
      },
      "lineNbr": 179,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Done. I added that GenSyncTokenCHROMIUM forces a shallow flush as a side effect if necessary - is that correct, or does it do a full flush?",
      "parentUuid": "537e1ed9_28c0c51d",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1d0ed7f_6d0a4854",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 50
      },
      "lineNbr": 179,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T01:02:34Z",
      "side": 1,
      "message": "\u003e Done. I added that GenSyncTokenCHROMIUM forces a shallow flush as a side effect if necessary - is that correct, or does it do a full flush?\n\nCorrect, just a shallow flush. Thanks!",
      "parentUuid": "fa894017_9f6e53a9",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "29987573_d934452c",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 50
      },
      "lineNbr": 199,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "nit: an OrderingBarrierCHROMIUM is needed here",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6e45a18_9e8df318",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 50
      },
      "lineNbr": 199,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "29987573_d934452c",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8771f06a_eca75464",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 50
      },
      "lineNbr": 201,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "And here.",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c716b37c_87dc11b3",
        "filename": "docs/design/gpu_synchronization.md",
        "patchSetId": 50
      },
      "lineNbr": 201,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8771f06a_eca75464",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1d91ac35_74f0b6d1",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 50
      },
      "lineNbr": 5147,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "By making these functions Custom, you lost the auto-generation of the extension_flag check.\nYou can either add it manually here, or if it makes sense, go back to regular functions but change the error path to raise GL_INVALID_OPERATION rather than losing the context.",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24db12a7_74e3f09d",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 50
      },
      "lineNbr": 5147,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "I\u0027ve added the extension flag check here, to gles2_cmd_decoder_passthrough_doers, and also to in_process_command_buffer and gpu_command_buffer_stub.\n\nLosing context seems OK if someone is trying to use an unsupported extension, this isn\u0027t going to be happening unexpectedly in the middle of doing something.",
      "parentUuid": "1d91ac35_74f0b6d1",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04d8d50a_13e51574",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc",
        "patchSetId": 50
      },
      "lineNbr": 2810,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "Ditto for the extension_flag check.",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40804352_c790459d",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc",
        "patchSetId": 50
      },
      "lineNbr": 2810,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "I added it to passthrough_doers.cc instead where the rest of the error handling is implemented, should be equivalent.",
      "parentUuid": "04d8d50a_13e51574",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "832bed36_02f0a405",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc",
        "patchSetId": 50
      },
      "lineNbr": 2810,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T01:02:34Z",
      "side": 1,
      "message": "SG.",
      "parentUuid": "40804352_c790459d",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0bd7db52_cae31302",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 50
      },
      "lineNbr": 993,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "This is not safe, because this will be called from the client thread, not the GPU thread, and the decoder (and its dependencies) should only be called from the GPU thread.\n\nTypically, you\u0027d want to implement all this in an equivalent SendGpuFenceOnGpuThread function, and has SendGpuThread just do a QueueTask to post to the GPU thread",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c60bd3d2_69c36504",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 50
      },
      "lineNbr": 993,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Done - this turned out to be a bit tedious since the InProcessCommandBuffer uses base::(Repeating)Closure, so the base::OnceCallback needed AdaptCallbackForRepeating, and I couldn\u0027t use the existing WrapCallback for thread trampolining since that didn\u0027t handle a 1-argument callback, just a closure. Does this look right now?\n\nI added some basic testing in gpu/ipc/client/gpu_context_tests.h and verified that this ends up calling the InProcessCommandBuffer functions successfully when run on Android.",
      "parentUuid": "0bd7db52_cae31302",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "684ad9a0_c2df4dbb",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 50
      },
      "lineNbr": 993,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T01:02:34Z",
      "side": 1,
      "message": "\u003e Done - this turned out to be a bit tedious since the InProcessCommandBuffer uses base::(Repeating)Closure, so the base::OnceCallback needed AdaptCallbackForRepeating\n\nDrats, we should fix that, QueueTask should take OnceClosures instead. Filed https://bugs.chromium.org/p/chromium/issues/detail?id\u003d789349\n\n\u003e and I couldn\u0027t use the existing WrapCallback for thread trampolining since that didn\u0027t handle a 1-argument callback, just a closure. Does this look right now?\n\nThere\u0027s still a thread thing, see comment on l.983.\n\n\u003e I added some basic testing in gpu/ipc/client/gpu_context_tests.h and verified that this ends up calling the InProcessCommandBuffer functions successfully when run on Android.\n\nThanks!",
      "parentUuid": "c60bd3d2_69c36504",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ea0d6e6_9b39b8e4",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 50
      },
      "lineNbr": 1008,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "nit: OnGetGpuFenceHandleCompleteOnGpuThread to indicate the thread?",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd5d5bb3_60ebaf1b",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 50
      },
      "lineNbr": 1008,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0ea0d6e6_9b39b8e4",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bdabd812_534ec3d0",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 50
      },
      "lineNbr": 1029,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "Ditto, need to QueueTask",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b189d1bc_18f14220",
        "filename": "gpu/ipc/in_process_command_buffer.cc",
        "patchSetId": 50
      },
      "lineNbr": 1029,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bdabd812_534ec3d0",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7edc80f6_68645298",
        "filename": "ui/gl/gl_fence_egl.cc",
        "patchSetId": 50
      },
      "lineNbr": 94,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T00:05:08Z",
      "side": 1,
      "message": "I don\u0027t think we need to do this, or even should - even though the context may be lost or not current, the destructor only makes an EGL call, which doesn\u0027t require a current context. At the same time, not destroying the EGL object will cause a leak (destroying the GL context will not destroy it, since it\u0027s an EGL object, not a GL one).",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4374b069_759ef703",
        "filename": "ui/gl/gl_fence_egl.cc",
        "patchSetId": 50
      },
      "lineNbr": 94,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-28T08:26:32Z",
      "side": 1,
      "message": "Done, replaced with this comment:\n\n  // Do nothing. We want the destructor to destroy the EGL fence even if the GL                           \n  // context was lost. The EGL context may still be valid, and this helps avoid                           \n  // leaks.         \n\n(I wasn\u0027t aware that the EGL context can remain valid after losing a GL context.)",
      "parentUuid": "7edc80f6_68645298",
      "revId": "dccdb6a6bfb7146104afb699656abf673a193cd2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}