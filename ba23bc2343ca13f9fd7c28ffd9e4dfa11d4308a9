{
  "comments": [
    {
      "key": {
        "uuid": "8a3c1b76_16b0304b",
        "filename": "ui/views/controls/button/md_text_button.cc",
        "patchSetId": 3
      },
      "lineNbr": 291,
      "author": {
        "id": 1002092
      },
      "writtenOn": "2017-07-17T01:02:51Z",
      "side": 1,
      "message": "does this result in the correct thing for disabled buttons? (i.e. 000000 at 0.1 alpha) -\u003e #e6e6e6\n\nMy first reading of BlendTowardOppositeLuma on a color like 0xcccccc is that it would make it darker, not lighter, since the luma is already bright..\n\nExcept digging in, I see that BlendTowardOppositeLuma ignores the alpha channel of |stroke_color|, in which case it would use 0x757575 not 0xcccccc . Luma of 0x757575 might be just below the threshold so will actually lighten. It\u0027s very borderline though.\n\nBut then..... what is |text_color| for disabled controls? Now it\u0027s 0x9e9e9e So maybe BlendTowardOppositeLuma _will_ actually darken instead.\n\n\nPerhaps we just pick the alpha to use once? Like\n\n\nif (is_prominent) {\n  stroke_color \u003d SK_ColorTRANSPARENT;\n} else {\n  int stroke_alpha;\n  if (state() \u003d\u003d STATE_DISABLED)\n    stroke_alpha \u003d UseMaterialSecondaryButtons() ? 0x40 : ??;\n  else\n    stroke_alpha \u003d UseMaterialSecondaryButtons() ? 0x5f : 0x4e;\n  stroke_color \u003d SkColorSetA(text_color, stroke_alpha);\n}\n\n\nI\u0027m guessing BlendTowardOppositeLuma was chosen over explicitly blending with white to \"lighten\u0027 in case the background is dark, but using more transparency achieves the same thing.\n\n\n(like I said at http://crbug.com/737271#c4, _really_ I think we should just use constants, or theme colors directly. Applying logic here makes adapting to spec changes unnecessarily complex, and I\u0027m not convinced it does the right thing for high contrast themes).",
      "range": {
        "startLine": 291,
        "startChar": 27,
        "endLine": 291,
        "endChar": 48
      },
      "revId": "ba23bc2343ca13f9fd7c28ffd9e4dfa11d4308a9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e186362e_5b6e7e23",
        "filename": "ui/views/controls/button/md_text_button.cc",
        "patchSetId": 3
      },
      "lineNbr": 291,
      "author": {
        "id": 1000805
      },
      "writtenOn": "2017-07-17T20:02:43Z",
      "side": 1,
      "message": "If we want to BlendTowardOppositeLuma(), we need to call GetResultingPaintColor() first with the stroke and whatever-is-behind-the-stroke colors to compute the resulting opaque color.  Otherwise it will do the wrong thing, since as you note it doesn\u0027t take alpha into account (and indeed can\u0027t do so in a sane way).\n\nThe effects of BlendTowardOppositeLuma() and using more transparency won\u0027t be quite the same unless the background color is guaranteed to be pure white or pure black.  If we BlendTowardOppositeLuma(), then we will always modify the stroke color a constant amount regardless of background color, whereas if we use transparency, then as the background color becomes closer to the stroke color, disabled and non-disabled buttons will have more-similar stroke colors to each other.\n\nProbably the BlendTowardOppositeLuma() effect is better, though not hugely.\n\nAs for logic, I agree with you that long-term it would be better to not have complicated logic here, but if one wants a variety of subtle shading effects on things like button strokes, then it just means the constants or logic have to be elsewhere; my proposal is in the theme system itself.  I wouldn\u0027t try to address this in this CL.",
      "parentUuid": "8a3c1b76_16b0304b",
      "range": {
        "startLine": 291,
        "startChar": 27,
        "endLine": 291,
        "endChar": 48
      },
      "revId": "ba23bc2343ca13f9fd7c28ffd9e4dfa11d4308a9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}