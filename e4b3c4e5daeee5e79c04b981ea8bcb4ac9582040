{
  "comments": [
    {
      "key": {
        "uuid": "fbae6e78_70e520ca",
        "filename": "cc/trees/layer_tree_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 1512,
      "author": {
        "id": 1002681
      },
      "writtenOn": "2017-07-31T16:28:21Z",
      "side": 1,
      "message": "I think this should be higher up in the call stack.  LayerTreeHostImpl::RootScrollBegin looks like it might be the right place, it\u0027s called from InputHandlerProxy when target_viewport is set to true (as I think it is in this case, right?). It\u0027s only called for GestureScrollBegin but you should be able to prevent setting a currently scrolling node which should then drop any following GSUs. Returning the right ScrollResult from there might even prevent generating GSUs but I\u0027m not sure how those get generated.",
      "range": {
        "startLine": 1511,
        "startChar": 1,
        "endLine": 1512,
        "endChar": 42
      },
      "revId": "e4b3c4e5daeee5e79c04b981ea8bcb4ac9582040",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1a5775f_6a56f29b",
        "filename": "cc/trees/layer_tree_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 1512,
      "author": {
        "id": 1212214
      },
      "writtenOn": "2017-07-31T18:31:32Z",
      "side": 1,
      "message": "I\u0027m not sure I follow. LayerTreeHostImpl::RootScrollBegin is not on the callstack for scrolls driven by InputHandlerProxy::SynchronouslySetRootScrollOffset as far as I can see. The path is actually quite direct, if you look at the implementation of LayerTreeHostImpl::SetSynchronousInputHandlerRootScrollOffset (which is called directly from the InputHandlerProxy). That function immediately \u0027distributes\u0027 the root scroll, which directly sets scroll offsets on the outer/inner viewport.",
      "parentUuid": "fbae6e78_70e520ca",
      "range": {
        "startLine": 1511,
        "startChar": 1,
        "endLine": 1512,
        "endChar": 42
      },
      "revId": "e4b3c4e5daeee5e79c04b981ea8bcb4ac9582040",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5793477_594f1e9a",
        "filename": "cc/trees/layer_tree_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 1512,
      "author": {
        "id": 1002681
      },
      "writtenOn": "2017-07-31T18:46:38Z",
      "side": 1,
      "message": "Ah, you\u0027re right. Sigh...yet another special path...\n\nThis method shouldn\u0027t exist, we should be calling through the regular DistributeScrollDelta, that already has checks for user_scrollable and will reduce the branching and duplication that leads to bugs like this.\n\nCould you see if you can make this work by calling RootScrollBegin (to set the target to the viewport) followed by DistributeScrollDelta from SetSynchronousInputHandlerRootScrollOffset, rather than calling into this method? Hopefully then you wouldn\u0027t need any additional changes.",
      "parentUuid": "a1a5775f_6a56f29b",
      "range": {
        "startLine": 1511,
        "startChar": 1,
        "endLine": 1512,
        "endChar": 42
      },
      "revId": "e4b3c4e5daeee5e79c04b981ea8bcb4ac9582040",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "612c809a_006e9a58",
        "filename": "cc/trees/layer_tree_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 1512,
      "author": {
        "id": 1212214
      },
      "writtenOn": "2017-08-02T14:45:43Z",
      "side": 1,
      "message": "Discoveries so far:\n\n1. RootScrollBegin calls DistributeScrollDelta (via ScrollBeginImpl), so likely don\u0027t need to call both.\n2. However for viewport scroll nodes it looks like DistributeScrollDelta skips any checks of scrollable - https://cs.chromium.org/chromium/src/cc/trees/layer_tree_host_impl.cc?gsn\u003dCanConsumeDelta\u0026l\u003d3437 :\n\nfor (...) {\n  if (scroll_node \u003d\u003d viewport_scroll_node) {\n    // Add to the current scroll chain\n    break;\n  }\n \n  if (!scroll_node-\u003escrollable) {\n    break; // Without adding to chain\n  }\n\n  if (CanConsumeDelta(scroll_node, *scroll_state)) { // This checks user_scrollable_*.\n\n    // Add to chain.\n  }\n...\n}\n...\nscroll_state-\u003eDistributeToScrollChainDescendant();\n\n\nIt is feasible that DistributeToScrollChainDescendant somehow absorbs the delta if layers aren\u0027t scrollable, but I haven\u0027t been able to follow that logic all the way yet.\n\nI\u0027m going to dig into DistributeToScrollChainDescendant next, let me know if you have any ideas around this area. It\u0027s getting complicated fast! :)",
      "parentUuid": "d5793477_594f1e9a",
      "range": {
        "startLine": 1511,
        "startChar": 1,
        "endLine": 1512,
        "endChar": 42
      },
      "revId": "e4b3c4e5daeee5e79c04b981ea8bcb4ac9582040",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b0cdb0c_dab8fa3a",
        "filename": "cc/trees/layer_tree_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 1512,
      "author": {
        "id": 1212214
      },
      "writtenOn": "2017-08-02T14:53:19Z",
      "side": 1,
      "message": "Small addendum; spoke to majidvp and he opinionated that the scroll chain should only have items that are scrollable (and user scrollable) in it. E.g. the viewport case should go through CanConsumeDelta as well.",
      "parentUuid": "612c809a_006e9a58",
      "range": {
        "startLine": 1511,
        "startChar": 1,
        "endLine": 1512,
        "endChar": 42
      },
      "revId": "e4b3c4e5daeee5e79c04b981ea8bcb4ac9582040",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}