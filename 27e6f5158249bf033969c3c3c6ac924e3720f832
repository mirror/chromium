{
  "comments": [
    {
      "key": {
        "uuid": "7f71aa47_762254a8",
        "filename": "content/browser/devtools/protocol/input_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 283,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2017-08-18T17:04:48Z",
      "side": 1,
      "message": "Looking at the code, MouseWheelPhaseHandler sometimes sends an event to this RenderWidgetHostViewBase, which will be inconsistent since we don\u0027t send all the other events to the view. Also, I\u0027m worried about the lifetime here. And MouseWheelPhaseHandler has a lot of logic which does not apply in our automation case.\n\nCan we instead send two events, one with PhaseBegan, another with PhaseEnded, so that every mousewheel is a separate sequence? Doing any timeouts during automation is not good, since it\u0027s not a user which interacts with Chrome, but another program with it\u0027s own timing.",
      "range": {
        "startLine": 283,
        "startChar": 37,
        "endLine": 283,
        "endChar": 76
      },
      "revId": "27e6f5158249bf033969c3c3c6ac924e3720f832",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40782ff4_c2846037",
        "filename": "content/browser/devtools/protocol/input_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 283,
      "author": {
        "id": 1213209
      },
      "writtenOn": "2017-08-18T17:31:33Z",
      "side": 1,
      "message": "Both ForwardWheelEvent function which is normally called and RenderWidgetHostView*::ProcessMouseWheelEvent are calling host_-\u003eForwardWheelEventWithLatencyInfo(event, latency) function to add the wheel event to mouse_wheel_event_queue. So, the two of them will be the same till one of the function bodies changes.\n\nThis solution here is a short term one anyways, the ideal correction will be decoupling The generating of WebInputEvent from nativeEvents and routing(as well as phase handling) of the generated WebInputEvents. This would also address oopif cases since instead of directly forwarding the events DispatchMouseEvent will be able to call the routing function. I already filed a bug for this (crbug.com/756573).\n\nYes, we can, but it would break the scroll latching behavior since every wheel event will cause a sequence of GSB, GSU, and GSE. I don\u0027t think the timer might cause an issue but if you prefer not to deal with it here I can change it.",
      "parentUuid": "7f71aa47_762254a8",
      "range": {
        "startLine": 283,
        "startChar": 37,
        "endLine": 283,
        "endChar": 76
      },
      "revId": "27e6f5158249bf033969c3c3c6ac924e3720f832",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5df3b65c_79e47729",
        "filename": "content/browser/devtools/protocol/input_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 283,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2017-08-22T17:33:53Z",
      "side": 1,
      "message": "This approach relies on some implementation details of MouseWheelPhaseHandler which can change at any moment. I think that might be not safe in the future.\n\n\u003e I don\u0027t think the timer might cause an issue but if you prefer not to deal with it here I can change it.\n\nTimer is always an issue during external automation, since it adds unpredictability - can fire before _or_ after automation client sends next event and thus mess up with event handling.",
      "parentUuid": "40782ff4_c2846037",
      "range": {
        "startLine": 283,
        "startChar": 37,
        "endLine": 283,
        "endChar": 76
      },
      "revId": "27e6f5158249bf033969c3c3c6ac924e3720f832",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aafcf322_c10e9d5b",
        "filename": "content/browser/devtools/protocol/input_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 283,
      "author": {
        "id": 1213209
      },
      "writtenOn": "2017-08-23T14:25:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5df3b65c_79e47729",
      "range": {
        "startLine": 283,
        "startChar": 37,
        "endLine": 283,
        "endChar": 76
      },
      "revId": "27e6f5158249bf033969c3c3c6ac924e3720f832",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "01880c02_de712953",
        "filename": "content/browser/devtools/protocol/input_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 489,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2017-08-22T17:33:53Z",
      "side": 1,
      "message": "So, this can produce two events, while we are going to invoke callback just once (for the first one). Or may it swallow the event? In this case the callback will hang here forever. I think this is too fragile to rely upon. Let\u0027s instead send two events manually.",
      "range": {
        "startLine": 489,
        "startChar": 32,
        "endLine": 489,
        "endChar": 67
      },
      "revId": "27e6f5158249bf033969c3c3c6ac924e3720f832",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d95c5a4_1c2779ed",
        "filename": "content/browser/devtools/protocol/input_handler.cc",
        "patchSetId": 2
      },
      "lineNbr": 489,
      "author": {
        "id": 1213209
      },
      "writtenOn": "2017-08-23T14:25:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "01880c02_de712953",
      "range": {
        "startLine": 489,
        "startChar": 32,
        "endLine": 489,
        "endChar": 67
      },
      "revId": "27e6f5158249bf033969c3c3c6ac924e3720f832",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}