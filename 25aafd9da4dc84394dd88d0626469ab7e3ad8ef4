{
  "comments": [
    {
      "key": {
        "uuid": "c2bbb142_fcbb594d",
        "filename": "tools/clang/value_cleanup/ValueRewriter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-02T19:33:44Z",
      "side": 1,
      "message": "Nit: key_literal, et cetera (we generally still use Chrome C++ conventions, even though this is built on top of LLVM\u0027s slightly different coding conventions)",
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ee0de38_4fa4de9d",
        "filename": "tools/clang/value_cleanup/ValueRewriter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-03T11:51:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c2bbb142_fcbb594d",
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "88f9c3c9_8705e6c3",
        "filename": "tools/clang/value_cleanup/ValueRewriter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-02T19:33:44Z",
      "side": 1,
      "message": "Can we use llvm::StringRef::split(SmallVectorImpl\u003cStringRef\u003e\u0026, char, int, bool) here?",
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26bbd92e_adef9264",
        "filename": "tools/clang/value_cleanup/ValueRewriter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-03T11:51:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "88f9c3c9_8705e6c3",
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e69ddfe2_5f12261a",
        "filename": "tools/clang/value_cleanup/ValueRewriter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-02T19:01:40Z",
      "side": 1,
      "message": "I would like to use `valExpr-\u003egetLocEnd()` here, but this results in `valExpr` being swallowed. Apparently `valExpr-\u003egetLocStart()` and `valExpr-\u003egetLocEnd()` are equal here. Do you happen to know why this is?",
      "range": {
        "startLine": 85,
        "startChar": 29,
        "endLine": 85,
        "endChar": 37
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "709e1a0f_2efde100",
        "filename": "tools/clang/value_cleanup/ValueRewriter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-02T19:33:44Z",
      "side": 1,
      "message": "It\u0027s probably a token range rather than a character range, so the end loc is actually pointing the last token in the source range, rather than one past the end of the character range (if that makes sense). If you want to be explicit about this, you can use clang::Lexer::getLocForEndOfToken(), which should do the right thing. Probably.",
      "parentUuid": "e69ddfe2_5f12261a",
      "range": {
        "startLine": 85,
        "startChar": 29,
        "endLine": 85,
        "endChar": 37
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "414a8baf_cdf7d659",
        "filename": "tools/clang/value_cleanup/ValueRewriter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-03T11:51:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "709e1a0f_2efde100",
      "range": {
        "startLine": 85,
        "startChar": 29,
        "endLine": 85,
        "endChar": 37
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "613b1916_ccb44ee8",
        "filename": "tools/clang/value_cleanup/tests/listvalue-expected.cc",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-02T19:01:40Z",
      "side": 1,
      "message": "This confuses me a bit since I am building the initializer_list string without spaces. Also the generated edit snippets are without spaces. Does the apply_edits script do some magic here?",
      "range": {
        "startLine": 35,
        "startChar": 17,
        "endLine": 35,
        "endChar": 36
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10b0a62b_b0f4e66c",
        "filename": "tools/clang/value_cleanup/tests/listvalue-expected.cc",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-02T19:33:44Z",
      "side": 1,
      "message": "The pipeline automatically runs clang-format on the output.\n\n(There\u0027s also some special magic for extending deletions to include commas if deleting an item in a list, but that wouldn\u0027t be used here)",
      "parentUuid": "613b1916_ccb44ee8",
      "range": {
        "startLine": 35,
        "startChar": 17,
        "endLine": 35,
        "endChar": 36
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d637267d_af100511",
        "filename": "tools/clang/value_cleanup/tests/listvalue-expected.cc",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-02T19:33:44Z",
      "side": 1,
      "message": "I\u0027m curious--but why require manual construction of a base::Value? It means we\u0027d only need one overload of SetPath / SetKey -- but it also means that every caller needs to manually construct a base::Value. Wouldn\u0027t that be worse for overall binary size?",
      "range": {
        "startLine": 35,
        "startChar": 39,
        "endLine": 35,
        "endChar": 57
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a985259a_568f11e4",
        "filename": "tools/clang/value_cleanup/tests/listvalue-expected.cc",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-03T11:51:36Z",
      "side": 1,
      "message": "While I agree requiring manual construction hampers usability a bit, it is an effective way to combat the combinatorial explosion that would be necessary otherwise. base::Value currently has 13 different constructors (not counting default and move constructor), and there are in total 5 overloads for SetKey / SetPath. If we didn\u0027t require manual construction we thus would need to have 13 * 5 \u003d 65 versions of SetKey / SetPath to maintain the same functionality.\n\nRegarding binary size: You might be right, but given that none of the constructors are inlined the effect should not be huge, correct?",
      "parentUuid": "d637267d_af100511",
      "range": {
        "startLine": 35,
        "startChar": 39,
        "endLine": 35,
        "endChar": 57
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6417321_65f7e539",
        "filename": "tools/clang/value_cleanup/tests/listvalue-expected.cc",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-03T11:51:36Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "10b0a62b_b0f4e66c",
      "range": {
        "startLine": 35,
        "startChar": 17,
        "endLine": 35,
        "endChar": 36
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9bf92feb_47d1d469",
        "filename": "tools/clang/value_cleanup/tests/listvalue-expected.cc",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1001168
      },
      "writtenOn": "2018-01-04T07:28:12Z",
      "side": 1,
      "message": "Well, it depends on how much it\u0027s called really. It\u0027s not just a constructor--there\u0027s a destructor invocation as well. Even if it\u0027s not inlined, the cost is non-zero.\n\nI hate to say this... but maybe using macros to help generate those combinations would actually be a reasonable strategy to use here?\n\n(That\u0027s kind of out of scope of this CL, though if we do want to change this, it\u0027s probably something to do as a prereq)",
      "parentUuid": "a985259a_568f11e4",
      "range": {
        "startLine": 35,
        "startChar": 39,
        "endLine": 35,
        "endChar": 57
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a32b938d_a1c9c0f3",
        "filename": "tools/clang/value_cleanup/tests/listvalue-expected.cc",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1179305
      },
      "writtenOn": "2018-01-05T10:37:33Z",
      "side": 1,
      "message": "Fair point, I\u0027ll see what Brett says about this. In the meantime I will prepare a CL that applies this tool to my local Linux checkout so that we hopefully can get a better idea of the overall binary size impact.",
      "parentUuid": "9bf92feb_47d1d469",
      "range": {
        "startLine": 35,
        "startChar": 39,
        "endLine": 35,
        "endChar": 57
      },
      "revId": "25aafd9da4dc84394dd88d0626469ab7e3ad8ef4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}