{
  "comments": [
    {
      "key": {
        "uuid": "653d1162_8c5babef",
        "filename": "gpu/ipc/in_process_command_buffer.h",
        "patchSetId": 16
      },
      "lineNbr": 108,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T19:33:33Z",
      "side": 1,
      "message": "Could we pass in the GpuChannelManagerDelegate directly, rather than the GpuChannelManager, since that\u0027s all you need?\nIt would be fairly odd to talk to the GpuChannelManager from here. Doubly so in the Android WebView case where it lives on a different thread.\n\nIt does make sense to call the GpuChannelManagerDelegate (though we may want to rename it) from here, in particular we may consider doing other things such as StoreShaderToDisk",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fcb564b_50fe136b",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-11-27T19:39:50Z",
      "side": 1,
      "message": "Can you explain a little why this is changing?\n\nRegisterChild() happens in response to a message on the GpuHost pipe, and DoSetParentOnChild() happens locally (maybe in response to a message on FrameSinkManagerClient pipe?). Why does this order change with viz?",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "931059b0_83452319",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-27T19:53:49Z",
      "side": 1,
      "message": "For non-viz there is one ContextProvider/CommandBuffer per Compositor/Display. There is a blocking calls involved in setting that up, which means that SetChild() has been called before DoSetParentOnChild().\n\nIn viz, there is only one ContextProvider/CommandBuffer for all Compositors. The Display is created separate and isn\u0027t involved in this. There is no blocking call for subsequent Compositors and DoSetParentOnChild() can happen before SetChild().",
      "parentUuid": "7fcb564b_50fe136b",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8f92476_f62e7bf6",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1000608
      },
      "writtenOn": "2017-11-27T23:12:17Z",
      "side": 1,
      "message": "FYI calling SetParent on the I/O thread like this (particularly inside a lock) is a bit risky. It could cause a synchronous windows message to the parent window (on the UI thread), which could deadlock. In practice it\u0027s probably ok because WS_EX_NOPARENTNOTIFY was specified on the child window.",
      "parentUuid": "931059b0_83452319",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2c18e73_5b8e0b5f",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-28T01:18:39Z",
      "side": 1,
      "message": "Thanks for the heads up John! PostTask\u0027ing back to the UI thread to call SetParent would be straight forward, do you think that is worth doing just to be safe?",
      "parentUuid": "a8f92476_f62e7bf6",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "964a87a6_e0390e75",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-28T19:33:33Z",
      "side": 1,
      "message": "I\u0027m not a windows expert, but I would expect to only do UI calls on the UI thread - I don\u0027t know all the implications if we do not. I think the deadlock concerns are real.",
      "parentUuid": "a2c18e73_5b8e0b5f",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e82e7f61_9a400ada",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1000608
      },
      "writtenOn": "2017-11-28T20:00:15Z",
      "side": 1,
      "message": "Either way isn\u0027t great - if we post to the UI thread then there\u0027s extra latency before the window contents become visible. Best case might be to post to a worker thread and do it there - then there\u0027s lower latency and no deadlock risk. GDI is threadsafe, so that shouldn\u0027t be an issue.",
      "parentUuid": "964a87a6_e0390e75",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43a29069_b5d1865b",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-29T14:14:15Z",
      "side": 1,
      "message": "I can move ::SetParent() outside the lock in both functions, which removes any risk of deadlock. If there is a chance that ::SetParent() will cause a sync call (from the IO thread) to the parent window that doesn\u0027t seem great. Would a worker thread not have the same issue with the sync call (from the worker thread) to the parent window though?\n\nI\u0027ll read through what I can find on MSDN today so I understand this a bit better.",
      "parentUuid": "e82e7f61_9a400ada",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0b767acb_7f5d6156",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T20:18:07Z",
      "side": 1,
      "message": "The types of deadlocks we ran into in the past is that some GDI operations cause implicit sync IPCs (Windows ones, not Chrome ones) to the thread that owns the affected window. Since they are not visible to the Chrome IPC system, there is no option to have them re-enter. If the GPU thread needs the browser IO thread to make progress (so that it can process WM messages), it could cause a deadlock if the SetParent is also blocking on the GPU thread to finish.",
      "parentUuid": "43a29069_b5d1865b",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e6add5a_e7a345d5",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-29T20:48:20Z",
      "side": 1,
      "message": "Oh, ack, this approach needs to change then. I\u0027ll have it post back to UI and see if that introduces much delay?",
      "parentUuid": "0b767acb_7f5d6156",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aca48d83_03b1cdac",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 16
      },
      "lineNbr": 38,
      "author": {
        "id": 1000608
      },
      "writtenOn": "2017-11-29T21:03:28Z",
      "side": 1,
      "message": "Doing it on a worker thread would also avoid a deadlock, because the IO thread wouldn\u0027t wait on the worker thread for the operation to complete.",
      "parentUuid": "4e6add5a_e7a345d5",
      "revId": "61db7671e17d2483e885dbabda422daab402dfc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}