{
  "comments": [
    {
      "key": {
        "uuid": "d21aa121_7e3b6299",
        "filename": "content/renderer/render_frame_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 740,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-08-21T16:28:03Z",
      "side": 1,
      "message": "Does base::debug::Alias on a cast work correctly? I thought you could only Alias actual variables reliably?",
      "revId": "25276ee9a7bcacfe31fe8ec7b9a3707e8b54a0ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7ed4bc7_034bc9fc",
        "filename": "content/renderer/render_frame_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 753,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-08-21T16:28:03Z",
      "side": 1,
      "message": "I\u0027m not sure I buy the explanation on the bug. volatile should apply to the data not the pointer (like const, and unlike restrict). Dereferencing the (regular) pointer to volatile memory should do the right thing. Adding volatile to the pointer should mean essentially forcing spilling the variable onto the stack, but that shouldn\u0027t matter for this. That\u0027s consistent with the output in the bug, maybe I\u0027m missing something.\n\nThe reason I\u0027m particularly concerned is that we use volatile in parts of the code to ensure the compiler respects load/stores to avoid security issues with memory shared with untrusted processes (e.g. preventing reading a value again after validation, or storing a temporary into shared memory then reading it again). We use the pointer-to-volatile pattern, not the volatile-pointer-to-volatile-memory pattern, and if we need to change it I would like to understand why.",
      "revId": "25276ee9a7bcacfe31fe8ec7b9a3707e8b54a0ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}