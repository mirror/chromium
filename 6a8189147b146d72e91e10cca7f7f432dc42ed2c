{
  "comments": [
    {
      "key": {
        "uuid": "a07767d8_5fbc362d",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-08-28T19:07:18Z",
      "side": 1,
      "message": "This change actually moved onShow first intentionally, so this might cause a regression there: \nhttps://codereview.chromium.org/2147543006/diff/60001/chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java\n\nAdding yusufo@ to clarify on this.",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ea040b1_953c716b",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1116074
      },
      "writtenOn": "2017-09-05T05:13:14Z",
      "side": 1,
      "message": "That is true, this will cause an unnecessary resize if I remember correctly.\n\nAlso, I believe this call, swapContentViewCore is only used for prerender which should now be deprecated everywhere other than the hidden tab use in custom tabs. Is it possible that this change is not needed for your purposes?",
      "parentUuid": "a07767d8_5fbc362d",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a67664c6_3102fd56",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1003044
      },
      "writtenOn": "2017-09-05T05:33:05Z",
      "side": 1,
      "message": "It\u0027s used for reader mode -- I\u0027m not sure if it\u0027s shipping but regardless there\u0027s a test testInfoBarContainerSwapsWebContents that otherwise fails (setCVC calls down into AttachTabHelpers so onShow needs to be after for the permissions code to think it\u0027s visible).\n\nHow can I test whether there\u0027s an unnecessary resize? I\u0027d guess that it would occur due to the relative positions of onSizeChanged and setContentViewCore, and the onShow is unrelated.",
      "parentUuid": "0ea040b1_953c716b",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e416e98e_ca34e4ba",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1116074
      },
      "writtenOn": "2017-09-05T06:13:42Z",
      "side": 1,
      "message": "Hmm. I see. Reader mode actually just started using custom tabs as well, so I dont think we will need swapping for it in the long term.\n\nLooks like that test mostly uses swap to get a side effect and swaps with an empty WebContents. I would really prefer if we can make the test pass using some other way and keep the swap code intact.\n\nLet me try to see if there is another way to make it pass.",
      "parentUuid": "a67664c6_3102fd56",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06a5b095_a011e5d1",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1003044
      },
      "writtenOn": "2017-09-05T09:05:55Z",
      "side": 1,
      "message": "I poked around a bit and as best I can tell this change doesn\u0027t affect resizing, because the onSizeChanged call is first.",
      "parentUuid": "e416e98e_ca34e4ba",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7841131e_db975e4f",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1116074
      },
      "writtenOn": "2017-09-05T15:46:49Z",
      "side": 1,
      "message": "I believe the order of things that happens is this:\n\nHere we are setting a fake size to ContentViewCore, because we know it itself will soon resize to that. If we do nothing, it ends up sending a (0,0) layout which is its actual size for now. When we call setContentViewCore it makes ContainerView inside it to start listening to various visibility and hierarchy changes and respond to them with (My size might have changed). onShow triggers one of these signals (switching it from hidden to visible). That makes it check its size, which it realizes is not the fake size (yet), but (0,0).\n\nWe don\u0027t want that. For this call, we want it to stay unaware that its current size is fake, because the next size update will set it to that value anyway.",
      "parentUuid": "06a5b095_a011e5d1",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9fe6d787_2c9fb059",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1003044
      },
      "writtenOn": "2017-09-06T10:24:48Z",
      "side": 1,
      "message": "How can I verify if there\u0027s an extra resize happening or not? I added logging in a few places and moving this onShow() doesn\u0027t appear to affect the calls (in number or sizing values) to any of ContentViewCore::WasResized, RenderWidgetHostImpl::WasResized or WebViewImpl::ResizeVisualViewport when entering reader mode.\n\nHaving the onShow() come after setContentViewCore() makes this consistent with everywhere else that initialises tabs, everywhere else we attach TabHelpers before dispatching WebContentsObserver::WasShown() and as such observing WasShown()/WasHidden() mostly lets us respond to the visibility of a tab, except for this case where we don\u0027t get the initial WasShown().",
      "parentUuid": "7841131e_db975e4f",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31ef954c_8d9edfac",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 13
      },
      "lineNbr": 2386,
      "author": {
        "id": 1116074
      },
      "writtenOn": "2017-09-06T16:14:16Z",
      "side": 1,
      "message": "Sorry for pushing back on this, because I do realize this is an exception that doesn\u0027t make sense on first look. It would make more sense to set first and then call onShow. And I know this looks like an edge case and this logic is fragile mostly because we made it so. But I still want to avoid regressing.\n\nPrerender in Android is almost 100% used by only the hidden tab logic in CustomTabsConnection, that is designed for external prerender request coming from other apps. So even if this breaks that one test and reader mode, it makes practical sense to keep focus on  the external prerender use case not regressing.\n\nThe extra resize will not happen in cases where intent is coming from an already existing Chrome tab.(Reader mode, omnibox prerenders will work fine).\n\nIt will happen in cases where we have an external prerender, Chrome prerendering a WebContents with no ContentViewCore and then a tab being created on cold start and getting a swap call. In this scenario, both the ContentViewCore being swapped in and out will have no initial size since we haven\u0027t gotten the update from the Android View hierarchy. And with set and onShow being called on that order, they will become aware of that fact (their internal size is (w,h) but Android would tell them it is (0,0)) causing a resize. Your best bet for reproducing this probably is CustomTabActivityTest#testHiddenTabCorrectUrl which I believe goes through this flow. My worry is with your patch that test will cause an extra resize after the tab is created going back and forth between (w,h) and (0,0).",
      "parentUuid": "9fe6d787_2c9fb059",
      "range": {
        "startLine": 2386,
        "startChar": 8,
        "endLine": 2386,
        "endChar": 26
      },
      "revId": "6a8189147b146d72e91e10cca7f7f432dc42ed2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}