{
  "comments": [
    {
      "key": {
        "uuid": "b539f781_2a7f60bb",
        "filename": "ios/chrome/browser/ui/animations/locationbar_animation_configurator.h",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1115958
      },
      "writtenOn": "2017-11-02T13:55:10Z",
      "side": 1,
      "message": "Instead of this being a configurator that owns and exposes an property animator, can it just be an property animator subclass?",
      "range": {
        "startLine": 10,
        "startChar": 46,
        "endLine": 10,
        "endChar": 54
      },
      "revId": "b9a1e8652ad3efe4b9f5851ba607b64df753af63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4933c309_e260a210",
        "filename": "ios/chrome/browser/ui/animations/locationbar_animation_configurator.h",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1133065
      },
      "writtenOn": "2017-11-03T00:38:48Z",
      "side": 1,
      "message": "I was actually was thinking of going in the opposite direction of what this CL is doing.  It looks like here, you\u0027re consolidating all the animation logic into one object to configure the UIViewPropertyAnimator.  This doesn\u0027t really work for fullscreen animations, where different UIViewControllers are manipulating their own UI.  For Fullscreen, the animator exposes all the knowledge that the UI needs to perform the animations, and the UIViewControllers manipulate their UI in animation blocks when the animator is exposed via an observer pattern. There are a couple benefits to doing it this way:\n- It splits up the animation into smaller logical chunks that are handled by more specific views/view controllers\n- The views are always updated in the same place.  The code that performs the layout of the subviews will be the same code that updates the views in the animation blocks.  As it\u0027s currently implemented, the configurator updates the frames of views to the layout values that are also calculated elsewhere.",
      "parentUuid": "b539f781_2a7f60bb",
      "range": {
        "startLine": 10,
        "startChar": 46,
        "endLine": 10,
        "endChar": 54
      },
      "revId": "b9a1e8652ad3efe4b9f5851ba607b64df753af63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1688e8cf_4420d5cf",
        "filename": "ios/chrome/browser/ui/animations/locationbar_animation_configurator.mm",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1148126
      },
      "writtenOn": "2018-01-05T10:44:23Z",
      "side": 1,
      "message": "I thought about exposing the views to an object, like you do; but this doesn\u0027t scale very well because with autolayout you have to animate constraints, not frames. This means that effectively for each view that takes part in the animation, you will have to expose the view, any of the constraints for this view, and if you need to add/remove views in the animation, you\u0027ll need all the views to set up the new constraints, etc. \n\nI think in CL 850400 it\u0027s a bit better, since you only expose the actions to be animated in a form of methods; this way the animator knows that it needs to \"expand omnibox in the toolbar\", but it doesn\u0027t really know what the omnibox is and how to expand it. But it shouldn\u0027t: it only should care that it needs to happen at the same time as \"fading out omnibox buttons\".",
      "revId": "b9a1e8652ad3efe4b9f5851ba607b64df753af63",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}