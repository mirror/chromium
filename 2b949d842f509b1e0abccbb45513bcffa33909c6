{
  "comments": [
    {
      "key": {
        "uuid": "8c97aeeb_7f9ee25a",
        "filename": "chrome/browser/loader/chrome_resource_dispatcher_host_delegate.cc",
        "patchSetId": 4
      },
      "lineNbr": 957,
      "author": {
        "id": 1132034
      },
      "writtenOn": "2017-08-09T16:00:24Z",
      "side": 1,
      "message": "nit: is base::Passed() required with unique_ptr?",
      "revId": "2b949d842f509b1e0abccbb45513bcffa33909c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2068db82_a9f46d45",
        "filename": "chrome/browser/page_load_metrics/metrics_web_contents_observer.cc",
        "patchSetId": 4
      },
      "lineNbr": 204,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-08-07T19:17:56Z",
      "side": 1,
      "message": "i have a preference for avoiding holding on to the raw ptr if at all possible. could we maybe use the return value of the call to insert() instead?\n\nauto it \u003d provisional_loads_.insert(...);\nDCHECK(it.second) \u003c\u003c \"provisional_loads_ already contains NavigationHandle.\"\nfor (auto\u0026 observer : testing_observers_)\n  observer.OnTrackerCreated(it.first);",
      "revId": "2b949d842f509b1e0abccbb45513bcffa33909c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3e08d94_823ab76c",
        "filename": "chrome/browser/page_load_metrics/metrics_web_contents_observer.cc",
        "patchSetId": 4
      },
      "lineNbr": 301,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-08-07T19:17:56Z",
      "side": 1,
      "message": "it looks like the code to handle null is only needed for tests - is that right?\n\ni\u0027d like to avoid adding any logic to production code that\u0027s really only needed to accomodate tests. could we instead require tests to provide a non-null instance, and perhaps assert that it\u0027s non-null here?\n\ni\u0027d also be fine with having ExtraRequestCompleteInfo contain a std::unique_ptr\u003cLoadTimingInfo\u003e and just std::move()\u0027ing the value like we do for data_reduction_proxy_data.",
      "revId": "2b949d842f509b1e0abccbb45513bcffa33909c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "315bd62a_6f5707ad",
        "filename": "chrome/browser/page_load_metrics/page_load_metrics_browsertest.cc",
        "patchSetId": 4
      },
      "lineNbr": 269,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-08-07T19:17:56Z",
      "side": 1,
      "message": "this is a nice extension of capabilities for waiting, thanks! I prefer to add this to the existing PageLoadMetricsWaiter class so implementers have have to work with a single waiter. Was your concern with the main vs sub frame issue? We can figure that out by doing:\n\n// It is safe for us to use UnsafeFindFrameByFrameTreeNodeId here since we only want to know if a given frame is a main frame, not get the actual RFH.\nbool is_main_frame \u003d \ncontent::WebContents::FromFrameTreeNodeId(extra_request_complete_info.frame_tree_node_id)-\u003eUnsafeFindFrameByFrameTreeNodeId(extra_request_complete_info.frame_tree_node_id)-\u003eGetParent() \u003d\u003d nullptr;\n\nWe could then make the PageLoadMetricsWaiter\u0027s PageLoadMetricsObserver implement OnLoadedResource, forward that to PageLoadMetricsWaiter, and add a new TimingField enum entry LOAD_TIMING_INFO which has its bit cleared in the OnLoadedResource method.",
      "revId": "2b949d842f509b1e0abccbb45513bcffa33909c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16d8d521_d9cc7844",
        "filename": "chrome/browser/page_load_metrics/page_load_metrics_browsertest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1289,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-08-07T19:17:56Z",
      "side": 1,
      "message": "let\u0027s use /page_load_metrics/404.html here instead, which should produce the same result, but has more deterministic behavior since the http response headers are specified in the config file for that response.",
      "revId": "2b949d842f509b1e0abccbb45513bcffa33909c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84cf0183_8c5c5a9c",
        "filename": "chrome/browser/page_load_metrics/page_load_metrics_browsertest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1289,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-08-07T19:25:17Z",
      "side": 1,
      "message": "One thing that\u0027s surprising here though, is that if /nonexisting-resource returns a non-200 error code like 404, it should be ignored and never passed through to PLMOs, which means the waiter should hang.\n\nWhich suggests to me that something funny is going on - perhaps /nonexisting-resource returns a 200 response code? Maybe the test server has a default handler that returns a 200.\n\nMaybe you could add some logging code in the observer to see if that\u0027s happening. If so, this may not be testing a failure after all and maybe we should remove this test case.\n\nThe other failure case I was thinking of was when a provisional load fails to commit. In that case, I\u0027d still like observers to see all timing up to the failure point. The closest test we have that you could model after is AbortNewNavigation. I suspect though that we do not log any load timing metrics for aborted navigations yet. So we can defer that if you prefer.",
      "parentUuid": "16d8d521_d9cc7844",
      "revId": "2b949d842f509b1e0abccbb45513bcffa33909c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}