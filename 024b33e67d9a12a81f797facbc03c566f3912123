{
  "comments": [
    {
      "key": {
        "uuid": "fb8462b1_f68ef9c7",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 35,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-08-15T18:23:58Z",
      "side": 1,
      "message": "Might be helpful to document where these types are defined",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1b059bf_bea1fd49",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 35,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-08-15T22:32:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fb8462b1_f68ef9c7",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "55145aa2_b09f90c6",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 166,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-08-15T18:23:58Z",
      "side": 1,
      "message": "I don\u0027t think this is guaranteed at all. A misbehaving process could send a message with no space for extra header bytes, in which case this call will receive a null extra_header.",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31407623_820b0524",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 166,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-08-15T22:32:07Z",
      "side": 1,
      "message": "Wouldn\u0027t |extra_header_size| then be zero, though, so the |handles_size \u003e extra_header_size| check above will cause us to return false immediately before this check?  And we shouldn\u0027t see this API called at all if there are no handles in the incoming message.\n\nTurned this into an earlier early-exit condition.",
      "parentUuid": "55145aa2_b09f90c6",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6f046e3_55630c1d",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 166,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-08-15T22:42:08Z",
      "side": 1,
      "message": "Right... good point",
      "parentUuid": "31407623_820b0524",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bb8ba2df_b90f5b80",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 169,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-08-15T22:32:07Z",
      "side": 1,
      "message": "This mirrors a check in the POSIX implementation; is there a reason that we don\u0027t check for the two values actually being equal?  I\u0027d expect that if they differ then something fishy is going on?",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d43895a8_6e976f40",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 169,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-08-15T22:42:08Z",
      "side": 1,
      "message": "It\u0027s possible for the number of handles attached to a message to exceed some limit imposed by the system. In that case we may send follow-up messages with more handles. Thus incoming_handles_ accumulates handles over potentially multiple physical messages, and thus it\u0027s possible for incoming_handles_.size() to be smaller than |num_handles|.\n\nReturning |true| but leaving |handles| as null is an indication (to Channel) that there is nothing wrong yet, but we don\u0027t have enough handles to complete the message currently being built from incoming data.\n\nIt may not in fact be possible under non-fishy circumstances for incoming_handles_.size() to legitimately *exceed* num_handles, but that\u0027s not entirely clear to me without reading kernel source, so this errs on the side of less strict behavior.",
      "parentUuid": "bb8ba2df_b90f5b80",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1395f81c_1fc8266b",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 169,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-08-16T20:52:22Z",
      "side": 1,
      "message": "Oh, I see. So num_handles is the total number of handles that the whole message contains, not the number of handles associated with an individual OS-level message fragment.\n\nHowever, I thought that this only gets called once the entire Mojo-level message has been received, even if it has been split across multiple underlying OS-level messages (see OnReadComplete(), which early-exits returning true if there isn\u0027t enough data available to process the message, yet).\n\nIf you look at the OnMxHandleSignalled implementation below, I\u0027m accumulating all the handles from received messages into a vector to attached to the resulting Message (though I\u0027ve explicitly DCHECK\u0027d against \u003e64 handles per-message in the WriteNoLock implementation..).",
      "parentUuid": "d43895a8_6e976f40",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4007c870_9eef57ff",
        "filename": "mojo/edk/system/channel_fuchsia.cc",
        "patchSetId": 4
      },
      "lineNbr": 169,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-08-16T21:12:25Z",
      "side": 1,
      "message": "\u003e Oh, I see. So num_handles is the total number of handles that the whole message contains, not the number of handles associated with an individual OS-level message fragment.\n\u003e \n\u003e However, I thought that this only gets called once the entire Mojo-level message has been received, even if it has been split across multiple underlying OS-level messages (see OnReadComplete(), which early-exits returning true if there isn\u0027t enough data available to process the message, yet).\n\nIt gets called once all the *data* is received for a message, i.e. once we have a valid header which says \"N bytes\" and we have at least N bytes of data buffered. If you were to send a tiny message with 10000 handles attached, we still might end up sending multiple OS-level messages to get all the handles there, with the extra handle messages having 0 bytes of data.\n\n\u003e \n\u003e If you look at the OnMxHandleSignalled implementation below, I\u0027m accumulating all the handles from received messages into a vector to attached to the resulting Message (though I\u0027ve explicitly DCHECK\u0027d against \u003e64 handles per-message in the WriteNoLock implementation..).\n\nRight, unless I\u0027m misinterpreting, this is exactly the same thing ChannelPosix does.\n\nWe treat input as a queue of incoming bytes and a queue of incoming handles. Once we have a valid message header, we wait until we have enough bytes *and* enough handles to constitute the full message as specified by that header, at which point we dispatch exactly that number of bytes and handles to the layer above.\n\nAnd in fact there is no constraint that requires unix domain sockets to adhere to message boundaries in either direction (i.e. they can be fragmented or coalesced freely), so it is in fact valid for the incoming handle queue size to exceed the current message\u0027s num_handles.",
      "parentUuid": "1395f81c_1fc8266b",
      "revId": "024b33e67d9a12a81f797facbc03c566f3912123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}