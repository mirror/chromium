{
  "comments": [
    {
      "key": {
        "uuid": "6085f311_a4df68a5",
        "filename": "media/filters/chunk_demuxer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1160,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-12-21T03:31:37Z",
      "side": 1,
      "message": "Instead of having the ChunkDemuxer destroy itself, can the caller instead post a no-op task with a std::unique_ptr\u003cChunkDemuxer\u003e on the task (almost akin to SequencedTaskRunner::DeleteSoon).\n\nThis leaves the lifetime policy decision to the owner and allows ChunkDemuxer to not care about how it gets destroyed.\n\nIn this case WebMediaPlayerImpl would std::move its demuxer to a task and post that task with BACKGROUND+CONTINUE_ON_SHUTDOWN traits.",
      "range": {
        "startLine": 1160,
        "startChar": 0,
        "endLine": 1160,
        "endChar": 67
      },
      "revId": "b567514093dadc3cde269d802bb86d193623abab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c247691e_564855be",
        "filename": "media/filters/chunk_demuxer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1160,
      "author": {
        "id": 1002455
      },
      "writtenOn": "2017-12-21T20:41:20Z",
      "side": 1,
      "message": "Good points. Done - the no-op task is now an explicit WMPI method that does the destruction timing. This change simplifies the unit/integration/fuzzer test changes, too.",
      "parentUuid": "6085f311_a4df68a5",
      "range": {
        "startLine": 1160,
        "startChar": 0,
        "endLine": 1160,
        "endChar": 67
      },
      "revId": "b567514093dadc3cde269d802bb86d193623abab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2801a137_1813cf18",
        "filename": "media/filters/chunk_demuxer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1162,
      "author": {
        "id": 1002455
      },
      "writtenOn": "2017-12-21T02:46:17Z",
      "side": 1,
      "message": "metrics OWNERS and robliao@: This method is running in a process which might have globals and singletons disappear due to the TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN used to schedule the task that\u0027s executing here. Is SCOPED_UMA_HISTOGRAM_TIMER graceful in those conditions? Or must we use TaskShutdownBehavior::SKIP_ON_SHUTDOWN to ensure no globals/singletons disappear in the scope of this method\u0027s execution?\n\nAlso, note that l.1163 could take a while. On Z620 Windows local release build, I anecdotally observed about 30ms recorded by this timer for each of about 40 media elements each containing about half the amount of media maximum bytes we let them have in this pipeline; this machine has tons of RAM though, so those times could become higher on constrained memory machines where disk paging might happen -- hence this approach to fix the strongly suspected cause of the renderer hangs.",
      "range": {
        "startLine": 1162,
        "startChar": 2,
        "endLine": 1162,
        "endChar": 28
      },
      "revId": "b567514093dadc3cde269d802bb86d193623abab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b13f2c4_f616d405",
        "filename": "media/filters/chunk_demuxer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1162,
      "author": {
        "id": 1003325
      },
      "writtenOn": "2017-12-21T03:31:37Z",
      "side": 1,
      "message": "I\u0027ll defer this question to the metrics OWNERs. My reading is that UMA structures stick around for the entire lifetime of the process.",
      "parentUuid": "2801a137_1813cf18",
      "range": {
        "startLine": 1162,
        "startChar": 2,
        "endLine": 1162,
        "endChar": 28
      },
      "revId": "b567514093dadc3cde269d802bb86d193623abab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56162e73_b09e989c",
        "filename": "media/filters/chunk_demuxer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1162,
      "author": {
        "id": 1124674
      },
      "writtenOn": "2017-12-21T20:20:09Z",
      "side": 1,
      "message": "I think the histogram itself should just be marked as intentionally leaked, and never destroyed, so it should be fine to use here.",
      "parentUuid": "6b13f2c4_f616d405",
      "range": {
        "startLine": 1162,
        "startChar": 2,
        "endLine": 1162,
        "endChar": 28
      },
      "revId": "b567514093dadc3cde269d802bb86d193623abab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b28eec6_88370d22",
        "filename": "media/filters/chunk_demuxer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1162,
      "author": {
        "id": 1002455
      },
      "writtenOn": "2017-12-21T20:41:20Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "56162e73_b09e989c",
      "range": {
        "startLine": 1162,
        "startChar": 2,
        "endLine": 1162,
        "endChar": 28
      },
      "revId": "b567514093dadc3cde269d802bb86d193623abab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}