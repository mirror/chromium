{
  "comments": [
    {
      "key": {
        "uuid": "bdfd4295_75758341",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1115906
      },
      "writtenOn": "2017-07-12T01:28:57Z",
      "side": 1,
      "message": "why the switch from target to current?",
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26a3b35d_eaaba3b0",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-07-12T01:33:42Z",
      "side": 1,
      "message": "IIUC at this point in the rules the distinction is minimal but technically I think we should be using the configuration under which the rule is currently being evaluated, which is \"current\" - the \"target\" is, I think, only different from \"current\" in the BUILDCONFIG, where we need to understand the host and target toolchain properties.\n\nBut having read the GN docs I\u0027m afraid I\u0027m still not really sure.",
      "parentUuid": "bdfd4295_75758341",
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "604a373e_ec9545d2",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1170679
      },
      "writtenOn": "2017-07-12T01:41:28Z",
      "side": 1,
      "message": "I have no experience with the Chrome naming conventions, but in a cross compile environment, target is the CPU where the code will actually run (you compile for this target), while current may be the architecture where it is compiled. We want to configure based on the target architecture.\n\nBut as I said, I don\u0027t know the chrome naming convention.",
      "parentUuid": "26a3b35d_eaaba3b0",
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bb14561_d630bc70",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2017-07-12T16:34:24Z",
      "side": 1,
      "message": "I don\u0027t really understand this so feel free to ignore me, but...\n\n* I\u0027d probably at least move this to its own CL.  I don\u0027t think it\u0027s related to what we\u0027re doing here.\n* From a \"I have no idea what I\u0027m talking about\" point of view, my instinct (from experience with cross compilers) would be that \"target\" would be the machine that will run the code and \"current\" would be the machine running the compiler.  For instance, when developing for ARM Chromebooks I use my 64-bit x86 Linux box to compile code.  In that case, would \"current\" be \"x64\" and \"target\" be \"arm32\"?  If my instinct matches reality when we\u0027d want to leave this at \"target\" and not change it to \"current\".  ...but maybe my instinct is wrong since below checks against \"current_cpu \u003d\u003d \"arm\"",
      "parentUuid": "604a373e_ec9545d2",
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41c4b35d_b5c9d12b",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-07-12T21:19:30Z",
      "side": 1,
      "message": "I\u0027m working based off of the descriptions at: https://chromium.googlesource.com/chromium/src/tools/gn/+/HEAD/docs/cross_compiles.md, but that documentation is surprisingly unclear, and has a recommendation that it is generally best to use current_cpu, without any explanation as to why. :)\n\nHaving discussed this with brettw, my understanding is that there are basically two forms of \"cross-compile\" that the host/current/target distinction serves:\n\nIf our output consists of multiple target architectures, e.g. we cross-compile(ish) on Linux/x64 to build for ChromeOS/x64, and include bundled PNaCl components, then:\n  - host_* is Linux/x64 throughout the build.\n  - target_* is ChromeOS/x64 across all native targets in the build.\n  - target_* is PNaCl across all the portable targets in the build.\n  - current_* is Linux/x64 when building host tools, whether for native or portable targets.\n  - current_* is ChromeOS/x64 or PNaCl for native and portable output binaries.\n\ne.g. If I\u0027m building idl_to_nacl.exe then:\n  - host is Linux/x64\n  - target is PNaCl\n  - current is Linux/x64 because idl_to_nacl.exe will run on the host as part of the build.\n\ni.e. \"current\" is usually the right thing to use, if you\u0027re thinking about the properties of an output binary.",
      "parentUuid": "9bb14561_d630bc70",
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1848b6e_80328bed",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-07-12T21:23:20Z",
      "side": 1,
      "message": "Put more concisely:\nhost - the architecture that the toolchain is running on.\ncurrent - the architecture that the binary we\u0027re currently building will run on.\ntarget - either the architecture the binary will run on (for outputs) or the architecture the binary will be configured to target (for building toolchain components).\n\ni.e. target is not always what the binary will run on.",
      "parentUuid": "41c4b35d_b5c9d12b",
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10556a2b_086e4b03",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1170679
      },
      "writtenOn": "2017-07-12T21:32:15Z",
      "side": 1,
      "message": "Thanks for the explanation. My take is that current_cpu is the right thing to use, but it requires cooperation from the toolchain to set it correctly. In our case, target_cpu should work as well, and it\u0027s independent from the toolchain. This is my understanding based on the following two paragraphs:\n\n\"For the default toolchain, target_cpu and current_cpu are the same. For a secondary toolchain, current_cpu is set based on the toolchain definition and target_cpu remains the same.\"\n\n\"Be sure you understand the differences between host_cpu, target_cpu, current_cpu, and toolchain_cpu (and the os equivalents). The first two are set as described above. You are responsible for making sure that current_cpu is set appropriately in your toolchain definitions;\"\n\nThat said, I am happy with the change.",
      "parentUuid": "d1848b6e_80328bed",
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3e15b811_a5575536",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2017-07-12T16:34:24Z",
      "side": 1,
      "message": "I think the logic is backwards here.  We want \"arm32\" to the the special case.  By default we want frame pointers on.  AKA: if we happened to compile an x86-32 bit Chrome (not sure we actually still do this?) we\u0027d want frame pointers.\n\nSo this (untested) code:\n\n  # We need frame pointers for CWP and profiling gives a\n  # big enough benefit that the frame pointer penalty is\n  # worth it.  ...but frame pointers are broken on clang\n  # for arm32 and nobody\u0027s fixing it, so turn frame\n  # pointers off since there\u0027s no benefit to offset the\n  # frame pointer penalty.\n  # See \u003chttps://bugs.llvm.org/show_bug.cgi?id\u003d18505\u003e.\n  if (current_cpu \u003d\u003d \"arm\") {\n    enable_frame_pointers \u003d false\n  } else {\n    enable_frame_pointers \u003d true\n  }",
      "range": {
        "startLine": 81,
        "startChar": 2,
        "endLine": 86,
        "endChar": 3
      },
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "715ff67a_e044a0c1",
        "filename": "build/config/compiler/compiler.gni",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2017-07-12T21:19:30Z",
      "side": 1,
      "message": "OK; I\u0027d musunderstood that we basically only want them for 64-bit architectures - if we want them on all architectures unless they\u0027re broken then special-casing ARM 32-bit makes more sense.",
      "parentUuid": "3e15b811_a5575536",
      "range": {
        "startLine": 81,
        "startChar": 2,
        "endLine": 86,
        "endChar": 3
      },
      "revId": "5566066365ab941749adaac822b2a70b9b2d126b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}