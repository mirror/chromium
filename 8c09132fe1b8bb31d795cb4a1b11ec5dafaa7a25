{
  "comments": [
    {
      "key": {
        "uuid": "78607be8_2510f1f4",
        "filename": "gpu/GLES2/extensions/CHROMIUM/CHROMIUM_fence.txt",
        "patchSetId": 37
      },
      "lineNbr": 38,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "this naming is somewhat reverse from ANDROID_native_fence_sync where \"dup\" refers when we extract a handle from an existing fence object instead of importing a fence to GL. Can we use the CreateGpuFence name here instead?",
      "range": {
        "startLine": 38,
        "startChar": 15,
        "endLine": 38,
        "endChar": 40
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26a91a6e_b42531d4",
        "filename": "gpu/GLES2/extensions/CHROMIUM/CHROMIUM_fence.txt",
        "patchSetId": 37
      },
      "lineNbr": 38,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "This does extract a handle from a the existing ClientGpuFence object so that the service-side one will be based on the duplicated file handle, but I agree it\u0027s confusing. I think the names should ideally clearly distinguish between creating a fresh fence and making one associated with a pre-existing one. To me, \"Create\" implies \"create from scratch\" which would be misleading, and \"Insert\" doesn\u0027t have strong connotations either way if the inserted thing is new or not.\n\nWhat do you think about CreateDuplicateGpuFenceCHROMIUM (or CreateClonedGpuFenceCHROMIUM) and InsertNewGpuFenceCHROMIUM ?",
      "parentUuid": "78607be8_2510f1f4",
      "range": {
        "startLine": 38,
        "startChar": 15,
        "endLine": 38,
        "endChar": 40
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e1dd967_0da37daf",
        "filename": "gpu/GLES2/extensions/CHROMIUM/CHROMIUM_fence.txt",
        "patchSetId": 37
      },
      "lineNbr": 46,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "Can this be named InsertGpuFence? so we can use the \"Create\" name above and that would also match CHROMIUM_sync_point a bit better?",
      "range": {
        "startLine": 46,
        "startChar": 15,
        "endLine": 46,
        "endChar": 37
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "199e40a2_56e5fbfd",
        "filename": "gpu/GLES2/extensions/CHROMIUM/CHROMIUM_fence.txt",
        "patchSetId": 37
      },
      "lineNbr": 46,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "Will do, deferring the rename until I hear back about the choices.",
      "parentUuid": "3e1dd967_0da37daf",
      "range": {
        "startLine": 46,
        "startChar": 15,
        "endLine": 46,
        "endChar": 37
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ddee53d2_b1bb26f3",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 37
      },
      "lineNbr": 420,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "can this return a fence id instead? similar to CreateImage..",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45e2ed9b_b354323a",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 37
      },
      "lineNbr": 420,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "I\u0027m confused. This is an autogenerated wrapper for a service side creation which happens when the GL command gets executed. The CreateGpuFenceINTERNAL method directly forwards the request asynchronously to gles2_cmd_decoder\u0027s DoCreateGpuFenceINTERNAL, and there\u0027s no way for that to return an ID without making it synchronous. It just needs a locally generated ID for reference in other commands.\n\nCreateImage uses GpuChannelHost\u0027s base::AtomicSequenceNumber next_image_id_ for its numbers to get channel-unique IDs, which seems unnecessary here. If I\u0027m understanding it right, the GPU fence IDs only need to be unique within a stream, and MakeIds does that, similar to how texture IDs get allocated. There\u0027s currently no need for cross-stream GPU fence IDs.\n\nAlso, both creation paths for GPU fences (from scratch, or clone from handle) need to share an ID space, and it seems odd to call a gpu_control method just to generate an ID here.",
      "parentUuid": "ddee53d2_b1bb26f3",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a329a2e_77f68fff",
        "filename": "gpu/command_buffer/client/gpu_control.h",
        "patchSetId": 37
      },
      "lineNbr": 64,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "can this be:\n\n\"int32_t CreateGpuFence(ClientGpuFence fence)\"\n\nconsistent with CreateImage above..",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6eaaa7ab_a25416f1",
        "filename": "gpu/command_buffer/client/gpu_control.h",
        "patchSetId": 37
      },
      "lineNbr": 64,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "See comment on GLES2Implementation::CreateGpuFenceCHROMIUM(), I think both creation paths should use the same ID namespace, and client side allocation seems cleaner than per-channel.",
      "parentUuid": "9a329a2e_77f68fff",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f0e6a458_105ab4f0",
        "filename": "gpu/command_buffer/client/gpu_control.h",
        "patchSetId": 37
      },
      "lineNbr": 65,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "Can this be:\n\n\"GetGpuFence(int32_t id, const base::Callback\u003cvoid(std::unique_ptr\u003cgfx::GpuFence\u003e)\u003e\u0026 callback)\"?\n\nto minimize the use of the handle..",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a05e080b_2195baf7",
        "filename": "gpu/command_buffer/client/gpu_control.h",
        "patchSetId": 37
      },
      "lineNbr": 65,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "I\u0027ve thought about it, but that\u0027s actually kind of annoying in practice. Typical use case is for the recipient to create a GLFence from it, and the GLFence takes ownership of the file descriptor. Since the GpuFence would already own it it, you\u0027d need to call CloneHandleForIPC or equivalent on it to prevent double closing. Having the callback get the handle directly so that it can use it to create a GLFence from the handle seems cleaner.\n\nIIRC we had previously discussed the alternative of using GLFence directly as a GpuFence, but that has issues in practice, specifically it would lead to local GL commands being run in the client command_buffer_proxy_impl.cc code that interfaces with IPC, and that seems unpleasant.",
      "parentUuid": "f0e6a458_105ab4f0",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34fca79e_368b8835",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 37
      },
      "lineNbr": 28,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "I\u0027m failing to see the need for all these callbacks as part of this class. It seems like a basic manager class like gpu/command_buffer/service/image_manager.h/cc should be sufficient with appropriate client APIs.",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "116f1842_463bdfc3",
        "filename": "gpu/command_buffer/service/gpu_fence_manager.h",
        "patchSetId": 37
      },
      "lineNbr": 28,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "I think the callbacks are essential. A primary use case is creating a service side GPU fence asynchronously and then retrieving the handle via callback, and the callback needs to be run when the actual creation happens. The usual case is that the callback gets registered before the service side GLFence exists, and there needs to be a place to store it. \n\nI was largely following the query manager example here which I think has similar requirements. I\u0027m not sure how client side storage would work while remaining asynchronous. I didn\u0027t see a way to trigger a Send() in gpu_command_buffer_stub.cc in reaction to a GL command completing, is there one? The abstractions for query manager and SignalSyncToken seem to go the other way.",
      "parentUuid": "34fca79e_368b8835",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fff031b8_688170a3",
        "filename": "ui/gfx/gpu_fence.h",
        "patchSetId": 37
      },
      "lineNbr": 35,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "I think this should be a base::ScopedFD or similar to make lifetime and ownership clear. Handle/FileDescriptor should be limited to IPC.",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce120ffe_3d9e05b5",
        "filename": "ui/gfx/gpu_fence.h",
        "patchSetId": 37
      },
      "lineNbr": 35,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "Done, using a base::ScopedFD.",
      "parentUuid": "fff031b8_688170a3",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3bd7a96b_00970274",
        "filename": "ui/gfx/gpu_fence_handle.h",
        "patchSetId": 37
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "I don\u0027t think we should have this as it encourage misuse/overuse of this handle type. Can we instead have a \"base::ScopedFD TakeFileFromHandle\" function below for consuming a handle? consistent with https://chromium-review.googlesource.com/c/chromium/src/+/717796, makes it more clear that these handles should only be used for IPC...",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49083903_6bedea8b",
        "filename": "ui/gfx/gpu_fence_handle.h",
        "patchSetId": 37
      },
      "lineNbr": 40,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "See response on gpu_fence.h, if I do the restructuring proposed there I can get rid of both Close() and CloneHandleForIPC().",
      "parentUuid": "3bd7a96b_00970274",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9576d7e8_2980885d",
        "filename": "ui/gl/gl_fence.h",
        "patchSetId": 37
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "nit: move static functions above next to other static functions",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "775e68cc_56afaf90",
        "filename": "ui/gl/gl_fence.h",
        "patchSetId": 37
      },
      "lineNbr": 40,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9576d7e8_2980885d",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c7782354_86aa1c24",
        "filename": "ui/gl/gl_fence.h",
        "patchSetId": 37
      },
      "lineNbr": 47,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "nit: CreateGpuFence?",
      "range": {
        "startLine": 47,
        "startChar": 34,
        "endLine": 47,
        "endChar": 51
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "87b3a69a_a51fce33",
        "filename": "ui/gl/gl_fence.h",
        "patchSetId": 37
      },
      "lineNbr": 47,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "That would be misleading in the current implementation since it doesn\u0027t create a GpuFence object. Currently, clients create the GLFence with this method, and then extract a GpuFenceHandle from it that they can then use to make a GpuFence for use with a GL call:\n\n    std::unique_ptr\u003cgl::GLFence\u003e local_fence \u003d gl::GLFence::CreateForGpuFence();\n    gfx::GpuFence gpu_fence(\n        local_fence-\u003eGetGpuFenceHandle());\n    EGLint id \u003d gl-\u003eDuplicateGpuFenceCHROMIUM(gpu_fence.AsClientGpuFence());\n\nA static method that returns a GpuFence would work, but would make it impossible to access the underlying GLFence object. That would be a bit annoying for GpuFenceManager since I wouldn\u0027t be able to call ServerWait on a service-side-created new GpuFence unless it re-converts it to a separately created GLFence:",
      "parentUuid": "c7782354_86aa1c24",
      "range": {
        "startLine": 47,
        "startChar": 34,
        "endLine": 47,
        "endChar": 51
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1339c24_600ed453",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 37
      },
      "lineNbr": 11,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "nit: I would prefer a static CreateGpuFence function for this when using Initialize that can fail.",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "694f1f8e_0c756537",
        "filename": "ui/gl/gl_fence_android_native_fence_sync.cc",
        "patchSetId": 37
      },
      "lineNbr": 11,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c1339c24_600ed453",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa030fd9_9d7179da",
        "filename": "ui/gl/gl_fence_egl.h",
        "patchSetId": 37
      },
      "lineNbr": 20,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "can we remove this argument a require Initialize to always be called?",
      "range": {
        "startLine": 20,
        "startChar": 22,
        "endLine": 20,
        "endChar": 53
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed9fd778_adb28100",
        "filename": "ui/gl/gl_fence_egl.h",
        "patchSetId": 37
      },
      "lineNbr": 20,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "Done via a local helper class and factory methods so that I can keep the constructor hidden.\n\nI wanted to avoid having a public constructor that creates uninitialized objects because all of the other GLFence constructors currently create a usable object that doesn\u0027t require explicit initialization. If someone creates a GLFenceEGL and doesn\u0027t initialize it, I don\u0027t see a good way of catching and reporting this misuse. Silently treating methods such as ServerWait as a no-op on an uninitialized fence would be likely to break things in unobvious ways, and a CHECK(IsValid()) or equivalent in all the method calls would be unpleasant.",
      "parentUuid": "fa030fd9_9d7179da",
      "range": {
        "startLine": 20,
        "startChar": 22,
        "endLine": 20,
        "endChar": 53
      },
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a8ea9ee_decf3991",
        "filename": "ui/gl/gl_fence_egl.h",
        "patchSetId": 37
      },
      "lineNbr": 38,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-11-16T20:08:03Z",
      "side": 1,
      "message": "seems like this should be part of GLFenceAndroidNativeFenceSync. why isn\u0027t it?",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "108cf24c_8ab805b4",
        "filename": "ui/gl/gl_fence_egl.h",
        "patchSetId": 37
      },
      "lineNbr": 38,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-11-17T03:03:10Z",
      "side": 1,
      "message": "Moved, and made the sync_ and display_ attributes protected so that the subclass can use them for the eglDupNativeFenceFDANDROID call.\n\nTechnically, this method does work on this class if it was initialized with the right arguments, but I agree it looks odd here, especially since it doesn\u0027t enforce the constraint.",
      "parentUuid": "1a8ea9ee_decf3991",
      "revId": "8c09132fe1b8bb31d795cb4a1b11ec5dafaa7a25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}