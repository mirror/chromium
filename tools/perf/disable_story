#!/usr/bin/env python
# Copyright 2017 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Disables benchmark stories
"""

import argparse
import inspect
import os
import string
import sys
import subprocess
import tempfile

from core import path_util
path_util.AddTelemetryToPath()

from telemetry import benchmark as benchmark_module

from py_utils import discover

# Some expectation files have special prefixes to access the
# telemetry.story.expectations object. This dict records these customizations.
PER_FILE_PREFIXES = {
    None: 'story.expectations',
    ('page_sets', 'system_health', 'expectations.py'): 'expectations',
    ('benchmarks', 'smoothness.py'): 'story_module',
}

class ExpectationInfo(object):
  """Parses an expectation class for information.

  It contains information about the file containing the expectation.
  """
  def __init__(self, cls):
    self.filename = inspect.getsourcefile(cls)

    lines, self.starting_line = inspect.getsourcelines(cls)
    self.start_offset = -1
    for i, line in enumerate(lines):
      if 'def SetExpectations' in line:
        self.start_offset = i
        break
    if self.start_offset < 0:
      raise ValueError(
          'No SetExpectations function found in %r' % self.filename)

    # indentation is proper indentation needed when lines to the
    # given expectation.
    for i, char in enumerate(lines[self.start_offset+1]):
      if char in string.ascii_letters:
        self.indentation = lines[self.start_offset+1][:i]
        break

    # path is the tuple from a known root to the file containing the expectation
    # class. It's used to determine if the file has a special prefix to access
    # the telemetry.story.expectation module.
    path = ()
    filepath = self.filename
    known_roots = (('tools', 'perf'), ('third_party', 'catapult'))
    while not any(
        filepath.endswith(os.path.join(root))
        for root in known_roots) and filepath:
      filepath, rest = os.path.split(filepath)
      path = (rest,) + path
    if not filepath:
      raise ValueError('%s is outside of expected expectation file roots %r' % (
          self.filename, ','.join(os.path.join(root) for root in known_roots)))
    self.path = path

  @property
  def offset_to_insert(self):
    return self.start_offset + self.starting_line

  def disable_story_text(self, story, bug):
    story_prefix = PER_FILE_PREFIXES.get(self.path, PER_FILE_PREFIXES[None])
    return [
        'self.DisableStory(',
        '  %r,' % story,
        '  %s,' % ('[%s.ALL]' % (story_prefix)),
        '  %r)' % ('crbug.com/%d' % bug),
    ]

def commit_message_lines(benchmark, story, bug, owners):
  return [
      '//tools/perf: Disable story in %s\n' % benchmark,
      '\n',
      'Disables the %s story in the %s benchmark\n' % (story, benchmark),
      'This CL is autogenerated. See\n',
      'http://go/perfbot-sheriff/#disable-cl-script for more info.\n',
      'TBR=%s\n' % ','.join(owners),
      '\n',
      'Bug: %s\n' % ('chromium:#%d' % bug),
  ]

def load_benchmark_by_name(name):
  benchmarks_dir = os.path.join(
      path_util.GetChromiumSrcDir(), 'tools', 'perf', 'benchmarks')
  top_level_dir = os.path.dirname(benchmarks_dir)

  all_benchmarks = discover.DiscoverClasses(
      benchmarks_dir, top_level_dir, benchmark_module.Benchmark,
      index_by_class_name=True)
  return all_benchmarks[name]

def main():
  parser = argparse.ArgumentParser(description=(
      'Disable stories for a benchmark. This script can be made to upload the'
      ' CL and attempt to commit it.'))
  parser.add_argument(
      'benchmark',
      help='The benchmark within which the story should be disabled')
  parser.add_argument(
      'story', help='The story to disable.')
  parser.add_argument(
      'bug', type=int, help='The bug number. Will be used in the CL, and put'
      ' in the code')
  parser.add_argument(
      '--upload-cl', '-u', action='store_true',
      help='Uploads a CL disabling the story. The CL will be TBRed and CQed'
      'immediately.')
  parser.add_argument(
      '--commit', '-c', action='store_true',
      help='If uploading a CL, attempts to commits the CL.')
  options = parser.parse_args()

  bench = load_benchmark_by_name(options.benchmark)
  exp_info = ExpectationInfo(bench().GetExpectations().__class__)

  with open(exp_info.filename) as f:
    current_lines = f.readlines()

  to_insert = [
      exp_info.indentation + line + '\n'
      for line in exp_info.disable_story_text(options.story, options.bug)]

  # Empty expectation functions have 'pass' statements. Remove this, since
  # we're adding something.
  if 'pass' in current_lines[exp_info.offset_to_insert]:
    current_lines.pop(exp_info.offset_to_insert)
  current_lines = current_lines[
      :exp_info.offset_to_insert] + to_insert + current_lines[
          exp_info.offset_to_insert:]

  with open(exp_info.filename, 'w') as f:
    f.writelines(current_lines)

  if options.upload_cl:
    subprocess.check_call(['git', 'add', '.'])
    subprocess.check_call(['git', 'checkout', '-b', 'disable_%s_story' % (
      options.benchmark), 'origin/master'])
    _, msg_file = tempfile.mkstemp('commit_msg')
    try:
      with open(msg_file, 'w') as f:
        f.writelines(commit_message_lines(
            options.benchmark, options.story, options.bug,
            bench().GetOwners().AsDict()['values']))
      subprocess.check_call(['git', 'commit', '-F', msg_file])
      upload_args = [
          'git', 'cl', 'upload', '--message-file=%s' % msg_file, '-f']
      if options.commit:
          upload_args.expand(['--use-commit-queue', '--send-mail'])
      subprocess.check_call(upload_args)
    finally:
      os.unlink(msg_file)

  return 0

if __name__ == '__main__':
  sys.exit(main())

