#!/usr/bin/env python
# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import argparse
import re
import sys
import urllib2


_BUILD_REGEX = r'builds/(\d+)'
_REVISION_REGEX = r'Cr-Commit-Position: refs/heads/master@{#(\d+)}'


def _GetBuildRevisionRange(build_url, test_name):
  data = urllib2.urlopen(build_url).read()
  if not test_name in data:
    raise Exception('Cannot find %s in %s' % (test_name, build_url))
  if not ('failed ' + test_name) in data:
    return None
  revisions = re.findall(_REVISION_REGEX, data)
  revisions = list(int(r) for r in revisions)
  return min(revisions), max(revisions)


def FindFirstFailureRange(build_url, test_name):
  build_number = re.findall(_BUILD_REGEX, build_url)
  assert len(build_number) == 1, (
    'Must put in a valid build url with build number')
  build_number = int(build_number[0])

  initial_build_url = build_url[:build_url.find('builds/')] + 'builds/'
  while True:
    current_build_url = initial_build_url + str(build_number)
    failure_range = _GetBuildRevisionRange(current_build_url, test_name)
    if failure_range == None:
      return first_failure_range, first_failed_build
    else:
      first_failure_range = failure_range
      first_failed_build = current_build_url
    build_number -= 1


def Main(args):
  parser = argparse.ArgumentParser(
      'Find first failed revision range for a given failed test. Notes that '
      'this tool cannot handle flaky test failures.')
  parser.add_argument('test_name')
  parser.add_argument('build_url',
                      help='A build url which |test_name| is failing')
  options = parser.parse_args(args)
  first_failure_range, first_failed_build = FindFirstFailureRange(
      options.build_url, options.test_name)
  print 'First failure range: ', first_failure_range, (
         '- %s CLs' % (first_failure_range[1] - first_failure_range[0] + 1))
  print 'First failed build: ', first_failed_build
  return 0


if __name__ == '__main__':
  sys.exit(Main(sys.argv[1:]))
