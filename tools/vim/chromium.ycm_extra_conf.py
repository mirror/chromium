# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Autocompletion configuration for using YouCompleteMe with Chromium code.
#
# Usage:
#
#   1. Install YCM [https://github.com/Valloric/YouCompleteMe]
#          (Googlers should check out [go/ycm])
#
#   2. Create a symbolic link to this file called .ycm_extra_conf.py in the
#      directory above your Chromium checkout (i.e. next to your .gclient file).
#
#          cd src/..
#          ln -rs src/tools/vim/chromium.ycm_extra_conf.py .ycm_extra_conf.py
#
#      Or on Windows (Powershell):
#
#          cd src\..
#
#          New-Item -Type SymbolicLink `
#              -Value src\tools\vim\chromium.ycm_extra_conf.py `
#              -Path .ycm_extra_conf.py
#
# If you are using Vim/NeoVIm:

#   Whitelist the .ycm_extra_conf.py from step #2 by adding the following to
#   your .vimrc:
#
#          let g:ycm_extra_conf_globlist=['<path to .ycm_extra_conf.py>']
#
#   You can also add other .ycm_extra_conf.py files you want to use to this list
#   to prevent excessive prompting each time you visit a directory covered by a
#   config file.
#
#
# Notes:
#
#   * You must use ninja and Clang to build Chromium.
#
#   * You must have built Chromium recently. YCM relies on generated files being
#     available in the output directory.
#
#   * Windows: ** IMPORTANT **
#
#     On Windows, YCM relies on the response files used during compilation to be
#     available in the build directory.
#
#     To generate the response files:
#
#        ninja -C <build directory> -d keeprsp -n
#
#     The above command doesn't invoke the compiler, but generates the response
#     file and leaves it on the disk.
#
#
# Hacking notes:
#
#   * The purpose of this script is to construct an accurate enough command line
#     for YCM to pass to clang so it can build and extract the symbols.
#
#   * If you are changing the code, please add a test.
#
#   * That whole ninja & clang thing? We could support other configs if someone
#     were willing to write the correct commands and a parser.
#

import os
import os.path
import re
import shlex
import subprocess
import sys

_header_alternates = ('.cc', '.cpp', '.c', '.mm', '.m')

_extension_flags = {
    '.m': ['-x', 'objective-c'],
    '.mm': ['-x', 'objective-c++'],
}


def PathExists(*args):
  return os.path.exists(os.path.join(*args))


def HasCommandLineFlag(command_line, flag):
  """Returns true |command_line| contains the specified flag.

  Args:
    command_line: (List of Strings) Tokenized command line.
    flag: (String) Flag to search for. E.g. '--foo'

  Returns:
    (Boolean): True if |command_line| contains |flag| or an option of the form
       |flag| + '=' + value. E.g. either '--foo' or '--foo=bar'.
  """
  if flag in command_line:
    return True

  flag = flag + '='

  for c in command_line:
    if c.startswith(flag):
      return True
  return False


def FindChromeSrcFromFilename(filename):
  """Searches for the root of the Chromium checkout.

  Simply checks parent directories until it finds .gclient and src/.

  Args:
    filename: (String) Path to source file being edited.

  Returns:
    (String) Path of 'src/', or None if unable to find.
  """
  curdir = os.path.normpath(os.path.dirname(filename))
  while not (
      os.path.basename(curdir) == 'src' and PathExists(curdir, 'DEPS') and
      (PathExists(curdir, '..', '.gclient') or PathExists(curdir, '.git'))):
    nextdir = os.path.normpath(os.path.join(curdir, '..'))
    if nextdir == curdir:
      return None
    curdir = nextdir
  return curdir


def GetDefaultSourceFile(chrome_root, filename):
  """Returns the default source file to use as an alternative to |filename|.

  Compile flags used to build the default source file is assumed to be a
  close-enough approximation for building |filename|.

  Args:
    chrome_root: (String) Absolute path to the root of Chromium checkout.
    filename: (String) Absolute path to the source file.

  Returns:
    (String) Absolute path to substitute source file.
  """
  blink_root = os.path.join(chrome_root, 'third_party', 'WebKit')
  if filename.startswith(blink_root):
    return os.path.join(blink_root, 'Source', 'core', 'CoreInitializer.cpp')
  else:
    if 'test.' in filename:
      return os.path.join(chrome_root, 'base', 'logging_unittest.cc')
    return os.path.join(chrome_root, 'base', 'logging.cc')


def GetNinjaBuildOutputsForSourceFile(out_dir, filename):
  """Returns a list of build outputs for filename.

  The list is generated by invoking 'ninja -t query' tool to retrieve a list of
  inputs and outputs of |filename|. This list is then filtered to only include
  .o and .obj outputs.

  Args:
    out_dir: (String) Absolute path to ninja build output directory.
    filename: (String) Absolute path to source file.

  Returns:
    (List of Strings) List of target names. Will return [] if |filename| doesn't
        yield any .o or .obj outputs.
  """
  # Ninja needs the path to the source file relative to the output build
  # directory.
  rel_filename = os.path.relpath(filename, out_dir)

  p = subprocess.Popen(
      ['ninja', '-C', out_dir, '-t', 'query', rel_filename],
      stdout=subprocess.PIPE,
      stderr=subprocess.STDOUT,
      universal_newlines=True)
  stdout, _ = p.communicate()
  if p.returncode != 0:
    return []

  # The output looks like:
  #   ../../relative/path/to/source.cc:
  #     outputs:
  #       obj/reative/path/to/target.source.o
  #       obj/some/other/target2.source.o
  #       another/target.txt
  #
  outputs_text = stdout.partition('\n  outputs:\n')[2]
  output_lines = [line.strip() for line in outputs_text.split('\n')]
  return [
      target for target in output_lines
      if target and (target.endswith('.o') or target.endswith('.obj'))
  ]


def GetClangCommandLineForNinjaOutput(out_dir, build_target):
  """Returns the Clang command line for building |build_target|

  Asks ninja for the list of commands used to build |filename| and returns the
  final Clang invocation.

  Args:
    out_dir: (String) Absolute path to ninja build output directory.
    build_target: (String) A build target understood by ninja

  Returns:
    (String or None) Clang command line or None if a Clang command line couldn't
        be determined.
  """
  p = subprocess.Popen(
      ['ninja', '-v', '-C', out_dir, '-t', 'commands', build_target],
      stdout=subprocess.PIPE,
      universal_newlines=True)
  stdout, stderr = p.communicate()
  if p.returncode != 0:
    return None

  # Ninja will return multiple build steps for all dependencies up to
  # |build_target|. The build step we want is the last Clang invocation, which
  # is expected to be the one that outputs |build_target|.
  for line in reversed(stdout.split('\n')):
    if 'clang' in line:
      return line
  return None


def GetClangCommandLineFromNinjaForSource(out_dir, filename):
  """Returns a Clang command line used to build |filename|.

  The same source file could be built multiple times using different tool
  chains. In such cases, this command returns the first Clang invocation. We
  currently don't prefer one toolchain over another. Hopefully the tool chain
  corresponding to the Clang command line is compatible with the Clang build
  used by YCM.

  Args:
    out_dir: (String) Absolute path to Chromium checkout.
    filename: (String) Absolute path to source file.

  Returns:
    (String or None): Command line for Clang invocation using |filename| as a
        source. Returns None if no such command line could be found.
  """
  build_targets = GetNinjaBuildOutputsForSourceFile(out_dir, filename)
  for build_target in build_targets:
    command_line = GetClangCommandLineForNinjaOutput(out_dir, build_target)
    if command_line:
      return command_line
  return None


# Based on Clang's lib/Driver/ToolChain.cpp.
def GetClangDriverModeForCompiler(compiler_name):
  """Given a compiler name, returns the corresponding '--driver-mode' flag.

  Args:
    compiler_name: (String) Name of compiler. Could be a path name. E.g. clang,
        clang-cl.exe, /foo/bar/g++.

  Returns:
    String: The driver mode flag, or None if one could not be determined.
  """

  _clang_driver_suffixes = [
      ('clang', None),  # No driver
      ('clang++', '--driver-mode=g++'),  # g++
      ('clang-c++', '--driver-mode=g++'),  # g++
      ('clang-cc', None),
      ('clang-cpp', '--driver-mode=cpp'),  # cpp
      ('clang-g++', '--driver-mode=g++'),  # g++
      ('clang-gcc', None),
      ('clang-cl', '--driver-mode=cl'),  # cl
      ('cc', None),
      ('cpp', '--driver-mode=cpp'),  # cpp
      ('cl', '--driver-mode=cl'),  # cl
      ('++', '--driver-mode=g++')  # g++
  ]

  def FindDriverSuffix(basename):
    for d in _clang_driver_suffixes:
      if basename.endswith(d[0]):
        return (d[1], True)
    return (None, False)

  compiler_name = os.path.basename(compiler_name)

  # clang-cl.exe -> clang-cl
  compiler_name = os.path.splitext(compiler_name)[0]

  flag, found = FindDriverSuffix(compiler_name)

  if not found:
    # Try again after stripping trailing version number.
    # clang++3.5 -> clang++
    compiler_name = compiler_name.rstrip('0123456789.')
    flag, found = FindDriverSuffix(compiler_name)

  if not found:
    # Try again after removing trailing components.
    # clang++-tot -> clang++
    compiler_name = compiler_name.rsplit('-', 1)[0]
    flag, found = FindDriverSuffix(compiler_name)

  return flag


def EnsureDriverFlagForClangCommandLine(clang_commandline):
  """Ensure that a suitable '--driver-mode' flag exists on the commandline.

  Args:
    clang_commandline: (List of String) Clang command line.

  Returns:
    (List of String) The same command line possibly with additional
        '--driver-mode' flags. |clang_commandline| will be returned as is if no
        driver mode can be determined.
  """
  if HasCommandLineFlag(clang_commandline, '--driver-mode'):
    return

  driver_mode = GetClangDriverModeForCompiler(clang_commandline[0])
  if driver_mode is not None:
    clang_commandline.insert(1, driver_mode)


def ReadOptionsFromResponseFile(workdir, rspfile):
  """Read options from Ninja response files.

  The YCM pipeline currently loses @foo.rsp style response file specifiers in
  the command line. This function reads in the contents of a response file and
  returns the corresponding list of command line options.

  While the resulting command line will likely fail if used with a limited shell
  like cmd.exe, the YCM pipeline doesn't indirect through a shell.

  Args:
    workdir: (String) Working directory. If the response file uses a relative
        path, it will be resolved relative to this path.
    rspfile: (String) Path to response file.

  Returns:
    (List of Strings) The list of command line arguments read from the response
        file.
  """
  rspfile = os.path.normpath(os.path.join(workdir, rspfile))
  try:
    with open(rspfile, 'r') as f:
      rspdata = f.read()
      return shlex.split(rspdata)
  except:
    return ['@missing-rsp-file:{}'.format(rspfile)]


def GetClangOptionsFromCommandLine(clang_commandline, out_dir,
                                   additional_flags):
  """Extracts relevant command line options from |clang_commandline|

  Args:
    clang_commandline: (String) Full Clang invocation.
    out_dir: (String) Absolute path to ninja build directory. Relative paths in
        the command line are relative to |out_dir|.
    additional_flags: (List of String) Additional flags to return. These flags
        will be appended to the curated Clang commandline.

  Returns:
    (List of Strings) The list of command line flags for this source file. Can
    be empty.
  """
  # Parse flags that are important for YCM's purposes.
  clang_tokens = shlex.split(clang_commandline)

  # Slurp any wrappers until we get to a clang invocation:
  clang_invocation_index = -1
  rspfile_index = -1
  for token_index, token in enumerate(clang_tokens):
    if 'clang' in token and clang_invocation_index == -1:
      clang_invocation_index = token_index

    if token.startswith('@') and rspfile_index == -1:
      rspfile_index = token_index

  if clang_invocation_index != -1:
    clang_tokens = clang_tokens[clang_invocation_index:]
    rspfile_index -= clang_invocation_index

  if rspfile_index > 0:
    rspoptions = ReadOptionsFromResponseFile(out_dir,
                                             clang_tokens[rspfile_index][1:])
    clang_tokens=clang_tokens[:rspfile_index] + \
        rspoptions + clang_tokens[rspfile_index + 1:]

  if not HasCommandLineFlag(clang_tokens, '--working-directory'):
    clang_tokens.insert(1, '--working-directory={}'.format(out_dir))

  EnsureDriverFlagForClangCommandLine(clang_tokens)

  # Pass all other flags as-is including the compiler name.
  return clang_tokens + additional_flags


def GetClangOptionsFromNinjaForFilename(chrome_root, filename):
  """Returns the Clang command line options needed for building |filename|.

  Command line options are based on the command used by ninja for building
  |filename|. If |filename| is a .h file, uses its companion .cc or .cpp file.
  If a suitable companion file can't be located or if ninja doesn't know about
  |filename|, then uses default source files in Blink and Chromium for
  determining the commandline.

  Args:
    chrome_root: (String) Path to src/.
    filename: (String) Absolute path to source file being edited.

  Returns:
    (List of Strings) The list of command line flags for this source file. Can
    be empty.
  """
  if not chrome_root:
    return []

  # Version of Clang used to compile Chromium can be newer then version of
  # libclang that YCM uses for completion. So it's possible that YCM's libclang
  # doesn't know about some used warning options, which causes compilation
  # warnings (and errors, because of '-Werror');
  additional_flags = ['-Wno-unknown-warning-option']

  sys.path.append(os.path.join(chrome_root, 'tools', 'vim'))
  from ninja_output import GetNinjaOutputDirectory
  out_dir = GetNinjaOutputDirectory(chrome_root)

  basename, extension = os.path.splitext(filename)
  if extension == '.h':
    candidates = [basename + ext for ext in _header_alternates]
  else:
    candidates = [filename]

  clang_line = None
  buildable_extension = extension
  for candidate in candidates:
    clang_line = GetClangCommandLineFromNinjaForSource(out_dir, candidate)
    if clang_line:
      buildable_extension = os.path.splitext(candidate)[1]
      break

  additional_flags += _extension_flags.get(buildable_extension, [])

  if not clang_line:
    # If ninja didn't know about filename or it's companion files, then try a
    # default build target. It is possible that the file is new, or build.ninja
    # is stale.
    clang_line = GetClangCommandLineFromNinjaForSource(out_dir,
                                                       GetDefaultSourceFile(
                                                           chrome_root,
                                                           filename))

  if not clang_line:
    return additional_flags

  return GetClangOptionsFromCommandLine(clang_line, out_dir, additional_flags)


def FlagsForFile(filename):
  """This is the main entry point for YCM. Its interface is fixed.

  Args:
    filename: (String) Path to source file being edited.

  Returns:
    (Dictionary)
      'flags': (List of Strings) Command line flags.
      'do_cache': (Boolean) True if the result should be cached.
  """
  abs_filename = os.path.abspath(filename)
  chrome_root = FindChromeSrcFromFilename(abs_filename)
  clang_flags = GetClangOptionsFromNinjaForFilename(chrome_root, abs_filename)

  # If clang_flags could not be determined, then assume that was due to a
  # transient failure. Preventing YCM from caching the flags allows us to try to
  # determine the flags again.
  should_cache_flags_for_file = bool(clang_flags)

  return {'flags': clang_flags, 'do_cache': should_cache_flags_for_file}
