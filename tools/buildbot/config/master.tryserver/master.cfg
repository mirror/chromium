# -*- python -*-
# ex: set syntax=python:

# Copyright (c) 2006-2008 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This is the buildmaster config file for the 'chromium' bot. It must
# be installed as 'master.cfg' in your buildmaster's base directory
# (although the filename can be changed with the --basedir option to
# 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .

from buildbot import locks
from buildbot.buildslave import BuildSlave
from buildbot.changes.pb import PBChangeSource
from buildbot.steps import shell

# These modules are beside this configuration file. They should be moved to
# scripts/master.
from builders_pools import BuildersPools
from try_job_http import TryJobHTTP
from try_job_svn import TryJobSubversion

# These modules come from scripts/master, which must be in the PYTHONPATH.
import chromium_step
import factory_commands
import master_utils

# These modules come from scripts/common, which must be in the PYTHONPATH.
import chromium_config as config
import chromium_utils

ActiveMaster = config.Master.TryServer

# The default behavior of this master.cfg file is to run our production
# buildbot only when running on our production host.
PRODUCTION_BUILDBOT_MASTER = ActiveMaster.is_production_host

# Use only one builder per platform instead of one builder per slave.
USE_SINGLE_BUILDER = True

if PRODUCTION_BUILDBOT_MASTER:
  # Production defaults
  MASTER_HOST = ActiveMaster.master_host
  WEB_STATUS = True
  MAIL_NOTIFIER = True
  IRC_STATUS_BOT = False
  PB_LISTENER = False
  IN_BIG_HOUSE = True
else:
  MASTER_HOST = config.Master.Experimental.master_host
  WEB_STATUS = True
  MAIL_NOTIFIER = False
  IRC_STATUS_BOT = False
  PB_LISTENER = False
  IN_BIG_HOUSE = False

MASTER_PORT = ActiveMaster.master_port


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)
c['slavePortnum'] = ActiveMaster.slave_port


####### BUILDSLAVES

# the 'bots' list defines the set of allowable buildslaves. Each element is a
# tuple of bot-name and bot-password. These correspond to values given to the
# buildslave's mktap invocation.
c['slaves'] = []
c['builders'] = []


####### CHANGESOURCES

c['change_source'] = [ PBChangeSource() ]


####### BUILDERS

# FACTORIES

m_win = master_utils.MasterFactory('src/chrome',
                                   config.Master.trunk_url_src,
                                   config.Master.trunk_internal_url_src,
                                   target_platform='win32')

m_win_webkit = master_utils.MasterFactory('src/webkit',
                                          config.Master.trunk_url_src,
                                          config.Master.trunk_internal_url_src,
                                          target_platform='win32')

m_linux = master_utils.MasterFactory('src/chrome',
                                     config.Master.trunk_url_src,
                                     config.Master.trunk_internal_url_src,
                                     target_platform='linux2')

m_mac = master_utils.MasterFactory('src/chrome',
                                   config.Master.trunk_url_src,
                                   config.Master.trunk_internal_url_src,
                                   target_platform='darwin')

def CreateBot(platform, prefix='try ', postfix=None, slave_name=None,
              slave_dir=None, password=config.Master.GetBotPassword(),
               builder_name=None, index=None, target=None,
               webkit=False, tests=None,
              options=None, mode=None, solution=None, svnurl=None,
              perf_id=None, timeout=1200, locks=None, slave_names=None,
              check_deps=False):
  """Generates and register a builder along with its slave(s).

  Implicitly register slave_name or slave_names if they weren't registered yet.
  If none of slave_name or slave_names is supplied, a slave name will be
  constructed from the builder name."""
  if platform not in ('win32', 'win64', 'linux', 'mac'):
    raise Exception(platform + ' is not an known os type')
  if not builder_name:
    builder_name = prefix + platform
    if postfix:
      builder_name += ' ' + postfix
    if target in ('Hammer', 'Debug'):
      builder_name += ' dbg'
    if target == 'Release':
      builder_name += ' rel'
    if index:
      builder_name += ' ' + str(index)
  if not slave_name:
    slave_name = builder_name.replace(' ', '-')
  if not slave_dir:
    slave_dir = builder_name.replace(' ', '-')
  multi_config = isinstance(target, (list, tuple))
  if multi_config:
    first_target = target[0]
  else:
    first_target = target

  run_crash_handler=False
  build_dir = None
  if platform in ('win32', 'win64'):
    if webkit:
      factory = m_win_webkit
    else:
      factory = m_win
      run_crash_handler = True
    if not options:
      options = ['--fastbuild']
  elif platform == 'linux':
    factory = m_linux
    if not options:
      options = ['--build-tool=scons', '--', 'Hammer']
  elif platform == 'mac':
    factory = m_mac
    build_dir = 'src/build'
    if not options:
      options = ['--build-tool=xcode', '--', '-project', 'all.xcodeproj']
  builder_factory = factory.NewBuildFactory(
      identifier=builder_name, slave_type='Trybot', target=first_target,
      run_crash_handler=run_crash_handler, tests=tests, options=options,
      mode=mode, solution=solution, svnurl=svnurl, perf_id=perf_id,
      compile_timeout=timeout, build_dir=build_dir, check_deps=check_deps)
  if multi_config:
    # Do a release compilation to trap release-only compilation failure.
    factory_cmd_obj = factory_commands.FactoryCommands(
        builder_factory, builder_name, target[1], factory._build_dir,
        factory._target_platform)
    factory_cmd_obj.AddCompileStep(factory._solution, timeout=timeout)
  # TODO(maruel):  if mode == 'official': archive the build somewhere. Probably
  # always archive the build?
  # TODO(maruel):  Add a revert step here to accelerate the next build?
  # TODO(maruel):  Preemptively recompile clean to accelerate next build?
  builder = {
    'name': builder_name,
    'builddir': slave_dir,
    'factory': builder_factory,
  }
  if slave_names:
    builder['slavenames'] = slave_names
    for slave_name in slave_names:
      if not slave_name in c['slaves']:
        c['slaves'].append(BuildSlave(slave_name, password))
  else:
    builder['slavename'] = slave_name
    if not slave_name in c['slaves']:
      c['slaves'].append(BuildSlave(slave_name, password))

  if locks:
    builder['locks'] = [locks]
  c['builders'].append(builder)


# Try queues.
pools = BuildersPools()
webkit_merge_pools = BuildersPools()
number_win32 = 20
number_linux = 4
number_mac = 6
linux_locks = [None]
mac_locks = [None]
win32_locks = [None]
win_multi_locks = [None]


# A index to slave name mapper.
def GetWinSlaveName(index):
  """hae139, hae140, ..., hae148, try-win32-1, try-win32-2, ..."""
  if IN_BIG_HOUSE:
    slaves = ['hae%d' % i for i in range(139, 149)]
  else:
    slaves = []
  slaves += ['try-win32-%d' % i for i in range(1, number_win32 + 1)]
  return slaves[index - 1]

def GetLinuxSlaveName(index):
  """hae137, hae138, try-linux-1, try-linux-2, ..."""
  if IN_BIG_HOUSE:
    slaves = ['hae%d' % i for i in range(137, 139)]
  else:
    slaves = []
  slaves += ['try-linux-%d' % i for i in range(1, number_linux + 1)]
  return slaves[index - 1]

def GetMacSlaveName(index):
  """hae133, hae134, hae135, hae136, try-mac-1, try-mac-2, ..."""
  if IN_BIG_HOUSE:
    slaves = ['hae%d' % i for i in range(133, 137)]
  else:
    slaves = []
  slaves += ['try-mac-%d' % i for i in range(1, number_mac + 1)]
  return slaves[index - 1]


# Linux bots
linux_tests = ['base', 'net', 'googleurl', 'unit', 'ui', 'test_shell', 'media']
if USE_SINGLE_BUILDER:
  linux_slaves = [GetLinuxSlaveName(x) for x in range(1, number_linux + 1)]
  CreateBot(index=1,
            platform='linux',
            target='Hammer',
            tests=linux_tests,
            slave_names=linux_slaves,
            builder_name='linux',
            check_deps=True)
  pools[1].append('linux')
else:
  for index in range(1, number_linux + 1):
    linux_locks.append(locks.SlaveLock('try-linux-%d' % index))
    CreateBot(index=index, platform='linux', target='Hammer',
              tests=linux_tests,
              slave_name=GetLinuxSlaveName(index),
              locks=linux_locks[index])
    pools[1].append('try linux dbg %d' % index)


# Mac bots
mac_tests = ['base', 'net', 'googleurl', 'unit', 'ui', 'test_shell', 'media']
if USE_SINGLE_BUILDER:
  mac_slaves = [GetMacSlaveName(x) for x in range(1, number_mac + 1)]
  CreateBot(index=1,
            platform='mac',
            target='Debug',
            tests=mac_tests,
            slave_names=mac_slaves,
            builder_name='mac')
  pools[2].append('mac')
else:
  for index in range(1, number_mac + 1):
    mac_locks.append(locks.SlaveLock('try-mac-%d' % index))
    CreateBot(index=index,
              platform='mac',
              target='Debug',
              tests=mac_tests,
              slave_name=GetMacSlaveName(index),
              locks=mac_locks[index])
    pools[2].append('try mac dbg %d' % index)


# Windows bots
win_tests = ['base', 'net', 'unit', 'ui', 'test_shell', 'media']
if USE_SINGLE_BUILDER:
  win_slaves = [GetWinSlaveName(x) for x in range(1, number_win32 + 1)]
  CreateBot(index=1,
            target='Debug',
            platform='win32',
            tests=win_tests,
            slave_names=win_slaves,
            builder_name='win')
  pools[0].append('win')
else:
  for index in range(1, number_win32 + 1):
    win32_locks.append(locks.SlaveLock('try-win32-%d' % index))
    CreateBot(index=index,
              target='Debug',
              platform='win32',
              tests=win_tests,
              slave_name=GetWinSlaveName(index),
              locks=win32_locks[index],
              builder_name='try win32 %d' % index)
    pools[0].append('try win32 %d' % index)


####### SCHEDULERS

# Configure the Schedulers;
# Main Tryscheduler for the try queue. groups is defined in the loop above.
c['schedulers'] = []

c['schedulers'].append(TryJobHTTP(name='try_job_http',
                                  port=ActiveMaster.try_job_port,
                                  pools=pools))
c['schedulers'].append(TryJobSubversion(name='try_job_svn',
                                        svn_url=ActiveMaster.svn_url,
                                        pools=pools))


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

if WEB_STATUS:
  #from buildbot.status.html import WebStatus
  from chromium_status import WebStatus
  c['status'].append(WebStatus(MASTER_PORT, allowForce=True))
  c['status'].append(WebStatus(ActiveMaster.master_port_alt, allowForce=False))

# TODO(maruel):  Send to the email burried in the buildsetID.
if MAIL_NOTIFIER:
  from mail_notifier import MailNotifier
  c['status'].append(MailNotifier(
      fromaddr='try_server_noreply@%s' % config.Master.master_domain,
      subject="try %(result)s for %(reason)s on %(builder)s @ r%(revision)s",
      mode='all',
      relayhost=config.Master.smtp,
      lookup=config.Master.master_domain,
      reply_to='maruel@chromium.org'))

# TODO(maruel):  Alert the nick burried in the buildsetID.
if IRC_STATUS_BOT:
  from buildbot.status import words
  # Patch our topic-observing bot in on top of the IRC factory.
  from chromium_status import IrcStatusChatterBot
  words.IrcStatusFactory.protocol = IrcStatusChatterBot
  c['status'].append(words.IRC(host=config.IRC.host,
                               nick='trybot',
                               channels=config.IRC.channels))

if PB_LISTENER:
  from buildbot.status import client
  c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = 'debugpassword'

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole('tcp:9999:interface=127.0.0.1',
#                                       'admin', 'password')


####### PROJECT IDENTITY

# the 'projectName' string will be used to describe the project that this
# buildbot is working on. For example, it is used as the title of the
# waterfall HTML page. The 'projectURL' string will be used to provide a link
# from buildbot HTML pages to your project's home page.

c['projectName'] = ActiveMaster.project_name
c['projectURL'] = 'http://go/ChromeTryServer'

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = 'http://build.chromium.org/buildbot/try-server/'
