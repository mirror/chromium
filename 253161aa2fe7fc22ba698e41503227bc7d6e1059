{
  "comments": [
    {
      "key": {
        "uuid": "b66e51d2_a0f0b3bf",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1003152
      },
      "writtenOn": "2017-08-29T14:22:40Z",
      "side": 1,
      "message": "Note that this might be lossy. I wonder if should use a base::StringValue, then somehow figure out if it should be CBOR-encoded as an int64. Let me know if you see any nice solutions.",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8994839_745cd14b",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-08-29T16:53:58Z",
      "side": 1,
      "message": "Doing a conversion from a string or stringpiece isn\u0027t a problem, but I don\u0027t see a way to tell whether a conversion is needed or if it is simply a string.\nThought about passing a type to EncodeCBOR, but that won\u0027t work when it comes to uint64s in ListValues and Dictionaries.\nThe only solution I can come up with is to have my own values class.",
      "parentUuid": "b66e51d2_a0f0b3bf",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eeeb845a_9519e103",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-08-29T16:59:32Z",
      "side": 1,
      "message": "A-ha, I think I got it.. working on patch..",
      "parentUuid": "f8994839_745cd14b",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7ff2f20_8061cf2d",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-08-29T17:02:38Z",
      "side": 1,
      "message": "FWIW, I\u0027m very nervous about using a JSON value as the input and output of a CBOR encoder. CBOR has a wider value space, including 64-bit integers, byte (non-Unicode) strings, and tags, and they\u0027re just fundamentally not representable in JSON.\n\nbase::Value does happen to handle byte strings, which is odd given the comment at the top of the file.",
      "parentUuid": "f8994839_745cd14b",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26465ab8_14138cd9",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1003152
      },
      "writtenOn": "2017-08-29T18:16:01Z",
      "side": 1,
      "message": "Agree that the mismatch is unfortunate. However, I\u0027d strongly prefer an API that is stateless and takes structured input. Do you have any ideas how we could satisfy both?",
      "parentUuid": "a7ff2f20_8061cf2d",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}