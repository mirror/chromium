{
  "comments": [
    {
      "key": {
        "uuid": "b66e51d2_a0f0b3bf",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1003152
      },
      "writtenOn": "2017-08-29T14:22:40Z",
      "side": 1,
      "message": "Note that this might be lossy. I wonder if should use a base::StringValue, then somehow figure out if it should be CBOR-encoded as an int64. Let me know if you see any nice solutions.",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8994839_745cd14b",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-08-29T16:53:58Z",
      "side": 1,
      "message": "Doing a conversion from a string or stringpiece isn\u0027t a problem, but I don\u0027t see a way to tell whether a conversion is needed or if it is simply a string.\nThought about passing a type to EncodeCBOR, but that won\u0027t work when it comes to uint64s in ListValues and Dictionaries.\nThe only solution I can come up with is to have my own values class.",
      "parentUuid": "b66e51d2_a0f0b3bf",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eeeb845a_9519e103",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-08-29T16:59:32Z",
      "side": 1,
      "message": "A-ha, I think I got it.. working on patch..",
      "parentUuid": "f8994839_745cd14b",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7ff2f20_8061cf2d",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-08-29T17:02:38Z",
      "side": 1,
      "message": "FWIW, I\u0027m very nervous about using a JSON value as the input and output of a CBOR encoder. CBOR has a wider value space, including 64-bit integers, byte (non-Unicode) strings, and tags, and they\u0027re just fundamentally not representable in JSON.\n\nbase::Value does happen to handle byte strings, which is odd given the comment at the top of the file.",
      "parentUuid": "f8994839_745cd14b",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26465ab8_14138cd9",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1003152
      },
      "writtenOn": "2017-08-29T18:16:01Z",
      "side": 1,
      "message": "Agree that the mismatch is unfortunate. However, I\u0027d strongly prefer an API that is stateless and takes structured input. Do you have any ideas how we could satisfy both?",
      "parentUuid": "a7ff2f20_8061cf2d",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "917a936f_cd883e04",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1001949
      },
      "writtenOn": "2017-08-29T18:21:33Z",
      "side": 1,
      "message": "Clearly it\u0027d work for Kim to build a whole parallel cbor::Value type, but the right way to design that type is going to depend on the constraints from other future users of the CBOR library. (For example, web packages will want to avoid copying long bytestrings when parsing CBOR.) I\u0027m inclined to say that making this API stateless is premature abstraction, and that we should wait to do it until there\u0027s at least another user.",
      "parentUuid": "26465ab8_14138cd9",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "227f424e_cf7dc0bb",
        "filename": "content/browser/webauth/cbor/cbor_writer.cc",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1128380
      },
      "writtenOn": "2017-08-29T18:31:51Z",
      "side": 1,
      "message": "I have to say I agree with Jeffrey on this point. The simple impl I had before is admittedly not very robust, but certainly sufficient for WebAuthN\u0027s limited use case and is residing solely in WebAUthN space. I can keep the JSONWriter-style refactor in a WIP branch for when I or anyone else wants to implement a better encoder \u0026 decoder for wider use.",
      "parentUuid": "917a936f_cd883e04",
      "revId": "253161aa2fe7fc22ba698e41503227bc7d6e1059",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}