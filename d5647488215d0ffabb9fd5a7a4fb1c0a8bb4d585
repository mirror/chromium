{
  "comments": [
    {
      "key": {
        "uuid": "37712bef_3fa75c31",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 111,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2017-08-25T01:07:05Z",
      "side": 1,
      "message": "I\u0027m struggling to understand this function. I\u0027ve reread it a handful of times. The comment describes it as doing short copies until it can do chunk-sized copies. (However, it works on loadchunk/storechunk, which are chunk-sized.)\n\nAdditionally, it seems to only be called from here:\nhttps://chromium-review.googlesource.com/c/chromium/src/+/627098/5/third_party/zlib/contrib/arm/inffast.c#231\nThe comment there seems to match the comment here. I believe my understanding of the small-copies-before-using-chunk-sized-copies matches these.\n\nBut the way this operates hasn\u0027t become clear to me yet.\n* We\u0027re copying |from| -\u003e |out|.\n* |from| is calculated by moving backwards from |out| by the magnitude |dist|. Since |dist| is unsigned, |from| must come first in the absolute memory address. This seems odd.\n* |from| is never updated, so we\u0027re copying the same values multiple times. (loadchunk could be moved out of the loop)\n* Since we increment |out| by an unsigned value, we\u0027re working from the front of the buffer to the back.\n\nAn example run-through might be shifting a buffer to the right 3 bytes\n* Suppose our buffer is filled with the values 1, 2, 3, 4, 5, ...\n* |dist| is 3\n* We load the first chunk from the buffer and write it to the shifted-right location (clobbering 3 bytes)\n* |out| +\u003d 3, so |out| is now 6 bytes from the beginning of the buffer\n* We double |dist| so it is now 6.\n* 6 \u003c the chunk size of 16 so we loop again\n* We load the first chunk again (didn\u0027t move |from|) and write it to the shifted-right location, which is now the front of the buffer + 6\n* At this point, we have clobbered 6 bytes and our buffer looks like 1, 2, 3, 1, 2, 3, 4, 5, 6, ...\n* It continues looping, doubling |dist| each time. So the next doubling causes |dist| to become 12, the copy happens, and when |dist| doubles again it becomes 24 and is greater than the chunk size so it doesn\u0027t loop further.\n\n\nMaybe I\u0027m misreading something?",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe2f7c6d_71382225",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 111,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-08-25T03:31:06Z",
      "side": 1,
      "message": "Well, that\u0027s how DEFLATE works: more like memcpy than memmove.\n\nA string of 20 consecutive \u0027A\u0027 bytes can be encoded as a literal \u0027A\u0027 followed by a \u003clength\u003d19, distance\u003d1\u003e code. A string of 7 consecutive \"ABC\"s can be encoded as the three literals \u0027A\u0027, \u0027B\u0027, \u0027C\u0027 followed by a \u003clength\u003d18, distance\u003d3\u003e code. When decoding, after the first three literals our buffer is \"ABC_etc\", where the underscore denotes the out pointer. Iterations of this loop expand that to \"ABCABC_etc\" (and now len\u003d15, dist\u003d6), \"ABCABCABCABC_etc\" (and now len\u003d9, dist\u003d12, so the loop ends).\n\nThere\u0027s a comment \"The main part of this loop is a simple copy of eight bytes...\" about a similar technique in the Go Snappy port at https://github.com/golang/snappy/blob/master/decode_amd64.s#L367\n\nThat comment was originally in the C++ Snappy implementation but the C++ Snappy code appears to have refactored itself since then.",
      "parentUuid": "37712bef_3fa75c31",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a65a2246_fcbfaa95",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 111,
      "author": {
        "id": 1240200
      },
      "writtenOn": "2017-08-25T04:02:43Z",
      "side": 1,
      "message": "At that call site (and at line 196 below) all the preconditions are met to allow a very sloppy implementation.  It reads a chunk, and writes a chunk at the output, and then doubles the period that it\u0027s working with until that period is at least as large as a chunk.  This means that it can splatter something like twice the chunksize of output, but it can do it in log_2(16/dist) iterations.\n\nOnce that\u0027s done, a regular chunk copy can run, because as far as it\u0027s concerned the source and the destination do not overlap by a hazardous distance.",
      "parentUuid": "fe2f7c6d_71382225",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5975e41_3eb466fc",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 111,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2017-08-25T08:00:49Z",
      "side": 1,
      "message": "Oh geeze. Of course. I was so fixed on this being a memmove for some reason. This makes a LOT more sense now. :)",
      "parentUuid": "a65a2246_fcbfaa95",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e5240ef_1a68af7c",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 130,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-08-24T05:56:12Z",
      "side": 1,
      "message": "I\u0027m confused why you mentioned memset. Did you mean memmove instead?",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "198875ba_bf46339e",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 130,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-08-24T21:33:21Z",
      "side": 1,
      "message": "Yeah, makes sense. Quoting the man page: \"The  memmove()  function  copies n bytes from memory area src to memory area dest.  The memory areas may overlap...\".\n\nOn the other hand, a VMOV has quite a different meaning than a VLD (which is what is done in the function).",
      "parentUuid": "5e5240ef_1a68af7c",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edaddb92_28139924",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 130,
      "author": {
        "id": 1240200
      },
      "writtenOn": "2017-08-25T04:02:43Z",
      "side": 1,
      "message": "It\u0027s a memset(), not a memmove().  When the source and destination overlap, memmove() explicitly reproduces the entire source buffer at the new destination, which is precisely the opposite of what is required by deflate.  The memset() behaviour referenced here is to fill the destination with a repeating pattern of length `period` (rather than length 1, the only option in libc memset()).  It\u0027s simply a quirk of the way that inflate works that the fill pattern lies immediately before the address to be written.",
      "parentUuid": "198875ba_bf46339e",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9baac76_f46126e6",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2017-08-24T08:22:49Z",
      "side": 1,
      "message": "This parameter (period) seems to be called \"dist\" elsewhere.\nAs I understand it, both here and in chunkunroll_relaxed (where it is called \"dist\"), it represents the size to be copied before using the chunk-sized copies.\n\nThe difference seems to be the places where it is called \"dist\" we still copy chunks. But I imagine that isn\u0027t significant. In fact, that seems to be the only difference between this and chunkcopy_lapped_relaxed. Are both of these functions needed?",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0b33fa37_083729be",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-08-24T21:33:21Z",
      "side": 1,
      "message": "IIRC, the compressed segments can have quite a few different cases.\n\nEach chunk_function() were carefully optimized for those.",
      "parentUuid": "f9baac76_f46126e6",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2099d361_d7b1052f",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1240200
      },
      "writtenOn": "2017-08-25T04:02:43Z",
      "side": 1,
      "message": "This version implements cases where the source and the destination buffers overlap.  The deflate algorithm uses this condition to write repeating patterns; chunkcopy_lapped_relaxed() would fumble this because it assumes it can read and write chunks of 16 bytes at a time, which doesn\u0027t work (easily) for shorter periods.",
      "parentUuid": "0b33fa37_083729be",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3b8c27d_8838ba5b",
        "filename": "third_party/zlib/contrib/arm/chunkcopy.h",
        "patchSetId": 5
      },
      "lineNbr": 136,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2017-08-25T08:00:49Z",
      "side": 1,
      "message": "Got ya. Thank you. :)",
      "parentUuid": "2099d361_d7b1052f",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20c504d4_34978136",
        "filename": "third_party/zlib/contrib/arm/inffast.c",
        "patchSetId": 5
      },
      "lineNbr": 108,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-08-24T05:56:12Z",
      "side": 1,
      "message": "FYI in https://chromium-review.googlesource.com/c/chromium/src/+/601694 I found significant improvement in loading the bits 8 bytes at a time instead of 1 byte at a time. This optimization is similar to but independent of the 8 byte or 16 byte wider load / stores when resolving a length-distance pair (a copy).\n\n601694 is also not ARM-specific, and applies to x86_64 too.",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "44968647_302b5bb8",
        "filename": "third_party/zlib/contrib/arm/inffast.c",
        "patchSetId": 5
      },
      "lineNbr": 108,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-08-24T21:33:21Z",
      "side": 1,
      "message": "Indeed is something we could try to squeeze even more performance (e.g. a \u0027vld\u0027 using the D0-D31 registers) after we land this current patch. \n\nOn the other hand, it is an open question how common are data segments of that tiny size. It may require some code without major gains (not to mention that is more intrusive on vanilla zlib code).\n\nAbout 601694: it assumes that unaligned 64bits loads are cheap and readily available, no?\n\nUnfortunately, not all platforms have \u0027free\u0027 cost unaligned loads (i.e. Intel).\n\nLast time I checked, unaligned access had many restrictions on ARMv7 (i.e. only word-aligned *or* using the SIMD path as we have in this patch, otherwise it generates an alignment fault).\n\nThe few instructions that could work (LDR, PUSH, STR) would pretty much overload the bus: the memory access would be broken down into multiple accesses, bringing penalty forcing cache reloads, etc.\n\nUnfortunately, optimization strategies (i.e. loading more data) may be common between the architectures, but not necessarily the optimal implementation.",
      "parentUuid": "20c504d4_34978136",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "395d2238_c42306f4",
        "filename": "third_party/zlib/contrib/arm/inffast.c",
        "patchSetId": 5
      },
      "lineNbr": 108,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-08-25T02:47:08Z",
      "side": 1,
      "message": "\u003e it is an open question how common are data segments of that tiny size.\n\nI\u0027m not sure why the data segment size matters. The technique in 601694 doesn\u0027t apply only to tiny source buffers.\n\nOn x86_64, I measured a 1.2x throughput gain from reading into the bit accumulator 8 bytes at a time. Independent of that, read/writing 8 bytes at a time for length-distance copies gave an additional 1.3x. The first technique requires a little endian CPU. The second technique does not.\n\n\n\u003e About 601694: it assumes that unaligned 64bits loads are cheap and readily available, no?\n\nYes, it does, which is why it is gated on e.g. #if defined(__aarch64__). 601694 should have no code changes on 32 bit ARM.",
      "parentUuid": "44968647_302b5bb8",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8afc215_3c0bfad0",
        "filename": "third_party/zlib/contrib/arm/inffast.c",
        "patchSetId": 5
      },
      "lineNbr": 108,
      "author": {
        "id": 1240200
      },
      "writtenOn": "2017-08-25T04:02:43Z",
      "side": 1,
      "message": "Separate optimisations in separate patches.  This is usually the first thing anyone does when they approach an VLC coder, but I separated it out into another patch and then began a more substantial refactor of the code handling (fewer switches for fewer branch mispredicts), but then backed off because it was conflicting with pre-existing and on-going work in zlib-ng.",
      "parentUuid": "395d2238_c42306f4",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e5b530d_1d5b1dd5",
        "filename": "third_party/zlib/contrib/arm/inffast.c",
        "patchSetId": 5
      },
      "lineNbr": 108,
      "author": {
        "id": 1240200
      },
      "writtenOn": "2017-08-25T06:36:09Z",
      "side": 1,
      "message": "BTW, to express a legal unaligned load in C you can\u0027t necessarily just cast the pointer, but you can write bytes loads and rely on the compiler to fuse them provided it\u0027s a clear machine word load (eg., src[0]+src[1]*256u+...).  All the big endian targets I tried with that produce special endian-reversing and alignment-fixing loads and these are probably still faster than the original code despite the extra work.\n\nThis breaks down a little in some compilers if you scale it down to 16-bit, but works in principle on 32-bit targets (and provides a performance gain on \u003e\u003d armv7).  You just have to watch the compiler closely to make sure it doesn\u0027t screw up.",
      "parentUuid": "c8afc215_3c0bfad0",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a788724_acbea8a5",
        "filename": "third_party/zlib/contrib/arm/inflate.c",
        "patchSetId": 5
      },
      "lineNbr": 1,
      "author": {
        "id": 1237531
      },
      "writtenOn": "2017-08-24T05:56:12Z",
      "side": 1,
      "message": "Is there a summary somewhere of how this inflate.c differs from the top level inflate.c?",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e46ba553_2afb8a8b",
        "filename": "third_party/zlib/contrib/arm/inflate.c",
        "patchSetId": 5
      },
      "lineNbr": 1,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-08-24T21:33:21Z",
      "side": 1,
      "message": "No, but changes are minimal, targeting easy of rebase with new release of zlib.\n\nPlease check: https://gist.github.com/Adenilson/1d53394d2cad6632287bd88ef6f4b7d6",
      "parentUuid": "2a788724_acbea8a5",
      "revId": "d5647488215d0ffabb9fd5a7a4fb1c0a8bb4d585",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}