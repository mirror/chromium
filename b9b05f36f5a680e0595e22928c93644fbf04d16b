{
  "comments": [
    {
      "key": {
        "uuid": "144c7c7c_7b1a2cee",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-23T16:01:04Z",
      "side": 1,
      "message": "Why are 2 threads initializing the same thread-local storage?",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e25f048e_8c2b9a4a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-28T23:09:12Z",
      "side": 1,
      "message": "A TLS object is shared across all threads, it\u0027s initialized to point to a slot. That slot just doesn\u0027t have the same *value* on each thread (i.e. the thread-specific part is not the object, it\u0027s the value).",
      "parentUuid": "144c7c7c_7b1a2cee",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e947e736_a786ebf9",
        "filename": "base/threading/thread_local_storage.cc",
        "patchSetId": 1
      },
      "lineNbr": 262,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-25T22:38:03Z",
      "side": 1,
      "message": "callers already check this, i don\u0027t think we need to add it again",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c5edb03_4520fc90",
        "filename": "base/threading/thread_local_storage.cc",
        "patchSetId": 1
      },
      "lineNbr": 262,
      "author": {
        "id": 1146127
      },
      "writtenOn": "2018-01-26T12:38:51Z",
      "side": 1,
      "message": "This is for performance - checking an atomic is faster than mutex (especially since the mutex is a common one) but since racing initialization is rare - it\u0027s not something I\u0027m intent insisting upon. DCHECK(!initialized())?",
      "parentUuid": "e947e736_a786ebf9",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fcd065c5_51e55f13",
        "filename": "base/threading/thread_local_storage.cc",
        "patchSetId": 1
      },
      "lineNbr": 262,
      "author": {
        "id": 1146127
      },
      "writtenOn": "2018-01-26T12:48:13Z",
      "side": 1,
      "message": "Actually this would also be racy, so DCHECK is not a good idea",
      "parentUuid": "4c5edb03_4520fc90",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "288db4c4_0e4f57e5",
        "filename": "base/threading/thread_local_storage.cc",
        "patchSetId": 1
      },
      "lineNbr": 262,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-26T16:30:03Z",
      "side": 1,
      "message": "Right, DCHECK would be racey, but since callers already check initialized() before calling this, the early out here is really not going to be useful very much. I don\u0027t think it\u0027s worth the LOC because of that.",
      "parentUuid": "fcd065c5_51e55f13",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b709c01_db06ee62",
        "filename": "base/threading/thread_local_storage.cc",
        "patchSetId": 1
      },
      "lineNbr": 265,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-25T22:38:03Z",
      "side": 1,
      "message": "can you add a comment explaining why the lock is here for the future?",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a44bef7_69704a6f",
        "filename": "base/threading/thread_local_storage.cc",
        "patchSetId": 1
      },
      "lineNbr": 271,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-25T22:38:03Z",
      "side": 1,
      "message": "these braces aren\u0027t doing anything for us anymore",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7f90284_e8755d6f",
        "filename": "base/threading/thread_local_storage.h",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-26T11:21:02Z",
      "side": 1,
      "message": "Add default initialization of this variable to \u003d 0;\n\nThen ThreadLocalStorage::StaticSlot::Initialize() doesn\u0027t need to set it to 0 and initialization is non-racy anymore.",
      "range": {
        "startLine": 133,
        "startChar": 39,
        "endLine": 133,
        "endChar": 40
      },
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0be510c_3da8c83a",
        "filename": "base/threading/thread_local_storage.h",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1146127
      },
      "writtenOn": "2018-01-26T12:24:43Z",
      "side": 1,
      "message": "I don\u0027t see how initialized_ default initialization helps with the race.\n\nAre you rather talking about slot_ initialization to -1? This looks like a possible solution to crash on CHECKs but there might still be incorrect work with g_tls_metadata when two threads race for inititialization (one lock protected section executing immediately after the other) unless initialized_ is set to 1 and checked within the lock scope.",
      "parentUuid": "a7f90284_e8755d6f",
      "range": {
        "startLine": 133,
        "startChar": 39,
        "endLine": 133,
        "endChar": 40
      },
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "184095b2_211000c9",
        "filename": "base/threading/thread_local_storage.h",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-26T13:03:42Z",
      "side": 1,
      "message": "My bad, wrong line, also default initialize slot_ \u003d kInvalidSlotValue;\n\nThen it goes from kInvalidSlotValue -\u003e initialized value under the lock and is const thereafter (assuming synchronization around Free()\u0027s which are hopefully not done while multiple threads are up -- unwinding only when down to main thread on shutdown is typical of other //base constructs so that\u0027s okay IMO)",
      "parentUuid": "d0be510c_3da8c83a",
      "range": {
        "startLine": 133,
        "startChar": 39,
        "endLine": 133,
        "endChar": 40
      },
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03700683_d5555268",
        "filename": "base/threading/thread_local_storage.h",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1146127
      },
      "writtenOn": "2018-01-26T13:28:34Z",
      "side": 1,
      "message": "ok, but still, looks like\nbase::subtle::Release_Store(\u0026initialized_, 1); \nshould go into the lock scope together with an initialized() check immediately after the AutoLock line. Otherwise its possible that racy Initialize will lead to the same StaticSlot attempting to occupy two slots in g_tls_metadata. Right?",
      "parentUuid": "184095b2_211000c9",
      "range": {
        "startLine": 133,
        "startChar": 39,
        "endLine": 133,
        "endChar": 40
      },
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b71bd848_aded6765",
        "filename": "base/threading/thread_local_storage.h",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-28T23:09:12Z",
      "side": 1,
      "message": "Right, that feels a whole lot like LazyInstance initialization actually... why don\u0027t we just use that logic? e.g. lazy_instance_helpers.h\n\nI\u0027m not very familiar with StaticSlot, what are the use cases? I\u0027ve always used a non-static-slots stored in a LazyInstance FWIW...\n\nFeels weird to leave something uninitialized but then race to initialize it.",
      "parentUuid": "03700683_d5555268",
      "range": {
        "startLine": 133,
        "startChar": 39,
        "endLine": 133,
        "endChar": 40
      },
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3822ecde_e8dc01f2",
        "filename": "base/threading/thread_local_storage.h",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1146127
      },
      "writtenOn": "2018-01-30T15:12:14Z",
      "side": 1,
      "message": "I\u0027ve had a look at lazy_instance_helpers. A possible option would be to wrap slot_/other member variable and g_tls_metadata manipulations with NeedsLazyInstance/CompleteLazyInstance even as they are now. However, given that the initialization scenario requires an AutoLock anyway, don\u0027t you think that a second synchronization mechanism looks redundant? \n\nGiven that racing StaticSlot initializations are rare they are unlikely to add much wait for the lock during other StaticSlot initializations. Which, if it was the case, could be a motivation for another sync mechanism. Or am I missing something?\n\nIt seems that the use case for the StaticSlot is static storage duration variables. And yeah, LazyInstance of the non-static Slot looks a working option as well.",
      "parentUuid": "b71bd848_aded6765",
      "range": {
        "startLine": 133,
        "startChar": 39,
        "endLine": 133,
        "endChar": 40
      },
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a26bd57_32856554",
        "filename": "base/threading/thread_local_storage.h",
        "patchSetId": 1
      },
      "lineNbr": 135,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2018-01-26T11:21:02Z",
      "side": 1,
      "message": "Also, I believe these members can be made private for realz now with C++11 (with a constexpr default constructor and inline POD member initialization). I did that recently for LazyInstance and it didn\u0027t generate static initializers.",
      "revId": "b9b05f36f5a680e0595e22928c93644fbf04d16b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}