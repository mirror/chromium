{
  "comments": [
    {
      "key": {
        "uuid": "41af25a7_20203512",
        "filename": "gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.cc",
        "patchSetId": 6
      },
      "lineNbr": 98,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-11T22:05:42Z",
      "side": 1,
      "message": "nit: it would be good to release the lock before the syscall (which could block, though unlikely).",
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cfcdda0b_aebc2ccc",
        "filename": "gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.h",
        "patchSetId": 6
      },
      "lineNbr": 30,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-11T22:05:42Z",
      "side": 1,
      "message": "nit: explicit",
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3561679b_5e96c1db",
        "filename": "gpu/ipc/service/protected_gpu_memory_buffer_manager.h",
        "patchSetId": 6
      },
      "lineNbr": 23,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-11T22:56:37Z",
      "side": 1,
      "message": "As I\u0027m mentioned multiple times offline. I think GMB is the wrong level to do this. Dummy GMB \u003c-\u003e protected GMB mapping only works on one chrome platform, Ozone. And only with one Ozone implementation Ozone-DRM. To avoid unnecessary maintenance burden and keep it simple to understand it should ideally be done at the Ozone-DRM level. By introducing it at the GMB level we\u0027re making two abstraction levels above what is needed aware of it. I\u0027d like this to at least be moved back to the NativePixmap abstraction level as ProtectedNativePixmapManager. I thought that was what we agreed on? and not clear why the plan changed.",
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4d31c81_bcd44a47",
        "filename": "gpu/ipc/service/protected_gpu_memory_buffer_manager.h",
        "patchSetId": 6
      },
      "lineNbr": 23,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2017-10-11T23:39:42Z",
      "side": 1,
      "message": "This works only with Ozone right now, because it is at the moment the only concrete implementation of what is otherwise designed and intended to be a platform-independent GPU process API.\n\nI believe that moving it to ozone and making it use NativePixmap, which are an ozone abstraction, would actually make this platform-dependent (ozone-only), which would make it difficult to expose as a general GPU process API.\n\nIn my understanding, GpuMemoryBuffer is a general platform-independent buffer abstraction to share and pass around GPU-allocated buffers, while NativePixmaps are a platform-specific way to implement GpuMemoryBuffers.\n\nPerhaps we could instead discuss/address issues with this design and/or idea of this API that could make it difficult or not suitable for/usable on other platforms. Would you be able to explain any technical or design reasons you may be seeing why this would not work on other platforms (once implemented by means available there) please?\n\nOr, alternatively, could you perhaps suggest an alternative API that would allow exposing and sharing GPU-allocated buffers inaccessible to unprivileged clients of the GPU process in a way transparent to them please?",
      "parentUuid": "3561679b_5e96c1db",
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8c0f6b7_9da4f749",
        "filename": "gpu/ipc/service/protected_gpu_memory_buffer_manager.h",
        "patchSetId": 6
      },
      "lineNbr": 23,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-12T20:18:36Z",
      "side": 1,
      "message": "Protected buffers implemented in software like this only makes sense on Chrome OS (ozone DRM) where we have full control of the OS. On platforms such as Linux, Android, Windows or MacOS we would have to rely on a protected buffer mechanism that is provided by the platform and is likely HW assisted. I don\u0027t see how any of the software protected buffer logic that this CL implements will make sense there.\n\nAlso, it\u0027s standard policy in chromium to not generalize and create unnecessary abstractions until needed. If the day comes when we need to support protected buffers on other platforms then we can look at how to support that.\n\nI made a copy of this CL (https://chromium-review.googlesource.com/c/chromium/src/+/716958) and uploaded some changes that would remove the use of GMB in an attempt to provide a more concrete example. See diff between patch set 1 and 4. It doesn\u0027t have to be done exactly like that of course and gpu process init order might be wrong but it should give you an idea of what I\u0027m thinking. It would be really nice to take that one step further and move it all into ozone-DRM where I think it belongs but depending on how urgent it is to land this that might too much work.",
      "parentUuid": "d4d31c81_bcd44a47",
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b09dd482_659e8d60",
        "filename": "gpu/ipc/service/protected_gpu_memory_buffer_manager.h",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-11T22:05:42Z",
      "side": 1,
      "message": "nit: no need for this since you can\u0027t instantiate this class and it has no member variable.",
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf3b78f3_5059e4b2",
        "filename": "ui/gfx/gpu_memory_buffer.h",
        "patchSetId": 6
      },
      "lineNbr": 114,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-11T22:56:37Z",
      "side": 1,
      "message": "Do we need this? if it\u0027s really needed then I\u0027d like it done as a dtor to be consistent with SharedMemoryHandle and in a separate patch.",
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2acf1fa0_825c2582",
        "filename": "ui/ozone/platform/drm/gpu/gbm_buffer.cc",
        "patchSetId": 6
      },
      "lineNbr": 267,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-11T22:56:37Z",
      "side": 1,
      "message": "these lines look good. can we start by landing this as a separate CL first? I think we need this in canary for a few days before it\u0027s safe to merge it to 62.",
      "range": {
        "startLine": 263,
        "startChar": 2,
        "endLine": 267,
        "endChar": 73
      },
      "revId": "7711f8e4d78e4a442a5527aa78fb2fb04cb70ddf",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}