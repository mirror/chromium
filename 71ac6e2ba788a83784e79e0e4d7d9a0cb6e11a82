{
  "comments": [
    {
      "key": {
        "uuid": "c6ceddff_1a1bc8e9",
        "filename": "content/browser/gpu/gpu_data_manager_impl_private.cc",
        "patchSetId": 10
      },
      "lineNbr": 827,
      "author": {
        "id": 1000608
      },
      "writtenOn": "2017-08-10T19:17:23Z",
      "side": 1,
      "message": "FYI, we normally do this sort of switch propagation with kSwitchNames in content/browser/gpu/gpu_process_host.cc",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a76e324_3c6d034e",
        "filename": "content/browser/gpu/gpu_data_manager_impl_private.cc",
        "patchSetId": 10
      },
      "lineNbr": 827,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-08-10T20:55:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c6ceddff_1a1bc8e9",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2c35cb77_09675dd8",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 10
      },
      "lineNbr": 7201,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T20:10:25Z",
      "side": 1,
      "message": "This seems a bit hacky. The only reason we\u0027re passing the display item list is for the paint op buffer and the rtree, and we look at the internals of it to get the rtree. I\u0027m not saying we should transport different items here, but I think we can clean up this api.\n\nCan you leave a TODO to rethink this approach. I think we can get a proxy iterator type of thing going on display item list, so you should be able to do something along the lines of\n\nfor (cc::PaintOp* op : list-\u003eFlattenedView(playback_rect)) {\n  ...\n}",
      "range": {
        "startLine": 7199,
        "startChar": 0,
        "endLine": 7201,
        "endChar": 60
      },
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa70f673_b6238c8a",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 10
      },
      "lineNbr": 7212,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T20:10:25Z",
      "side": 1,
      "message": "I think this was noted already, but this shouldn\u0027t be reset like this",
      "range": {
        "startLine": 7211,
        "startChar": 0,
        "endLine": 7212,
        "endChar": 33
      },
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb0816cc_9f585da9",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 10
      },
      "lineNbr": 7216,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T20:10:25Z",
      "side": 1,
      "message": "Is this type \u0026 skip check? I was kind of wondering if at some point we don\u0027t serialize NoopOp at all but I guess that could be done in the flattening iterator (if it\u0027s isn\u0027t already)",
      "range": {
        "startLine": 7216,
        "startChar": 20,
        "endLine": 7216,
        "endChar": 22
      },
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "354b36b1_01badf81",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 3706,
      "author": {
        "id": 1116061
      },
      "writtenOn": "2017-08-10T23:31:12Z",
      "side": 1,
      "message": "As piman@ mentioned, we can replace GrGLCreateNativeInterface() with a custom handler that uses gl::GetGLProcAddress() to read bindings.  This will allow bindings to work on all platforms.\n\nCode in old prototype is here:\nhttps://github.com/vmiura/chromium/blob/experimental_skia_command_buffer/gpu/command_buffer/service/gles2_cmd_decoder.cc#L118",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "580ee63e_6447fb76",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 3710,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T20:10:25Z",
      "side": 1,
      "message": "Maybe we should return false? Or is that bad?",
      "range": {
        "startLine": 3710,
        "startChar": 18,
        "endLine": 3710,
        "endChar": 58
      },
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20bd474e_2cd11fe8",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 19983,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T20:10:25Z",
      "side": 1,
      "message": "Should we error if surface/canvas already exist? (ie two begin rasters in a row)",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc945719_be6101f7",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 20028,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T20:10:25Z",
      "side": 1,
      "message": "Probably need to error if !canvas_ (ie begin was not called)",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16f7e82f_2cc0dfe2",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 20038,
      "author": {
        "id": 1000608
      },
      "writtenOn": "2017-08-10T19:17:23Z",
      "side": 1,
      "message": "The last argument should be \"size\" so we can be sure we don\u0027t run off the end of the buffer.\n\nAlso these should probably be a \"volatile char*\" to make it more clear to the compiler that this data could change at any time (due to a malicious renderer). And cc::PaintOp::Deserialize and the functions it calls also need to be safe against that.",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "026fd39b_b29fc9e2",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 20038,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-08-10T20:55:45Z",
      "side": 1,
      "message": "Oh whoops, thanks.\n\nHmm, ok.  I\u0027ll look into making all the Deserialize function take volatiles in a separate patch.",
      "parentUuid": "16f7e82f_2cc0dfe2",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69585d3a_954ba263",
        "filename": "gpu/command_buffer/service/gles2_cmd_decoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 20083,
      "author": {
        "id": 1002513
      },
      "writtenOn": "2017-08-10T20:10:25Z",
      "side": 1,
      "message": "reset canvas_ as well",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13034bac_d46f4339",
        "filename": "skia/BUILD.gn",
        "patchSetId": 10
      },
      "lineNbr": 329,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-08-10T19:25:25Z",
      "side": 1,
      "message": "Mmh, this seems problematic. We explicitly dynamically load the GL library in the GPU process (only), so that\n1- we can deal with it not being there\n2- we can pick the one we want (native vs ANGLE vs SwiftShader)\n3- just loading it in the browser process causes problems (e.g. crashes, hangs on fork(), etc. because GL drivers do very very naughty things)\n\nTaking a quick look at the code, I guess we want this to be able to use glXGetProcAddress to build the GrGLInterface. I think we should be able to use GrGLAssembleInterface with (a wrapper around) gl::GetGLProcAddress (from ui/gl/gl_implementation.h), and that would ensure we use the same library/entrypoints as the rest of the command buffer code.",
      "revId": "71ac6e2ba788a83784e79e0e4d7d9a0cb6e11a82",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}