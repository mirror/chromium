{
  "comments": [
    {
      "key": {
        "uuid": "d246bc9d_65504cb3",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 4
      },
      "lineNbr": 7205,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-23T21:56:43Z",
      "side": 1,
      "message": "Did we lose the rect? Does it not matter any more?",
      "revId": "858a15a5ae0ecbcbffbaa3829b8e6e7c74adbef2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d07bb924_2ee3b9df",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 4
      },
      "lineNbr": 7205,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-10-23T22:42:45Z",
      "side": 1,
      "message": "https://chromium-review.googlesource.com/c/chromium/src/+/734169",
      "parentUuid": "d246bc9d_65504cb3",
      "revId": "858a15a5ae0ecbcbffbaa3829b8e6e7c74adbef2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d44c2ef4_b4860689",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 4
      },
      "lineNbr": 7241,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-23T21:56:43Z",
      "side": 1,
      "message": "I\u0027m wondering, is this something we need to serialize, or could it be handled service-side, as a side effect of DrawRecordOps (and top-level Begin/End)? It seems like we\u0027re always serializing the same thing here, and it\u0027ll always be before the DrawRecordOp (and vice versa for the RestoreOp). In particular adding a canvas on the client side to keep track of things seems redundant, because we could reconstruct those things on the service side (since we have to go through a canvas anyway).",
      "revId": "858a15a5ae0ecbcbffbaa3829b8e6e7c74adbef2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5212f498_d0782d90",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 4
      },
      "lineNbr": 7241,
      "author": {
        "id": 1145109
      },
      "writtenOn": "2017-10-23T22:35:35Z",
      "side": 1,
      "message": "Hmmm, maybe the serialization of these save/restore ops can be avoided but the reason for maintaining a canvas on the client side was to figure out the scale at which images were required. And skipping decoding images for ops which will be clipped out.",
      "parentUuid": "d44c2ef4_b4860689",
      "revId": "858a15a5ae0ecbcbffbaa3829b8e6e7c74adbef2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "54de0d7b_f918e27c",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 4
      },
      "lineNbr": 7241,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-10-23T22:42:45Z",
      "side": 1,
      "message": "Re: canvas.  Agreed that having a canvas client-side is sad, but it\u0027s a requirement for the way image decoding works at the moment.  The image decoding system works currently by looking at the current state of the raster canvas to know what size image to request from the image decode cache.\n\nI\u0027ve talked with vmpstr/khushalsagar some about maybe making predecode figuring out what size is needed and then somehow noting that information to be reused at serialization/raster rather than recalculating the scale.  I think that is a larger refactoring than is needed at the moment, and so for now there\u0027s a canvas here.  It looks like it\u0027s not doing much here but counting saves, but it will also be used for images in the future.\n\n\nRe: DrawRecordOp.  This code right now doesn\u0027t serialize a DrawRecordOp explicitly, but pulls out everything inside of it and serializes those ops directly.  I don\u0027t think there\u0027s any blocking reason why I avoided that, but it seemed slightly simpler.\n\nWhat is your particular concern here?  Serialization size?  Code complexity?  It doesn\u0027t seem substantially different to me to have a DrawRecordOp + size of internal record than it does to have a SaveOp+RestoreOp in terms of serialization size.",
      "parentUuid": "d44c2ef4_b4860689",
      "revId": "858a15a5ae0ecbcbffbaa3829b8e6e7c74adbef2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7419f6b1_c62a4c5b",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 4
      },
      "lineNbr": 7241,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-10-23T23:30:52Z",
      "side": 1,
      "message": "\u003e Re: canvas.  Agreed that having a canvas client-side is sad, but it\u0027s a requirement for the way image decoding works at the moment.  The image decoding system works currently by looking at the current state of the raster canvas to know what size image to request from the image decode cache.\n\u003e \n\u003e I\u0027ve talked with vmpstr/khushalsagar some about maybe making predecode figuring out what size is needed and then somehow noting that information to be reused at serialization/raster rather than recalculating the scale.  I think that is a larger refactoring than is needed at the moment, and so for now there\u0027s a canvas here.  It looks like it\u0027s not doing much here but counting saves, but it will also be used for images in the future.\n\nOk, got it. Was missing context, it sounds like you have further uses for the canvas not apparent in this CL.\n\n\u003e Re: DrawRecordOp.  This code right now doesn\u0027t serialize a DrawRecordOp explicitly, but pulls out everything inside of it and serializes those ops directly.  I don\u0027t think there\u0027s any blocking reason why I avoided that, but it seemed slightly simpler.\n\u003e \n\u003e What is your particular concern here?  Serialization size?  Code complexity?  It doesn\u0027t seem substantially different to me to have a DrawRecordOp + size of internal record than it does to have a SaveOp+RestoreOp in terms of serialization size.\n\nHere\u0027s my thinking process of how I got to this question: we have to worry somewhere on the service side about doing more restore than saves (side question: where do we do that?). Therefore we must be counting these things on the service side, and validating these operations. Since they\u0027re implicit with DrawRecordOp from the pov of the caller, it seems simpler/safer to handle that transformation DrawRecordOp-\u003eSave+ops+Restore(s) on the service side (fewer ops, no need for a canvas to count them on the client side, no need to validate them on the service side. IOW maximizing entropy of cmd buffer \u003d\u003d fewer possibilities for possibly security-sensitive errors).\nIf you need the canvas anyway, then maybe this is the better way to go, if you think so.",
      "parentUuid": "54de0d7b_f918e27c",
      "revId": "858a15a5ae0ecbcbffbaa3829b8e6e7c74adbef2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28228006_125373d7",
        "filename": "gpu/command_buffer/client/gles2_implementation.cc",
        "patchSetId": 4
      },
      "lineNbr": 7241,
      "author": {
        "id": 1115895
      },
      "writtenOn": "2017-10-24T17:54:58Z",
      "side": 1,
      "message": "\u003e Here\u0027s my thinking process of how I got to this question: we have to worry somewhere on the service side about doing more restore than saves (side question: where do we do that?). \n\nIf it helps, SkCanvas::restore() is robust to restore-related underflow, so there doesn\u0027t need to be any checking matching saves and restores during deserialization.",
      "parentUuid": "7419f6b1_c62a4c5b",
      "revId": "858a15a5ae0ecbcbffbaa3829b8e6e7c74adbef2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}