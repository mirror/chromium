{
  "comments": [
    {
      "key": {
        "uuid": "14b3d50b_dd395b8d",
        "filename": "base/files/file_util_posix.cc",
        "patchSetId": 4
      },
      "lineNbr": 216,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-21T22:15:00Z",
      "side": 1,
      "message": "nit: no else after return.",
      "range": {
        "startLine": 216,
        "startChar": 4,
        "endLine": 216,
        "endChar": 8
      },
      "revId": "a490c539e3056e3237ee7858e34110c31e177123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45b90355_5910c0cb",
        "filename": "base/files/file_util_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1558,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-21T22:15:00Z",
      "side": 1,
      "message": "I imagine you copied some of this from an existing test. Let\u0027s not worry about what they did. For your test, can we check the return value here? Also lines 1570, 1576 (returns 0), etc.",
      "revId": "a490c539e3056e3237ee7858e34110c31e177123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e6adb51_231f2f8b",
        "filename": "base/files/file_util_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1604,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-21T22:15:00Z",
      "side": 1,
      "message": "This raises the same issue as before. Just running this test on the existing base/ impl results in CopyDirectory() returning true. How do we know there isn\u0027t an existing caller that\u0027s counting on this behavior?",
      "revId": "a490c539e3056e3237ee7858e34110c31e177123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16a5b796_e97ee34e",
        "filename": "base/files/file_util_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1604,
      "author": {
        "id": 1117055
      },
      "writtenOn": "2017-09-21T22:17:23Z",
      "side": 1,
      "message": "We don\u0027t, but this is a potential security issue I was trying to patch out along with the TOC-TOU issue.",
      "parentUuid": "7e6adb51_231f2f8b",
      "revId": "a490c539e3056e3237ee7858e34110c31e177123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ca093d8_87810392",
        "filename": "base/files/file_util_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1604,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-21T22:50:16Z",
      "side": 1,
      "message": "Yes, but if fixing a potential security issue causes other problems, the cure may be worse than the disease. With symlinks in the destination, aren\u0027t there valid use cases where one may want to set up a symlink? The code in base/ has a lot of caller in Chromium, and more elsewhere. e.g. as libbase in ChromeOS. So I want to be conservative and not potentially break behavior callers rely on. Can we leave the general behavior the same, focus on fixing the implementation details that can trigger TOC-TOU issues, and worry about handling symlinks in the destination separately?",
      "parentUuid": "16a5b796_e97ee34e",
      "revId": "a490c539e3056e3237ee7858e34110c31e177123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef718a8c_a5fdb4ba",
        "filename": "base/files/file_util_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1604,
      "author": {
        "id": 1135824
      },
      "writtenOn": "2017-09-22T08:19:24Z",
      "side": 1,
      "message": "IMHO, we should change the code here to not ever write to symlinks or fifos or whatnot unless the caller specifically opted in to that behavior. We\u0027ve seen multiple exploits on Chrome OS abusing privileged processes to write data elsewhere by placing unexpected existing objects in the destination directory. At this point, I\u0027m convinced user education will not solve this issue, so we need to make the API safe by default. Whether that\u0027s going to happen as part of this CL or some other CL I don\u0027t care ;-)",
      "parentUuid": "8ca093d8_87810392",
      "revId": "a490c539e3056e3237ee7858e34110c31e177123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "926b2b6c_5d7ae8c0",
        "filename": "base/files/file_util_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 1623,
      "author": {
        "id": 1001934
      },
      "writtenOn": "2017-09-21T22:15:00Z",
      "side": 1,
      "message": "nit: |var_name|",
      "range": {
        "startLine": 1623,
        "startChar": 60,
        "endLine": 1623,
        "endChar": 74
      },
      "revId": "a490c539e3056e3237ee7858e34110c31e177123",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}