// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ui.ozone.mojom;

import "mojo/common/file.mojom";
import "mojo/common/file_path.mojom";
//import "skia/public/interfaces/bitmap.mojom";

import "ui/display/mojo/display_constants.mojom";
import "ui/display/mojo/display_mode.mojom";
import "ui/display/mojo/display_snapshot_mojo.mojom";
import "ui/display/mojo/gamma_ramp_rgb_entry.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";
import "ui/gfx/mojo/accelerated_widget.mojom";
import "ui/ozone/public/interfaces/overlay_surface_candidate.mojom";


// Mus is split into two processes. The GpuAdapter is the interface between
// Mus-WS and Mus-GPU. Mus-WS is a higher-privilege process while Mus-GPU
// operates with less privileges (mirroring the Chrome browser to GPU process
// relationship.
// All services in GpuAdapter are implemented by the lower privilege GPU process.
interface GpuAdapter {
	// Creates scanout capable DRM buffers to back |widget|.
	 CreateWindow(gfx.mojom.AcceleratedWidget widget);

	// Destroys the DRM buffers backing |widget|.
	 DestroyWindow(gfx.mojom.AcceleratedWidget widget);

	// Sets the size of the DRM buffer for |widget|.
	 SetWindowBounds(gfx.mojom.AcceleratedWidget widget, gfx.mojom.Rect bounds);

	// Take control of the display and invoke a provided callback with a boolean status.
	TakeDisplayControl() => (bool success);

	// Release control of the display and invoke a provided callback with a boolean status.
	RelinquishDisplayControl() => (bool success);

	// Request a callback providing a list of the available displays.
	RefreshNativeDisplays() => (array<display.mojom.DisplaySnapshotMojo> display_snapshots);

	AddGraphicsDevice(mojo.common.mojom.FilePath path, mojo.common.mojom.File file);
	RemoveGraphicsDevice(mojo.common.mojom.FilePath path);

	DisableNativeDisplay(int64 display_id) => (int64 display_id, bool success);

	ConfigureNativeDisplay(int64 display_id, display.mojom.DisplayMode display_mode, gfx.mojom.Point point) => (int64 display_id, bool success);

	 GetHDCPState(int64 display_id) => (int64 display_id, bool success, display.mojom.HDCPState state);
	 SetHDCPState(int64 display_id, display.mojom.HDCPState  state) => (int64 display_id, bool success);

	// need lots of stuff
	SetColorCorrection(int64 display_id, array<display.mojom.GammaRampRGBEntry> degamma_lut, array<display.mojom.GammaRampRGBEntry> gamma_lut, array<float> correction_matrix);

	// need OverlayCheck_Params
	 CheckOverlayCapabilities(gfx.mojom.AcceleratedWidget widget, array<ui.ozone.mojom.OverlaySurfaceCandidate> candidates) => (gfx.mojom.AcceleratedWidget widget, array<ui.ozone.mojom.OverlaySurfaceCandidate> candidates, array<ui.ozone.mojom.OverlayStatus> status);
	

	// Do I need the ping action?

};

