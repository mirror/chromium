{
  "comments": [
    {
      "key": {
        "uuid": "a4022f44_2ec4eb26",
        "filename": "content/browser/compositor/viz_process_transport_factory.cc",
        "patchSetId": 21
      },
      "lineNbr": 147,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T23:11:25Z",
      "side": 1,
      "message": "Do we have a guarantee that the InProcessCommandBuffer\u0027s SetChildSurface message is done and processed at this point? Otherwise this would cause GpuProcessHost to kill the GPU process upon receiving the straggler.\n\nI /think/ on GpuProcessTransportFactory we have that guarantee because we call RemoveCompositor after we close the LTH which has the side effect of destroying the LTFS and the ContextProvider which calls a Finish. I\u0027m not sure if we have such a guarantee here?",
      "revId": "aa513bc59b42f8fbb5146ec6111d977892c0f7e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6ee1824_d11af44f",
        "filename": "content/browser/compositor/viz_process_transport_factory.cc",
        "patchSetId": 21
      },
      "lineNbr": 147,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-30T15:27:31Z",
      "side": 1,
      "message": "Good point. Shutting down the ContextProvider/CommandBuffer does a sync IPC guarantees that when the Display/OutputSurface is destroyed the GPU end has been destroyed.\n\nWe lose synchronization with GPU process tasks and the ui::Compositor. This was the reason sadrul@ had to fix a bunch of GLX context stuff, because the browser was destroying the XWindow early and causing the GPU to crash when the MakeCurrent failed.\n\nI\u0027m not sure what the right solution is though, we don\u0027t want to introduce a sync IPC to destroy top level windows again I\u0027d assume? I could track HWNDs that are maybe waiting on GpuProcessHost::SetChildSurface(), but that only solves this problem and not any of the related issues.",
      "parentUuid": "a4022f44_2ec4eb26",
      "revId": "aa513bc59b42f8fbb5146ec6111d977892c0f7e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0d15b97_e3cbac80",
        "filename": "content/browser/compositor/viz_process_transport_factory.cc",
        "patchSetId": 21
      },
      "lineNbr": 147,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-30T19:19:44Z",
      "side": 1,
      "message": "I think the easy way is to do the sync IPC, which would be no regression over the current behavior without viz. But agreed that over the long term we\u0027d want an asynchronous solution.",
      "parentUuid": "f6ee1824_d11af44f",
      "revId": "aa513bc59b42f8fbb5146ec6111d977892c0f7e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d43bddc_a9104174",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 21
      },
      "lineNbr": 22,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-11-29T23:11:25Z",
      "side": 1,
      "message": "nit: info_.emplace(parent, EmbeddingInfo()); ?",
      "revId": "aa513bc59b42f8fbb5146ec6111d977892c0f7e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0bfac6a_4c492d78",
        "filename": "ui/gfx/win/rendering_window_manager.cc",
        "patchSetId": 21
      },
      "lineNbr": 22,
      "author": {
        "id": 1146978
      },
      "writtenOn": "2017-11-30T15:27:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0d43bddc_a9104174",
      "revId": "aa513bc59b42f8fbb5146ec6111d977892c0f7e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}