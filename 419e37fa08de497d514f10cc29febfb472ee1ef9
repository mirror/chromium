{
  "comments": [
    {
      "key": {
        "uuid": "d2496ccf_a652bb8e",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1151884
      },
      "writtenOn": "2018-02-06T21:51:30Z",
      "side": 1,
      "message": "I think you should add a method to WidgetObserver (maybe \"OnAddedToWidget\"; sky will probably have an opinion on the name) that will be called when AddObserver is called, then you don\u0027t need to change the callsites. I also think this should just call OnWidgetVisibilityChanged(bubble_widget, bubble_widget-\u003eIsVisible()), or at least have them delegate to the same method.",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3fe95f1b_e1fb5580",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1126912
      },
      "writtenOn": "2018-02-06T23:11:57Z",
      "side": 1,
      "message": "Observing a widget !\u003d being added to it, so that is confusing. Calling it OnWidgetObserving and letting sky@ have input too.\n\nGood suggestion, thanks!",
      "parentUuid": "d2496ccf_a652bb8e",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb32e3cd_ee16dfa7",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2018-02-07T00:14:20Z",
      "side": 1,
      "message": "The pattern you have here basically comes down to:\nsource-\u003eAddObserver(x);\n// In AddObserver impl:\nx-\u003eYouAddedMe();\n\nThat\u0027s weird, and I don\u0027t think such a function belongs in WidgetObserver. If code creating the widget needs to know when the widget has been created it should be responsible for tracking that. By which I mean don\u0027t change the base class just because it\u0027s convenient.",
      "parentUuid": "3fe95f1b_e1fb5580",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9b2fa376_9f883460",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1126912
      },
      "writtenOn": "2018-02-07T00:27:03Z",
      "side": 1,
      "message": "It\u0027s convenient because it lets all call sites use a single call:\n\nwidget-\u003eAddObserver(observer);\n\nThe observer here needs to know the initial state of the widget as it needs to be *in sync* with widget-\u003eIsVisible(). If we don\u0027t have this callback all call sites are essentially:\n\nobserver-\u003eSetInitialWidgetState(widget-\u003eIsVisible());\nwidget-\u003eAddObserver(observer);\n\nThis pattern *is brittle* because all call sites (7 of them, + new code) will need to remember the SetInitialWidgetState() call. Also we\u0027d need a public SetInitialWidgetState which is just wonky.\n\nAn alternative is:\n\nObserver /* does not inherit from WidgetObserver as it\u0027s error prone (AddObserver does not set initial state) */ {\n  void ObserveWidget(widget) {\n    SetState(widget-\u003eIsVisible());\n    widget-\u003eAddObserver(\u0026widget_observer_proxy_);\n  }\n  private:\n    WidgetObserverProxy {\n      ctor(Observer* parent) : parent_(parent)\n      void OnWidgetVisibilityChanged(widget, visible) override { parent-\u003eSetState(visible); }\n      void OnWidgetDestroying(widget) { widget-\u003eRemoveObserver(this); }\n    }\n};\n\nBut then we can\u0027t use WidgetObserver directly and instead need boilerplate code (as code style forbids protected inheritance). Is this pattern recommended / do you see any other patterns? I don\u0027t want the solution to be as brittle as having all code sites duplicate SetInitialState + AddObserver.",
      "parentUuid": "eb32e3cd_ee16dfa7",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "beb4cd24_c913797f",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2018-02-07T18:38:03Z",
      "side": 1,
      "message": "I need to study this code a bit more. My knee jerk reaction is the problem stems from having an object other than the observer responsible for attaching it. I would expect the observer implementation itself to attach itself to the appropriate object. Basically the ObserverWidget() implementation you have on the WidgetObserver impl. You mention that is error prone. Why?",
      "parentUuid": "9b2fa376_9f883460",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8ba233c_62ec232c",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1126912
      },
      "writtenOn": "2018-02-07T19:14:55Z",
      "side": 1,
      "message": "If the object should always responsible for attaching itself we shouldn\u0027t have public WidgetObserver inheritance right (or other code would be able to attach the observer for the widget, which breaks the code).\n\nIt\u0027s error prone because there\u0027s no automatic enforcement that the attachment is done by the observer that way. Example:\n\nObserver (public WidgetObserver):\n  void AttachToWidget(views::Widget* widget):\n    SetInitialStateBasedOnWidgetState(widget);\n    widget-\u003eAddObserver(this);\n\nWe would then expect that the call sites call:\n\nobserver-\u003eAttachToWidget(widget);\n\nBut there is no enforcement of this, so:\n\nwidget-\u003eAddObserver(observer);\n\nThis will still compile and run fine, but the observer cannot set its initial state based on the widget, and parts of the functionality (observing when the widget goes invisible), still works.\n\nSo long as WidgetObserver is public inheritance we can\u0027t reasonably enforce that attachment is done using the correct method. My current workaround plan is to have:\n\nAttachToWidget(widget):\n  attached_using_correct_method_ \u003d true;\n\nOnWidgetVisibilityChanged(widget, visibility):\n DCHECK(attached_using_correct_method_);\n\nTo just enforce that AddObserver is *not used* to attach this externally from call sites. I think it would be preferable if there was only one way to attach the observer to and observe the widget, and that\u0027s using Widget/WidgetObserver APIs.\n\nDoes this reasoning make sense? SetInitialStateBasedOnWidgetState() is an important call for us to be in sync with the widget in this case and not just observe future changes.",
      "parentUuid": "beb4cd24_c913797f",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4b7d0c2f_780f32c5",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2018-02-07T19:21:39Z",
      "side": 1,
      "message": "\u003e If the object should always responsible for attaching itself we shouldn\u0027t have public WidgetObserver inheritance right (or other code would be able to attach the observer for the widget, which breaks the code).\n\nThe style guide says no private inheritance. But yes, in many cases in Chrome observer inheritance should be thought of as a private. It\u0027s an implementation detail.\n\n\u003e It\u0027s error prone because there\u0027s no automatic enforcement that the attachment is done by the observer that way. Example:\n\u003e \n\u003e Observer (public WidgetObserver):\n\u003e   void AttachToWidget(views::Widget* widget):\n\u003e     SetInitialStateBasedOnWidgetState(widget);\n\u003e     widget-\u003eAddObserver(this);\n\u003e \n\u003e We would then expect that the call sites call:\n\u003e \n\u003e observer-\u003eAttachToWidget(widget);\n\u003e \n\u003e But there is no enforcement of this, so:\n\u003e \n\u003e widget-\u003eAddObserver(observer);\n\u003e \n\u003e This will still compile and run fine, but the observer cannot set its initial state based on the widget, and parts of the functionality (observing when the widget goes invisible), still works.\n\u003e \n\u003e So long as WidgetObserver is public inheritance we can\u0027t reasonably enforce that attachment is done using the correct method. My current workaround plan is to have:\n\u003e \n\u003e AttachToWidget(widget):\n\u003e   attached_using_correct_method_ \u003d true;\n\u003e \n\u003e OnWidgetVisibilityChanged(widget, visibility):\n\u003e  DCHECK(attached_using_correct_method_);\n\u003e \n\u003e To just enforce that AddObserver is *not used* to attach this externally from call sites. I think it would be preferable if there was only one way to attach the observer to and observe the widget, and that\u0027s using Widget/WidgetObserver APIs.\n\u003e \n\u003e Does this reasoning make sense? SetInitialStateBasedOnWidgetState() is an important call for us to be in sync with the widget in this case and not just observe future changes.\n\nAnother option (which is typically not used in chrome code), is to move the inheritance of the observer to a private internal class. That avoids the problem you mention here.",
      "parentUuid": "f8ba233c_62ec232c",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d689c85a_e81f4d22",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1126912
      },
      "writtenOn": "2018-02-07T20:16:56Z",
      "side": 1,
      "message": "I think there\u0027s two points against this (not trying to coerce you into an opinion here):\n\n1. The Widget/WidgetObserver pairing already provides a familiar API, anyone writing the call site knows that widget-\u003eAddObserver(observer) is a supported pattern. You don\u0027t need to look up the specific observer API for every single observer (was it observer-\u003eAttachToWidget(widget) or observer-\u003eOnWidgetCreated(widget) or observer-\u003eOnBubbleCreated(...)).\n\n2. The private internal class will likely end up being written for every single observer and is hence less well tested than Widget -\u003e WidgetObserver:\n\n2.1. It contains more nested / complicated callbacks (parent_-\u003eOnWidgetVisibilityChanged() forwarding for every WidgetObserver method we care about).\n\n2.2. Any incorrect redirecting of OnWidgetVisibilityChanging -\u003e OnWidgetVisibilityChanged is very hard to spot in a list of forwarding declarations that look very similar. We (at least I) would get this wrong \u003e1 times.\n\nAnother option is to move class members (in this case InkDrop) into a nested WidgetObserverProxy class, but this doesn\u0027t semantically make sense / is very hairy. It also prevents subclasses from overriding any behavior (StarView currently overrides OnWidgetDestroying).\n\n(2) here is significant enough for me to not want to write this boilerplate/proxy dispatch code, and instead DCHECK(attach_using_correct_method_); to best-effort prevent direct widget-\u003eAddObserver(observer) calls. It\u0027s more brittle as this won\u0027t enforce that no AddObserver calls are made after initial attachment though, so it\u0027s just a best effort way to tell callers to use the other API.\n\nI think reusing the WidgetObserver API makes sense to use for the call site. It keeps the code simpler, avoids proxies and prevents inventing new APIs on the fly. I don\u0027t think having an OnAttach() method is that bad / shoehorned into the API.",
      "parentUuid": "4b7d0c2f_780f32c5",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a9cf38c_d6af890f",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2018-02-07T20:50:44Z",
      "side": 1,
      "message": "What is unique about this argument in comparison to any other observer we have in Chrome? I think it equally applies to all observers, yet we have very few functions like you are proposing being added. And again, I think that\u0027s because the object adding the observer should be responsible for taking the steps to ensure whatever state the observer needs is setup at the time the observer is added.\n\nIf you are to add an OnAdded like function, why not a OnRemoved function? The same argument applies, right? In particular if another object is adding/removing the observer implementation then how does the observer implementation know it is no longer observing? This again is why I think the observer implementation should be the one adding itself, not another object.",
      "parentUuid": "d689c85a_e81f4d22",
      "range": {
        "startLine": 66,
        "startChar": 6,
        "endLine": 66,
        "endChar": 19
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca54beac_4c6ba442",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 1151884
      },
      "writtenOn": "2018-02-06T21:51:30Z",
      "side": 1,
      "message": "nit: no {}",
      "range": {
        "startLine": 204,
        "startChar": 14,
        "endLine": 204,
        "endChar": 16
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "037fd0ff_f3495df9",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.cc",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 1126912
      },
      "writtenOn": "2018-02-06T23:11:57Z",
      "side": 1,
      "message": "pref keeping since it\u0027s part of an if-else block",
      "parentUuid": "ca54beac_4c6ba442",
      "range": {
        "startLine": 204,
        "startChar": 14,
        "endLine": 204,
        "endChar": 16
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a8d1822_b1149217",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1126912
      },
      "writtenOn": "2018-02-06T21:08:06Z",
      "side": 1,
      "message": "Note that this is protected to prevent AddObserver calls from the outside that misses highlighting the icon.",
      "range": {
        "startLine": 29,
        "startChar": 23,
        "endLine": 29,
        "endChar": 33
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "21a318d8_1d2e9cc4",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1151884
      },
      "writtenOn": "2018-02-06T21:51:30Z",
      "side": 1,
      "message": "From Google C++ style guide: \"All inheritance should be public\"",
      "parentUuid": "1a8d1822_b1149217",
      "range": {
        "startLine": 29,
        "startChar": 23,
        "endLine": 29,
        "endChar": 33
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13106f5d_78f1736b",
        "filename": "chrome/browser/ui/views/location_bar/bubble_icon_view.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1126912
      },
      "writtenOn": "2018-02-06T23:11:57Z",
      "side": 1,
      "message": "Fixed w/ your other suggestion (removes need for OnBubbleWidgetCreated).",
      "parentUuid": "21a318d8_1d2e9cc4",
      "range": {
        "startLine": 29,
        "startChar": 23,
        "endLine": 29,
        "endChar": 33
      },
      "revId": "419e37fa08de497d514f10cc29febfb472ee1ef9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}