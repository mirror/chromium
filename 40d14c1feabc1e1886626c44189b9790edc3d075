{
  "comments": [
    {
      "key": {
        "uuid": "880843a6_54343d10",
        "filename": "third_party/WebKit/Source/modules/gamepad/GamepadEvent.h",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2017-11-08T20:59:18Z",
      "side": 1,
      "message": "I don\u0027t think this is correct. This logic effectively takes \"now\" and converts\nit from one clock to another.\n\nWhat needs to happen is to convert \"gamepad event time\" to time ticks clock *if necessary*.\nThe gamepad event time is available in gamepad.timestamp_ [1].\n\nI actually don\u0027t know what is the underlying clock for gamepad.timestamp_\ntime values. bajones@ seems to be the expert in Chromium gamepad implementation and may be \nable shed some light here.\n\nBut I highly suspect that the base clock for provided timestamp is platform specific\nin which case we may need to do different things for different platform. Here are the\nbroad possibilities:\n\n1) gamepad.timestamp_ is sourced from the same clock as base::TimeTicks \u003d\u003e no clock conversion  is needed. Just turn it directly into base::TimeTicks. This is best case :)\n\n2) gamepad.timestamp_ is sourced from different clock \u003d\u003e clock conversion is needed. Depending\non the source clock this may be just an offset or scale + offset. \n\n3) gamepad.timestamp_ is sourced from different clock and accurate conversion is not possible.\n   \u003d\u003e In such a case we usually just ignore the OS timestamp and create our own timestamp\n    by using base::TimeTicks::Now(). This is similar to what you are doing now. But if \n    (1) or (2) is possible I prefer to do them first as it provides a more accurate\n    timestamp value.\n\n\nDepending on your investigation and perhaps bajones@ recommendation we will decide which\nis these approaches (if any) is best for each and every platform.\n\n[1]https://codesearch.chromium.org/chromium/src/third_party/WebKit/Source/modules/gamepad/Gamepad.h?type\u003dcs\u0026l\u003d94",
      "range": {
        "startLine": 34,
        "startChar": 4,
        "endLine": 34,
        "endChar": 66
      },
      "revId": "40d14c1feabc1e1886626c44189b9790edc3d075",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0f4e5d29_49fe5db3",
        "filename": "third_party/WebKit/Source/modules/gamepad/GamepadEvent.h",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1136314
      },
      "writtenOn": "2017-11-09T22:30:15Z",
      "side": 1,
      "message": "Gamepad.timestamp isn\u0027t consistent across platforms or even between different data fetchers on the same platform, and often is implemented as a monotonically increasing counter. E.g., RawInputDataFetcher uses report_id which is simply incremented on each call to UpdateGamepad, and GamepadPlatformDataFetcherWin uses dwPacketNumber as reported from XInput. All DataFetcher implementations would need to be made consistent before using the timestamp to initialize the event.\n\nThe spec says this about Gamepad.timestamp:\n\n\u003e The value must be relative to the navigationStart attribute of the PerformanceTiming interface.\n\nhttps://www.w3.org/TR/gamepad/#gamepad-interface\n\nCurrently I think none of our DataFetchers do this part correctly. We would need to update them to set timestamps relative to navigationStart, and then convert back to system time when creating GamepadEvent.\n\nAlso note that GamepadEvent is only used for connection/disconnection events, not for button/axis changes (these are polled). The timestamp in Gamepad represents the most recently polled data, which isn\u0027t necessarily the same as the time of the connection/disconnection event.",
      "parentUuid": "880843a6_54343d10",
      "range": {
        "startLine": 34,
        "startChar": 4,
        "endLine": 34,
        "endChar": 66
      },
      "revId": "40d14c1feabc1e1886626c44189b9790edc3d075",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06f40e74_f289caf7",
        "filename": "third_party/WebKit/Source/modules/gamepad/GamepadEvent.h",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1125304
      },
      "writtenOn": "2017-11-10T03:13:00Z",
      "side": 1,
      "message": "Thanks Matt for illuminating this.\n\nTo clarify this CL and the original bug was only concerned about GamepadEvent.timestamp\nand not Gamepad.timestamp.\n\nReading these it seems to me that getting an \"OS timestamp\" that can be converted to time tick\nis going to be a lot of work. And even then, these timestamps may not really be that relevant\nto the connect/disconnect events but rather the last data poll.\n\nSo for GamepadEvent (e.g., connect/disconnect), I think it is good enough\nto use the moment of creation of the event as the event timestamp. This is what \nwe do for many other event types and it was already the case. So let\u0027s keep\nit that way. So I think it is fine to close the original bug as \"WontFix\".\n\nAs for making Gamepad.timestamp actually follow the spec. I found that there is\nalready a bug for that: https://crbug.com/398642\nI am going to leave a comment on that bug with some of the valuable info here to make\nsure they are captured.\n\n\njj.lopezjaimez@: Given above, it seems that we don\u0027t really need to make any\nchanges here. Thanks for championing this issue and helping figure this out.",
      "parentUuid": "0f4e5d29_49fe5db3",
      "range": {
        "startLine": 34,
        "startChar": 4,
        "endLine": 34,
        "endChar": 66
      },
      "revId": "40d14c1feabc1e1886626c44189b9790edc3d075",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}