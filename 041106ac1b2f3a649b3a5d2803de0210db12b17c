{
  "comments": [
    {
      "key": {
        "uuid": "f1ba94a1_c74f7782",
        "filename": "ui/events/event.h",
        "patchSetId": 12
      },
      "lineNbr": 121,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2018-02-06T19:01:45Z",
      "side": 1,
      "message": "IsFromPlatformHook",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b5e3db7_d56659ba",
        "filename": "ui/events/event.h",
        "patchSetId": 12
      },
      "lineNbr": 121,
      "author": {
        "id": 1133074
      },
      "writtenOn": "2018-02-07T03:11:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f1ba94a1_c74f7782",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "973faa58_1c4d7572",
        "filename": "ui/events/event_constants.h",
        "patchSetId": 12
      },
      "lineNbr": 128,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2018-02-06T19:01:45Z",
      "side": 1,
      "message": "\u0027platform hook\u0027 probably does not make a lot of sense in non-Windows. Maybe call it \u0027EF_LOW_LEVEL\u0027 or \u0027EF_PRE_PLATFORM_HANDLED\u0027 (or something like that to reflect that this is a key-event chrome received before the platform had a chance to handle the event).",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cc8f793_de079ce4",
        "filename": "ui/events/event_constants.h",
        "patchSetId": 12
      },
      "lineNbr": 128,
      "author": {
        "id": 1133074
      },
      "writtenOn": "2018-02-07T03:11:08Z",
      "side": 1,
      "message": "I\u0027ll defer to one of your suggestions as it is more likely to use terms consistent with the event handling section of Chromium.",
      "parentUuid": "973faa58_1c4d7572",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c88e5886_13ad6673",
        "filename": "ui/views/win/hwnd_message_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 807,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2018-02-06T19:01:45Z",
      "side": 1,
      "message": "I would say create this on-demand here (and maybe destroyed in UnlockKeys below).",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b784217a_0d32d739",
        "filename": "ui/views/win/hwnd_message_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 807,
      "author": {
        "id": 1133074
      },
      "writtenOn": "2018-02-07T03:11:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c88e5886_13ad6673",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "00886a2b_2bae0be7",
        "filename": "ui/views/win/hwnd_message_handler.h",
        "patchSetId": 12
      },
      "lineNbr": 196,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2018-02-06T19:01:45Z",
      "side": 1,
      "message": "Would it be possible to return a Scoped object from here, so that (1) only the caller can unlock, and (2) it becomes difficult for the caller to forget to unlock. e.g.\n\n ScopedKeyboardLock LockKeys(std::vector\u003c...\u003e keys);\n\nWhen the returned object is destroyed, it automatically unlocks.",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85bab3e3_bd9d7033",
        "filename": "ui/views/win/hwnd_message_handler.h",
        "patchSetId": 12
      },
      "lineNbr": 196,
      "author": {
        "id": 1133074
      },
      "writtenOn": "2018-02-06T19:43:41Z",
      "side": 1,
      "message": "I could do that my only concern is around how far up the chain it is returned.  Conceptually I am thinking of this design having a browser tab component and a lower level window component.  These two components could be in separate processes.  If that occurs, I would not want to pass this scoped object over a process boundary.\n\nI could pass the scoped object to the owning class (WindowTreeHost derivation in this case) since I would expect it to live in the same process as the window.  This would prevent other callers from unlocking but I don\u0027t think it makes unlocking simpler (caller has to remember to destroy the returned object when the window is destroyed instead of allowing the window itself to destroy it).\n\nWDYT?",
      "parentUuid": "00886a2b_2bae0be7",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41d3f342_7e380d45",
        "filename": "ui/views/win/hwnd_message_handler.h",
        "patchSetId": 12
      },
      "lineNbr": 196,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2018-02-07T21:00:36Z",
      "side": 1,
      "message": "Can the aura::Window itself own the scoped object?",
      "parentUuid": "85bab3e3_bd9d7033",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8b37013_b1a6f753",
        "filename": "ui/views/win/hwnd_message_handler.h",
        "patchSetId": 12
      },
      "lineNbr": 196,
      "author": {
        "id": 1133074
      },
      "writtenOn": "2018-02-07T22:16:39Z",
      "side": 1,
      "message": "It is reasonable to consider.\n\nAt the moment aura::Window is not used at all.  aura::WindowTreeHost is used for KeyEvent injection and I had the platform window own the hook.\n\nIt looks like the Windows and X11 WindowTreeHost Impls each have their own method used for injecting input (i.e. not a shared interface) so I would likely still call into the WindowTreeHost impl to create the KB hook and give it a callback/interface for injecting KeyEvents.  The WindowTreeHost could then pass ownership of the ScopedHook to aura::Window.\n\nMy assumption is that we would use the RootWindow (similar to how aura::Window::SetCapture() is used) since there could be any number of child aura:Windows (for menus and such).\n\nIs that along the lines of what you were thinking?\n\nIs the lifetime of the root aura::Window relatively stable or will I need to handle OnWindowDestroyed (and similar using WindowObserver) events in RenderWidgetHostView?",
      "parentUuid": "41d3f342_7e380d45",
      "revId": "041106ac1b2f3a649b3a5d2803de0210db12b17c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}