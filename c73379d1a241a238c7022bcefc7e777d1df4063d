{
  "comments": [
    {
      "key": {
        "uuid": "ea490826_0e41b65b",
        "filename": "media/audio/alsa/alsa_input.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1153409
      },
      "writtenOn": "2017-09-11T12:31:51Z",
      "side": 1,
      "message": "Actually, now I\u0027m thinking this line together with l.164 looks confusing.\nWould it be enough to get frames ones at l.164 and to adjust the value here basing on how many frames we\u0027ve read in the \u0027while\u0027 loop so far?",
      "revId": "c73379d1a241a238c7022bcefc7e777d1df4063d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5108bb99_11cf9301",
        "filename": "media/audio/alsa/alsa_input.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1001872
      },
      "writtenOn": "2017-09-11T17:25:36Z",
      "side": 1,
      "message": "This is a very good question. I am not 100% sure myself.\nFrom my experiments on a single machine it looks like number of frames did not change within this while loop. However, if it does happen new frames count will give us more accurate time estimation.\n(not sure if alsa can get new frames asynchronously, but I don\u0027t see reasons why not)",
      "parentUuid": "ea490826_0e41b65b",
      "revId": "c73379d1a241a238c7022bcefc7e777d1df4063d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bee93c08_6b017202",
        "filename": "media/audio/alsa/alsa_input.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1153409
      },
      "writtenOn": "2017-09-13T14:46:31Z",
      "side": 1,
      "message": "My understanding is that at the moment ReadAudio() is called we estimate the delay by the number of frames queued up to this moment. When we popped first n frames from the queue and called OnData(), the delay for the next portion and next OnData() is \"n frames\" smaller (they were queued later).\nIf new frames arrive while we are going through the queue, it should not affect the delay of already queued frames.\nSo if alsa can get new frames asynchronously it\u0027s even more the reason to not call PcmAvailUpdate() on each iteration.",
      "parentUuid": "5108bb99_11cf9301",
      "revId": "c73379d1a241a238c7022bcefc7e777d1df4063d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1b1cd94_dbb2ced5",
        "filename": "media/audio/alsa/alsa_input.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1001872
      },
      "writtenOn": "2017-09-13T17:10:26Z",
      "side": 1,
      "message": "Technically you are right. However, if new frames will arrive asynchronously, getting accurate number of frames will lead to more accurate timestamp for the next read.\nLet\u0027s work this example, we read 4 chunks and new frames will arrive async after chunk 2.\navail_frames \u003d 1000\nread chunk \u003d 100\nsample rate \u003d 10000 --\u003e 0.1 ms per sample\nOnData() called every 5ms\n\n1. OnData(), Now() \u003d 5555 ms, Now() - delay(1000fr) \u003d 5455, start of recording \u003d 5455 - data_read(100) \u003d 5445\n2. OnData(), Now() \u003d 5560 ms, Now() - delay(900fr) \u003d 5470, start of recording \u003d 5470 - data_read(200) \u003d 5450\n\n\u003e\u003e Async data arrived, +200 frames, avail frames \u003d 1000 again, already read data \u003d 200 frames\n\n3. OnData(), Now() \u003d 5565 ms, Now() - delay(1000) \u003d 5465, start of recording \u003d 5465 - data_read(300) \u003d 5435\n4. OnData(), Now() \u003d 5570 ms, Now() - delay(900) \u003d 5480, start of recording \u003d 5480 - data_read(400) \u003d 5440\n\nIn my task, I need to get the most accurate timestamp for the start of the recording. This means getting the minimal \"start of the recording\" time from the list (because I don\u0027t exactly know internal audio delay, I am just picking one that is the most accurate).\n\nIf we don\u0027t update number of available frames in the loop, all subsequent OnData() calls will have less and less accurate data (assuming we read faster then sampling rate*data) which is always the case for me.\n\nHowever, if data get asynchronously updated, new avail_frames will give us sudden boost in accuracy of the recording start. In my practice, number of avail frames usually gives range of 10ms. Using the technique above (calculating and selecting minimal start of the recording timestamp) I can improve accuracy to about 1ms.\n\nOf course all of the above make sense only if audio stack (alsa) can update frames asynchronously in the background.\n\nLet me know if this sounds confusing :). I \u0027ll be happy to jump on VC and explain.",
      "parentUuid": "bee93c08_6b017202",
      "revId": "c73379d1a241a238c7022bcefc7e777d1df4063d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b92260e3_4cfc042d",
        "filename": "media/audio/alsa/alsa_input.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1153409
      },
      "writtenOn": "2017-09-14T15:26:23Z",
      "side": 1,
      "message": "I think I know what you mean, but \"OnData() called every 5ms\" is unclear.\nOnData is called in ReadAudio() in a cycle [https://cs.chromium.org/chromium/src/media/audio/alsa/alsa_input.cc?type\u003dcs\u0026sq\u003dpackage:chromium\u0026l\u003d211], so it is called irregularly.\n\nAlso, in your example timestamp at step 3 goes backward.\nWhich contradicts OnData contract (https://cs.chromium.org/chromium/src/media/audio/audio_io.h?type\u003dcs\u0026sq\u003dpackage:chromium\u0026l\u003d128).\n\n----\nActually, it looks like we need to verify with DCHECKs all the code here, to make sure we are not getting backward timestamps even without requesting PcmAvailUpdate() on each call. It depends on how well we are dealing with |next_read_time_| and scheduling next ReadAudio()\ncall (https://cs.chromium.org/chromium/src/media/audio/alsa/alsa_input.cc?type\u003dcs\u0026sq\u003dpackage:chromium\u0026l\u003d236)",
      "parentUuid": "b1b1cd94_dbb2ced5",
      "revId": "c73379d1a241a238c7022bcefc7e777d1df4063d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fee1927_94743fbb",
        "filename": "media/audio/alsa/alsa_input.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1001872
      },
      "writtenOn": "2017-09-14T18:42:07Z",
      "side": 1,
      "message": "Thanks for looking into that.\n\nI gave 5ms as an example. In practice it could be any, irregular interval, but it is usually less then audio length (converted to time) that has been read. (you can see actual example I link late here)\n\nRegarding contract. It is violated already. In my example above, please end loop after step 2, and start step 3 from the new one. You will read exactly the same data, and therefor you get earlier timestamp which violates the contract. What this mean in practice, is that first timestamp is INACCURATE, and subsequent timestamps is EVEN MORE INACCURATE. And if we insist on the following OnData() contract - there will be no way to get accurate recording timestamps.\n\nHere are examples of timestamps (\"capture ts\" column) arriving to AudioInputController::SyncWriter if I change the code and use number of frames from the beginning of the function:\nhttps://docs.google.com/a/google.com/spreadsheets/d/1wZFq3nzmggH4owuJ1Zv6D3XFM0StdQZrLucKNb7mxuE/edit?usp\u003dsharing\n\n\"capture ts diff\" contains difference from the previous arrived ts, and as you can clearly see it is often negative (violates contract).\n\nI think the problem here is that underlying audio layer CAN NOT reliably tell us when the sound capturing is actually started. And that is the problem. I don\u0027t know how to solve unreliable Alsa timings, but at least I can get more reliable estimates.",
      "parentUuid": "b92260e3_4cfc042d",
      "revId": "c73379d1a241a238c7022bcefc7e777d1df4063d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}