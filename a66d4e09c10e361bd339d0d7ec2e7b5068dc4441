{
  "comments": [
    {
      "key": {
        "uuid": "b6db6635_7db797ca",
        "filename": "device/ctap/BUILD.gn",
        "patchSetId": 7
      },
      "lineNbr": 56,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "Is this dependency necessary?",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 56,
        "endChar": 12
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac54b951_8a47f5d8",
        "filename": "device/ctap/BUILD.gn",
        "patchSetId": 7
      },
      "lineNbr": 56,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b6db6635_7db797ca",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 56,
        "endChar": 12
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "68c55eb3_91aa48c1",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 1,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "2018",
      "range": {
        "startLine": 1,
        "startChar": 13,
        "endLine": 1,
        "endChar": 17
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a82a4e26_0bf08f03",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 1,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "68c55eb3_91aa48c1",
      "range": {
        "startLine": 1,
        "startChar": 13,
        "endLine": 1,
        "endChar": 17
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dee91397_a50cd277",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "Calling count() and then find() means searching the map twice. Instead,\n\nauto it \u003d response_map.find(CBOR(1));\nif (it \u003d\u003d response_map.end() || !it-\u003esecond.is_string())\n  return false;\n\nit \u003d response_map.find(CBOR(2));\nif (it \u003d\u003d response_map.end() || !it-\u003esecond.is_bytestring())\n  return false;\n\netc...",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 32,
        "endChar": 53
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85a8013a_d138b23b",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Thanks for the advice!",
      "parentUuid": "dee91397_a50cd277",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 32,
        "endChar": 53
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "74cf179c_1b089f65",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 111,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "Why is this a CHECK and not a DCHECK? Would it be reasonable to just return kCtap2ErrInvalidCBOR if the buffer is zero-length?",
      "range": {
        "startLine": 111,
        "startChar": 2,
        "endLine": 111,
        "endChar": 25
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1018233_59e0c256",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 111,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Returned kCtap2ErrInvalidCBOR instead of using CHECK.",
      "parentUuid": "74cf179c_1b089f65",
      "range": {
        "startLine": 111,
        "startChar": 2,
        "endLine": 111,
        "endChar": 25
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "72d606eb_b7c8f984",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 132,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "The find() calls here are duplicating the work of MakeCredentialResponseCheck above. I would just do all this work in a single place.",
      "range": {
        "startLine": 130,
        "startChar": 0,
        "endLine": 132,
        "endChar": 76
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e76e2310_cdeb8adc",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 132,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "72d606eb_b7c8f984",
      "range": {
        "startLine": 130,
        "startChar": 0,
        "endLine": 132,
        "endChar": 76
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d8ceb4e3_5efacbe0",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 134,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "This is confusing. I would have assumed that we wanted to parse |buffer| and make the CBOR encoded data available but it seems like we\u0027re just parsing, validating and then re-encoding it.",
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8929c098_37aade42",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 134,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "That is correct. This is mainly because the attestation object returned from the authenticator is mainly treated as an \"opaque object\" and returned to the relying party. \n\nHowever, although we are returning CBOR encoded byte arrays directly to relying party, the encoding format of what is returned from the security key and what is expected from the relying party is a bit different.\n\nMore specifically, per CTAP spec, security keys will return CBOR map with unsigned keys. However, relying party expects CBOR map with string keys (\"fmt\" / \"authData\" / \"attStmt\" ) . The values for theses keys remain the same.  \n\nI believe that parsing byte returns from security keys and checking them for validity/types are necessary and that we  shouldn\u0027t continue to process any data received from external device unless it strictly conforms to format specified by the protocol. (We have already found handful of bugs in CTAP security key manufacturers because of this! :) )",
      "parentUuid": "d8ceb4e3_5efacbe0",
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84bca400_32ce8fdd",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 146,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "Same comment about the \"check\" methods applies here and below. Lots of duplicated work and validation logic spread all over the file.",
      "range": {
        "startLine": 146,
        "startChar": 28,
        "endLine": 146,
        "endChar": 53
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7a80150_9cbd8016",
        "filename": "device/ctap/device_response_convertor.cc",
        "patchSetId": 7
      },
      "lineNbr": 146,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "84bca400_32ce8fdd",
      "range": {
        "startLine": 146,
        "startChar": 28,
        "endLine": 146,
        "endChar": 53
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a1713ad6_a2874ffd",
        "filename": "device/ctap/device_response_convertor.h",
        "patchSetId": 7
      },
      "lineNbr": 1,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "2018",
      "range": {
        "startLine": 1,
        "startChar": 13,
        "endLine": 1,
        "endChar": 17
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "296cc2ab_94e5389f",
        "filename": "device/ctap/device_response_convertor.h",
        "patchSetId": 7
      },
      "lineNbr": 1,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a1713ad6_a2874ffd",
      "range": {
        "startLine": 1,
        "startChar": 13,
        "endLine": 1,
        "endChar": 17
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "271d1fda_3ac5920f",
        "filename": "device/ctap/device_response_convertor.h",
        "patchSetId": 7
      },
      "lineNbr": 33,
      "author": {
        "id": 1113896
      },
      "writtenOn": "2018-01-09T19:31:08Z",
      "side": 1,
      "message": "Use base::span\u003cuint8_t\u003e in these functions and you will find that you don\u0027t need to construct as many intermediate std::vectors because a span can be constructed directly from an array or raw pointer without copying anything.",
      "range": {
        "startLine": 33,
        "startChar": 31,
        "endLine": 33,
        "endChar": 58
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0cfec0cf_d63679fc",
        "filename": "device/ctap/device_response_convertor.h",
        "patchSetId": 7
      },
      "lineNbr": 33,
      "author": {
        "id": 1247602
      },
      "writtenOn": "2018-01-09T22:46:04Z",
      "side": 1,
      "message": "Even if we used base::span here, wouldn\u0027t we have to copy base::span\u0027s data when we call cbor::CBORReader::Read()? In this case, wouldn\u0027t using const reference be cheaper since we\u0027re not copying anything when we call cbor::CBORReader::Read()? \n\nPlease let me know if I\u0027m misunderstanding anything! :)",
      "parentUuid": "271d1fda_3ac5920f",
      "range": {
        "startLine": 33,
        "startChar": 31,
        "endLine": 33,
        "endChar": 58
      },
      "revId": "a66d4e09c10e361bd339d0d7ec2e7b5068dc4441",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}