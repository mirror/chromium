{
  "comments": [
    {
      "key": {
        "uuid": "334a1591_e5e8c42f",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 146,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:00:10Z",
      "side": 1,
      "message": "If we get an entry builder and don\u0027t add any metrics, does anything get logged? e.g. does this give us enough data for the BLOCK case (non reload).",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "663a953d_67198575",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 146,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-11T13:31:14Z",
      "side": 1,
      "message": "Good question - historically empty entries were dropped, but some teams depended on being able to log empty entries, so the behavior was changed. Rob, is my understanding on this current? We don\u0027t drop empty entries anymore, right?\n\nYou can see the change to add support for empty entries here:\nhttps://codereview.chromium.org/2855053002\na new test was added: AddEntryWithEmptyMetrics and that test still exists today.",
      "parentUuid": "334a1591_e5e8c42f",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9da4ddc9_4fb6e7d5",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 75,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:00:10Z",
      "side": 1,
      "message": "I\u0027m curious why these URL changes are necessary, since AFAIK GURL will canonicalize them to have a slash anyways.",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "200ac737_32227005",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 75,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-11T13:31:14Z",
      "side": 1,
      "message": "That\u0027s right, GURL normalizes URLs to include the trailing slash. UKM makes use of GURL in ways we weren\u0027t doing previously, so in order for URL lookup to match, it\u0027s better to use the normalized URL and be consistent.\n\nThe change to this test wasn\u0027t strictly necessary since it doesn\u0027t use UKM, but I feel it\u0027s better for us to use valid URLs (which include the \u0027/\u0027 in the path) consistently across our tests - I\u0027ve done similar cleanups for test code in a few other codebases in the past as this issue tends to crop up in various ways when URLs without trailing \u0027/\u0027 for the path are used.",
      "parentUuid": "9da4ddc9_4fb6e7d5",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24a1ebb0_e7a2fc84",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 75,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:54:24Z",
      "side": 1,
      "message": "I\u0027m fine with the change, I\u0027m just wondering if it changes behavior at all (even if the test uses UKM). AFAICT we only need the trailing slash if we\u0027re using the string as a stand-in for the GURLs spec().",
      "parentUuid": "200ac737_32227005",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e257c440_a35e93aa",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 75,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-12T14:00:04Z",
      "side": 1,
      "message": "Ah, sure - there should be no change in behavior.",
      "parentUuid": "24a1ebb0_e7a2fc84",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa96af9f_bbb6512d",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 154,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:00:10Z",
      "side": 1,
      "message": "Aside: Not for this CL, but having a method called GetSourceForUrl that takes a char * seems wrong. I think either it should take a GURL or a StringPiece and be renamed GetSourceForUrlSpec.",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "788a75dc_76679781",
        "filename": "chrome/browser/page_load_metrics/observers/document_write_page_load_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 154,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-11T13:31:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "aa96af9f_bbb6512d",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a59f3549_4daf4675",
        "filename": "chrome/browser/page_load_metrics/observers/from_gws_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 448,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:00:10Z",
      "side": 1,
      "message": "Optional: Here and elsewhere I\u0027d be tempted to:\nif (ukm::UkmRecorder* ukm_recorder \u003d g_browser_process-\u003eukm_recorder()) {\n  ...\n}\n\nTo scope the recorder to the conditional.",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "685621a6_e87084ce",
        "filename": "chrome/browser/page_load_metrics/observers/from_gws_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 448,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-11T13:31:14Z",
      "side": 1,
      "message": "I don\u0027t feel strongly, but I believe this style is common in blink code, but not Chrome code. I personally find it slightly harder to read, but it is shorter which is nice.\n\nMy inclincation is to follow convention, and this is not the convention for looking up the ukm recorder elsewhere in the codebase:\nhttps://cs.chromium.org/search/?q\u003d%5C%3D.*%5C%3Eukm_recorder%5C(%5C)\u0026type\u003dcs\n\nand more generally this style (an if test with assignment inside) is very uncommon in chrome/ code (only 20 files I can find that do this):\nhttps://cs.chromium.org/search/?q\u003dif%5C+%5C(%5B%5E)%5D*%5C+%3D%5C++file:chrome/+lang:c%2B%2B\u0026type\u003dcs\n\nSo I\u0027m disinclined to start using this pattern more in chrome code. It seems to be something more commonly done in blink code.",
      "parentUuid": "a59f3549_4daf4675",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c7452a7_45969558",
        "filename": "chrome/browser/page_load_metrics/observers/from_gws_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 448,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:54:24Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "685621a6_e87084ce",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82613a79_f296911a",
        "filename": "chrome/browser/page_load_metrics/observers/from_gws_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 448,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-07-11T13:56:34Z",
      "side": 1,
      "message": "Yep this has been my understanding too (a Chromium vs WebKit/Blink style diff). See also\nhttps://groups.google.com/a/chromium.org/d/msg/chromium-dev/cQmHtdqTwGo/A-8GotxWd5cJ",
      "parentUuid": "685621a6_e87084ce",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e9c85a1_8af1a8e2",
        "filename": "chrome/browser/page_load_metrics/observers/service_worker_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 116,
      "author": {
        "id": 1000128
      },
      "writtenOn": "2017-07-11T13:56:34Z",
      "side": 1,
      "message": "By the way, are all the core PageLoad metrics understood to be logged only for main frame navigations? If not, we might want to add to this comment to say for \"main frame pages controlled by a service worker\". If my understanding is right, IsServiceWorkerControlled() only returns true for main frame loads.\n\nActually I wonder if this is a bug in our current code. Are OnDomContentLoadedEventStart() and OnLoadEventStart() only called for the main frame load? Our code intends to do:\n\nif (IsServiceWorkerControlled()) {\n  // sw controlled metrics\n} else {\n  // non sw controlled metrics\n}\n\nIf they are called for subframes too, the else{} is logging both non-sw controlled main frame loads and all subframe loads.",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36ee0fb6_01df29ea",
        "filename": "chrome/browser/page_load_metrics/observers/service_worker_page_load_metrics_observer.cc",
        "patchSetId": 6
      },
      "lineNbr": 116,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-11T14:07:10Z",
      "side": 1,
      "message": "Sure - I updated the comment.\n\nAll the callbacks you mention are for main frames only, so your code should be working as you intend it to.",
      "parentUuid": "5e9c85a1_8af1a8e2",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bff5feaf_f1b8528a",
        "filename": "chrome/browser/page_load_metrics/observers/subresource_filter_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 98,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:00:10Z",
      "side": 1,
      "message": "I would prefer if this took a GURL since it should be readily available, but it seems not trivial without changing GetSourceForUrl.",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e773799_5300592e",
        "filename": "chrome/browser/page_load_metrics/observers/subresource_filter_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 98,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-11T13:31:14Z",
      "side": 1,
      "message": "Yup, I don\u0027t think it\u0027s critical.\n\nI prefer test methods take string over GURL since taking GURL can mean writing unnecessary boilerplate. See for example our many calls to NavigateAndCommit(GURL(kUrl)) - I think this makes tests less readable - I\u0027d rather that there be a NavigateAndCommit that takes char*.",
      "parentUuid": "bff5feaf_f1b8528a",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3068a04d_56e121e4",
        "filename": "chrome/browser/page_load_metrics/observers/subresource_filter_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 98,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-11T13:54:24Z",
      "side": 1,
      "message": "Agree to disagree :) I don\u0027t think GURL(\u003cstring\u003e) is too much boilerplate, and these types of methods are exactly why tests become fragile when using char *s or strings that don\u0027t represent canonicalized URLs.\n\nIn this particular case, I think using a scoped test var is also nicer than a global const char*, which is repeated in the test and could become out of sync when edits are made.",
      "parentUuid": "9e773799_5300592e",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0b9e695_1c03b376",
        "filename": "chrome/browser/page_load_metrics/observers/subresource_filter_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 98,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-12T14:00:04Z",
      "side": 1,
      "message": "It\u0027s a good point re: URL canonicalization. To address that I think I\u0027d rather modify GetSourceForUrl to convert to GURL internally. I tend to prefer making test utilities as simple to use as possible, so rather than requiring every call site to wrap a constant in GURL(), we can do that once in the GetSourceForUrl impl. How does that sound?",
      "parentUuid": "3068a04d_56e121e4",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab5dbe48_70a11681",
        "filename": "chrome/browser/page_load_metrics/observers/subresource_filter_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 98,
      "author": {
        "id": 1142059
      },
      "writtenOn": "2017-07-12T14:27:09Z",
      "side": 1,
      "message": "I think doing internal canonicalization is better than what is done currently, but I would still prefer a GURL interface for the following reasons. I just want to preface this by saying that this is a small issue and I realize I\u0027m bikeshedding :)\n\n1. As I mentioned in the above comment. Tests should be instantiating the url once and using that in multiple APIs e.g.\nGURL url(kExampleUrl);\nNavigateToUrl(url);\n...\nGetSourcesForUrl(url)\n...\n\nThis is nicer than:\nNavigateToUrl(GURL(kExampleUrl))\nGetSourcesForUrl(kExampleUrl)\n\nSince the latter repeats the constant. If I wanted to change the URL to another constant I\u0027d need to edit the test in two places rather than one.\n\nAdditionally, there are lots of tests that first do something like:\nconst GURL url(\"https://example.test/\");\nAnd then use |url| everywhere. These tests would need to move to the constant char* model to use this API, or repeat the raw string.\n\n2. It makes GetSourcesForUrl() \"simpler\" in the sense that current callers need less code boilerplate, but more complex in that we lose type information and the set of valid inputs increases since we\u0027re losing structure.\n\n3. Plenty of valid usages may not have easy access to a char* since most browser APIs vend GURLs (WebContents, NavigationEntry, etc). In those cases you will need to use url.spec().c_str() to get the underlying pointer, which is not great.",
      "parentUuid": "d0b9e695_1c03b376",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08d9d2d1_fa8cb25e",
        "filename": "chrome/browser/page_load_metrics/observers/subresource_filter_metrics_observer_unittest.cc",
        "patchSetId": 6
      },
      "lineNbr": 98,
      "author": {
        "id": 1136769
      },
      "writtenOn": "2017-07-12T14:39:03Z",
      "side": 1,
      "message": "Thanks for the explanation! I\u0027d suggest raising this concern on ukm-team@. To properly address this, the fix would be to update the test APIs to no longer take char*.\n\nMy preference is to keep the APIs as they are, for reasons I\u0027ve stated earlier (keep the test code simpler), but if ukm-team@ feels differently you are welcome to drive the change there.\n\nOne more bit of info that is probably relevant to this discussion: GURL implementers seem to have decided that comparison by string is fine and should be supported without callers having to wrap the stringpiece in a temporary GURL(), as GURL provides the following:\n\nbool operator\u003d\u003d(const GURL\u0026 x, const base::StringPiece\u0026 spec);\n(in addition to operator\u003d\u003d taking only GURLs)\n\nGiven that GURL itself provides the ability to compare GURL and stringpiece/char*, this suggests to me that higher layer libraries are probably also fine to take char*/stringpiece for comparing with GURL.\n\nI do agree with you that there are some cases where we need to use more structured types for comparison (such as if we were inspecting particular components of URLs, etc), but when we\u0027re writing tests that are really just using URLs as identifiers, using char* seems totally fine to me.",
      "parentUuid": "ab5dbe48_70a11681",
      "revId": "b5d38a49e45cd37760d558910b7bff5d65c786f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}