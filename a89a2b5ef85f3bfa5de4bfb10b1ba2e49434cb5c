{
  "comments": [
    {
      "key": {
        "uuid": "616d0abf_ee3dcbb0",
        "filename": "ash/wm/overview/window_selector_item.cc",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-11-02T21:06:46Z",
      "side": 1,
      "message": "Instead of separately looking for LONG_PRESS here, should this explicitly look for the ET_GESTURE_TAP and trigger the selection only in that case, and goes back to the overview mode in all other cases? Alternatively, since you know from here that drag event happens only if SCROLL_UPDATE happened, then you can explicitly look for a SCROLL_END, and CompleteDrag() when that happens, and for all other GESTURE_END, cancel the drag and go back to the original overview state? I think that\u0027d be easier to follow.",
      "revId": "a89a2b5ef85f3bfa5de4bfb10b1ba2e49434cb5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c6e978a_9f02c645",
        "filename": "ash/wm/overview/window_selector_item.cc",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 1160212
      },
      "writtenOn": "2017-11-03T18:09:02Z",
      "side": 1,
      "message": "All the event handling is done is overview_drag_controller. There\u0027s three situation we want to account for:\n1) regular tap - activate window\n2) drag - snap window maybe\n3) long press - reset to previous state\n\nRight now both 1 and 2 are handled together by checking |location_in_screen|. To add 3 we have to pipe some more info to overview_drag_controller. If we check for TAP then we would have to pipe another event up to overview_drag_controller and then make sure GESTURE_END doesn\u0027t activate. Same goes for checking for SCROLL_UPDATE.\n\ncase ui::GESTURE_TAP:\nlistener()-\u003eHandleReleaseEvent(location, true /* tapped */);\nbreak;\ncase ui::GESTURE_END:\nlistener()-\u003eHandleReleaseEvent(location, false);\n\nand then\nCompleteDrag(location, tapped)\nif (tapped_) return;\ntapped_ \u003d tapped;\ndostuff...\n\nis that better?",
      "parentUuid": "616d0abf_ee3dcbb0",
      "revId": "a89a2b5ef85f3bfa5de4bfb10b1ba2e49434cb5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ea8bca8_9d45ff83",
        "filename": "ash/wm/overview/window_selector_item.cc",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-11-06T16:10:27Z",
      "side": 1,
      "message": "What about other events? e.g. pinch? I assume all those events would go to (3): reset to previous state? If so, I suggest handling handling GESTURE_TAP, GESTURE_SCROLL_END/FLING_START, and GESTURE_END separately, and more explicitly. For example:\n\n  case ui::ET_GESTURE_TAP:\n    listener()-\u003eActivateWindowAt(screen_location);\n    break;\n  case SCROLL_END:\n  case FLING_START:\n    listener()-\u003eCompleteDragAt(screen_location);\n    break;\n  case ui::ET_GESTURE_END:\n    listener()-\u003eResetGesture(screen_location);\n    break;",
      "parentUuid": "5c6e978a_9f02c645",
      "revId": "a89a2b5ef85f3bfa5de4bfb10b1ba2e49434cb5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}