{
  "comments": [
    {
      "key": {
        "uuid": "c606efdf_459e212a",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 9
      },
      "lineNbr": 2827,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-07-14T16:17:26Z",
      "side": 1,
      "message": "You need to explicitly Close the binding before re-binding it or Bind will DCHECK",
      "revId": "d16e288f9f5c6d74d6c05d284ce1beaad4fe9d4a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6431cbba_85f29f73",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 9
      },
      "lineNbr": 2827,
      "author": {
        "id": 1003152
      },
      "writtenOn": "2017-07-14T19:14:49Z",
      "side": 1,
      "message": "It\u0027s actually much more fun than that!\n\nWe normally close the previous binding in response to DidCommitProvisionalLoad, but the failing test uses CommitBeforeSwapAckSentHelper [1].\n\nNow CommitBeforeSwapAckSentHelper runs a nested message loop inside the IPC handler for FrameMsg_DidCommitProvisionalLoad, before it is actually dispatched to RFHI, so the BindInterfaceProviderForNewDocument that is sent afterwards, arrives first. :-/\n\nDo you see and quick \u0026 easy fixes?\n\n[1]: https://cs.chromium.org/chromium/src/content/browser/renderer_host/render_widget_host_view_browsertest.cc?rcl\u003dcbdd0ee2333b75ef32a4b02a3c243ab99ebead99\u0026l\u003d218",
      "parentUuid": "c606efdf_459e212a",
      "revId": "d16e288f9f5c6d74d6c05d284ce1beaad4fe9d4a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ac44729_b3da7240",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 9
      },
      "lineNbr": 2827,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-07-17T14:33:01Z",
      "side": 1,
      "message": "Sorry, I thought I had replied Friday but I see no record of this anywhere.\n\nRunning a nested loop while manually deferring an IPC makes it pretty hard to find any quick \u0026 easy fixes.\n\nWe could queue incoming InterfaceProvider requests (in BindInterfaceProviderForNewDocument) and ensure that they\u0027re only actually processed in sync with their corresponding DCPL IPC.\n\nOR we could move DCPL to the FrameHost mojom interface (adding the InterfaceProvider request to it rather than in a separate BIPFND message), which is probably something we eventually want anyway. Then the deferral/queueing can happen in a single place, the DCPL impl. This might not be so bad?\n\nNote that we don\u0027t really have the nice (albeit rarely desirable) ability to capture the message and dispatch it later like we do with legacy IPC, so you\u0027d have to manually capture/queue the message parameters, but still that may be the cleanest solution.",
      "parentUuid": "6431cbba_85f29f73",
      "revId": "d16e288f9f5c6d74d6c05d284ce1beaad4fe9d4a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f03a63c2_65ee8911",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 9
      },
      "lineNbr": 2827,
      "author": {
        "id": 1003152
      },
      "writtenOn": "2017-07-24T18:59:19Z",
      "side": 1,
      "message": "Apologies, got sidetracked last week.\n\nI moved DCPL to FrameHost, which was rather painless (not uploaded yet).\n\nI was thinking about what would be the cleanest way to intercept FrameHost messages. Which of these do you hate the least?\n\n1.) Unbind the InterfaceRequest from frame_host_associated_binding_ if it\u0027s already bound, otherwise override the binder method to forward to the testing object.\n\n2.) Use std::unique_ptr\u003cmojo::AssociatedBinding\u003e frame_host_associated_binding_; and replace it during testing to redirect to the testing object (Unbind-\u003eBind the if it is already bound). This way the binder method does not need to be overridden.\n\n3.) Make use of AssociatedBinding::AddFilter (although it\u0027s unclear how we could make this message-specific).\n\n4.) Something else?",
      "parentUuid": "8ac44729_b3da7240",
      "revId": "d16e288f9f5c6d74d6c05d284ce1beaad4fe9d4a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0c43ab9_40edf460",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 9
      },
      "lineNbr": 2827,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-07-24T19:30:30Z",
      "side": 1,
      "message": "#1 is impossible. Due to the ordering requirements of IPC Channel and associated interfaces, we do not allow Channel-associated interfaces to be unbound: doing so would require all incoming messages to be blocked (because of how associated interfaces are specified) and we don\u0027t want arbitrary legacy IPC messages to be blocked.\n\n#2 borders on acceptable but seems kind of messy.\n\n#3 would not be feasible without some dubious refactoring. Otherwise you would be manually parsing the message and I don\u0027t think that\u0027s acceptable.\n\n#4 what about just adding a special testing API to allow overriding how FrameHost requests are handled, and have explicit logic in RFHI to forward to an overriding binder if set?",
      "parentUuid": "f03a63c2_65ee8911",
      "revId": "d16e288f9f5c6d74d6c05d284ce1beaad4fe9d4a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd59dd66_1e003e1e",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 9
      },
      "lineNbr": 2827,
      "author": {
        "id": 1003152
      },
      "writtenOn": "2017-07-24T20:42:23Z",
      "side": 1,
      "message": "So how about this: the RFHI would bind an incoming FrameHostAssociatedInterfaceRequest not to itself, but to a class that implements mojom::FrameHost but just forwards everything to the RFHI (the instance of this class would be a member, and it would also own the binding). During testing, the target where this class delegates to can be overridden. This way, no Mojo magic involved, the binder does not need to be overridden either.\n\nAlternatively, mandate that the testing override should already be in place when the RFHI is created, and *only* override the binder so that when the FrameHostAssociatedInterfaceRequest comes in, it is dispatched to the testing implementation?",
      "parentUuid": "f0c43ab9_40edf460",
      "revId": "d16e288f9f5c6d74d6c05d284ce1beaad4fe9d4a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d1fabcc_2c602e99",
        "filename": "content/browser/frame_host/render_frame_host_impl.cc",
        "patchSetId": 9
      },
      "lineNbr": 2827,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-07-25T15:32:35Z",
      "side": 1,
      "message": "I mean, sure, that (the first thing) sounds fine. I wasn\u0027t imagining that the binder got overridden though, but rather that the binder would an RFHI method that internally could delegate to a global override if set. It\u0027s the same thing as what you suggest, it just doesn\u0027t require an intermediate object.",
      "parentUuid": "dd59dd66_1e003e1e",
      "revId": "d16e288f9f5c6d74d6c05d284ce1beaad4fe9d4a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}