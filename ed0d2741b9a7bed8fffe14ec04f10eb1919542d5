{
  "comments": [
    {
      "key": {
        "uuid": "baf96e63_5f962df8",
        "filename": "net/dns/host_resolver_impl_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 157,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-09-01T17:45:55Z",
      "side": 1,
      "message": "Why is this constructed in a loop? Do you anticipate the Task Scheduler to start rescheduling tasks (like this one in Wait) and somehow preserving the stack?",
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6dfbd634_17d71d36",
        "filename": "net/dns/host_resolver_impl_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 157,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-09-11T14:24:12Z",
      "side": 1,
      "message": "ScopedBlockingCall no longer needed here. ConditionVariable instantiates its own ScopedBlockingCall https://chromium-review.googlesource.com/c/chromium/src/+/654058",
      "parentUuid": "baf96e63_5f962df8",
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "633c9756_3189012c",
        "filename": "net/dns/host_resolver_impl_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 385,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-09-01T17:45:55Z",
      "side": 1,
      "message": "It seems inefficient to construct this temporary in a loop, given that by definition, this task runner can\u0027t also start running some other task while the loop is processing.",
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57ef26c2_652c1099",
        "filename": "net/dns/host_resolver_impl_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 385,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-09-11T14:24:12Z",
      "side": 1,
      "message": "ScopedBlockingCall no longer needed here. WaitableEvent instantiates its own ScopedBlockingCall https://chromium-review.googlesource.com/c/chromium/src/+/654058",
      "parentUuid": "633c9756_3189012c",
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e1159b2_c310e5e2",
        "filename": "net/dns/host_resolver_proc.cc",
        "patchSetId": 5
      },
      "lineNbr": 204,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-09-01T17:45:55Z",
      "side": 1,
      "message": "Similarly, why construct multiple ScopedBlockingCAlls given that this whole function may?\n\nAlso, note line 196 may also (AIUI)",
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "107de277_2ade1a05",
        "filename": "net/dns/host_resolver_proc.cc",
        "patchSetId": 5
      },
      "lineNbr": 204,
      "author": {
        "id": 1113149
      },
      "writtenOn": "2017-09-05T17:56:34Z",
      "side": 1,
      "message": "My understanding is that DnsReloaderMaybeReload() does file I/O. The comments in scoped_blocking_call.h suggest that that requires a ScopedBlockingCall (using MAY_BLOCK, which isn\u0027t implemented but I had to look at cross-refs to notice), but the rest of the codebase suggests that it doesn\u0027t, it only requires a MayBlock() TaskTrait. Francois, can you clarify?",
      "parentUuid": "8e1159b2_c310e5e2",
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbf7c8a1_cf84c416",
        "filename": "net/dns/host_resolver_proc.cc",
        "patchSetId": 5
      },
      "lineNbr": 204,
      "author": {
        "id": 1113149
      },
      "writtenOn": "2017-09-05T17:56:34Z",
      "side": 1,
      "message": "I noticed after writing most of this comment that MAY_BLOCK isn\u0027t actually supported yet, but if it does get implemented later: what\u0027s the intended distinction between WILL_BLOCK and MAY_BLOCK? At this point we\u0027ve already checked our own cache, but the OS might have a cached result that we\u0027re missing. On Windows and Linux that happens around 10% of the time, on Android it\u0027s rare.",
      "range": {
        "startLine": 204,
        "startChar": 28,
        "endLine": 204,
        "endChar": 38
      },
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ecc926a_5de4b12b",
        "filename": "net/dns/host_resolver_proc.cc",
        "patchSetId": 5
      },
      "lineNbr": 204,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-09-11T14:24:12Z",
      "side": 1,
      "message": "MAY_BLOCK is now implemented https://chromium-review.googlesource.com/c/chromium/src/+/639330 :)\n\nTaskScheduler manages a thread pool whose initial size is chosen to maximize CPU usage when there are pending tasks. If a task makes a blocking call and the thread pool size doesn\u0027t change, CPU usage is no longer maximized. The goal of ScopedBlockingCall is to increment the thread pool size during blocking calls so that CPU usage is always maximized.\n\nA WILL_BLOCK ScopedBlockingCall increments the thread pool size immediately.\nA MAY_BLOCK ScopedBlockingCall increments the thread pool size if it stays alive for a few ms.\n\nI\u0027m about to land clearer documentation for ScopedBlockingCall https://chromium-review.googlesource.com/c/chromium/src/+/657259/2/base/threading/scoped_blocking_call.h A trace https://drive.google.com/a/google.com/file/d/0B83u4q-r0vlmZmItWHRSQldDWlE/view?usp\u003dsharing (open in chrome://tracing) and jank profiler dashboard data clearly show that DNS lookups fall into the WILL_BLOCK category.",
      "parentUuid": "bbf7c8a1_cf84c416",
      "range": {
        "startLine": 204,
        "startChar": 28,
        "endLine": 204,
        "endChar": 38
      },
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "002293d0_b2912ae6",
        "filename": "net/dns/host_resolver_proc.cc",
        "patchSetId": 5
      },
      "lineNbr": 204,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2017-09-11T14:24:12Z",
      "side": 1,
      "message": "Discussed offline with rsleevi@:\n- Most of the time in this method is spent in blocking calls. Therefore, there should be an active ScopedBlockingCall instance for the whole duration of this method.\n- It wouldn\u0027t be appropriate to have a ScopedBlockingCall for the whole duration of this method if it used a significant amount of CPU.",
      "parentUuid": "107de277_2ade1a05",
      "revId": "ed0d2741b9a7bed8fffe14ec04f10eb1919542d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}