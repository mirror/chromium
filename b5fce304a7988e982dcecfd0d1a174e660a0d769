{
  "comments": [
    {
      "key": {
        "uuid": "81d4f999_ad6c3d9d",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-13T20:55:10Z",
      "side": 1,
      "message": "When investigating test failures, I found out that ReadbackYUV() causes both the source canvas and captured stream to be rendered corruptly. I discussed the issue with miu@ offline and found out that context is not restored to its state before. This change fixes it as far as I tested.\ndanakj@ can you take a look at this and advise? I am not sure if this is the right approach as the context is shared. Do you know what is the safe way to do this?",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d890bc30_2e4dd891",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T15:43:53Z",
      "side": 1,
      "message": "This will reset state that the GrContext changed, not that other things changed. GLHelper doesn\u0027t have such a method, and it doesn\u0027t use GrContext, so this looks like a no-op roughly.\n\nSome choices are..\n1. When returning from this, canvas code can\u0027t assume any state and must reset anything it expects?\n2. Write the code here explicitly instead of GLHelper, then we can see what changed and reset it?\n3. Add some sort of Reset method to ReadbackYUVInterface?\n\nWhat would #1 look like?",
      "parentUuid": "81d4f999_ad6c3d9d",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f996224_8041edb2",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-14T22:03:07Z",
      "side": 1,
      "message": "I just double checked. This line actually fixes it somehow. GrContext and GLHelper share the same GLES2Interface*. \n\nRe your suggestionss, what reset method should I use to do them? Just to be clear, ReadbackYUV() causes both the source canvas and captured stream to be rendered corruptly. I think ReadbackYUV() sets a state which isnt cleared.\n\n[0] https://cs.chromium.org/chromium/src/services/ui/public/cpp/gpu/context_provider_command_buffer.cc?rcl\u003d0951256184bfbf3bb7c4b23ee01c24d84841abb7\u0026l\u003d378",
      "parentUuid": "d890bc30_2e4dd891",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5db06cfd_42067871",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T22:20:06Z",
      "side": 1,
      "message": "\u003e I just double checked. This line actually fixes it somehow. GrContext and GLHelper share the same GLES2Interface*. \n\nThen I guess resetContext() is doing some work unconditoinally even tho it\u0027s not being used, but its not aware of what GLHelper is doing and just happens to overlap and reset the right things (for now) and maybe other additional things which may or may not be expected, and may or may not be what canvas would want.\n\n\u003e Just to be clear, ReadbackYUV() causes both the source canvas and captured stream to be rendered corruptly\n\nI\u0027m not sure what you mean here I guess. I think you\u0027re just saying that any gl commands we run after are depending on some state that ReadbackYUV has changed.\n\nThen I guess what I\u0027m saying for #1 is that after canvas does this readback, both canvas and the captured stream generating code should not assume these GL states and should be setting them.\n\nFor #2/3 there is no such Reset method, it would be adding one that un-sets the things ReadbackYUV sets essentially. A reset method kinda feels more fragile to me fwiw which is why i asked about what #1 would look like first.",
      "parentUuid": "3f996224_8041edb2",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6d1b47f_576a21e7",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-11-14T23:08:02Z",
      "side": 1,
      "message": "\u003e This will reset state that the GrContext changed\n\nThat is not what resetContext does.  The way it works is that GrContext maintains a cache of what it knows the current state of the GL context is.  This allows skia to optimize-out unnecessary state changing calls to the GL interface.  However, when the GL context is used directly, without going through skia, the state cached inside of GrContext falls out of sync.  GrContext::resetContext is used to tell skia that its cache is no longer valid, which is exectly what you need to do in this situation. Also, in order to help performance, you should avoid calling resetContext with no arguments.  You should pass it a bit mask that identifies exactly whick parts of the GL state were altered without going through skia. In this case, I think all you need is resetContext(kTextureBinding_GrGLBackendState)",
      "parentUuid": "5db06cfd_42067871",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84752cc4_d0600a36",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T23:15:04Z",
      "side": 1,
      "message": "Oh thanks Justin. Canvas is drawing through the GrContext I guess, and we\u0027re changing state and then calling GrContext things again? I\u0027m not sure why I was thinking canvas is using the GL context directly.. #justtuesdaythings.\n\nReadbackYUV() is changing the framebuffer attachment, so that would also need to be passed. In that case I agree resetContext() would be the right thing to do.",
      "parentUuid": "e6d1b47f_576a21e7",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33db487b_7365fd43",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-11-14T23:20:12Z",
      "side": 1,
      "message": "Exactly, canvas rasterization uses GrContext (for now, OOP canvas raster will change this. yay!).\nFor maintainability, the call to resetContext should be moved.  Better to put it right next to the GL calls that are changing the state.",
      "parentUuid": "84752cc4_d0600a36",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34ef8480_3da90370",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T23:21:44Z",
      "side": 1,
      "message": "Note that it would then create a GrContext even if there wasn\u0027t one already though. To avoid that we have ContextProvider::InvalidateGrContext().",
      "parentUuid": "33db487b_7365fd43",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}