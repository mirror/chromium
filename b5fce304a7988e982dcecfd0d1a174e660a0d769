{
  "comments": [
    {
      "key": {
        "uuid": "81d4f999_ad6c3d9d",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-13T20:55:10Z",
      "side": 1,
      "message": "When investigating test failures, I found out that ReadbackYUV() causes both the source canvas and captured stream to be rendered corruptly. I discussed the issue with miu@ offline and found out that context is not restored to its state before. This change fixes it as far as I tested.\ndanakj@ can you take a look at this and advise? I am not sure if this is the right approach as the context is shared. Do you know what is the safe way to do this?",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d890bc30_2e4dd891",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T15:43:53Z",
      "side": 1,
      "message": "This will reset state that the GrContext changed, not that other things changed. GLHelper doesn\u0027t have such a method, and it doesn\u0027t use GrContext, so this looks like a no-op roughly.\n\nSome choices are..\n1. When returning from this, canvas code can\u0027t assume any state and must reset anything it expects?\n2. Write the code here explicitly instead of GLHelper, then we can see what changed and reset it?\n3. Add some sort of Reset method to ReadbackYUVInterface?\n\nWhat would #1 look like?",
      "parentUuid": "81d4f999_ad6c3d9d",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f996224_8041edb2",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-14T22:03:07Z",
      "side": 1,
      "message": "I just double checked. This line actually fixes it somehow. GrContext and GLHelper share the same GLES2Interface*. \n\nRe your suggestionss, what reset method should I use to do them? Just to be clear, ReadbackYUV() causes both the source canvas and captured stream to be rendered corruptly. I think ReadbackYUV() sets a state which isnt cleared.\n\n[0] https://cs.chromium.org/chromium/src/services/ui/public/cpp/gpu/context_provider_command_buffer.cc?rcl\u003d0951256184bfbf3bb7c4b23ee01c24d84841abb7\u0026l\u003d378",
      "parentUuid": "d890bc30_2e4dd891",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5db06cfd_42067871",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T22:20:06Z",
      "side": 1,
      "message": "\u003e I just double checked. This line actually fixes it somehow. GrContext and GLHelper share the same GLES2Interface*. \n\nThen I guess resetContext() is doing some work unconditoinally even tho it\u0027s not being used, but its not aware of what GLHelper is doing and just happens to overlap and reset the right things (for now) and maybe other additional things which may or may not be expected, and may or may not be what canvas would want.\n\n\u003e Just to be clear, ReadbackYUV() causes both the source canvas and captured stream to be rendered corruptly\n\nI\u0027m not sure what you mean here I guess. I think you\u0027re just saying that any gl commands we run after are depending on some state that ReadbackYUV has changed.\n\nThen I guess what I\u0027m saying for #1 is that after canvas does this readback, both canvas and the captured stream generating code should not assume these GL states and should be setting them.\n\nFor #2/3 there is no such Reset method, it would be adding one that un-sets the things ReadbackYUV sets essentially. A reset method kinda feels more fragile to me fwiw which is why i asked about what #1 would look like first.",
      "parentUuid": "3f996224_8041edb2",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6d1b47f_576a21e7",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-11-14T23:08:02Z",
      "side": 1,
      "message": "\u003e This will reset state that the GrContext changed\n\nThat is not what resetContext does.  The way it works is that GrContext maintains a cache of what it knows the current state of the GL context is.  This allows skia to optimize-out unnecessary state changing calls to the GL interface.  However, when the GL context is used directly, without going through skia, the state cached inside of GrContext falls out of sync.  GrContext::resetContext is used to tell skia that its cache is no longer valid, which is exectly what you need to do in this situation. Also, in order to help performance, you should avoid calling resetContext with no arguments.  You should pass it a bit mask that identifies exactly whick parts of the GL state were altered without going through skia. In this case, I think all you need is resetContext(kTextureBinding_GrGLBackendState)",
      "parentUuid": "5db06cfd_42067871",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84752cc4_d0600a36",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T23:15:04Z",
      "side": 1,
      "message": "Oh thanks Justin. Canvas is drawing through the GrContext I guess, and we\u0027re changing state and then calling GrContext things again? I\u0027m not sure why I was thinking canvas is using the GL context directly.. #justtuesdaythings.\n\nReadbackYUV() is changing the framebuffer attachment, so that would also need to be passed. In that case I agree resetContext() would be the right thing to do.",
      "parentUuid": "e6d1b47f_576a21e7",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33db487b_7365fd43",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-11-14T23:20:12Z",
      "side": 1,
      "message": "Exactly, canvas rasterization uses GrContext (for now, OOP canvas raster will change this. yay!).\nFor maintainability, the call to resetContext should be moved.  Better to put it right next to the GL calls that are changing the state.",
      "parentUuid": "84752cc4_d0600a36",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34ef8480_3da90370",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-14T23:21:44Z",
      "side": 1,
      "message": "Note that it would then create a GrContext even if there wasn\u0027t one already though. To avoid that we have ContextProvider::InvalidateGrContext().",
      "parentUuid": "33db487b_7365fd43",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cf3f744_eebe16ad",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1123894
      },
      "writtenOn": "2017-11-15T01:51:32Z",
      "side": 1,
      "message": "- junov@, kTextureBinding_GrGLBackendState doesn\u0027t work unfortunately. I did a binary search within those params and found \"kView_GrGLBackendState | kVertex_GrGLBackendState\" works.\n- I moved resetContext() next to GL calls as you asked in this patch. However, it doesn\u0027t really fit into the GLHelper design as it is since there isn\u0027t any reference to GrContext there. I would prefer leaving it as a TODO and tackle it in https://crbug.com/774297. We can call |context_provider-\u003eGetGrContext()-\u003eresetContext()| here or add |blink::WebGraphicsContext3DProvider::InvalidateGrContext()|. WDYT?\n- Android bots[0] are hitting this DCHECK[1] in the test call to loseSharedGraphicsContext3D. Is it expected or a bug? Any quick fixes?\n[0] https://logs.chromium.org/v/?s\u003dchromium%2Fbb%2Ftryserver.chromium.android%2Flinux_android_rel_ng%2F428788%2F%2B%2Frecipes%2Fsteps%2Fcontent_browsertests__with_patch__on_Android%2F0%2Flogs%2FWebRtcCaptureFromElementBrowserTest.CaptureFromCanvas2DHandlesContextLoss%2F0\n[1] https://cs.chromium.org/chromium/src/components/viz/service/frame_sinks/frame_sink_manager_impl.cc?rcl\u003daa1f040d458602c618d3caaf2d1f8f7bebc99629\u0026l\u003d251",
      "parentUuid": "34ef8480_3da90370",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ea5bd18_e4068c80",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1115939
      },
      "writtenOn": "2017-11-15T15:43:04Z",
      "side": 1,
      "message": "* A binary search (or any experimental approach for that matter) is not a reliable way to determine the bits to pass to InvalidateGrContext(). The problem is that you might be getting lucky by accident. For example, there might be a call to glTexParameteri that just happens to be a no-op in the specific context of your test case.  What you need to do is review all the GL calls that are made by reading the code attentively to determine which parts of the state are altered.  This is why it is a good idea to put the InvalidateGrContext call near the GL calls, so that the relation between the GL calls and the resetContext bits is clear.  Doing that part in a follow-up is fine IMHO.  \n* I agree with Dana that it is preferable to use WebGraphicsContext3DProvider::InvalidateGrContext()\n* Regarding the test failure, it is really not clear to me how the CL might be causing that failure.  Maybe Dana has some insight?",
      "parentUuid": "5cf3f744_eebe16ad",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "104c9294_4c5c4a11",
        "filename": "content/renderer/media_capture_from_element/canvas_capture_handler.cc",
        "patchSetId": 13
      },
      "lineNbr": 333,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2017-11-15T15:53:23Z",
      "side": 1,
      "message": "\u003e We can call |context_provider-\u003eGetGrContext()-\u003eresetContext()| here or add |blink::WebGraphicsContext3DProvider::InvalidateGrContext()|. WDYT?\n\nPlease feel free to add the method to WGC3DProvider. It is just a blink wrapper of the other type, not meant to be different.\n\nAre you sure that DCHECK is from this patch? Were the tests just not starting a compositor before this patch? If it is this CL I\u0027m afraid you may need to bisect what is causing it by reconstructing the patch in bits until it occurs, perhaps with prints along the way to see where things differ.",
      "parentUuid": "6ea5bd18_e4068c80",
      "range": {
        "startLine": 333,
        "startChar": 0,
        "endLine": 333,
        "endChar": 51
      },
      "revId": "b5fce304a7988e982dcecfd0d1a174e660a0d769",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}