{
  "comments": [
    {
      "key": {
        "uuid": "53487c8d_99d3667b",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2018-01-16T22:35:51Z",
      "side": 1,
      "message": "There\u0027s a big problem here: we are trying to move ServiceManagerContext initialization to before browser-threads creation. There\u0027s a good amount of work there just to bring (only) the IO thread up sooner so that can happen. \n\nThis now adds yet another ordering dependency on another part of the browser before we can bring up Service Manager, which seems like a clear step in the wrong direction.",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d1d3c46_c4ae9400",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-16T23:01:12Z",
      "side": 1,
      "message": "Hmm, if we need to specify the task runner for an embedded service during the initialization of ServiceManagerContext (as is currently the case), then I don\u0027t see any alternative to passing it into this initialization call.\n\nIMO, this dependency on \"another part of the browser\" is not a big one. If you look at [1], all that is needed is to create an instance of AudioThreadImpl, which is essentially just a base::Thread. If creating that before the initialization of ServiceManagerContext would cause any issues, we would probably have to allow configuration of the task runner for embedded services in a stage _after_ the initialization of ServiceManagerContext. But I don\u0027t currently see any issue with creating the AudioThreadImpl first.\n\n[1] https://chromium-review.googlesource.com/c/chromium/src/+/759412/10/content/browser/browser_main_loop.cc",
      "parentUuid": "53487c8d_99d3667b",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1dfbbd6c_d2637077",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2018-01-17T00:34:15Z",
      "side": 1,
      "message": "Sorry this is being dragged out so much, but I strongly disagree that this is not significant. The issue with just creating AudioThreadImpl first is not technical, but a matter of principle. We shouldn\u0027t have to initialize part of some random subsystem before we can bring up the service manager. It is already true that we do in some capacity, but we want to reduce, not increase, the extent to which it\u0027s true. I don\u0027t think we should allow *any* such new dependencies to be introduced for any reason.\n\nI\u0027d like us to find another way to solve this.\n\nOne option could be to allow EmbeddedServiceInfo to use an async factory function so that service creation can take an arbitrarily long time. Then you could have appropriate plumbing such that the \"audio thread\" doesn\u0027t need to be known at registration time and can be acquired as needed without changing ServiceManagerContext\u0027s own inputs. Does that sound like a reasonable direction?",
      "parentUuid": "5d1d3c46_c4ae9400",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "363c3a64_43371043",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-17T01:18:25Z",
      "side": 1,
      "message": "Yes, that sounds reasonable. I also agree that a dependency on something with a name as specific as \"AudioThreadImpl\" is bad. I think it would be okay if it was just a base::TaskRunner though. I was just too lazy to refactor AudioManager to accept one instead of AudioThreadImpl, but it can be done. Would that be more acceptable or already break the principle?\n\nProviding EmbeddedServiceInfo an async factory function from which it can obtain the target task runner lazily is an interesting proposal. The interesting thing to think about would be what happens if that async factory function gets called before the corresponding thread (in our case the \"audio thread\") has been created. I guess we would then have to store the callback somewhere and make sure to invoke it as soon as the thread has been created. This feels more complicated than the approach of passing a base::TaskRunner to ServiceManagerContext on construction, but I think it can work. If that sounds good to you, I could try and sketch this out in code so we can see how it would look like. What do you think?",
      "parentUuid": "1dfbbd6c_d2637077",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06040357_d6b8f19b",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2018-01-17T15:24:28Z",
      "side": 1,
      "message": "Yep that SGTM. It is indeed more complicated than passing a TaskRunner to ServiceManagerContext, but for reasons stated above I just don\u0027t think the latter is tenable. Thanks!",
      "parentUuid": "363c3a64_43371043",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09763b44_ba984ce7",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-17T18:52:45Z",
      "side": 1,
      "message": "Actually, before I attempt an implementation of this approach in EmbeddedInstanceManager, could you take a look and share your thoughts about https://chromium-review.googlesource.com/c/chromium/src/+/817646? I am not sure that my interpretation of the intended behavior of EmbeddedInstanceManager is correct and want to make sure it is before another attempt at modifying it. If https://chromium-review.googlesource.com/c/chromium/src/+/817646 seems like an improvement to you, I would like to base the changes on that instead of on the current state.",
      "parentUuid": "06040357_d6b8f19b",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02c50c83_1f9392fd",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2018-01-17T23:55:17Z",
      "side": 1,
      "message": "Hmm. I started reviewing it, but it seems to drastically increase rather than decrease the complexity of EmbeddedInstanceManager. I\u0027m happy to take another look at EmbeddedInstanceManager myself if you like - I think it might be overdue for a complete rewrite at this point.",
      "parentUuid": "09763b44_ba984ce7",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21ab0fe9_dcbed8e7",
        "filename": "content/browser/service_manager/service_manager_context.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2018-01-18T00:39:15Z",
      "side": 1,
      "message": "The reason why it appears to be more complex after my proposed change is that it includes two functional changes:\n1. It fixes a race condition that I believe to be present in the current state\n2. It changes the behavior from blocking on Shutdown() to non-blocking.\n\nThe current state of the code (before my proposed change) looks like there is less going on, but it took me a long time to figure out all the concurrency cases that can happen (and write the tests for them, which were missing). With that I am not convinced that it was really much simpler before.",
      "parentUuid": "02c50c83_1f9392fd",
      "revId": "ac974285fce3d70a3ad90ca4624cfb42bcc6442f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}