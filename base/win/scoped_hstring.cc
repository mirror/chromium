// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/win/scoped_hstring.h"

#include <delayimp.h>
#include <winstring.h>

#include "base/strings/string_piece.h"
#include "base/strings/utf_string_conversions.h"
#include "base/threading/thread_restrictions.h"

namespace {

// A frame-based exception handler filter function for a handler for exceptions
// generated by the Visual C++ delay loader helper function.
int FilterVisualCPPExceptions(DWORD exception_code) {
  return HRESULT_FACILITY(exception_code) == FACILITY_VISUALCPP
             ? EXCEPTION_EXECUTE_HANDLER
             : EXCEPTION_CONTINUE_SEARCH;
}

}  // namespace

namespace base {
namespace win {

// static
bool ScopedHString::load_succeeded = false;

// static
void ScopedHStringTraits::Free(HSTRING hstr) {
  WindowsDeleteString(hstr);
}

// static
ScopedHString ScopedHString::Create(StringPiece16 str) {
  DCHECK(load_succeeded);
  HSTRING hstr;
  HRESULT hr = WindowsCreateString(str.data(), str.length(), &hstr);
  if (SUCCEEDED(hr))
    return ScopedHString(hstr);
  DLOG(ERROR) << "Failed to create HSTRING" << std::hex << hr;
  return ScopedHString(nullptr);
}

ScopedHString ScopedHString::Create(StringPiece str) {
  return Create(UTF8ToWide(str));
}

ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {
  DCHECK(load_succeeded);
}

// static
bool ScopedHString::ResolveCoreWinRTStringDelayload() {
  ThreadRestrictions::AssertIOAllowed();

  static const bool load_succeeded = []() {
    HRESULT hr = E_FAIL;
    __try {
      hr = __HrLoadAllImportsForDll("api-ms-win-core-winrt-string-l1-1-0.dll");
    } __except (FilterVisualCPPExceptions(::GetExceptionCode())) {
      hr = E_FAIL;
    }
    ScopedHString::load_succeeded = SUCCEEDED(hr);
    return SUCCEEDED(hr);
  }();
  return load_succeeded;
}

std::string ScopedHString::GetAsUTF8() const {
  std::string result;
  const StringPiece16 wide_string = Get();
  WideToUTF8(wide_string.data(), wide_string.length(), &result);
  return result;
}

const StringPiece16 ScopedHString::Get() const {
  UINT32 length = 0;
  const wchar_t* buffer = ::WindowsGetStringRawBuffer(get(), &length);
  return StringPiece16(buffer, length);
}

}  // namespace win
}  // namespace base
