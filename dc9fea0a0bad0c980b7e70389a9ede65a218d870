{
  "comments": [
    {
      "key": {
        "uuid": "f49f095c_0579276f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-08-27T04:25:03Z",
      "side": 1,
      "message": "How does this approximate it better? We\u0027re now rounding to ints when we were using the subpixel positions before.\nI\u0027d say rounding subpixel positions to ints will result in visible differences between compositing and HW overlays.\nBefore this patch we\u0027d just use GL compositing to avoid those differences.\nAre we sure we want that?",
      "revId": "dc9fea0a0bad0c980b7e70389a9ede65a218d870",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "836cd156_291dc9b5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-27T14:33:48Z",
      "side": 1,
      "message": "What do you mean by subpixel positions before? Afaict, we used MathUtil::MapEnclosingClippedRect before, which rounds to the enclosing rect. That\u0027s a pretty poor approximation of GPU rasterization. Rounding to closest rect should be better but it\u0027s not perfect unless we also adjust source crop rect. I thought we could do that as a follow up. This patch should at least not be worse than before and it solves a critical issue for fast-ink in 61 (rounding errors when screen is scaled and rotated). We could also limit HW overlays to rounding errors for now as that would still solve this critical issue in 61 but I\u0027m worried that would regress some low-latency rendering cases where it\u0027s currently better to not have an ideal match between composited output and HW overlays.\n\nShort term we need to solve the rounding error. Long term we should also make scaled HW overlays work in a way that matches GPU rasterization. This patch focuses on solving the short term problem without making the latter worse.",
      "parentUuid": "f49f095c_0579276f",
      "revId": "dc9fea0a0bad0c980b7e70389a9ede65a218d870",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48852412_43faf513",
        "filename": "cc/output/overlay_candidate.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-08-27T04:25:03Z",
      "side": 1,
      "message": "Wouldn\u0027t it be more accurate to round the width, and then recompute the position?\nIf you have mapper_rect.x and mapped_rect.right respectively 0.4 and 100.6, you\u0027d end up using an hw overlay of 101 in width. With the other approach the width would be 100 and the HW overlays would be less stretched horizontally.",
      "revId": "dc9fea0a0bad0c980b7e70389a9ede65a218d870",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a22dc3d_43626b66",
        "filename": "cc/output/overlay_candidate.cc",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-08-27T14:33:48Z",
      "side": 1,
      "message": "To approximate GPU rasterization shouldn\u0027t we map the above to 0 and 101 with source sub-pixel coords adjusted so 0.4 maps to normalized buffer coordinate 0.0 and 100.6 maps to 1.0? Otherwise what if we had a quad with a shared edge (e.g. 100.6 to 150)? \n\nLike I said in the other comment. I\u0027m happy to limit this to rounding errors for now and just reject candidates that can\u0027t be rounded safely.",
      "parentUuid": "48852412_43faf513",
      "revId": "dc9fea0a0bad0c980b7e70389a9ede65a218d870",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}