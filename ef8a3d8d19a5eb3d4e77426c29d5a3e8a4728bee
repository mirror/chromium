{
  "comments": [
    {
      "key": {
        "uuid": "0e4e37c9_a1a219d4",
        "filename": "base/optional.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-17T17:37:12Z",
      "side": 1,
      "message": "I\u0027d like to understand why this isn\u0027t const more. 8.4.2.1 says:\n\n\"A function that is explicitly defaulted shall ... have the same declared function type (except for possibly differing ref-qualifiers and except that in the case of a copy constructor or copy assignment operator, the parameter type may be “reference to non-const T”, where T is the name of the member function’s class) as if it had been implicitly declared\"\n\nWhen I read that I think it says that you /may/ drop the const in a copy constructor. But in that case a const ref would not bind to it (nor to the rvalue reference). So this would exclude copying from a const Optional lvalue with this method.\n\nIs that the intent? Or am I understanding this wrong?",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "378c0ed8_c279245a",
        "filename": "base/optional.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2018-01-17T18:49:10Z",
      "side": 1,
      "message": "My understanding is...;\n\ncf) copy constructor: http://en.cppreference.com/w/cpp/language/copy_constructor\n\nWhat we want to do here is just mimic of the implicitly declared copy/move constructors.\n\nIn our regular case, we expect T\u0027s copy ctor has the signature T(const T\u0026) in chromium, then because both\n\n- each direct and virtual base B of T has a copy constructor whose parameters are const B\u0026 or const volatile B\u0026;\n- each non-static data member M of T of class type or array of class type has a copy constructor whose parameters are const M\u0026 or const volatile M\u0026.\n\nare satisfied, the signature of the implicitly declared copy constructor of OptionalStorageBase is OptionalStorageBase(const OptionalStorageBase\u0026).\n\nHowever, if T has the copy constructor with the signature T(T\u0026) (non-const), because the second condition is not satisfied, the copy constructor is OptionalStorageBase(OptionalStorageBase\u0026).\n\n8.4.2.1 says,\n\n\"A function that is explicitly defaulted shall ... have the same declared function type (... except that in the case of copy constructor ..., the parameter type may be \"reference to non-const T\", ...)\"\n\nwhich means \"OptionalStorageBase(OptionalStorageBase\u0026) \u003d default;\" defines explicitly-defined copy constructor that is OptionalStorageBase(const OptionalStorageBase\u0026) or OptionalStorageBase(OptionalStorageBase\u0026) depending on T\u0027s copy constructor signature in this case.\n\nIf we declare as \"OptionalStorageBase(const OptionalStorageBase\u0026 other) \u003d default;\",\nnon-const case cannot be defaulted (i.e. it causes compile error) as;\n\n\"error: the parameter for this experror: the parameter for this explicitly-defaulted copy constructor is const, but a member or base requires it to be non-constlicitly-defaulted copy constructor is const, but a member or base requires it to be non-const\"\n\nbecause of signature mismatch.\ncf) https://stackoverflow.com/questions/10370713/when-are-special-member-functions-of-a-template-class-instantiated\n\n\nActually we have an example.\nhttps://cs.chromium.org/chromium/src/third_party/WebKit/Source/platform/bindings/DOMDataStore.h?q\u003dWTF::Optional%3CDOMWrapperMap%3CScriptWrappable%3E%3E\u0026sq\u003dpackage:chromium\u0026l\u003d183\n\nDOMWrapperMap has the member |map_|, which is of type PersistentValueMapTraits::MapType \u003d v8::GlobalValueMap\u003cKeyType*, v8::Object, PersistentValueMapTraits\u003e. The parent type of GlobalValueMap is PersistentValueMapBase, which declares \n\nhttps://cs.chromium.org/chromium/src/v8/include/v8-util.h?sq\u003dpackage:chromium\u0026l\u003d345\n  PersistentValueMapBase(PersistentValueMapBase\u0026);\n  void operator\u003d(PersistentValueMapBase\u0026);\n\nin private, without definition (older style to prohibit copy).\nSpecifically, this copy ctor does not have \"const\", so DOMWrapperMap also declares non-const copy ctor.\n\nIndeed we could fix v8, but we also use third_party libs, and there is no guarantee about copy ctor signatures. Thus, as we could support that edge cases with small change (just dropping const from copy ctor signature), I prefer supporting it. WDYT?",
      "parentUuid": "0e4e37c9_a1a219d4",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "722c8cb4_799733e9",
        "filename": "base/optional.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-17T19:28:51Z",
      "side": 1,
      "message": "Oh wow amazing. Thanks! Can you write this out some more in the comment to explain? This is really awesome explanation for me and I learnt a lot here. Don\u0027t worry about the comment being too large, this is a really obscure thing and we should document it as much as needed.",
      "parentUuid": "378c0ed8_c279245a",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9fdc94e_1ce75489",
        "filename": "base/optional.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-17T19:51:36Z",
      "side": 1,
      "message": "\u003e which means \"OptionalStorageBase(OptionalStorageBase\u0026) \u003d default;\" defines explicitly-defined\n\u003e copy constructor that is OptionalStorageBase(const OptionalStorageBase\u0026) or\n\u003e OptionalStorageBase(OptionalStorageBase\u0026) depending on T\u0027s copy constructor signature in this\n\u003e case.\n\nI showed this to jbroman who tried this out in a more reduced case and it didn\u0027t compile. Can you help me understand why it works in the Optional case?\n\nhttps://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:c%2B%2B,source:\u0027struct+S+%7B%0A++++S(S%26)+%3D+default%3B%0A%7D%3B%0A%0Avoid+Foo(const+S%26+s)+%7B%0A++++S+s2(s)%3B%0A%7D\u0027),l:\u00275\u0027,n:\u00270\u0027,o:\u0027C%2B%2B+source+%231\u0027,t:\u00270\u0027)),k:33.333333333333336,l:\u00274\u0027,n:\u00270\u0027,o:\u0027\u0027,s:0,t:\u00270\u0027),(g:!((h:compiler,i:(compiler:clang_trunk,filters:(b:\u00270\u0027,binary:\u00271\u0027,commentOnly:\u00270\u0027,demangle:\u00270\u0027,directives:\u00270\u0027,execute:\u00271\u0027,intel:\u00270\u0027,trim:\u00270\u0027),lang:c%2B%2B,libs:!(),options:\u0027\u0027,source:1),l:\u00275\u0027,n:\u00270\u0027,o:\u0027x86-64+clang+(trunk)+(Editor+%231,+Compiler+%231)+C%2B%2B\u0027,t:\u00270\u0027)),k:33.333333333333336,l:\u00274\u0027,n:\u00270\u0027,o:\u0027\u0027,s:0,t:\u00270\u0027),(g:!((h:output,i:(compiler:1,editor:1),l:\u00275\u0027,n:\u00270\u0027,o:\u0027%231+with+x86-64+clang+(trunk)\u0027,t:\u00270\u0027)),k:33.33333333333333,l:\u00274\u0027,n:\u00270\u0027,o:\u0027\u0027,s:0,t:\u00270\u0027)),l:\u00272\u0027,n:\u00270\u0027,o:\u0027\u0027,t:\u00270\u0027)),version:4\n\nBTW this is section 11.4.2 in the newer n4687 spec.",
      "parentUuid": "722c8cb4_799733e9",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed5091fb_92918f5b",
        "filename": "base/optional.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1195064
      },
      "writtenOn": "2018-01-17T20:46:56Z",
      "side": 1,
      "message": "My reading of 8.4.2.1 comes back to that it allows you to write a copy constructor \u003ddefault without const, if you should choose to do, even tho the compiler would not have done so. But once you do, it will take that form, not revert to what the compiler would have done implicitly.\n\nIf you change the \u003ddefault to \u003ddelete, it seems that the unit test added does not fail to compile, so it is not actually using this constructor here.\n\nvmpstr@ pointed out that these constructors are only inherited if trivially-copy-and-move-constructible. But that this specialization is only used when not-trivially-destructible. So these constructors written here are only used if trivially-copy-and-move-constructible-and-not-destructible. However such a type is not possible to create at this time, because of bugs in compiler libraries where is_trivially_copy_constructible ALSO checks trivial destructor, so this case is not possible atm. See the notes in http://en.cppreference.com/w/cpp/types/is_copy_constructible",
      "parentUuid": "c9fdc94e_1ce75489",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1033c9a_14a62aab",
        "filename": "base/optional.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2018-01-18T06:39:36Z",
      "side": 1,
      "message": "Ugrrr. Thank you very much for the info, testing and comments! I have totally misread.\n\nSo, stepping back, what we\u0027d like to support is constexpr copy/move ctor, in Optional.\nConsidering;\n- Currently the toolchain/spec looks to have an issue between trivially {copy,move} constructible and trivially destructible.\n- Even if it is fixed in upstream, we need to roll it.\n- If it is rolled, then I think it will be almost time to switch to C++17/C++20.\n\nSo, I don\u0027t think we need to support \"trivially_destructible \u003d false\" +\"constexpr copy,move constructor\" under the current situation. So I just dropped it with comment.\n\nAs for \"trivially_destructible \u003d true\" + \"constexpr copy,move constructor\" still needs to be fixed. And this CL (conceptually just dropping \"~OptionalStorageBase() \u003d default;\") should fix it. Also I reworded the comment a bit more.\n\nWDYT?",
      "parentUuid": "ed5091fb_92918f5b",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ebc2f50b_802104ff",
        "filename": "base/optional_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 192,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-01-17T17:37:12Z",
      "side": 1,
      "message": "Does this still work if first is const?",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c2225dd_67f9ed2b",
        "filename": "base/optional_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 192,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2018-01-17T18:49:10Z",
      "side": 1,
      "message": "Yes, it does. Added the case.",
      "parentUuid": "ebc2f50b_802104ff",
      "revId": "ef8a3d8d19a5eb3d4e77426c29d5a3e8a4728bee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}