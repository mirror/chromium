{
  "comments": [
    {
      "key": {
        "uuid": "5ca8a911_5c7055fe",
        "filename": "media/capture/video/chromeos/local_gpu_memory_buffer_manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-08-16T22:35:51Z",
      "side": 1,
      "message": "Please avoid abbreviations. Does \"bo\" stand for byte_order?\n\nhttps://google.github.io/styleguide/cppguide.html#General_Naming_Rules",
      "revId": "f515ee8d6c6a7e33d37744cd4f533ec1ebb7b9ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c50c23f4_c6f7ccf1",
        "filename": "media/capture/video/chromeos/local_gpu_memory_buffer_manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-17T02:11:03Z",
      "side": 1,
      "message": "Ah, sorry about this. bo means buffer object. It\u0027s a common abbreviation in Linux graphics libraries, but I should use the full name here.",
      "parentUuid": "5ca8a911_5c7055fe",
      "revId": "f515ee8d6c6a7e33d37744cd4f533ec1ebb7b9ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "84cacbfa_d532b2f8",
        "filename": "media/capture/video/chromeos/stream_buffer_manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 487,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-08-16T22:35:51Z",
      "side": 1,
      "message": "typo: relying",
      "revId": "f515ee8d6c6a7e33d37744cd4f533ec1ebb7b9ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08ffdad0_d2627f39",
        "filename": "media/capture/video/chromeos/stream_buffer_manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 487,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-17T02:11:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "84cacbfa_d532b2f8",
      "revId": "f515ee8d6c6a7e33d37744cd4f533ec1ebb7b9ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd5babc0_b4c8a22c",
        "filename": "media/capture/video/chromeos/video_capture_device_factory_chromeos.h",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-08-16T22:35:51Z",
      "side": 1,
      "message": "Why not inject a gpu::GpuMemoryBufferManager* into the constructor of each class that depends on it instead of making every such class take a dependency on the global state exposed via this static method?",
      "revId": "f515ee8d6c6a7e33d37744cd4f533ec1ebb7b9ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9f950c5_b0fc62e9",
        "filename": "media/capture/video/chromeos/video_capture_device_factory_chromeos.h",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 1001646
      },
      "writtenOn": "2017-08-17T02:11:03Z",
      "side": 1,
      "message": "In the video-capture-in-browser-process mode, the buffer manager is actually provided by\n\nhttps://cs.chromium.org/chromium/src/content/browser/gpu/browser_gpu_memory_buffer_manager.h\n\nand we can actually directly access the singleton instance through the BrowserGpuMemoryBufferManager::current() static method. However, if we want to use BrowserGpuMemoryBufferManager here we\u0027d need to have the capture_lib depend on content_browser, which would create a circular dependency and does not build in component build. Hence in this CL I have to pass down the pointer from BrowserGpuMemoryBufferManager::current() when we create the VCD factory.\n\nThe |buffer_manager| is used by the CameraBufferFactory I added in this CL, and we have two different classes that needs to instantiate a CameraBufferFacotry instance (CameraHalDelegate and StreamBufferManager). We can create a CameraBufferFactory here and pass it all the way down to StreamBufferManager, but using static function here seems simpler to me and is similar to what we would do if we can access the BrowserGpuMemoryBufferManager here directly.",
      "parentUuid": "cd5babc0_b4c8a22c",
      "revId": "f515ee8d6c6a7e33d37744cd4f533ec1ebb7b9ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3dc5da47_f8fe18fe",
        "filename": "media/capture/video/chromeos/video_capture_device_factory_chromeos.h",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-08-17T17:58:55Z",
      "side": 1,
      "message": "That is probably in line with what is (in my opinion dangerous) common practice, so I am okay if you keep it like this. \n\nJust to voice my concern, IMO, this is one of the situations where less code !\u003d simpler. Yes, we save code by not having to pass down dependencies. But we pay for it with two things:\n1. The consumers calling the static method take an unnecessary dependency on the whole VideoCaptureDeviceFactoryChromeOS. This means they can no longer be tested or reused in isolation (or testing setup requires setting global state, and possible cleaning it up afterwards).\n2. That dependency is \"hidden\", i.e. it is only visible from the implementation details. This makes it harder for readers to see and understand the design and leads to non-obvious issues exactly like what you described with the use of BrowserGpuMemoryBufferManager::current(), which  works form one context but not from another.",
      "parentUuid": "c9f950c5_b0fc62e9",
      "revId": "f515ee8d6c6a7e33d37744cd4f533ec1ebb7b9ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}