{
  "comments": [
    {
      "key": {
        "uuid": "9640bb33_3b5fbe31",
        "filename": "net/proxy_resolution/dhcp_pac_file_fetcher_win.cc",
        "patchSetId": 14
      },
      "lineNbr": 21,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-24T19:43:41Z",
      "side": 1,
      "message": "The ScopedBlockingCall in DhcpProxyScriptAdapterFetcher::GetPacURLFromDhcp will allow the TaskScheduler thread pool to grow when a :DhcpRequestParams() call blocks. https://chromium-review.googlesource.com/c/chromium/src/+/881273/14/net/proxy_resolution/dhcp_pac_file_adapter_fetcher_win.cc#249\n\nThe TaskScheduler is responsible for making sure that it doesn\u0027t create more threads than what\u0027s reasonable. We don\u0027t want every component in Chrome to try to outsmart TaskScheduler.",
      "revId": "c9c812f9af1d798c9532dbb747ce64aace141a8b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34690019_e68c4102",
        "filename": "net/proxy_resolution/dhcp_pac_file_fetcher_win.cc",
        "patchSetId": 14
      },
      "lineNbr": 288,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2018-01-26T17:15:01Z",
      "side": 1,
      "message": "This is also potentially extremely slow, and presumably needs ScopedBlockingCall.\n\nWhat is the consequence of *not* marking blocking code with that?\nPretty much any windows library call network code does on other threads may block.\nAnd it is a safe bet that other code may be slow as well.\n\nI would expect that any task posted to a MayBlock() task runner is understood to be potentially very slow without the need to explicitly annotate the parts of it that are thought to be slow.\n\nThanks",
      "revId": "c9c812f9af1d798c9532dbb747ce64aace141a8b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "161f1394_192f3593",
        "filename": "net/proxy_resolution/dhcp_pac_file_fetcher_win.cc",
        "patchSetId": 14
      },
      "lineNbr": 288,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2018-01-26T20:51:37Z",
      "side": 1,
      "message": "Added ScopedBlockingCall around this call.\n\nTaskScheduler is initialized with a maximum number of threads derived from the number of cores. When a MAY_BLOCK ScopedBlockingCall has been on the stack for some time, the maximum number of threads is incremented. The consequence of not using ScopedBlockingCall is that the maximum number of threads stays constant and Chrome may not use all available resources to process tasks.\n\nMayBlock() is used for 2 purposes:\n- Enforce that blocking calls are made only in contexts where they are expected.\n- TaskScheduler allows more MayBlock() tasks to run concurrently than non-MayBlock() tasks. Now that we have ScopedBlockingCall and that we know that MayBlock() tasks don\u0027t block as much as we expected :|, we may revisit this decision.\n\n\"Pretty much any windows library call network code does on other threads may block\" These calls should be made in the scope of a ScopedBlockingCall if we don\u0027t expect them to use too much CPU and we want to let other tasks use the CPU while they are running.",
      "parentUuid": "34690019_e68c4102",
      "revId": "c9c812f9af1d798c9532dbb747ce64aace141a8b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a456e3c_e0d28e6b",
        "filename": "net/proxy_resolution/dhcp_pac_file_fetcher_win.cc",
        "patchSetId": 14
      },
      "lineNbr": 288,
      "author": {
        "id": 1001766
      },
      "writtenOn": "2018-01-26T22:28:49Z",
      "side": 1,
      "message": "How are I/O vs CPU bound tasks supposed to be submitted to the task scheduler? It seems we lose that intent in this translation.\n\nA general idiom for networking code\u0027s use of worker pools is to start operations that (might) do synchronous I/O. Such as the two places identified in this CL.\n\nI am surprised to see the ScopedBlockingCall() appearing within the executed task\u0027s code (rather than just being a property of the task itself). Does that imply that these I/O bound tasks may have to wait behind CPU hogs simply to get started with their I/O request?\n\nSomething else lost with in this translation is there is no longer a component-defined throttle for these tasks. Unfortunately the comment at the top of the file describes edge cases where there may be O(100) network adapters -- this in turn would result in posting hundreds of tasks for checking DHCP. In the old model, only 12 of these would at most run in parallel. Whereas now they are all dumped to the global scheduler and could overwhelm the scheduling of other tasks.\n\nDo we need to add our own form of throttling/queuing before submitting to the tasks scheduler in order to be better citizens? (And conversely, I wouldn\u0027t want these tasks to be stuck waiting for some other misbehaving component, since that can block our ability to load URLs).\n\nThanks",
      "parentUuid": "161f1394_192f3593",
      "revId": "c9c812f9af1d798c9532dbb747ce64aace141a8b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}