{
  "comments": [
    {
      "key": {
        "uuid": "b58a2360_0f03bfb6",
        "filename": "content/browser/service_worker/service_worker_context_wrapper.cc",
        "patchSetId": 13
      },
      "lineNbr": 56,
      "author": {
        "id": 1125915
      },
      "writtenOn": "2017-09-08T02:09:20Z",
      "side": 1,
      "message": "You can use CHECK_LT(counter_, ...);",
      "range": {
        "startLine": 56,
        "startChar": 3,
        "endLine": 56,
        "endChar": 9
      },
      "revId": "dc92b12c5b5a3425be332894ab0881c995432949",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14bd48d4_023acb9f",
        "filename": "content/browser/service_worker/service_worker_context_wrapper.cc",
        "patchSetId": 13
      },
      "lineNbr": 68,
      "author": {
        "id": 1001727
      },
      "writtenOn": "2017-09-06T17:13:18Z",
      "side": 1,
      "message": "Drive-by:\nSince we only care whether or not all results were SERVICE_WORKER_OK, can we can avoid using this vector and use an int (to count how many failed) or bool (to indicate whether any failed)?\nI was thinking sth like:\n\na)\nnum_worker_stop_errors_ +\u003d (status !\u003d SERVICE_WORKER_OK);\nand in the end\nresult \u003d num_worker_errors_ \u003d\u003d 0;\n\nor\nb)\nbool any_worker_failed_ \u003d false;\nany_worker_failed_ |\u003d (status !\u003d SERVICE_WORKER_OK);\nand in the end\nresult \u003d !any_worker_failed_;",
      "range": {
        "startLine": 68,
        "startChar": 4,
        "endLine": 68,
        "endChar": 22
      },
      "revId": "dc92b12c5b5a3425be332894ab0881c995432949",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99fb3721_2ea68074",
        "filename": "content/browser/service_worker/service_worker_context_wrapper.cc",
        "patchSetId": 13
      },
      "lineNbr": 68,
      "author": {
        "id": 1227909
      },
      "writtenOn": "2017-09-07T02:09:48Z",
      "side": 1,
      "message": "Made it use a).",
      "parentUuid": "14bd48d4_023acb9f",
      "range": {
        "startLine": 68,
        "startChar": 4,
        "endLine": 68,
        "endChar": 22
      },
      "revId": "dc92b12c5b5a3425be332894ab0881c995432949",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba16a9b6_27d61413",
        "filename": "content/browser/service_worker/service_worker_context_wrapper.cc",
        "patchSetId": 13
      },
      "lineNbr": 500,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-09-06T19:14:03Z",
      "side": 1,
      "message": "What if the vector is empty, how does the ResultOnceCallback get called in that case?",
      "revId": "dc92b12c5b5a3425be332894ab0881c995432949",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d125ea5f_96730e5c",
        "filename": "content/browser/service_worker/service_worker_context_wrapper.cc",
        "patchSetId": 13
      },
      "lineNbr": 500,
      "author": {
        "id": 1227909
      },
      "writtenOn": "2017-09-07T02:09:48Z",
      "side": 1,
      "message": "Thanks, I modified this! If the vector is empty, it use early return. Is this ok?",
      "parentUuid": "ba16a9b6_27d61413",
      "revId": "dc92b12c5b5a3425be332894ab0881c995432949",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7035cd99_5907c861",
        "filename": "content/browser/service_worker/service_worker_context_wrapper.cc",
        "patchSetId": 13
      },
      "lineNbr": 507,
      "author": {
        "id": 1115965
      },
      "writtenOn": "2017-09-06T19:14:03Z",
      "side": 1,
      "message": "Is StopWorker guaranteed to complete asyncly? If the method can invoke the callback prior to return, I think the \u0027fence\u0027 could attempt to invoke its ResultOnceCallback multiple times.\n\nedit: Ah, ok, looks like it does always complete asyncly, internally it\u0027s using RunSoon(base::BindOnce(callback, SERVICE_WORKER_OK)).",
      "revId": "dc92b12c5b5a3425be332894ab0881c995432949",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "005a8926_eb6d7279",
        "filename": "content/browser/service_worker/service_worker_context_wrapper.cc",
        "patchSetId": 13
      },
      "lineNbr": 507,
      "author": {
        "id": 1227909
      },
      "writtenOn": "2017-09-07T02:09:48Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7035cd99_5907c861",
      "revId": "dc92b12c5b5a3425be332894ab0881c995432949",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}