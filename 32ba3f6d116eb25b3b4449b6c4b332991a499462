{
  "comments": [
    {
      "key": {
        "uuid": "eb255e2b_f167fe6c",
        "filename": "ios/chrome/browser/ui/fullscreen/chrome_coordinator+fullscreen_disabling.h",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1115958
      },
      "writtenOn": "2017-12-18T18:04:53Z",
      "side": 1,
      "message": "Nit: the \"didFoo\" naming scheme is usually used in delegates, where the method call reads like \"hey delegate, your delegator did Foo\". But this is just a regular method on the coordinator, so it should just be something like -disableFullscreen/-enableFullscreen.",
      "range": {
        "startLine": 16,
        "startChar": 8,
        "endLine": 16,
        "endChar": 37
      },
      "revId": "32ba3f6d116eb25b3b4449b6c4b332991a499462",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef464ab0_ecdb8b8f",
        "filename": "ios/chrome/browser/ui/fullscreen/chrome_coordinator+fullscreen_disabling.h",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1133065
      },
      "writtenOn": "2017-12-18T18:25:19Z",
      "side": 1,
      "message": "I had named it this way to kinda match the activation state stuff in BrowserCoordinator+Internal (e.g. |-viewControllerWasActivated|).  It seemed a better naming convention than explicit enable/disable calls because these are idempotent.  Calling |-disableFullscreen| twice would just replace the existing ScopedFullscreenDisabler, resulting in the same disabled count in the FullscreenModel.",
      "parentUuid": "eb255e2b_f167fe6c",
      "range": {
        "startLine": 16,
        "startChar": 8,
        "endLine": 16,
        "endChar": 37
      },
      "revId": "32ba3f6d116eb25b3b4449b6c4b332991a499462",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3e037cb_011a9c68",
        "filename": "ios/chrome/browser/ui/fullscreen/chrome_coordinator+fullscreen_disabling.mm",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1115958
      },
      "writtenOn": "2017-12-18T18:04:53Z",
      "side": 1,
      "message": "Please just subclass ChromeCoordinator rather than using the runtime to build a mixin, which is what this feels like.",
      "range": {
        "startLine": 69,
        "startChar": 4,
        "endLine": 69,
        "endChar": 28
      },
      "revId": "32ba3f6d116eb25b3b4449b6c4b332991a499462",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "156b3c8f_ca4af59b",
        "filename": "ios/chrome/browser/ui/fullscreen/chrome_coordinator+fullscreen_disabling.mm",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1133065
      },
      "writtenOn": "2017-12-18T18:25:19Z",
      "side": 1,
      "message": "Subclassing ChromeCoordinator will work here, but will not work as well once we move to BrowserCoordinator.  For example, we already use subclassing in OverlayCoordinator to get hooks into coordinator lifecycle events that affect the overlay scheduler.  Since multiple inheritance doesn\u0027t work in ObjC, how do you think we should solve situations like this in the future?  I could envision adding BrowserCoordinator+Internal helper methods to add arbitrary didStart/wasActivated/didStop/wasDeactivated actions, which could be used for both overlay scheduling + fullscreen disabling/enabling.  However, this potentially can add a lot of complexity to the coordinator layer, as we\u0027d be passing around blocks and allowing for arbitrary (and very flexible) manipulation of the base class.",
      "parentUuid": "b3e037cb_011a9c68",
      "range": {
        "startLine": 69,
        "startChar": 4,
        "endLine": 69,
        "endChar": 28
      },
      "revId": "32ba3f6d116eb25b3b4449b6c4b332991a499462",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63f13ca1_10b72340",
        "filename": "ios/chrome/browser/ui/fullscreen/chrome_coordinator+fullscreen_disabling.mm",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1115958
      },
      "writtenOn": "2017-12-19T18:04:22Z",
      "side": 1,
      "message": "No block passing!\n\nLet\u0027s use this now but keep thinking about ways to factor common code. For example, it doesn\u0027t seem right to subclass for one case (overlays) but not another. The best idea I have right now is for a coordinator helper pattern, which might involve implicit observation of the coordinator.",
      "parentUuid": "156b3c8f_ca4af59b",
      "range": {
        "startLine": 69,
        "startChar": 4,
        "endLine": 69,
        "endChar": 28
      },
      "revId": "32ba3f6d116eb25b3b4449b6c4b332991a499462",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd1fa638_d707a304",
        "filename": "ios/chrome/browser/ui/fullscreen/chrome_coordinator+fullscreen_disabling.mm",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 1133065
      },
      "writtenOn": "2017-12-20T23:12:22Z",
      "side": 1,
      "message": "Okay, I\u0027ll land as-is for now.  I had originally created BrowserCoordinatorObserver that exposed the start/activated/stop/deactivated signals to arbitrary observer objects.  Maybe we can have a CoordinatorHelper type class that could be a combination of a BrowserCoordinatorObserver and BrowserCoordinatorUserData (or an ObjC equivalent, I suppose).  Then we could keep the observer/user data APIs in the private target for the coordinator directory.  That way we could expose this functionality and at least have some control over how it gets used.",
      "parentUuid": "63f13ca1_10b72340",
      "range": {
        "startLine": 69,
        "startChar": 4,
        "endLine": 69,
        "endChar": 28
      },
      "revId": "32ba3f6d116eb25b3b4449b6c4b332991a499462",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}