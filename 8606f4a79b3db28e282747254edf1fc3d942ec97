{
  "comments": [
    {
      "key": {
        "uuid": "a757dbda_30795bfb",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1813,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2018-01-11T22:21:49Z",
      "side": 1,
      "message": "Do you need the while() loop? Does whether we have a pending wheel-end event depend on other threads, or only on the timer firing on this thread? If the latter then can you just Sleep(100ms) and then RunUntilIdle, since at that point you are guaranteed that _at least_ 100ms have elapsed, so the timer will definitely be due?",
      "range": {
        "startLine": 1811,
        "startChar": 0,
        "endLine": 1813,
        "endChar": 42
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6a09b53_ab00ef64",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1813,
      "author": {
        "id": 1213209
      },
      "writtenOn": "2018-01-12T18:24:41Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a757dbda_30795bfb",
      "range": {
        "startLine": 1811,
        "startChar": 0,
        "endLine": 1813,
        "endChar": 42
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d82525db_4b5ffea5",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1813,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2018-01-13T01:03:18Z",
      "side": 1,
      "message": "The ideal way to do this would be to switch to a mock TickClock, so that we can instantaneously fast-forward time, and then RunUntilIdle() here - that is easy if the test is single-threaded or relies on TaskScheduler (there is a MOCK_TIME mode for ScopedTaskEnvironment) but hard for multi-process tests.\n\nSo, is it feasible to use mock-time for these tests?  If so then let\u0027s file a bug for that follow-up work, which will make the test faster and possibly simpler, too. :)",
      "parentUuid": "b6a09b53_ab00ef64",
      "range": {
        "startLine": 1811,
        "startChar": 0,
        "endLine": 1813,
        "endChar": 42
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d52cba68_d8cc2ac2",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1859,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2018-01-11T22:21:49Z",
      "side": 1,
      "message": "Is the intention that this value be something that is effectively \"infinite\", from the test\u0027s point of view? If so then I\u0027d suggest picking a more obviously practically-infinite value, or perhaps using one of the action_timeout() values?",
      "range": {
        "startLine": 1859,
        "startChar": 40,
        "endLine": 1859,
        "endChar": 45
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "090eca38_b0c778ed",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1859,
      "author": {
        "id": 1213209
      },
      "writtenOn": "2018-01-12T18:24:41Z",
      "side": 1,
      "message": "Didn\u0027t know about testTimeouts, thanks",
      "parentUuid": "d52cba68_d8cc2ac2",
      "range": {
        "startLine": 1859,
        "startChar": 40,
        "endLine": 1859,
        "endChar": 45
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "778ed443_a95b5576",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 4981,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2018-01-11T22:21:49Z",
      "side": 1,
      "message": "nit: while(events.empty())",
      "range": {
        "startLine": 4981,
        "startChar": 9,
        "endLine": 4981,
        "endChar": 23
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e304deb_f3618959",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 4981,
      "author": {
        "id": 1213209
      },
      "writtenOn": "2018-01-12T18:24:41Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "778ed443_a95b5576",
      "range": {
        "startLine": 4981,
        "startChar": 9,
        "endLine": 4981,
        "endChar": 23
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6bba726d_498b86ef",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 4986,
      "author": {
        "id": 1001385
      },
      "writtenOn": "2018-01-11T22:21:49Z",
      "side": 1,
      "message": "As noted above, if the code is single-threaded, and you know that it is setting e.g. a 10ms timer, then you can base::PlatformThread::Sleep(TimeDelta::FromMilliseconds(10)) and then RunUntilIdle(), and be confident that the timer is now due, and will fire before that returns.\n\nUsing Run+QuitClosure can be value if you want to run *and* process events for a particular length of time, but more so if you can actually fire QuitClosure() when the event you are expect actually occurs, e.g. could you add a set_dispatched_messages_available_callback_for_test() helper on input_handler(), that you could pass the QuitClosure() to so that and then Run(), until it is executed.",
      "range": {
        "startLine": 4983,
        "startChar": 0,
        "endLine": 4986,
        "endChar": 19
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "efce2aa8_368f960f",
        "filename": "content/browser/renderer_host/render_widget_host_view_aura_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 4986,
      "author": {
        "id": 1213209
      },
      "writtenOn": "2018-01-12T18:24:41Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6bba726d_498b86ef",
      "range": {
        "startLine": 4983,
        "startChar": 0,
        "endLine": 4986,
        "endChar": 19
      },
      "revId": "8606f4a79b3db28e282747254edf1fc3d942ec97",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}