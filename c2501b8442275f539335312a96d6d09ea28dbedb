{
  "comments": [
    {
      "key": {
        "uuid": "cf1e0569_6d940a4c",
        "filename": "content/network/url_loader_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 327,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-09-22T23:13:11Z",
      "side": 1,
      "message": "Randy: is this correct / sufficient?\n\nBesides, if there is an ongoing asynchronous URLRequest::Read() when PauseCachingResponseBody() is called, I don\u0027t do anything to stop/cancel that read. I think it should be fine. WDYT?",
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "188df6fa_6f8479e5",
        "filename": "content/network/url_loader_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 476,
      "author": {
        "id": 1002532
      },
      "writtenOn": "2017-09-25T17:51:52Z",
      "side": 1,
      "message": "nit: received",
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c01f69d7_c35a058b",
        "filename": "content/network/url_loader_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 476,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-09-25T18:28:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "188df6fa_6f8479e5",
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a00a4e09_b5cea787",
        "filename": "content/network/url_loader_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 562,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-09-22T23:24:35Z",
      "side": 1,
      "message": "Out of curiosity: it took some effort to implement this class so that I can delay sending back the response contents to a certain point. Is there an easy way that is already available?",
      "range": {
        "startLine": 562,
        "startChar": 6,
        "endLine": 562,
        "endChar": 30
      },
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05eb83a7_ef51f71d",
        "filename": "content/network/url_loader_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 669,
      "author": {
        "id": 1002532
      },
      "writtenOn": "2017-09-25T17:51:52Z",
      "side": 1,
      "message": "can this be deterministic instead? i.e. posttasks to the current thread or flushing it? anything timing related like this would only flakily catch problems if they were introduced in the future.",
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa50fef3_ffe55698",
        "filename": "content/network/url_loader_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 669,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-09-25T18:28:11Z",
      "side": 1,
      "message": "I am happy to have more deterministic tests. But I am not sure how I can reliably flush:\nBetween the test server and the URL request is a socket connection. I imagine that it is possible that there is no pending tasks while the data is being transmitted by the socket connection (which should be regarded as test failure). Because the URL request side is woken up by socket readability, not pending tasks.\n\nPlease correct me if I am wrong. Thanks!",
      "parentUuid": "05eb83a7_ef51f71d",
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e79bd9bb_85407664",
        "filename": "content/network/url_loader_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 669,
      "author": {
        "id": 1002532
      },
      "writtenOn": "2017-09-27T01:41:41Z",
      "side": 1,
      "message": "good point. in that case, i\u0027d lean towards removing line 664-674 since a flaky check isn\u0027t worth it.",
      "parentUuid": "aa50fef3_ffe55698",
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e000bb66_a93963a5",
        "filename": "content/network/url_loader_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 669,
      "author": {
        "id": 1104639
      },
      "writtenOn": "2017-09-27T04:00:24Z",
      "side": 1,
      "message": "IMO this is not flaky check. Sorry if I wasn\u0027t clear in my previous comment. :)\n\nThe test passes deterministically. It doesn\u0027t matter how long we wait with the PostDelayedTask() on line 667, or doesn\u0027t have this PostDelayedTask() at all. The test should pass 100% of time.\n\nThe purpose of the PostDelayedTask(), is to widen the race window if the code has a bug and doesn\u0027t actually pause. Because it is a hypothetical failure scenario, we don\u0027t need to worry about whether that is flaky. -- \"The code has a bug\" is not well-undefined and can be of any reason, so it is not possible to guarantee that a test fails deterministically. For example, a simple test EXPECT_EQ(5, 2+3) could fail 50% of time if the adder hardware fails 50% of time.\n\nLine 672-673 ensures that with PauseCachingResponseBody we don\u0027t try to make any further read. So it is one of the two useful checks of this test (the other is line 678-679). I think it makes sense to keep them.\n\nWDYT? Thanks!",
      "parentUuid": "e79bd9bb_85407664",
      "revId": "c2501b8442275f539335312a96d6d09ea28dbedb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}