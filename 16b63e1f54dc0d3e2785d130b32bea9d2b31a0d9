{
  "comments": [
    {
      "key": {
        "uuid": "5e77eb07_78eec3c2",
        "filename": "chrome/browser/spellchecker/spellcheck_custom_dictionary.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1104796
      },
      "writtenOn": "2017-07-25T02:10:28Z",
      "side": 0,
      "message": "Is there any way we can actually ensure these things only get run with the proper priorities? The docs didn\u0027t seem to contain an obvious way to do that.",
      "range": {
        "startLine": 62,
        "startChar": 35,
        "endLine": 62,
        "endChar": 36
      },
      "revId": "16b63e1f54dc0d3e2785d130b32bea9d2b31a0d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a0e9e61_db84c100",
        "filename": "chrome/browser/spellchecker/spellcheck_custom_dictionary.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1001534
      },
      "writtenOn": "2017-07-25T14:15:36Z",
      "side": 0,
      "message": "There intentionally isn\u0027t a way to say \"is running in scheduler\" because eventually that would just be \"true\" everywhere. Instead we want to provide ability to check (and document through code) environment. As such base::ThreadRestrictions::AssertIOAllowed() is usually what DCHECK_CURRENTLY_ON(BrowserThread::FILE) is migrated to (or you can opt to rely on the base file APIs to do these checks for you when invoked but having every method in a class split across multiple runners begin with an assert of where it runs acts as nice documentation for the reader). As for the priority we decided to not add a priority assert because priority is much more a property of the caller than of the method itself so it doesn\u0027t make sense for a method to assert for itself that it runs at a given priority (in fact different callers could want the same method to run at different priorities).\n\nIf these were member methods than you could use a member background_task_runner_ to verify SequencedTaskRunner::RunsTasksInCurrentSequence(). But as they are standalone anonymous methods they really have no affinity and encoding one would be incorrect (well other than not accessing the same |file_path| in parallel, but the caller should make sure of that (by using a SequencedTaskRunner as you mentioned below).",
      "parentUuid": "5e77eb07_78eec3c2",
      "range": {
        "startLine": 62,
        "startChar": 35,
        "endLine": 62,
        "endChar": 36
      },
      "revId": "16b63e1f54dc0d3e2785d130b32bea9d2b31a0d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f34dab9_ecbeb93f",
        "filename": "chrome/browser/spellchecker/spellcheck_custom_dictionary.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1104796
      },
      "writtenOn": "2017-08-01T23:22:54Z",
      "side": 0,
      "message": "Verifying if IO is allowed is enough for me, I think.",
      "parentUuid": "5a0e9e61_db84c100",
      "range": {
        "startLine": 62,
        "startChar": 35,
        "endLine": 62,
        "endChar": 36
      },
      "revId": "16b63e1f54dc0d3e2785d130b32bea9d2b31a0d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}