{
  "comments": [
    {
      "key": {
        "uuid": "c26221da_45668214",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-15T16:35:17Z",
      "side": 1,
      "message": "BUG:  With the above change, this is now nullptr.\n\nWe\u0027ll probably have to move creating and setting the ct_tree_tracker to some point after the system_network_context is created in this method.\n\nThe fact that no test caught this seems like a problem.  Add a test?",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b58139db_c54dd75f",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "Doesn\u0027t it also imply a circular dependency now?\n\nThe SystemURLRequestContext\u0027s ct_verifier depends on ct_tree_tracker, which depends on the SystemURLRequestContext (by virtue of of host_resolver)\n\n+1 to moving this later, as that would also resolve that dependency graph issue",
      "parentUuid": "c26221da_45668214",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bc008c7_2bc549ea",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-15T17:43:57Z",
      "side": 1,
      "message": "It\u0027s not exactly a circular dependency - the SystemURLRequestContext is just a bag of stuff, much of which depends on other stuff.  Shutdown order does matter of that stuff does matter, though (HostResolver is the second to last thing destroyed, just before NetLog, so that shouldn\u0027t be an issue)\n\nRegardless, not sure what this would look like post-mojo, but could imagine having URLRequestContextBuilderMojo implementing a method to hook up a mojo wrapper for this, resolver circular dependency issues.  Or passing in a HostResolver hook to the mojo CtVerifier service before the NetworkService is created (With Mojo, you can pass around pipes before there\u0027s something on the other side, which does make dependencies a little weird).",
      "parentUuid": "b58139db_c54dd75f",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "585b2eb9_bd634400",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-20T18:11:16Z",
      "side": 1,
      "message": "In order to test this, I\u0027ve had to add some getters that allow the test to check the wiring. If you aren\u0027t thrilled about that, I could reduce the visibility of them and add some \"friend\" statements. I\u0027ve fixed the bug by moving the SetObserver() call to a bit later in the code. Is that what you meant by \"moving this later\" Ryan, or were you thinking somewhere outside of IOThread?",
      "parentUuid": "1bc008c7_2bc549ea",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39de8d2c_26841db1",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-20T18:20:18Z",
      "side": 1,
      "message": "Yes, that\u0027s what I meant.\n\nI don\u0027t suppose we could make a test that makes the CTVerifier do its thing instead - a test that relies on direct access to network stack objects isn\u0027t going to be useful - that\u0027s going to have to go away when the network service ships, and there will not be any equivalent way to test the existence of stuff.\n\nA browser test that tests behavior, on the other hand, will be able to pass both with any without the network service, so is much more future proof.",
      "parentUuid": "585b2eb9_bd634400",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e687a392_58cca34d",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-20T19:24:40Z",
      "side": 1,
      "message": "\u003e Yes, that\u0027s what I meant.\n\u003e \n\u003e I don\u0027t suppose we could make a test that makes the CTVerifier do its thing instead - a test that relies on direct access to network stack objects isn\u0027t going to be useful - that\u0027s going to have to go away when the network service ships, and there will not be any equivalent way to test the existence of stuff.\n\u003e\n\u003e\n\u003e A browser test that tests behavior, on the other hand, will be able to pass both with any without the network service, so is much more future proof.\n\nThat seems really unfortunate, and a potential step backwards in our testing coverage. While browser tests serve a valuable part of our testing, it\u0027s worth noting that a number of behaviours tested at the Browser Test level either rely on ensuring that objects are wired up correctly through the networking layer.\n\nFrom your description, it sounds like what you\u0027re describing about the future of Network Service testing is similar to what we have with UI tests - and the downsides they come with.\n\nFor example, an experiment like this will not result in any Network Service behaviour changes - that is, it won\u0027t block loads, nor will it expose additional information to API consumers. In our existing model, this is perfectly fine - because we can ensure the correct objects are called. It sounds like, for Network S13N, we\u0027d have to expose more of this as part of the S13N API (which would be undesirable, especially for experiments) or expose this CT behaviour as another service.\n\nI think, faced with the choice between exposing this as part of the API or leaving it untested (or, more aptly, testing it at-or-below the S13N layer, and leaving off integration testing) is a much more realistic outcome, so it\u0027d be great to figure out a testing story for experiments like this.",
      "parentUuid": "39de8d2c_26841db1",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "267373dc_b27e6caa",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-20T19:56:32Z",
      "side": 1,
      "message": "Note that we can monitor the test server as well.  If a feature isn\u0027t visible to the API consumer, and doesn\u0027t do anything visible to a server, either, what exactly does the feature do?\n\nA test that just checks that something is non-null really doesn\u0027t seem to give you all that much.\n\nIf we need to, we can make a NetworkService unittest (Which gives you access to both the NetworkService API and the URLRequestContext), but we\u0027re testing things that are hooked up in chrome/, that isn\u0027t really sufficient.",
      "parentUuid": "e687a392_58cca34d",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d04494be_edb579e2",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-20T20:14:24Z",
      "side": 1,
      "message": "\u003e Note that we can monitor the test server as well.  If a feature isn\u0027t visible to the API consumer, and doesn\u0027t do anything visible to a server, either, what exactly does the feature do?\n\nCorrect, this feature is not visible to the test server, and not visible to the loading infrastructure. That is, it does not alter error codes, add additional state to the load request, or change how the observable load behaves.\n\n\u003e A test that just checks that something is non-null really doesn\u0027t seem to give you all that much.\n\u003e \n\u003e If we need to, we can make a NetworkService unittest (Which gives you access to both the NetworkService API and the URLRequestContext), but we\u0027re testing things that are hooked up in chrome/, that isn\u0027t really sufficient.\n\nRight, in a non-NetworkService world, we would have a browser test that instantiates the load and ensures that the relevant state transitions happen as expected - providing end-to-end assurances (from the Profile down through loading and back up).\n\nIn this first phase, it\u0027s \"conceptually\" (although technically quite different) than how we might test histograms. We want to make sure that the appropriate aspects are logged, but that logging/non-logging (or histogramming/non-histogramming) doesn\u0027t affect the observable behaviour.\n\nAs captured in the launch bug, the goal of this is to asynchronously measure the consistency of the SCTs observed, using DNS. While that might imply \"Ah, we can listen for DNS events\" - that doesn\u0027t quite hold, because it\u0027s designed to happen asynchronously and without guarantees to when the request will be made. So while in a C++ world, we can ensure that the object is called as appropriate, in a Network Service world, this seems more complicated to test.\n\nWith this new change, we want to ensure that DNS requests are _not_ made under certain conditions. This is a negative test that doesn\u0027t lend itself well to NS-based testing - that is, the DNS request might not be made for any number of unrelated reasons, and so accessing the objects and ensuring the APIs are called offers a more realistic assurance of the necessary transitions - particularly as an integration test in which the number of reasons why X may or may not happen grows based on integrations (and which a unit test may not capture).",
      "parentUuid": "267373dc_b27e6caa",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0610b1d_73329057",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-20T21:05:27Z",
      "side": 1,
      "message": "So how do you see this being hooked up in a post-network-service world?  Seems like how it\u0027s enabled largely dictates how it should be tested.",
      "parentUuid": "d04494be_edb579e2",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e0b0b7fb_d826d80a",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-20T21:40:18Z",
      "side": 1,
      "message": "I think that\u0027s the question I was trying to get to.\n\nIn a Network Service world, this is still something that should only be enabled for Chrome (that is, not Chromium, not other Network Service consumers).\n\nDo we have recommended patterns for this? That is, is \"This is a service, and Chrome provides an implementation that does this magic\" the answer? This seems similar to the certificate verification side - where do we expose behaviours and \u0027additional features\u0027 that are Chrome-specific or Chrome-only?\n\nOne way (probably incorrect) that I\u0027ve been imagining is that when the network service starts, the //chrome directory has the ability to colocate additional //chrome implementations into that process as services. In the creation of the network service, we\u0027d pass those additional Mojo services in (much like we do here with the URLRequestContextBuilder), but they\u0027d be logic and behaviour controlled by //chrome.\n\nIf that is a viable path, then it seems like the testing story would be similar to what\u0027s being done here - we\u0027d stub in a fake/testing implementation of the service, and check that the service was being invoked as expected where it\u0027d be Network Service -\u003e browser_test multi-process in the unittest, rather than Network Service -\u003e network service single-process in the release code.\n\nThis pattern matches the C++ object hierarchy (in which //chrome implements an interface defined by //net / wires up the relevant objects in a Chrome-specific way), but may not be Mojo-best-practice, hence trying to understand if there\u0027s alternative ways.",
      "parentUuid": "b0610b1d_73329057",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13db8f8a_e0e4a277",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-28T18:55:35Z",
      "side": 1,
      "message": "How far in the future is this network-service world? Given that this code originally landed in Chrome untested quite some time ago, is it reasonable to settle for this testing for now and address this down the road, when this network-service world comes into being? At that point, it might be clearer what the best way to test this is.",
      "parentUuid": "e0b0b7fb_d826d80a",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b31bc74b_61827cdd",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-28T19:02:44Z",
      "side": 1,
      "message": "The goal is to have it ready on Chrome on desktop by the end of next year (I view the end of the following year as more likely, but this isn\u0027t a universally held opinion).\n\nThe problem with not having integration testing is that it makes it significantly more likely that this will break without anyone noticing when this class is removed.  I have already broken both certificate stuff and caching, with no tests catching them.\n\nAlso, relying on whoever does servicification to do testing seems problematic - they likely won\u0027t understand this code as well as you.  They may not write any integration tests (High chance of breakage!), and if they do, you\u0027re relying on someone else investing a lot of time to write your tests for you, which seems not great.",
      "parentUuid": "13db8f8a_e0e4a277",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4d682bc_ffe36154",
        "filename": "components/certificate_transparency/single_tree_tracker.cc",
        "patchSetId": 5
      },
      "lineNbr": 281,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-15T11:52:40Z",
      "side": 1,
      "message": "FYI, this code assumes that the cache entries will have address_family \u003d\u003d ADDRESS_FAMILY_UNSPECIFIED and host_resolver_flags \u003d\u003d 0. I\u0027m not sure for what proportion of users that assumption doesn\u0027t hold. Any idea? I could work around this by adding a Lookup(hostname) method to HostCache that ignores the address family and flags, if necessary.",
      "range": {
        "startLine": 280,
        "startChar": 2,
        "endLine": 281,
        "endChar": 45
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1067a153_23146e00",
        "filename": "components/certificate_transparency/single_tree_tracker.cc",
        "patchSetId": 5
      },
      "lineNbr": 281,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-15T16:35:17Z",
      "side": 1,
      "message": "If you\u0027re using a SOCKS4 proxy, always, but in general, I\u0027m not sure.\n\nIf you look are our resolution time histograms (https://uma.googleplex.com/timeline_v2?sid\u003d36fa4a17db310431882a6a4f73b3f163)...It actually looks like 75% are IPv4, but that can\u0027t be right...Can it?  It does ignore \"speculative requests\", so I suppose that could be it.",
      "parentUuid": "e4d682bc_ffe36154",
      "range": {
        "startLine": 280,
        "startChar": 2,
        "endLine": 281,
        "endChar": 45
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df80928c_d2e75d88",
        "filename": "components/certificate_transparency/single_tree_tracker.cc",
        "patchSetId": 5
      },
      "lineNbr": 281,
      "author": {
        "id": 1113149
      },
      "writtenOn": "2017-11-15T16:50:51Z",
      "side": 1,
      "message": "The two common combinations are that one and ADDRESS_FAMILY_IPV4/HOST_RESOLVER_DEFAULT_FAMILY_SET_DUE_TO_NO_IPV6. So you could either do what you suggested, or just check those two combinations.",
      "parentUuid": "e4d682bc_ffe36154",
      "range": {
        "startLine": 280,
        "startChar": 2,
        "endLine": 281,
        "endChar": 45
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "815ff6b6_1f2e7e34",
        "filename": "components/certificate_transparency/single_tree_tracker.cc",
        "patchSetId": 5
      },
      "lineNbr": 281,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-28T18:55:35Z",
      "side": 1,
      "message": "I\u0027ve made it check those two combinations for now. We can improve it to be agnostic to address_family and host_resolver_flags in the future, if we need to.",
      "parentUuid": "df80928c_d2e75d88",
      "range": {
        "startLine": 280,
        "startChar": 2,
        "endLine": 281,
        "endChar": 45
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0066e7b6_3ee4ddd3",
        "filename": "components/certificate_transparency/single_tree_tracker.h",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "Document",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74223c42_313e5cce",
        "filename": "components/certificate_transparency/tree_state_tracker.h",
        "patchSetId": 5
      },
      "lineNbr": 49,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "document",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fda6dbe6_6e702c80",
        "filename": "components/certificate_transparency/tree_state_tracker_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 100,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "naming",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6234fa1f_e1bea05c",
        "filename": "components/certificate_transparency/tree_state_tracker_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 100,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-28T18:55:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fda6dbe6_6e702c80",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1e639b6e_69b81ea0",
        "filename": "net/cert/ct_verifier.h",
        "patchSetId": 5
      },
      "lineNbr": 50,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "document",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f34c739e_218ddeaf",
        "filename": "net/dns/host_resolver.cc",
        "patchSetId": 5
      },
      "lineNbr": 125,
      "author": {
        "id": 1113149
      },
      "writtenOn": "2017-11-15T16:50:51Z",
      "side": 1,
      "message": "This implementation really belongs in the HostResolverImpl, not the HostResolver. Sorry, I know that\u0027s more work.\n\nAlso, I\u0027d like this API better if it got the source and staleness without the whole entry, similar to what ResolveStaleFromCache() does, but you\u0027re welcome to ignore that suggestion.",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bcf141d_5ff37c48",
        "filename": "net/dns/host_resolver.cc",
        "patchSetId": 5
      },
      "lineNbr": 125,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-28T18:55:35Z",
      "side": 1,
      "message": "The implementation needs to be shared with MockHostResolverBase, and I think HostResolverMojo too. I\u0027ve refactored this code, and the code from SingleTreeTracker that calls it, into a new function called HasCacheEntry(), which I\u0027ve put in net/dns/host_cache.{h,cc}. That can then be called from HostResolverImpl, MockHostResolverBase and HostResolverMojo. It no longer returns the whole entry, but instead returns just the source and staleness via out parameters. Better?",
      "parentUuid": "f34c739e_218ddeaf",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}