{
  "comments": [
    {
      "key": {
        "uuid": "c26221da_45668214",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-15T16:35:17Z",
      "side": 1,
      "message": "BUG:  With the above change, this is now nullptr.\n\nWe\u0027ll probably have to move creating and setting the ct_tree_tracker to some point after the system_network_context is created in this method.\n\nThe fact that no test caught this seems like a problem.  Add a test?",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b58139db_c54dd75f",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "Doesn\u0027t it also imply a circular dependency now?\n\nThe SystemURLRequestContext\u0027s ct_verifier depends on ct_tree_tracker, which depends on the SystemURLRequestContext (by virtue of of host_resolver)\n\n+1 to moving this later, as that would also resolve that dependency graph issue",
      "parentUuid": "c26221da_45668214",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bc008c7_2bc549ea",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-15T17:43:57Z",
      "side": 1,
      "message": "It\u0027s not exactly a circular dependency - the SystemURLRequestContext is just a bag of stuff, much of which depends on other stuff.  Shutdown order does matter of that stuff does matter, though (HostResolver is the second to last thing destroyed, just before NetLog, so that shouldn\u0027t be an issue)\n\nRegardless, not sure what this would look like post-mojo, but could imagine having URLRequestContextBuilderMojo implementing a method to hook up a mojo wrapper for this, resolver circular dependency issues.  Or passing in a HostResolver hook to the mojo CtVerifier service before the NetworkService is created (With Mojo, you can pass around pipes before there\u0027s something on the other side, which does make dependencies a little weird).",
      "parentUuid": "b58139db_c54dd75f",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "585b2eb9_bd634400",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-20T18:11:16Z",
      "side": 1,
      "message": "In order to test this, I\u0027ve had to add some getters that allow the test to check the wiring. If you aren\u0027t thrilled about that, I could reduce the visibility of them and add some \"friend\" statements. I\u0027ve fixed the bug by moving the SetObserver() call to a bit later in the code. Is that what you meant by \"moving this later\" Ryan, or were you thinking somewhere outside of IOThread?",
      "parentUuid": "1bc008c7_2bc549ea",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39de8d2c_26841db1",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-20T18:20:18Z",
      "side": 1,
      "message": "Yes, that\u0027s what I meant.\n\nI don\u0027t suppose we could make a test that makes the CTVerifier do its thing instead - a test that relies on direct access to network stack objects isn\u0027t going to be useful - that\u0027s going to have to go away when the network service ships, and there will not be any equivalent way to test the existence of stuff.\n\nA browser test that tests behavior, on the other hand, will be able to pass both with any without the network service, so is much more future proof.",
      "parentUuid": "585b2eb9_bd634400",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e687a392_58cca34d",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-20T19:24:40Z",
      "side": 1,
      "message": "\u003e Yes, that\u0027s what I meant.\n\u003e \n\u003e I don\u0027t suppose we could make a test that makes the CTVerifier do its thing instead - a test that relies on direct access to network stack objects isn\u0027t going to be useful - that\u0027s going to have to go away when the network service ships, and there will not be any equivalent way to test the existence of stuff.\n\u003e\n\u003e\n\u003e A browser test that tests behavior, on the other hand, will be able to pass both with any without the network service, so is much more future proof.\n\nThat seems really unfortunate, and a potential step backwards in our testing coverage. While browser tests serve a valuable part of our testing, it\u0027s worth noting that a number of behaviours tested at the Browser Test level either rely on ensuring that objects are wired up correctly through the networking layer.\n\nFrom your description, it sounds like what you\u0027re describing about the future of Network Service testing is similar to what we have with UI tests - and the downsides they come with.\n\nFor example, an experiment like this will not result in any Network Service behaviour changes - that is, it won\u0027t block loads, nor will it expose additional information to API consumers. In our existing model, this is perfectly fine - because we can ensure the correct objects are called. It sounds like, for Network S13N, we\u0027d have to expose more of this as part of the S13N API (which would be undesirable, especially for experiments) or expose this CT behaviour as another service.\n\nI think, faced with the choice between exposing this as part of the API or leaving it untested (or, more aptly, testing it at-or-below the S13N layer, and leaving off integration testing) is a much more realistic outcome, so it\u0027d be great to figure out a testing story for experiments like this.",
      "parentUuid": "39de8d2c_26841db1",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "267373dc_b27e6caa",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-20T19:56:32Z",
      "side": 1,
      "message": "Note that we can monitor the test server as well.  If a feature isn\u0027t visible to the API consumer, and doesn\u0027t do anything visible to a server, either, what exactly does the feature do?\n\nA test that just checks that something is non-null really doesn\u0027t seem to give you all that much.\n\nIf we need to, we can make a NetworkService unittest (Which gives you access to both the NetworkService API and the URLRequestContext), but we\u0027re testing things that are hooked up in chrome/, that isn\u0027t really sufficient.",
      "parentUuid": "e687a392_58cca34d",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d04494be_edb579e2",
        "filename": "chrome/browser/io_thread.cc",
        "patchSetId": 5
      },
      "lineNbr": 826,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-20T20:14:24Z",
      "side": 1,
      "message": "\u003e Note that we can monitor the test server as well.  If a feature isn\u0027t visible to the API consumer, and doesn\u0027t do anything visible to a server, either, what exactly does the feature do?\n\nCorrect, this feature is not visible to the test server, and not visible to the loading infrastructure. That is, it does not alter error codes, add additional state to the load request, or change how the observable load behaves.\n\n\u003e A test that just checks that something is non-null really doesn\u0027t seem to give you all that much.\n\u003e \n\u003e If we need to, we can make a NetworkService unittest (Which gives you access to both the NetworkService API and the URLRequestContext), but we\u0027re testing things that are hooked up in chrome/, that isn\u0027t really sufficient.\n\nRight, in a non-NetworkService world, we would have a browser test that instantiates the load and ensures that the relevant state transitions happen as expected - providing end-to-end assurances (from the Profile down through loading and back up).\n\nIn this first phase, it\u0027s \"conceptually\" (although technically quite different) than how we might test histograms. We want to make sure that the appropriate aspects are logged, but that logging/non-logging (or histogramming/non-histogramming) doesn\u0027t affect the observable behaviour.\n\nAs captured in the launch bug, the goal of this is to asynchronously measure the consistency of the SCTs observed, using DNS. While that might imply \"Ah, we can listen for DNS events\" - that doesn\u0027t quite hold, because it\u0027s designed to happen asynchronously and without guarantees to when the request will be made. So while in a C++ world, we can ensure that the object is called as appropriate, in a Network Service world, this seems more complicated to test.\n\nWith this new change, we want to ensure that DNS requests are _not_ made under certain conditions. This is a negative test that doesn\u0027t lend itself well to NS-based testing - that is, the DNS request might not be made for any number of unrelated reasons, and so accessing the objects and ensuring the APIs are called offers a more realistic assurance of the necessary transitions - particularly as an integration test in which the number of reasons why X may or may not happen grows based on integrations (and which a unit test may not capture).",
      "parentUuid": "267373dc_b27e6caa",
      "range": {
        "startLine": 826,
        "startChar": 15,
        "endLine": 826,
        "endChar": 26
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4d682bc_ffe36154",
        "filename": "components/certificate_transparency/single_tree_tracker.cc",
        "patchSetId": 5
      },
      "lineNbr": 281,
      "author": {
        "id": 1130929
      },
      "writtenOn": "2017-11-15T11:52:40Z",
      "side": 1,
      "message": "FYI, this code assumes that the cache entries will have address_family \u003d\u003d ADDRESS_FAMILY_UNSPECIFIED and host_resolver_flags \u003d\u003d 0. I\u0027m not sure for what proportion of users that assumption doesn\u0027t hold. Any idea? I could work around this by adding a Lookup(hostname) method to HostCache that ignores the address family and flags, if necessary.",
      "range": {
        "startLine": 280,
        "startChar": 2,
        "endLine": 281,
        "endChar": 45
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1067a153_23146e00",
        "filename": "components/certificate_transparency/single_tree_tracker.cc",
        "patchSetId": 5
      },
      "lineNbr": 281,
      "author": {
        "id": 1115968
      },
      "writtenOn": "2017-11-15T16:35:17Z",
      "side": 1,
      "message": "If you\u0027re using a SOCKS4 proxy, always, but in general, I\u0027m not sure.\n\nIf you look are our resolution time histograms (https://uma.googleplex.com/timeline_v2?sid\u003d36fa4a17db310431882a6a4f73b3f163)...It actually looks like 75% are IPv4, but that can\u0027t be right...Can it?  It does ignore \"speculative requests\", so I suppose that could be it.",
      "parentUuid": "e4d682bc_ffe36154",
      "range": {
        "startLine": 280,
        "startChar": 2,
        "endLine": 281,
        "endChar": 45
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df80928c_d2e75d88",
        "filename": "components/certificate_transparency/single_tree_tracker.cc",
        "patchSetId": 5
      },
      "lineNbr": 281,
      "author": {
        "id": 1113149
      },
      "writtenOn": "2017-11-15T16:50:51Z",
      "side": 1,
      "message": "The two common combinations are that one and ADDRESS_FAMILY_IPV4/HOST_RESOLVER_DEFAULT_FAMILY_SET_DUE_TO_NO_IPV6. So you could either do what you suggested, or just check those two combinations.",
      "parentUuid": "e4d682bc_ffe36154",
      "range": {
        "startLine": 280,
        "startChar": 2,
        "endLine": 281,
        "endChar": 45
      },
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0066e7b6_3ee4ddd3",
        "filename": "components/certificate_transparency/single_tree_tracker.h",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "Document",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74223c42_313e5cce",
        "filename": "components/certificate_transparency/tree_state_tracker.h",
        "patchSetId": 5
      },
      "lineNbr": 49,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "document",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fda6dbe6_6e702c80",
        "filename": "components/certificate_transparency/tree_state_tracker_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 100,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "naming",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e639b6e_69b81ea0",
        "filename": "net/cert/ct_verifier.h",
        "patchSetId": 5
      },
      "lineNbr": 50,
      "author": {
        "id": 1000193
      },
      "writtenOn": "2017-11-15T17:37:09Z",
      "side": 1,
      "message": "document",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f34c739e_218ddeaf",
        "filename": "net/dns/host_resolver.cc",
        "patchSetId": 5
      },
      "lineNbr": 125,
      "author": {
        "id": 1113149
      },
      "writtenOn": "2017-11-15T16:50:51Z",
      "side": 1,
      "message": "This implementation really belongs in the HostResolverImpl, not the HostResolver. Sorry, I know that\u0027s more work.\n\nAlso, I\u0027d like this API better if it got the source and staleness without the whole entry, similar to what ResolveStaleFromCache() does, but you\u0027re welcome to ignore that suggestion.",
      "revId": "ce5d85bd5da01c447966dd045257a3982e90242b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}