{
  "comments": [
    {
      "key": {
        "uuid": "d6b95b3a_5d3290ff",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 154,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "You should drop the check `queueCount \u003e 0`. The Vulkan spec guarantees that.\n\n(You probably copied that from vk_glow.c. And that code is a shadow of ancient code from the pre-Vulkan-1.0 era, where the spec was in its infancy).",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53be85b6_5e7ceae2",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 154,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Done.\n\nChanged to a DCHECK.",
      "parentUuid": "d6b95b3a_5d3290ff",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "76fc7d25_2d55bba0",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 201,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "It is incorrect to check for VK_SUCCESS here. Given your usage of vkEnumeratePhysicalDevices(), the function may return VK_INCOMPLETE, which would be success as far as this code is concerned.\n\nThe spec says: \"If pPhysicalDeviceCount is smaller than the number of physical devices available, VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available physical devices were returned.\"\n\nIn Vulkan, all error codes are negative, and VK_INCOMPLETE is not an error code. Therefore, I suggest you perform this check\n\n    // implicitly accepts VK_INCOMPLETE\n    if (result \u003e\u003d 0)\n\nor this check\n\n    // explicit\n    if (result !\u003d VK_SUCCESS \u0026\u0026 result !\u003d VK_INCOMPLETE)",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07779d44_e95bf630",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 201,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "76fc7d25_2d55bba0",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c32b1c74_87d3074b",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 203,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "On failure here, you must cleanup the VkInstance.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4f2c5f8_3c9424e9",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 203,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Moved VulkanInitialize to ClientBase::InitVulkan, it\u0027s now using ScopedVk* objects, so the clean up should now happen automatically.",
      "parentUuid": "c32b1c74_87d3074b",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c75015f8_95f62eff",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 226,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "Again, need to cleanup the VkInstance.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ceef383d_9d87f223",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 226,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "We\u0027re now using a ScopedVkInstance.",
      "parentUuid": "c75015f8_95f62eff",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d8fe449_dfa64900",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 239,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "This failure path must cleanup the VkInstance and VkDevice.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34fa8783_1d1a69b5",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 239,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Using ScopedVkStuff now :)",
      "parentUuid": "8d8fe449_dfa64900",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8cdf803_913a14f1",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 708,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "You need to check that gbm_bo_get_plane_fd() succeeded (that is, it returned fd !\u003d -1) before passing the fd to vkCreateDmaBufImageINTEL(). In general, passing invalid arguments to Vulkan results in undefined behavior.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd7167f8_35aadff2",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 708,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Done.\nAlso, we\u0027re now putting it into a ScopedFD to properly close it.",
      "parentUuid": "f8cdf803_913a14f1",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "81422dc2_656295cc",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 746,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "When vkCreateFoo(..., \u0026foo) fails, the spec requires that vkCreateFoo not modify foo. As a consequence, When vkCreateImageView fails here, vk_image_view remains unitialized memory, and ScopedVkImageView below gets initialized with garbage bits.\n\nSolution: Check the vkCreateImageView result before creating the ScopedVkImageView.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "513b8321_d874f5d0",
        "filename": "components/exo/wayland/clients/client_base.cc",
        "patchSetId": 7
      },
      "lineNbr": 746,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Changed to:\nScopedVkImage vk_image_view(VK_NULL_HANDLE, {vk_device});\nresult \u003d vkCreateImageView(..., vk_image_view-\u003ereceive());\nif (result !\u003d VK_SUCCESS) ...\n\nIn this way the vkImageView in the ScopedVk gets initialized.",
      "parentUuid": "81422dc2_656295cc",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8e39c56e_e5c6dc95",
        "filename": "components/exo/wayland/clients/client_base.h",
        "patchSetId": 7
      },
      "lineNbr": 25,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "Do any other configuration options for Chromium define USE_VULKAN? In particular, if someone enables Vulkan for Skia, will that incidentally define USE_VULKAN here? If yes, then #include \u003cvulkan/vulkan_intel.h\u003e will obviously break the build for many users.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e2ea685_01835b05",
        "filename": "components/exo/wayland/clients/client_base.h",
        "patchSetId": 7
      },
      "lineNbr": 25,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "USE_VULKAN is not used anywhere else.\nIf you enable Vulkan for Skia you get SK_VULKAN.\nI\u0027m afraid currently no one is building Chromium with Vulkan (I suspect it wouldn\u0027t even build today).\n\nWe could define something like USE_VULKAN_WAYLAND_CLIENT to make it more explicit that this define is specifically for wayland clients though.",
      "parentUuid": "8e39c56e_e5c6dc95",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "826b2215_f2ed8c83",
        "filename": "components/exo/wayland/clients/client_base.h",
        "patchSetId": 7
      },
      "lineNbr": 89,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "This struct contains EGL and Vulkan resources. In general, EGL allows the user to call eglDestroyFoo(foo) even if the foo is still being used. According to the EGL spec, eglDestroyFoo(foo) does two things: it invalidates the handle foo, so it is illegal to ever reference it again; and it *schedules* foo to be destroyed when it is no longer in use.\n\nSorta kinda, you can view foo as having two independent refcounts. eglDestroyFoo(foo) drops foo\u0027s external, user-facing refcount to 0. The driver will eventually delete foo when its internal, driver-private refcount reaches 0.\n\nAs a consequence, when Buffer::~Buffer() runs, the order in which it calls eglDestroyImage() and eglDestroySync() doesn\u0027t matter. The EGL spec doesn\u0027t care.\n\nVulkan does not behave that way.\n\nVulkan has two destruction requirements that are relevant to Buffer::~Buffer():\n\n    1. If a Vulkan resource has any children resources, then the user must not delete the parent resource before its children. For example, if you do vkCreateImage(device, ..., \u0026image), then you must vkDestroyImage(device, image, ...) before you vkDestroyDevice(..., device, ...). [There may be exceptions to this rule that I\u0027m not aware of].\n\n    2. The user must not destroy any Vulkan resource that is currently in use by a VkQueue.\n\n       For example, if you submit to a queue some command buffer that accesses an image, then you must prove that the command buffer has completed execution before destroying the image. The easiest way to prove that is vkQueueWaitIdle; second easiest is provide an out fence to vkQueueSubmit and wait on the fence.\n\nWhy did I write this mini essay? Because I see no guarantee that Buffer::~Buffer() satisfies requirements #1 and #2. Does any code elsewhere guarantee that the Buffer\u0027s Vulkan resources are destroyed safely?",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c03e0fe7_df33b665",
        "filename": "components/exo/wayland/clients/client_base.h",
        "patchSetId": 7
      },
      "lineNbr": 89,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "~Buffer satisfies #1. All the members dtors are called in the inverse order of declaration, and, if I didn\u0027t make any mistake, I declared them in order of allocation, so the reverse should satisfy #1.\n\nRegarding #2, that is up to whoever owns Buffer instances. Right now that is VulkanClient, VulkanClient waits on the queue after every frame.",
      "parentUuid": "826b2215_f2ed8c83",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f66b0c3_ccc82d5c",
        "filename": "components/exo/wayland/clients/client_helper.cc",
        "patchSetId": 7
      },
      "lineNbr": 85,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "Does C++11 (or C++14) allow these simple static methods to be defined inline in the header? If so, I think it would be cleaner. Feel free to ignore this suggestion.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be71ff7c_5099156d",
        "filename": "components/exo/wayland/clients/client_helper.cc",
        "patchSetId": 7
      },
      "lineNbr": 85,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "It does, I just wanted to be consistent with the Traits::InvalidValue defined for the gl traits.\nMiguel also suggested a way to avoid all these lines of code: crrev.com/c/732608",
      "parentUuid": "5f66b0c3_ccc82d5c",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a5f3cdd_1c2fdfd5",
        "filename": "components/exo/wayland/clients/client_helper.cc",
        "patchSetId": 7
      },
      "lineNbr": 137,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2017-10-18T14:58:15Z",
      "side": 1,
      "message": "These lot here are very similar. We could also consider e.g.\na templatised ScopedGeneric Traits like this one:\n\ntemplate \u003ctypename T\u003e\nclass DeleteVkStuff {\n public:\n  using FreeVkStuffCallback \u003d base::Callback\u003cvoid(VkDevice, T, void*)\u003e;\n\n  DeleteVkStuff(VkDevice vk_device, FreeVkStuffCallback free_vkstuff_cb)\n      : vk_device_(vk_device), free_vkstuff_cb_(free_vkstuff_cb) {}\n\n  static T InvalidValue() { return VK_NULL_HANDLE; }\n\n  void Free(T param) { free_vkstuff_cb_.Run(vk_device_, param, nullptr); }\n\n private:\n  const VkDevice vk_device_;\n  const FreeVkStuffCallback free_vkstuff_cb_;\n};\n\nwhich e.g. could be used as:\n\nusing ScopedVkImageView \u003d\n    base::ScopedGeneric\u003cVkImageView, DeleteVkStuff\u003cVkImageView\u003e\u003e;\n\nand then instantiated as \n\n  //VkDevice device \u003d ...;\n  //VkImageView view \u003d ...;\n\n  ScopedVkImageView scoped_image_view(\n      view,\n      DeleteVkStuff\u003cVkImageView\u003e(device, base::Bind(\u0026vkDestroyImageView)));\n\nwhere vkDestroyImageView() is a static library function.\n\nHaving to use Bind() gives us extra compiler checks about\ne.g. the arguments. We\u0027ll need to Bind explicitly to the\nappropriate deleter/destroyer on construction, but that \ngives us clarity IMHO.\n\nNote: I have used repeating Callbacks in these lines, but arguably\nwe should use OnceCallback in DeleteVkStuff and BindOnce in its \ncaller.",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 137,
        "endChar": 1
      },
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e96ecb4_5a404417",
        "filename": "components/exo/wayland/clients/client_helper.cc",
        "patchSetId": 7
      },
      "lineNbr": 137,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Uploaded the suggested solution to another CL: http://crrev.com/c/732608, so we can focus on Vulkan related issues in this CL and on metaprogramming stuff in the other CL.\n\nBtw, the callback can\u0027t be made a OnceCallback without changing ScopedGeneric (we could use a const_cast otherwise, but we don\u0027t want to go there.)",
      "parentUuid": "1a5f3cdd_1c2fdfd5",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 137,
        "endChar": 1
      },
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d9dcf38_439eae28",
        "filename": "components/exo/wayland/clients/vulkan.cc",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "I think C++ leaves command_buffer_ uninitialized. Please initialize it to VK_NULL_HANDLE for safety\u0027s sake.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "055123fa_94140284",
        "filename": "components/exo/wayland/clients/vulkan.cc",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4d9dcf38_439eae28",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "249ae81c_608732eb",
        "filename": "components/exo/wayland/clients/vulkan.cc",
        "patchSetId": 7
      },
      "lineNbr": 104,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "Does CHECK_EQ kill the process on failure? If not, then what it does it do?\n\nI don\u0027t understand the role this file plays in Chromium\u0027s testing. It may make sense, in follow-up patches, to teach this code how to recover from queue failure.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d5219c6_8ec18e5c",
        "filename": "components/exo/wayland/clients/vulkan.cc",
        "patchSetId": 7
      },
      "lineNbr": 104,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "CHECK_EQ kills the process on failure.\n\nThis file is a standalone binary. We typically build it manually and scp it to the device, and then run it.\n\nThey\u0027re working on getting Wayland clients to run in an automated way to check regressions, but this Vulkan client won\u0027t probably be part of it, at least initially.\n\nHow often should we expect a queuesubmit failure?",
      "parentUuid": "249ae81c_608732eb",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9002e010_d00b18be",
        "filename": "components/exo/wayland/clients/vulkan.cc",
        "patchSetId": 7
      },
      "lineNbr": 106,
      "author": {
        "id": 1163154
      },
      "writtenOn": "2017-10-18T01:31:17Z",
      "side": 1,
      "message": "Why do you call vkQueueWaitIdle() here? If at all possible, that should be replaced with a VkSemaphore; or, if a VkSemaphore is insufficient, then fallback to a VkFence.\n\nFor this initial commit, vkQueueWaitIdle() is good enough. But please have a plan for replacing it in follow-up CLs.",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d545f1a7_02054b6e",
        "filename": "components/exo/wayland/clients/vulkan.cc",
        "patchSetId": 7
      },
      "lineNbr": 106,
      "author": {
        "id": 1123405
      },
      "writtenOn": "2017-10-22T19:30:32Z",
      "side": 1,
      "message": "We call vkQueueWaitIdle because it was the easiest thing to do.\n\nWe should definitely improve it in the future. It can be a nice exercise to have it work with fences and pass them around once we get wayland/exo support.",
      "parentUuid": "9002e010_d00b18be",
      "revId": "1f4cde3e268ae89d3ab1b41558fefd78bf0348ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}