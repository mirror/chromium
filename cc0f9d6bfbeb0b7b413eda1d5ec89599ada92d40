{
  "comments": [
    {
      "key": {
        "uuid": "07636bc9_0a338a82",
        "filename": "chrome/app/chrome_main.cc",
        "patchSetId": 7
      },
      "lineNbr": 98,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2017-10-04T17:40:19Z",
      "side": 1,
      "message": "On a quick looks it seems like chrome_main is not compiled on android, where as chrome_browser_main is. I assume you want the profiler on android, so could you verify this file is compiled on android?",
      "range": {
        "startLine": 98,
        "startChar": 2,
        "endLine": 98,
        "endChar": 37
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f88c29f9_77fb864e",
        "filename": "chrome/app/chrome_main.cc",
        "patchSetId": 7
      },
      "lineNbr": 98,
      "author": {
        "id": 1002120
      },
      "writtenOn": "2017-10-04T18:57:12Z",
      "side": 1,
      "message": "The profiler is only supported on desktop platforms currently. We would probably add something equivalent to Android early initialization if and when we support that platform.",
      "parentUuid": "07636bc9_0a338a82",
      "range": {
        "startLine": 98,
        "startChar": 2,
        "endLine": 98,
        "endChar": 37
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5cfef41_00e92ba3",
        "filename": "chrome/app/chrome_main.cc",
        "patchSetId": 7
      },
      "lineNbr": 98,
      "author": {
        "id": 1002410
      },
      "writtenOn": "2017-10-09T23:57:04Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "f88c29f9_77fb864e",
      "range": {
        "startLine": 98,
        "startChar": 2,
        "endLine": 98,
        "endChar": 37
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3df1f87d_a3818837",
        "filename": "chrome/app/profiler/stack_sampling_profiler_launcher.cc",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1000763
      },
      "writtenOn": "2017-10-04T17:40:19Z",
      "side": 1,
      "message": "Style guide says static function locals should only be PODs (unless this can be a constexpr).",
      "range": {
        "startLine": 55,
        "startChar": 2,
        "endLine": 55,
        "endChar": 36
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09ef0f9c_d4d71732",
        "filename": "chrome/app/profiler/stack_sampling_profiler_launcher.cc",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1002120
      },
      "writtenOn": "2017-10-04T18:57:12Z",
      "side": 1,
      "message": "Side note: please retain the destruction of the StackSamplingProfiler object when addressing this change, to preserve existing behavior.",
      "parentUuid": "3df1f87d_a3818837",
      "range": {
        "startLine": 55,
        "startChar": 2,
        "endLine": 55,
        "endChar": 36
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "745911e7_2cbe5645",
        "filename": "chrome/app/profiler/stack_sampling_profiler_launcher.cc",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1103654
      },
      "writtenOn": "2017-10-06T20:23:47Z",
      "side": 1,
      "message": "I\u0027m not convinced we should preserve destruction of the object.\n\nRight now, the object destructor may block if there are pending profiling tasks. However, this is just to ensure that when those tasks run, the sampling profiler object is still around.\n\nI think it would be better to just leak the sampling profiler object when in the context of being the global one for the browser process. (For unit tests, the blocking logic still makes sense.)\n\nThe advantage of leaking is there\u0027s no extra code to run at destruction and no blocking needed. Yes, it would be a behavior change from what we have currently, but I think it would be worthwhile to do this while you\u0027re changing this already.\n\nHaving said that, I think having the object be static is not correct to achieve that - since I think that still introduces an static destructor call at exit - which I don\u0027t think is needed. Instead, you can make the static var be a pointer and allocate a new instance (with a comment saying it\u0027s intentionally leaked).",
      "parentUuid": "09ef0f9c_d4d71732",
      "range": {
        "startLine": 55,
        "startChar": 2,
        "endLine": 55,
        "endChar": 36
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41843485_2ef517bb",
        "filename": "chrome/app/profiler/stack_sampling_profiler_launcher.cc",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1002120
      },
      "writtenOn": "2017-10-09T15:20:30Z",
      "side": 1,
      "message": "We need the destructor to run to synchronize the stopping of profiling before application shutdown. Otherwise on Windows there\u0027s a race between termination of the main thread and the profiler thread, resulting in crashes when the profiler attempts to profile the destroyed main thread.\n\nAlso, unless there are layering reasons to avoid it I think it\u0027s reasonable to just allocate the object on the stack.",
      "parentUuid": "745911e7_2cbe5645",
      "range": {
        "startLine": 55,
        "startChar": 2,
        "endLine": 55,
        "endChar": 36
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8dfb1b3_39db311e",
        "filename": "chrome/app/profiler/stack_sampling_profiler_launcher.cc",
        "patchSetId": 7
      },
      "lineNbr": 55,
      "author": {
        "id": 1002410
      },
      "writtenOn": "2017-10-09T23:55:49Z",
      "side": 1,
      "message": "Good points!  I had forgotten that static allocation would run the destructor on exit, and had actually intended the semantics that Alexei is suggesting.  Per discussion with Mike, though, it seems like the it\u0027s important to run the destructor to synchronize across threads, as thread destruction order is otherwise not guaranteed.  I\u0027ve updated the code to use a \"scoped\" wrapper object, which is allocated on the stack.",
      "parentUuid": "41843485_2ef517bb",
      "range": {
        "startLine": 55,
        "startChar": 2,
        "endLine": 55,
        "endChar": 36
      },
      "revId": "cc0f9d6bfbeb0b7b413eda1d5ec89599ada92d40",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}