package java.io {

  public class File implements java.lang.Comparable {
    ctor public File(java.lang.String);
    ctor public File(java.lang.String, java.lang.String);
    ctor public File(java.io.File, java.lang.String);
    ctor public File(java.net.URI);
    method public boolean canExecute();
    method public boolean canRead();
    method public boolean canWrite();
    method public int compareTo(java.io.File);
    method public int compareTo(java.lang.Object);
    method public boolean createNewFile() throws java.io.IOException;
    method public static java.io.File createTempFile(java.lang.String, java.lang.String, java.io.File) throws java.io.IOException;
    method public static java.io.File createTempFile(java.lang.String, java.lang.String) throws java.io.IOException;
    method public boolean delete();
    method public void deleteOnExit();
    method public boolean exists();
    method public java.io.File getAbsoluteFile();
    method public java.lang.String getAbsolutePath();
    method public java.io.File getCanonicalFile() throws java.io.IOException;
    method public java.lang.String getCanonicalPath() throws java.io.IOException;
    method public long getFreeSpace();
    method public java.lang.String getName();
    method public java.lang.String getParent();
    method public java.io.File getParentFile();
    method public java.lang.String getPath();
    method public long getTotalSpace();
    method public long getUsableSpace();
    method public boolean isAbsolute();
    method public boolean isDirectory();
    method public boolean isFile();
    method public boolean isHidden();
    method public long lastModified();
    method public long length();
    method public java.lang.String[] list();
    method public java.lang.String[] list(java.io.FilenameFilter);
    method public java.io.File[] listFiles();
    method public java.io.File[] listFiles(java.io.FilenameFilter);
    method public java.io.File[] listFiles(java.io.FileFilter);
    method public static java.io.File[] listRoots();
    method public boolean mkdir();
    method public boolean mkdirs();
    method public boolean renameTo(java.io.File);
    method public boolean setExecutable(boolean, boolean);
    method public boolean setExecutable(boolean);
    method public boolean setLastModified(long);
    method public boolean setReadOnly();
    method public boolean setReadable(boolean, boolean);
    method public boolean setReadable(boolean);
    method public boolean setWritable(boolean, boolean);
    method public boolean setWritable(boolean);
    method public java.nio.file.Path toPath();
    method public java.net.URI toURI();
    method public deprecated java.net.URL toURL() throws java.net.MalformedURLException;
    field public static final java.lang.String pathSeparator;
    field public static final char pathSeparatorChar;
    field public static final java.lang.String separator;
    field public static final char separatorChar;
  }

  public abstract interface FileFilter {
    method public abstract boolean accept(java.io.File);
  }

  public class FileNotFoundException extends java.io.IOException {
    ctor public FileNotFoundException();
    ctor public FileNotFoundException(java.lang.String);
  }

  public abstract interface FilenameFilter {
    method public abstract boolean accept(java.io.File, java.lang.String);
  }

  public class FilterOutputStream extends java.io.OutputStream {
    ctor public FilterOutputStream(java.io.OutputStream);
    method public void write(int) throws java.io.IOException;
    field protected java.io.OutputStream out;
  }

  public class IOException extends java.lang.Exception {
    ctor public IOException();
    ctor public IOException(java.lang.String);
    ctor public IOException(java.lang.String, java.lang.Throwable);
    ctor public IOException(java.lang.Throwable);
  }

  public abstract class InputStream {
    ctor public InputStream();
    method public int available() throws java.io.IOException;
    method public void close() throws java.io.IOException;
    method public synchronized void mark(int);
    method public boolean markSupported();
    method public abstract int read() throws java.io.IOException;
    method public int read(byte[]) throws java.io.IOException;
    method public int read(byte[], int, int) throws java.io.IOException;
    method public synchronized void reset() throws java.io.IOException;
    method public long skip(long) throws java.io.IOException;
  }

  public class InvalidObjectException extends java.io.ObjectStreamException {
    ctor public InvalidObjectException(java.lang.String);
  }

  public abstract class ObjectStreamException extends java.io.IOException {
    ctor protected ObjectStreamException(java.lang.String);
    ctor protected ObjectStreamException();
  }

  public abstract class OutputStream {
    ctor public OutputStream();
    method public void close() throws java.io.IOException;
    method public void flush() throws java.io.IOException;
    method public abstract void write(int) throws java.io.IOException;
    method public void write(byte[]) throws java.io.IOException;
    method public void write(byte[], int, int) throws java.io.IOException;
  }

  public class PrintStream extends java.io.FilterOutputStream implements java.lang.Appendable {
    ctor public PrintStream(java.io.OutputStream);
    ctor public PrintStream(java.io.OutputStream, boolean);
    ctor public PrintStream(java.io.OutputStream, boolean, java.lang.String) throws java.io.UnsupportedEncodingException;
    ctor public PrintStream(java.lang.String) throws java.io.FileNotFoundException;
    ctor public PrintStream(java.lang.String, java.lang.String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public PrintStream(java.io.File) throws java.io.FileNotFoundException;
    ctor public PrintStream(java.io.File, java.lang.String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    method public java.io.PrintStream append(java.lang.CharSequence);
    method public java.io.PrintStream append(java.lang.CharSequence, int, int);
    method public java.io.PrintStream append(char);
    method public java.lang.Appendable append(char) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence, int, int) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence) throws java.io.IOException;
    method public boolean checkError();
    method protected void clearError();
    method public void close();
    method public void flush();
    method public java.io.PrintStream format(java.lang.String, java.lang.Object...);
    method public java.io.PrintStream format(java.util.Locale, java.lang.String, java.lang.Object...);
    method public void print(boolean);
    method public void print(char);
    method public void print(int);
    method public void print(long);
    method public void print(float);
    method public void print(double);
    method public void print(char[]);
    method public void print(java.lang.String);
    method public void print(java.lang.Object);
    method public java.io.PrintStream printf(java.lang.String, java.lang.Object...);
    method public java.io.PrintStream printf(java.util.Locale, java.lang.String, java.lang.Object...);
    method public void println();
    method public void println(boolean);
    method public void println(char);
    method public void println(int);
    method public void println(long);
    method public void println(float);
    method public void println(double);
    method public void println(char[]);
    method public void println(java.lang.String);
    method public void println(java.lang.Object);
    method protected void setError();
    method public void write(int);
    method public void write(byte[], int, int);
  }

  public class PrintWriter extends java.io.Writer {
    ctor public PrintWriter(java.io.Writer);
    ctor public PrintWriter(java.io.Writer, boolean);
    ctor public PrintWriter(java.io.OutputStream);
    ctor public PrintWriter(java.io.OutputStream, boolean);
    ctor public PrintWriter(java.lang.String) throws java.io.FileNotFoundException;
    ctor public PrintWriter(java.lang.String, java.lang.String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public PrintWriter(java.io.File) throws java.io.FileNotFoundException;
    ctor public PrintWriter(java.io.File, java.lang.String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    method public java.io.PrintWriter append(java.lang.CharSequence);
    method public java.io.PrintWriter append(java.lang.CharSequence, int, int);
    method public java.io.PrintWriter append(char);
    method public java.io.Writer append(char) throws java.io.IOException;
    method public java.io.Writer append(java.lang.CharSequence, int, int) throws java.io.IOException;
    method public java.io.Writer append(java.lang.CharSequence) throws java.io.IOException;
    method public boolean checkError();
    method protected void clearError();
    method public void close();
    method public void flush();
    method public java.io.PrintWriter format(java.lang.String, java.lang.Object...);
    method public java.io.PrintWriter format(java.util.Locale, java.lang.String, java.lang.Object...);
    method public void print(boolean);
    method public void print(char);
    method public void print(int);
    method public void print(long);
    method public void print(float);
    method public void print(double);
    method public void print(char[]);
    method public void print(java.lang.String);
    method public void print(java.lang.Object);
    method public java.io.PrintWriter printf(java.lang.String, java.lang.Object...);
    method public java.io.PrintWriter printf(java.util.Locale, java.lang.String, java.lang.Object...);
    method public void println();
    method public void println(boolean);
    method public void println(char);
    method public void println(int);
    method public void println(long);
    method public void println(float);
    method public void println(double);
    method public void println(char[]);
    method public void println(java.lang.String);
    method public void println(java.lang.Object);
    method protected void setError();
    method public void write(int);
    method public void write(char[], int, int);
    method public void write(char[]);
    method public void write(java.lang.String, int, int);
    method public void write(java.lang.String);
    field protected java.io.Writer out;
  }

  public abstract class Reader {
    ctor protected Reader();
    ctor protected Reader(java.lang.Object);
    method public abstract void close() throws java.io.IOException;
    method public void mark(int) throws java.io.IOException;
    method public boolean markSupported();
    method public int read(java.nio.CharBuffer) throws java.io.IOException;
    method public int read() throws java.io.IOException;
    method public int read(char[]) throws java.io.IOException;
    method public abstract int read(char[], int, int) throws java.io.IOException;
    method public boolean ready() throws java.io.IOException;
    method public void reset() throws java.io.IOException;
    method public long skip(long) throws java.io.IOException;
    field protected java.lang.Object lock;
  }

  public class UnsupportedEncodingException extends java.io.IOException {
    ctor public UnsupportedEncodingException();
    ctor public UnsupportedEncodingException(java.lang.String);
  }

  public abstract class Writer implements java.lang.Appendable {
    ctor protected Writer();
    ctor protected Writer(java.lang.Object);
    method public java.io.Writer append(java.lang.CharSequence) throws java.io.IOException;
    method public java.io.Writer append(java.lang.CharSequence, int, int) throws java.io.IOException;
    method public java.io.Writer append(char) throws java.io.IOException;
    method public java.lang.Appendable append(char) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence, int, int) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence) throws java.io.IOException;
    method public abstract void close() throws java.io.IOException;
    method public abstract void flush() throws java.io.IOException;
    method public void write(int) throws java.io.IOException;
    method public void write(char[]) throws java.io.IOException;
    method public abstract void write(char[], int, int) throws java.io.IOException;
    method public void write(java.lang.String) throws java.io.IOException;
    method public void write(java.lang.String, int, int) throws java.io.IOException;
    field protected java.lang.Object lock;
  }

}

package java.lang {

   abstract class AbstractStringBuilder implements java.lang.Appendable java.lang.CharSequence {
    method public java.lang.AbstractStringBuilder append(java.lang.Object);
    method public java.lang.AbstractStringBuilder append(java.lang.String);
    method public java.lang.AbstractStringBuilder append(java.lang.StringBuffer);
    method public java.lang.AbstractStringBuilder append(java.lang.CharSequence);
    method public java.lang.AbstractStringBuilder append(java.lang.CharSequence, int, int);
    method public java.lang.AbstractStringBuilder append(char[]);
    method public java.lang.AbstractStringBuilder append(char[], int, int);
    method public java.lang.AbstractStringBuilder append(boolean);
    method public java.lang.AbstractStringBuilder append(char);
    method public java.lang.AbstractStringBuilder append(int);
    method public java.lang.AbstractStringBuilder append(long);
    method public java.lang.AbstractStringBuilder append(float);
    method public java.lang.AbstractStringBuilder append(double);
    method public java.lang.Appendable append(char) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence, int, int) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence) throws java.io.IOException;
    method public java.lang.AbstractStringBuilder appendCodePoint(int);
    method public int capacity();
    method public char charAt(int);
    method public int codePointAt(int);
    method public int codePointBefore(int);
    method public int codePointCount(int, int);
    method public java.lang.AbstractStringBuilder delete(int, int);
    method public java.lang.AbstractStringBuilder deleteCharAt(int);
    method public void ensureCapacity(int);
    method public void getChars(int, int, char[], int);
    method public int indexOf(java.lang.String);
    method public int indexOf(java.lang.String, int);
    method public java.lang.AbstractStringBuilder insert(int, char[], int, int);
    method public java.lang.AbstractStringBuilder insert(int, java.lang.Object);
    method public java.lang.AbstractStringBuilder insert(int, java.lang.String);
    method public java.lang.AbstractStringBuilder insert(int, char[]);
    method public java.lang.AbstractStringBuilder insert(int, java.lang.CharSequence);
    method public java.lang.AbstractStringBuilder insert(int, java.lang.CharSequence, int, int);
    method public java.lang.AbstractStringBuilder insert(int, boolean);
    method public java.lang.AbstractStringBuilder insert(int, char);
    method public java.lang.AbstractStringBuilder insert(int, int);
    method public java.lang.AbstractStringBuilder insert(int, long);
    method public java.lang.AbstractStringBuilder insert(int, float);
    method public java.lang.AbstractStringBuilder insert(int, double);
    method public int lastIndexOf(java.lang.String);
    method public int lastIndexOf(java.lang.String, int);
    method public int length();
    method public int offsetByCodePoints(int, int);
    method public java.lang.AbstractStringBuilder replace(int, int, java.lang.String);
    method public java.lang.AbstractStringBuilder reverse();
    method public void setCharAt(int, char);
    method public void setLength(int);
    method public java.lang.CharSequence subSequence(int, int);
    method public java.lang.String substring(int);
    method public java.lang.String substring(int, int);
    method public abstract java.lang.String toString();
    method public void trimToSize();
  }

  public abstract interface Appendable {
    method public abstract java.lang.Appendable append(java.lang.CharSequence) throws java.io.IOException;
    method public abstract java.lang.Appendable append(java.lang.CharSequence, int, int) throws java.io.IOException;
    method public abstract java.lang.Appendable append(char) throws java.io.IOException;
  }

  public final class Boolean implements java.lang.Comparable {
    ctor public Boolean(boolean);
    ctor public Boolean(java.lang.String);
    method public boolean booleanValue();
    method public static int compare(boolean, boolean);
    method public int compareTo(java.lang.Boolean);
    method public int compareTo(java.lang.Object);
    method public static boolean getBoolean(java.lang.String);
    method public static int hashCode(boolean);
    method public static boolean logicalAnd(boolean, boolean);
    method public static boolean logicalOr(boolean, boolean);
    method public static boolean logicalXor(boolean, boolean);
    method public static boolean parseBoolean(java.lang.String);
    method public static java.lang.String toString(boolean);
    method public static java.lang.Boolean valueOf(boolean);
    method public static java.lang.Boolean valueOf(java.lang.String);
    field public static final java.lang.Boolean FALSE;
    field public static final java.lang.Boolean TRUE;
    field public static final java.lang.Class<java.lang.Boolean> TYPE;
  }

  public abstract interface CharSequence {
    method public abstract char charAt(int);
    method public default java.util.stream.IntStream chars();
    method public default java.util.stream.IntStream codePoints();
    method public abstract int length();
    method public abstract java.lang.CharSequence subSequence(int, int);
    method public abstract java.lang.String toString();
  }

  public final class Character implements java.lang.Comparable {
    ctor public Character(char);
    method public static int charCount(int);
    method public char charValue();
    method public static int codePointAt(java.lang.CharSequence, int);
    method public static int codePointAt(char[], int);
    method public static int codePointAt(char[], int, int);
    method public static int codePointBefore(java.lang.CharSequence, int);
    method public static int codePointBefore(char[], int);
    method public static int codePointBefore(char[], int, int);
    method public static int codePointCount(java.lang.CharSequence, int, int);
    method public static int codePointCount(char[], int, int);
    method public static int compare(char, char);
    method public int compareTo(java.lang.Character);
    method public int compareTo(java.lang.Object);
    method public static int digit(char, int);
    method public static int digit(int, int);
    method public static char forDigit(int, int);
    method public static byte getDirectionality(char);
    method public static byte getDirectionality(int);
    method public static java.lang.String getName(int);
    method public static int getNumericValue(char);
    method public static int getNumericValue(int);
    method public static int getType(char);
    method public static int getType(int);
    method public static int hashCode(char);
    method public static char highSurrogate(int);
    method public static boolean isAlphabetic(int);
    method public static boolean isBmpCodePoint(int);
    method public static boolean isDefined(char);
    method public static boolean isDefined(int);
    method public static boolean isDigit(char);
    method public static boolean isDigit(int);
    method public static boolean isHighSurrogate(char);
    method public static boolean isISOControl(char);
    method public static boolean isISOControl(int);
    method public static boolean isIdentifierIgnorable(char);
    method public static boolean isIdentifierIgnorable(int);
    method public static boolean isIdeographic(int);
    method public static boolean isJavaIdentifierPart(char);
    method public static boolean isJavaIdentifierPart(int);
    method public static boolean isJavaIdentifierStart(char);
    method public static boolean isJavaIdentifierStart(int);
    method public static deprecated boolean isJavaLetter(char);
    method public static deprecated boolean isJavaLetterOrDigit(char);
    method public static boolean isLetter(char);
    method public static boolean isLetter(int);
    method public static boolean isLetterOrDigit(char);
    method public static boolean isLetterOrDigit(int);
    method public static boolean isLowSurrogate(char);
    method public static boolean isLowerCase(char);
    method public static boolean isLowerCase(int);
    method public static boolean isMirrored(char);
    method public static boolean isMirrored(int);
    method public static deprecated boolean isSpace(char);
    method public static boolean isSpaceChar(char);
    method public static boolean isSpaceChar(int);
    method public static boolean isSupplementaryCodePoint(int);
    method public static boolean isSurrogate(char);
    method public static boolean isSurrogatePair(char, char);
    method public static boolean isTitleCase(char);
    method public static boolean isTitleCase(int);
    method public static boolean isUnicodeIdentifierPart(char);
    method public static boolean isUnicodeIdentifierPart(int);
    method public static boolean isUnicodeIdentifierStart(char);
    method public static boolean isUnicodeIdentifierStart(int);
    method public static boolean isUpperCase(char);
    method public static boolean isUpperCase(int);
    method public static boolean isValidCodePoint(int);
    method public static boolean isWhitespace(char);
    method public static boolean isWhitespace(int);
    method public static char lowSurrogate(int);
    method public static int offsetByCodePoints(java.lang.CharSequence, int, int);
    method public static int offsetByCodePoints(char[], int, int, int, int);
    method public static char reverseBytes(char);
    method public static int toChars(int, char[], int);
    method public static char[] toChars(int);
    method public static int toCodePoint(char, char);
    method public static char toLowerCase(char);
    method public static int toLowerCase(int);
    method public static java.lang.String toString(char);
    method public static char toTitleCase(char);
    method public static int toTitleCase(int);
    method public static char toUpperCase(char);
    method public static int toUpperCase(int);
    method public static java.lang.Character valueOf(char);
    field public static final int BYTES = 2; // 0x2
    field public static final byte COMBINING_SPACING_MARK = 8; // 0x8
    field public static final byte CONNECTOR_PUNCTUATION = 23; // 0x17
    field public static final byte CONTROL = 15; // 0xf
    field public static final byte CURRENCY_SYMBOL = 26; // 0x1a
    field public static final byte DASH_PUNCTUATION = 20; // 0x14
    field public static final byte DECIMAL_DIGIT_NUMBER = 9; // 0x9
    field public static final byte DIRECTIONALITY_ARABIC_NUMBER = 6; // 0x6
    field public static final byte DIRECTIONALITY_BOUNDARY_NEUTRAL = 9; // 0x9
    field public static final byte DIRECTIONALITY_COMMON_NUMBER_SEPARATOR = 7; // 0x7
    field public static final byte DIRECTIONALITY_EUROPEAN_NUMBER = 3; // 0x3
    field public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR = 4; // 0x4
    field public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR = 5; // 0x5
    field public static final byte DIRECTIONALITY_LEFT_TO_RIGHT = 0; // 0x0
    field public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING = 14; // 0xe
    field public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE = 15; // 0xf
    field public static final byte DIRECTIONALITY_NONSPACING_MARK = 8; // 0x8
    field public static final byte DIRECTIONALITY_OTHER_NEUTRALS = 13; // 0xd
    field public static final byte DIRECTIONALITY_PARAGRAPH_SEPARATOR = 10; // 0xa
    field public static final byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT = 18; // 0x12
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT = 1; // 0x1
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC = 2; // 0x2
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING = 16; // 0x10
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE = 17; // 0x11
    field public static final byte DIRECTIONALITY_SEGMENT_SEPARATOR = 11; // 0xb
    field public static final byte DIRECTIONALITY_UNDEFINED = -1; // 0xffffffff
    field public static final byte DIRECTIONALITY_WHITESPACE = 12; // 0xc
    field public static final byte ENCLOSING_MARK = 7; // 0x7
    field public static final byte END_PUNCTUATION = 22; // 0x16
    field public static final byte FINAL_QUOTE_PUNCTUATION = 30; // 0x1e
    field public static final byte FORMAT = 16; // 0x10
    field public static final byte INITIAL_QUOTE_PUNCTUATION = 29; // 0x1d
    field public static final byte LETTER_NUMBER = 10; // 0xa
    field public static final byte LINE_SEPARATOR = 13; // 0xd
    field public static final byte LOWERCASE_LETTER = 2; // 0x2
    field public static final byte MATH_SYMBOL = 25; // 0x19
    field public static final int MAX_CODE_POINT = 1114111; // 0x10ffff
    field public static final char MAX_HIGH_SURROGATE = 56319; // 0xdbff '\udbff'
    field public static final char MAX_LOW_SURROGATE = 57343; // 0xdfff '\udfff'
    field public static final int MAX_RADIX = 36; // 0x24
    field public static final char MAX_SURROGATE = 57343; // 0xdfff '\udfff'
    field public static final char MAX_VALUE = 65535; // 0xffff '\uffff'
    field public static final int MIN_CODE_POINT = 0; // 0x0
    field public static final char MIN_HIGH_SURROGATE = 55296; // 0xd800 '\ud800'
    field public static final char MIN_LOW_SURROGATE = 56320; // 0xdc00 '\udc00'
    field public static final int MIN_RADIX = 2; // 0x2
    field public static final int MIN_SUPPLEMENTARY_CODE_POINT = 65536; // 0x10000
    field public static final char MIN_SURROGATE = 55296; // 0xd800 '\ud800'
    field public static final char MIN_VALUE = 0; // 0x0000 '\u0000'
    field public static final byte MODIFIER_LETTER = 4; // 0x4
    field public static final byte MODIFIER_SYMBOL = 27; // 0x1b
    field public static final byte NON_SPACING_MARK = 6; // 0x6
    field public static final byte OTHER_LETTER = 5; // 0x5
    field public static final byte OTHER_NUMBER = 11; // 0xb
    field public static final byte OTHER_PUNCTUATION = 24; // 0x18
    field public static final byte OTHER_SYMBOL = 28; // 0x1c
    field public static final byte PARAGRAPH_SEPARATOR = 14; // 0xe
    field public static final byte PRIVATE_USE = 18; // 0x12
    field public static final int SIZE = 16; // 0x10
    field public static final byte SPACE_SEPARATOR = 12; // 0xc
    field public static final byte START_PUNCTUATION = 21; // 0x15
    field public static final byte SURROGATE = 19; // 0x13
    field public static final byte TITLECASE_LETTER = 3; // 0x3
    field public static final java.lang.Class<java.lang.Character> TYPE;
    field public static final byte UNASSIGNED = 0; // 0x0
    field public static final byte UPPERCASE_LETTER = 1; // 0x1
  }

  public final class Class<T> implements java.lang.reflect.GenericDeclaration java.lang.reflect.Type {
    method public <U> java.lang.Class<? extends U> asSubclass(java.lang.Class<U>);
    method public T cast(java.lang.Object);
    method public boolean desiredAssertionStatus();
    method public static java.lang.Class<?> forName(java.lang.String) throws java.lang.ClassNotFoundException;
    method public static java.lang.Class<?> forName(java.lang.String, boolean, java.lang.ClassLoader) throws java.lang.ClassNotFoundException;
    method public java.lang.reflect.AnnotatedType[] getAnnotatedInterfaces();
    method public java.lang.reflect.AnnotatedType getAnnotatedSuperclass();
    method public <A extends java.lang.annotation.Annotation> A getAnnotation(java.lang.Class<A>);
    method public java.lang.annotation.Annotation[] getAnnotations();
    method public <A extends java.lang.annotation.Annotation> A[] getAnnotationsByType(java.lang.Class<A>);
    method public java.lang.String getCanonicalName();
    method public java.lang.ClassLoader getClassLoader();
    method public java.lang.Class<?>[] getClasses();
    method public java.lang.Class<?> getComponentType();
    method public java.lang.reflect.Constructor<T> getConstructor(java.lang.Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method public java.lang.reflect.Constructor<?>[] getConstructors() throws java.lang.SecurityException;
    method public <A extends java.lang.annotation.Annotation> A getDeclaredAnnotation(java.lang.Class<A>);
    method public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public <A extends java.lang.annotation.Annotation> A[] getDeclaredAnnotationsByType(java.lang.Class<A>);
    method public java.lang.Class<?>[] getDeclaredClasses() throws java.lang.SecurityException;
    method public java.lang.reflect.Constructor<T> getDeclaredConstructor(java.lang.Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method public java.lang.reflect.Constructor<?>[] getDeclaredConstructors() throws java.lang.SecurityException;
    method public java.lang.reflect.Field getDeclaredField(java.lang.String) throws java.lang.NoSuchFieldException, java.lang.SecurityException;
    method public java.lang.reflect.Field[] getDeclaredFields() throws java.lang.SecurityException;
    method public java.lang.reflect.Method getDeclaredMethod(java.lang.String, java.lang.Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method public java.lang.reflect.Method[] getDeclaredMethods() throws java.lang.SecurityException;
    method public java.lang.Class<?> getDeclaringClass() throws java.lang.SecurityException;
    method public java.lang.Class<?> getEnclosingClass() throws java.lang.SecurityException;
    method public java.lang.reflect.Constructor<?> getEnclosingConstructor() throws java.lang.SecurityException;
    method public java.lang.reflect.Method getEnclosingMethod() throws java.lang.SecurityException;
    method public T[] getEnumConstants();
    method public java.lang.reflect.Field getField(java.lang.String) throws java.lang.NoSuchFieldException, java.lang.SecurityException;
    method public java.lang.reflect.Field[] getFields() throws java.lang.SecurityException;
    method public java.lang.reflect.Type[] getGenericInterfaces();
    method public java.lang.reflect.Type getGenericSuperclass();
    method public java.lang.Class<?>[] getInterfaces();
    method public java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method public java.lang.reflect.Method[] getMethods() throws java.lang.SecurityException;
    method public int getModifiers();
    method public java.lang.String getName();
    method public java.lang.Package getPackage();
    method public java.security.ProtectionDomain getProtectionDomain();
    method public java.net.URL getResource(java.lang.String);
    method public java.io.InputStream getResourceAsStream(java.lang.String);
    method public java.lang.Object[] getSigners();
    method public java.lang.String getSimpleName();
    method public java.lang.Class<? super T> getSuperclass();
    method public java.lang.reflect.TypeVariable<java.lang.Class<T>>[] getTypeParameters();
    method public boolean isAnnotation();
    method public boolean isAnonymousClass();
    method public boolean isArray();
    method public boolean isAssignableFrom(java.lang.Class<?>);
    method public boolean isEnum();
    method public boolean isInstance(java.lang.Object);
    method public boolean isInterface();
    method public boolean isLocalClass();
    method public boolean isMemberClass();
    method public boolean isPrimitive();
    method public boolean isSynthetic();
    method public T newInstance() throws java.lang.IllegalAccessException, java.lang.InstantiationException;
    method public java.lang.String toGenericString();
  }

  public class ClassFormatError extends java.lang.LinkageError {
    ctor public ClassFormatError();
    ctor public ClassFormatError(java.lang.String);
  }

  public abstract class ClassLoader {
    ctor protected ClassLoader(java.lang.ClassLoader);
    ctor protected ClassLoader();
    method public void clearAssertionStatus();
    method protected final deprecated java.lang.Class<?> defineClass(byte[], int, int) throws java.lang.ClassFormatError;
    method protected final java.lang.Class<?> defineClass(java.lang.String, byte[], int, int) throws java.lang.ClassFormatError;
    method protected final java.lang.Class<?> defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain) throws java.lang.ClassFormatError;
    method protected final java.lang.Class<?> defineClass(java.lang.String, java.nio.ByteBuffer, java.security.ProtectionDomain) throws java.lang.ClassFormatError;
    method protected java.lang.Package definePackage(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.net.URL) throws java.lang.IllegalArgumentException;
    method protected java.lang.Class<?> findClass(java.lang.String) throws java.lang.ClassNotFoundException;
    method protected java.lang.String findLibrary(java.lang.String);
    method protected final java.lang.Class<?> findLoadedClass(java.lang.String);
    method protected java.net.URL findResource(java.lang.String);
    method protected java.util.Enumeration<java.net.URL> findResources(java.lang.String) throws java.io.IOException;
    method protected final java.lang.Class<?> findSystemClass(java.lang.String) throws java.lang.ClassNotFoundException;
    method protected java.lang.Object getClassLoadingLock(java.lang.String);
    method protected java.lang.Package getPackage(java.lang.String);
    method protected java.lang.Package[] getPackages();
    method public final java.lang.ClassLoader getParent();
    method public java.net.URL getResource(java.lang.String);
    method public java.io.InputStream getResourceAsStream(java.lang.String);
    method public java.util.Enumeration<java.net.URL> getResources(java.lang.String) throws java.io.IOException;
    method public static java.lang.ClassLoader getSystemClassLoader();
    method public static java.net.URL getSystemResource(java.lang.String);
    method public static java.io.InputStream getSystemResourceAsStream(java.lang.String);
    method public static java.util.Enumeration<java.net.URL> getSystemResources(java.lang.String) throws java.io.IOException;
    method public java.lang.Class<?> loadClass(java.lang.String) throws java.lang.ClassNotFoundException;
    method protected java.lang.Class<?> loadClass(java.lang.String, boolean) throws java.lang.ClassNotFoundException;
    method protected static boolean registerAsParallelCapable();
    method protected final void resolveClass(java.lang.Class<?>);
    method public void setClassAssertionStatus(java.lang.String, boolean);
    method public void setDefaultAssertionStatus(boolean);
    method public void setPackageAssertionStatus(java.lang.String, boolean);
    method protected final void setSigners(java.lang.Class<?>, java.lang.Object[]);
  }

  public class ClassNotFoundException extends java.lang.ReflectiveOperationException {
    ctor public ClassNotFoundException();
    ctor public ClassNotFoundException(java.lang.String);
    ctor public ClassNotFoundException(java.lang.String, java.lang.Throwable);
    method public java.lang.Throwable getCause();
    method public java.lang.Throwable getException();
  }

  public class CloneNotSupportedException extends java.lang.Exception {
    ctor public CloneNotSupportedException();
    ctor public CloneNotSupportedException(java.lang.String);
  }

  public abstract interface Comparable<T> {
    method public abstract int compareTo(T);
  }

  public final class Double extends java.lang.Number implements java.lang.Comparable {
    ctor public Double(double);
    ctor public Double(java.lang.String) throws java.lang.NumberFormatException;
    method public static int compare(double, double);
    method public int compareTo(java.lang.Double);
    method public int compareTo(java.lang.Object);
    method public static long doubleToLongBits(double);
    method public static long doubleToRawLongBits(double);
    method public double doubleValue();
    method public float floatValue();
    method public static int hashCode(double);
    method public int intValue();
    method public static boolean isFinite(double);
    method public static boolean isInfinite(double);
    method public boolean isInfinite();
    method public static boolean isNaN(double);
    method public boolean isNaN();
    method public static double longBitsToDouble(long);
    method public long longValue();
    method public static double max(double, double);
    method public static double min(double, double);
    method public static double parseDouble(java.lang.String) throws java.lang.NumberFormatException;
    method public static double sum(double, double);
    method public static java.lang.String toHexString(double);
    method public static java.lang.String toString(double);
    method public static java.lang.Double valueOf(java.lang.String) throws java.lang.NumberFormatException;
    method public static java.lang.Double valueOf(double);
    field public static final int BYTES = 8; // 0x8
    field public static final int MAX_EXPONENT = 1023; // 0x3ff
    field public static final double MAX_VALUE = 1.7976931348623157E308;
    field public static final int MIN_EXPONENT = -1022; // 0xfffffc02
    field public static final double MIN_NORMAL = 2.2250738585072014E-308;
    field public static final double MIN_VALUE = 4.9E-324;
    field public static final double NEGATIVE_INFINITY = (-1.0/0.0);
    field public static final double NaN = (0.0/0.0);
    field public static final double POSITIVE_INFINITY = (1.0/0.0);
    field public static final int SIZE = 64; // 0x40
    field public static final java.lang.Class<java.lang.Double> TYPE;
  }

  public abstract class Enum<E extends java.lang.Enum<E>> implements java.lang.Comparable {
    ctor protected Enum(java.lang.String, int);
    method protected final java.lang.Object clone() throws java.lang.CloneNotSupportedException;
    method public final int compareTo(E);
    method public int compareTo(java.lang.Object);
    method public final boolean equals(java.lang.Object);
    method protected final void finalize();
    method public final java.lang.Class<E> getDeclaringClass();
    method public final int hashCode();
    method public final java.lang.String name();
    method public final int ordinal();
    method public static <T extends java.lang.Enum<T>> T valueOf(java.lang.Class<T>, java.lang.String);
  }

  public class Error extends java.lang.Throwable {
    ctor public Error();
    ctor public Error(java.lang.String);
    ctor public Error(java.lang.String, java.lang.Throwable);
    ctor public Error(java.lang.Throwable);
    ctor protected Error(java.lang.String, java.lang.Throwable, boolean, boolean);
  }

  public class Exception extends java.lang.Throwable {
    ctor public Exception();
    ctor public Exception(java.lang.String);
    ctor public Exception(java.lang.String, java.lang.Throwable);
    ctor public Exception(java.lang.Throwable);
    ctor protected Exception(java.lang.String, java.lang.Throwable, boolean, boolean);
  }

  public class IllegalAccessException extends java.lang.ReflectiveOperationException {
    ctor public IllegalAccessException();
    ctor public IllegalAccessException(java.lang.String);
  }

  public class IllegalArgumentException extends java.lang.RuntimeException {
    ctor public IllegalArgumentException();
    ctor public IllegalArgumentException(java.lang.String);
    ctor public IllegalArgumentException(java.lang.String, java.lang.Throwable);
    ctor public IllegalArgumentException(java.lang.Throwable);
  }

  public class InstantiationException extends java.lang.ReflectiveOperationException {
    ctor public InstantiationException();
    ctor public InstantiationException(java.lang.String);
  }

  public final class Integer extends java.lang.Number implements java.lang.Comparable {
    ctor public Integer(int);
    ctor public Integer(java.lang.String) throws java.lang.NumberFormatException;
    method public static int bitCount(int);
    method public static int compare(int, int);
    method public int compareTo(java.lang.Integer);
    method public int compareTo(java.lang.Object);
    method public static int compareUnsigned(int, int);
    method public static java.lang.Integer decode(java.lang.String) throws java.lang.NumberFormatException;
    method public static int divideUnsigned(int, int);
    method public double doubleValue();
    method public float floatValue();
    method public static java.lang.Integer getInteger(java.lang.String);
    method public static java.lang.Integer getInteger(java.lang.String, int);
    method public static java.lang.Integer getInteger(java.lang.String, java.lang.Integer);
    method public static int hashCode(int);
    method public static int highestOneBit(int);
    method public int intValue();
    method public long longValue();
    method public static int lowestOneBit(int);
    method public static int max(int, int);
    method public static int min(int, int);
    method public static int numberOfLeadingZeros(int);
    method public static int numberOfTrailingZeros(int);
    method public static int parseInt(java.lang.String, int) throws java.lang.NumberFormatException;
    method public static int parseInt(java.lang.String) throws java.lang.NumberFormatException;
    method public static int parseUnsignedInt(java.lang.String, int) throws java.lang.NumberFormatException;
    method public static int parseUnsignedInt(java.lang.String) throws java.lang.NumberFormatException;
    method public static int remainderUnsigned(int, int);
    method public static int reverse(int);
    method public static int reverseBytes(int);
    method public static int rotateLeft(int, int);
    method public static int rotateRight(int, int);
    method public static int signum(int);
    method public static int sum(int, int);
    method public static java.lang.String toBinaryString(int);
    method public static java.lang.String toHexString(int);
    method public static java.lang.String toOctalString(int);
    method public static java.lang.String toString(int, int);
    method public static java.lang.String toString(int);
    method public static long toUnsignedLong(int);
    method public static java.lang.String toUnsignedString(int, int);
    method public static java.lang.String toUnsignedString(int);
    method public static java.lang.Integer valueOf(java.lang.String, int) throws java.lang.NumberFormatException;
    method public static java.lang.Integer valueOf(java.lang.String) throws java.lang.NumberFormatException;
    method public static java.lang.Integer valueOf(int);
    field public static final int BYTES = 4; // 0x4
    field public static final int MAX_VALUE = 2147483647; // 0x7fffffff
    field public static final int MIN_VALUE = -2147483648; // 0x80000000
    field public static final int SIZE = 32; // 0x20
    field public static final java.lang.Class<java.lang.Integer> TYPE;
  }

  public class InterruptedException extends java.lang.Exception {
    ctor public InterruptedException();
    ctor public InterruptedException(java.lang.String);
  }

  public abstract interface Iterable<T> {
    method public default void forEach(java.util.function.Consumer<? super T>);
    method public abstract java.util.Iterator<T> iterator();
    method public default java.util.Spliterator<T> spliterator();
  }

  public class LinkageError extends java.lang.Error {
    ctor public LinkageError();
    ctor public LinkageError(java.lang.String);
    ctor public LinkageError(java.lang.String, java.lang.Throwable);
  }

  public final class Long extends java.lang.Number implements java.lang.Comparable {
    ctor public Long(long);
    ctor public Long(java.lang.String) throws java.lang.NumberFormatException;
    method public static int bitCount(long);
    method public static int compare(long, long);
    method public int compareTo(java.lang.Long);
    method public int compareTo(java.lang.Object);
    method public static int compareUnsigned(long, long);
    method public static java.lang.Long decode(java.lang.String) throws java.lang.NumberFormatException;
    method public static long divideUnsigned(long, long);
    method public double doubleValue();
    method public float floatValue();
    method public static java.lang.Long getLong(java.lang.String);
    method public static java.lang.Long getLong(java.lang.String, long);
    method public static java.lang.Long getLong(java.lang.String, java.lang.Long);
    method public static int hashCode(long);
    method public static long highestOneBit(long);
    method public int intValue();
    method public long longValue();
    method public static long lowestOneBit(long);
    method public static long max(long, long);
    method public static long min(long, long);
    method public static int numberOfLeadingZeros(long);
    method public static int numberOfTrailingZeros(long);
    method public static long parseLong(java.lang.String, int) throws java.lang.NumberFormatException;
    method public static long parseLong(java.lang.String) throws java.lang.NumberFormatException;
    method public static long parseUnsignedLong(java.lang.String, int) throws java.lang.NumberFormatException;
    method public static long parseUnsignedLong(java.lang.String) throws java.lang.NumberFormatException;
    method public static long remainderUnsigned(long, long);
    method public static long reverse(long);
    method public static long reverseBytes(long);
    method public static long rotateLeft(long, int);
    method public static long rotateRight(long, int);
    method public static int signum(long);
    method public static long sum(long, long);
    method public static java.lang.String toBinaryString(long);
    method public static java.lang.String toHexString(long);
    method public static java.lang.String toOctalString(long);
    method public static java.lang.String toString(long, int);
    method public static java.lang.String toString(long);
    method public static java.lang.String toUnsignedString(long, int);
    method public static java.lang.String toUnsignedString(long);
    method public static java.lang.Long valueOf(java.lang.String, int) throws java.lang.NumberFormatException;
    method public static java.lang.Long valueOf(java.lang.String) throws java.lang.NumberFormatException;
    method public static java.lang.Long valueOf(long);
    field public static final int BYTES = 8; // 0x8
    field public static final long MAX_VALUE = 9223372036854775807L; // 0x7fffffffffffffffL
    field public static final long MIN_VALUE = -9223372036854775808L; // 0x8000000000000000L
    field public static final int SIZE = 64; // 0x40
    field public static final java.lang.Class<java.lang.Long> TYPE;
  }

  public class NoSuchFieldException extends java.lang.ReflectiveOperationException {
    ctor public NoSuchFieldException();
    ctor public NoSuchFieldException(java.lang.String);
  }

  public class NoSuchMethodException extends java.lang.ReflectiveOperationException {
    ctor public NoSuchMethodException();
    ctor public NoSuchMethodException(java.lang.String);
  }

  public abstract class Number {
    ctor public Number();
    method public byte byteValue();
    method public abstract double doubleValue();
    method public abstract float floatValue();
    method public abstract int intValue();
    method public abstract long longValue();
    method public short shortValue();
  }

  public class NumberFormatException extends java.lang.IllegalArgumentException {
    ctor public NumberFormatException();
    ctor public NumberFormatException(java.lang.String);
  }

  public class Object {
    ctor public Object();
    method protected java.lang.Object clone() throws java.lang.CloneNotSupportedException;
    method public boolean equals(java.lang.Object);
    method protected void finalize() throws java.lang.Throwable;
    method public final java.lang.Class<?> getClass();
    method public int hashCode();
    method public final void notify();
    method public final void notifyAll();
    method public java.lang.String toString();
    method public final void wait(long) throws java.lang.InterruptedException;
    method public final void wait(long, int) throws java.lang.InterruptedException;
    method public final void wait() throws java.lang.InterruptedException;
  }

  public class Package {
    method public <A extends java.lang.annotation.Annotation> A getAnnotation(java.lang.Class<A>);
    method public java.lang.annotation.Annotation[] getAnnotations();
    method public <A extends java.lang.annotation.Annotation> A[] getAnnotationsByType(java.lang.Class<A>);
    method public <A extends java.lang.annotation.Annotation> A getDeclaredAnnotation(java.lang.Class<A>);
    method public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public <A extends java.lang.annotation.Annotation> A[] getDeclaredAnnotationsByType(java.lang.Class<A>);
    method public java.lang.String getImplementationTitle();
    method public java.lang.String getImplementationVendor();
    method public java.lang.String getImplementationVersion();
    method public java.lang.String getName();
    method public static java.lang.Package getPackage(java.lang.String);
    method public static java.lang.Package[] getPackages();
    method public java.lang.String getSpecificationTitle();
    method public java.lang.String getSpecificationVendor();
    method public java.lang.String getSpecificationVersion();
    method public boolean isCompatibleWith(java.lang.String) throws java.lang.NumberFormatException;
    method public boolean isSealed();
    method public boolean isSealed(java.net.URL);
  }

  public class ReflectiveOperationException extends java.lang.Exception {
    ctor public ReflectiveOperationException();
    ctor public ReflectiveOperationException(java.lang.String);
    ctor public ReflectiveOperationException(java.lang.String, java.lang.Throwable);
    ctor public ReflectiveOperationException(java.lang.Throwable);
  }

  public abstract interface Runnable {
    method public abstract void run();
  }

  public class RuntimeException extends java.lang.Exception {
    ctor public RuntimeException();
    ctor public RuntimeException(java.lang.String);
    ctor public RuntimeException(java.lang.String, java.lang.Throwable);
    ctor public RuntimeException(java.lang.Throwable);
    ctor protected RuntimeException(java.lang.String, java.lang.Throwable, boolean, boolean);
  }

  public class SecurityException extends java.lang.RuntimeException {
    ctor public SecurityException();
    ctor public SecurityException(java.lang.String);
    ctor public SecurityException(java.lang.String, java.lang.Throwable);
    ctor public SecurityException(java.lang.Throwable);
  }

  public final class StackTraceElement {
    ctor public StackTraceElement(java.lang.String, java.lang.String, java.lang.String, int);
    method public java.lang.String getClassName();
    method public java.lang.String getFileName();
    method public int getLineNumber();
    method public java.lang.String getMethodName();
    method public boolean isNativeMethod();
  }

  public final class String implements java.lang.CharSequence java.lang.Comparable {
    ctor public String();
    ctor public String(java.lang.String);
    ctor public String(char[]);
    ctor public String(char[], int, int);
    ctor public String(int[], int, int);
    ctor public deprecated String(byte[], int, int, int);
    ctor public deprecated String(byte[], int);
    ctor public String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
    ctor public String(byte[], int, int, java.nio.charset.Charset);
    ctor public String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException;
    ctor public String(byte[], java.nio.charset.Charset);
    ctor public String(byte[], int, int);
    ctor public String(byte[]);
    ctor public String(java.lang.StringBuffer);
    ctor public String(java.lang.StringBuilder);
    method public char charAt(int);
    method public int codePointAt(int);
    method public int codePointBefore(int);
    method public int codePointCount(int, int);
    method public int compareTo(java.lang.String);
    method public int compareTo(java.lang.Object);
    method public int compareToIgnoreCase(java.lang.String);
    method public java.lang.String concat(java.lang.String);
    method public boolean contains(java.lang.CharSequence);
    method public boolean contentEquals(java.lang.StringBuffer);
    method public boolean contentEquals(java.lang.CharSequence);
    method public static java.lang.String copyValueOf(char[], int, int);
    method public static java.lang.String copyValueOf(char[]);
    method public boolean endsWith(java.lang.String);
    method public boolean equalsIgnoreCase(java.lang.String);
    method public static java.lang.String format(java.lang.String, java.lang.Object...);
    method public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object...);
    method public deprecated void getBytes(int, int, byte[], int);
    method public byte[] getBytes(java.lang.String) throws java.io.UnsupportedEncodingException;
    method public byte[] getBytes(java.nio.charset.Charset);
    method public byte[] getBytes();
    method public void getChars(int, int, char[], int);
    method public int indexOf(int);
    method public int indexOf(int, int);
    method public int indexOf(java.lang.String);
    method public int indexOf(java.lang.String, int);
    method public java.lang.String intern();
    method public boolean isEmpty();
    method public static java.lang.String join(java.lang.CharSequence, java.lang.CharSequence...);
    method public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable<? extends java.lang.CharSequence>);
    method public int lastIndexOf(int);
    method public int lastIndexOf(int, int);
    method public int lastIndexOf(java.lang.String);
    method public int lastIndexOf(java.lang.String, int);
    method public int length();
    method public boolean matches(java.lang.String);
    method public int offsetByCodePoints(int, int);
    method public boolean regionMatches(int, java.lang.String, int, int);
    method public boolean regionMatches(boolean, int, java.lang.String, int, int);
    method public java.lang.String replace(char, char);
    method public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);
    method public java.lang.String replaceAll(java.lang.String, java.lang.String);
    method public java.lang.String replaceFirst(java.lang.String, java.lang.String);
    method public java.lang.String[] split(java.lang.String, int);
    method public java.lang.String[] split(java.lang.String);
    method public boolean startsWith(java.lang.String, int);
    method public boolean startsWith(java.lang.String);
    method public java.lang.CharSequence subSequence(int, int);
    method public java.lang.String substring(int);
    method public java.lang.String substring(int, int);
    method public char[] toCharArray();
    method public java.lang.String toLowerCase(java.util.Locale);
    method public java.lang.String toLowerCase();
    method public java.lang.String toUpperCase(java.util.Locale);
    method public java.lang.String toUpperCase();
    method public java.lang.String trim();
    method public static java.lang.String valueOf(java.lang.Object);
    method public static java.lang.String valueOf(char[]);
    method public static java.lang.String valueOf(char[], int, int);
    method public static java.lang.String valueOf(boolean);
    method public static java.lang.String valueOf(char);
    method public static java.lang.String valueOf(int);
    method public static java.lang.String valueOf(long);
    method public static java.lang.String valueOf(float);
    method public static java.lang.String valueOf(double);
    field public static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;
  }

  public final class StringBuffer extends java.lang.AbstractStringBuilder implements java.lang.CharSequence {
    ctor public StringBuffer();
    ctor public StringBuffer(int);
    ctor public StringBuffer(java.lang.String);
    ctor public StringBuffer(java.lang.CharSequence);
    method public synchronized java.lang.StringBuffer append(java.lang.Object);
    method public synchronized java.lang.StringBuffer append(java.lang.String);
    method public synchronized java.lang.StringBuffer append(java.lang.StringBuffer);
    method public synchronized java.lang.StringBuffer append(java.lang.CharSequence);
    method public synchronized java.lang.StringBuffer append(java.lang.CharSequence, int, int);
    method public synchronized java.lang.StringBuffer append(char[]);
    method public synchronized java.lang.StringBuffer append(char[], int, int);
    method public synchronized java.lang.StringBuffer append(boolean);
    method public synchronized java.lang.StringBuffer append(char);
    method public synchronized java.lang.StringBuffer append(int);
    method public synchronized java.lang.StringBuffer append(long);
    method public synchronized java.lang.StringBuffer append(float);
    method public synchronized java.lang.StringBuffer append(double);
    method public java.lang.AbstractStringBuilder append(char);
    method public java.lang.AbstractStringBuilder append(java.lang.CharSequence, int, int);
    method public java.lang.AbstractStringBuilder append(java.lang.CharSequence);
    method public synchronized java.lang.StringBuffer appendCodePoint(int);
    method public synchronized int capacity();
    method public synchronized char charAt(int);
    method public synchronized int codePointAt(int);
    method public synchronized int codePointBefore(int);
    method public synchronized int codePointCount(int, int);
    method public synchronized java.lang.StringBuffer delete(int, int);
    method public synchronized java.lang.StringBuffer deleteCharAt(int);
    method public synchronized void ensureCapacity(int);
    method public synchronized void getChars(int, int, char[], int);
    method public synchronized int indexOf(java.lang.String, int);
    method public synchronized java.lang.StringBuffer insert(int, char[], int, int);
    method public synchronized java.lang.StringBuffer insert(int, java.lang.Object);
    method public synchronized java.lang.StringBuffer insert(int, java.lang.String);
    method public synchronized java.lang.StringBuffer insert(int, char[]);
    method public java.lang.StringBuffer insert(int, java.lang.CharSequence);
    method public synchronized java.lang.StringBuffer insert(int, java.lang.CharSequence, int, int);
    method public java.lang.StringBuffer insert(int, boolean);
    method public synchronized java.lang.StringBuffer insert(int, char);
    method public java.lang.StringBuffer insert(int, int);
    method public java.lang.StringBuffer insert(int, long);
    method public java.lang.StringBuffer insert(int, float);
    method public java.lang.StringBuffer insert(int, double);
    method public synchronized int lastIndexOf(java.lang.String, int);
    method public synchronized int length();
    method public synchronized int offsetByCodePoints(int, int);
    method public synchronized java.lang.StringBuffer replace(int, int, java.lang.String);
    method public synchronized java.lang.StringBuffer reverse();
    method public synchronized void setCharAt(int, char);
    method public synchronized void setLength(int);
    method public synchronized java.lang.CharSequence subSequence(int, int);
    method public synchronized java.lang.String substring(int);
    method public synchronized java.lang.String substring(int, int);
    method public synchronized java.lang.String toString();
    method public synchronized void trimToSize();
  }

  public final class StringBuilder extends java.lang.AbstractStringBuilder implements java.lang.CharSequence {
    ctor public StringBuilder();
    ctor public StringBuilder(int);
    ctor public StringBuilder(java.lang.String);
    ctor public StringBuilder(java.lang.CharSequence);
    method public java.lang.StringBuilder append(java.lang.Object);
    method public java.lang.StringBuilder append(java.lang.String);
    method public java.lang.StringBuilder append(java.lang.StringBuffer);
    method public java.lang.StringBuilder append(java.lang.CharSequence);
    method public java.lang.StringBuilder append(java.lang.CharSequence, int, int);
    method public java.lang.StringBuilder append(char[]);
    method public java.lang.StringBuilder append(char[], int, int);
    method public java.lang.StringBuilder append(boolean);
    method public java.lang.StringBuilder append(char);
    method public java.lang.StringBuilder append(int);
    method public java.lang.StringBuilder append(long);
    method public java.lang.StringBuilder append(float);
    method public java.lang.StringBuilder append(double);
    method public java.lang.AbstractStringBuilder append(char);
    method public java.lang.AbstractStringBuilder append(java.lang.CharSequence, int, int);
    method public java.lang.AbstractStringBuilder append(java.lang.CharSequence);
    method public java.lang.StringBuilder appendCodePoint(int);
    method public java.lang.StringBuilder delete(int, int);
    method public java.lang.StringBuilder deleteCharAt(int);
    method public java.lang.StringBuilder insert(int, char[], int, int);
    method public java.lang.StringBuilder insert(int, java.lang.Object);
    method public java.lang.StringBuilder insert(int, java.lang.String);
    method public java.lang.StringBuilder insert(int, char[]);
    method public java.lang.StringBuilder insert(int, java.lang.CharSequence);
    method public java.lang.StringBuilder insert(int, java.lang.CharSequence, int, int);
    method public java.lang.StringBuilder insert(int, boolean);
    method public java.lang.StringBuilder insert(int, char);
    method public java.lang.StringBuilder insert(int, int);
    method public java.lang.StringBuilder insert(int, long);
    method public java.lang.StringBuilder insert(int, float);
    method public java.lang.StringBuilder insert(int, double);
    method public java.lang.StringBuilder replace(int, int, java.lang.String);
    method public java.lang.StringBuilder reverse();
    method public java.lang.String toString();
  }

  public class Thread implements java.lang.Runnable {
    ctor public Thread();
    ctor public Thread(java.lang.Runnable);
    ctor public Thread(java.lang.ThreadGroup, java.lang.Runnable);
    ctor public Thread(java.lang.String);
    ctor public Thread(java.lang.ThreadGroup, java.lang.String);
    ctor public Thread(java.lang.Runnable, java.lang.String);
    ctor public Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String);
    ctor public Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long);
    method public static int activeCount();
    method public final void checkAccess();
    method public deprecated int countStackFrames();
    method public static java.lang.Thread currentThread();
    method public deprecated void destroy();
    method public static void dumpStack();
    method public static int enumerate(java.lang.Thread[]);
    method public static java.util.Map<java.lang.Thread, java.lang.StackTraceElement[]> getAllStackTraces();
    method public java.lang.ClassLoader getContextClassLoader();
    method public static java.lang.Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler();
    method public long getId();
    method public final java.lang.String getName();
    method public final int getPriority();
    method public java.lang.StackTraceElement[] getStackTrace();
    method public java.lang.Thread.State getState();
    method public final java.lang.ThreadGroup getThreadGroup();
    method public java.lang.Thread.UncaughtExceptionHandler getUncaughtExceptionHandler();
    method public long googleGetContext0();
    method public void googleSetContext0(long);
    method public static boolean holdsLock(java.lang.Object);
    method public void interrupt();
    method public static boolean interrupted();
    method public final boolean isAlive();
    method public final boolean isDaemon();
    method public boolean isInterrupted();
    method public final synchronized void join(long) throws java.lang.InterruptedException;
    method public final synchronized void join(long, int) throws java.lang.InterruptedException;
    method public final void join() throws java.lang.InterruptedException;
    method public final deprecated void resume();
    method public void run();
    method public void setContextClassLoader(java.lang.ClassLoader);
    method public final void setDaemon(boolean);
    method public static void setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler);
    method public final synchronized void setName(java.lang.String);
    method public final void setPriority(int);
    method public void setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler);
    method public static void sleep(long) throws java.lang.InterruptedException;
    method public static void sleep(long, int) throws java.lang.InterruptedException;
    method public synchronized void start();
    method public final deprecated void stop();
    method public final deprecated synchronized void stop(java.lang.Throwable);
    method public final deprecated void suspend();
    method public static void yield();
    field public static final int MAX_PRIORITY = 10; // 0xa
    field public static final int MIN_PRIORITY = 1; // 0x1
    field public static final int NORM_PRIORITY = 5; // 0x5
  }

  public static final class Thread.State extends java.lang.Enum {
    method public static java.lang.Thread.State valueOf(java.lang.String);
    method public static final java.lang.Thread.State[] values();
    enum_constant public static final java.lang.Thread.State BLOCKED;
    enum_constant public static final java.lang.Thread.State NEW;
    enum_constant public static final java.lang.Thread.State RUNNABLE;
    enum_constant public static final java.lang.Thread.State TERMINATED;
    enum_constant public static final java.lang.Thread.State TIMED_WAITING;
    enum_constant public static final java.lang.Thread.State WAITING;
  }

  public static abstract interface Thread.UncaughtExceptionHandler {
    method public abstract void uncaughtException(java.lang.Thread, java.lang.Throwable);
  }

  public class ThreadGroup implements java.lang.Thread.UncaughtExceptionHandler {
    ctor public ThreadGroup(java.lang.String);
    ctor public ThreadGroup(java.lang.ThreadGroup, java.lang.String);
    method public int activeCount();
    method public int activeGroupCount();
    method public deprecated boolean allowThreadSuspension(boolean);
    method public final void checkAccess();
    method public final void destroy();
    method public int enumerate(java.lang.Thread[]);
    method public int enumerate(java.lang.Thread[], boolean);
    method public int enumerate(java.lang.ThreadGroup[]);
    method public int enumerate(java.lang.ThreadGroup[], boolean);
    method public final int getMaxPriority();
    method public final java.lang.String getName();
    method public final java.lang.ThreadGroup getParent();
    method public final void interrupt();
    method public final boolean isDaemon();
    method public synchronized boolean isDestroyed();
    method public void list();
    method public final boolean parentOf(java.lang.ThreadGroup);
    method public final deprecated void resume();
    method public final void setDaemon(boolean);
    method public final void setMaxPriority(int);
    method public final deprecated void stop();
    method public final deprecated void suspend();
    method public void uncaughtException(java.lang.Thread, java.lang.Throwable);
  }

  public class Throwable {
    ctor public Throwable();
    ctor public Throwable(java.lang.String);
    ctor public Throwable(java.lang.String, java.lang.Throwable);
    ctor public Throwable(java.lang.Throwable);
    ctor protected Throwable(java.lang.String, java.lang.Throwable, boolean, boolean);
    method public final synchronized void addSuppressed(java.lang.Throwable);
    method public synchronized java.lang.Throwable fillInStackTrace();
    method public synchronized java.lang.Throwable getCause();
    method public java.lang.String getLocalizedMessage();
    method public java.lang.String getMessage();
    method public java.lang.StackTraceElement[] getStackTrace();
    method public final synchronized java.lang.Throwable[] getSuppressed();
    method public synchronized java.lang.Throwable initCause(java.lang.Throwable);
    method public void printStackTrace();
    method public void printStackTrace(java.io.PrintStream);
    method public void printStackTrace(java.io.PrintWriter);
    method public void setStackTrace(java.lang.StackTraceElement[]);
  }

}

package java.lang.annotation {

  public abstract interface Annotation {
    method public abstract java.lang.Class<? extends java.lang.annotation.Annotation> annotationType();
    method public abstract boolean equals(java.lang.Object);
    method public abstract int hashCode();
    method public abstract java.lang.String toString();
  }

}

package java.lang.reflect {

  public class AccessibleObject {
    ctor protected AccessibleObject();
    method public <T extends java.lang.annotation.Annotation> T getAnnotation(java.lang.Class<T>);
    method public java.lang.annotation.Annotation[] getAnnotations();
    method public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public boolean isAccessible();
    method public static void setAccessible(java.lang.reflect.AccessibleObject[], boolean) throws java.lang.SecurityException;
    method public void setAccessible(boolean) throws java.lang.SecurityException;
  }

  public abstract interface AnnotatedType {
    method public abstract java.lang.reflect.Type getType();
  }

  public final class Constructor<T> extends java.lang.reflect.Executable {
    method public java.lang.reflect.AnnotatedType getAnnotatedReturnType();
    method public java.lang.Class<T> getDeclaringClass();
    method public java.lang.Class<?>[] getExceptionTypes();
    method public int getModifiers();
    method public java.lang.String getName();
    method public java.lang.annotation.Annotation[][] getParameterAnnotations();
    method public java.lang.Class<?>[] getParameterTypes();
    method public java.lang.reflect.TypeVariable<java.lang.reflect.Constructor<T>>[] getTypeParameters();
    method public T newInstance(java.lang.Object...) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException, java.lang.InstantiationException, java.lang.reflect.InvocationTargetException;
    method public java.lang.String toGenericString();
  }

  public abstract class Executable extends java.lang.reflect.AccessibleObject implements java.lang.reflect.GenericDeclaration {
    method public java.lang.reflect.AnnotatedType[] getAnnotatedExceptionTypes();
    method public java.lang.reflect.AnnotatedType[] getAnnotatedParameterTypes();
    method public java.lang.reflect.AnnotatedType getAnnotatedReceiverType();
    method public abstract java.lang.reflect.AnnotatedType getAnnotatedReturnType();
    method public abstract java.lang.Class<?> getDeclaringClass();
    method public abstract java.lang.Class<?>[] getExceptionTypes();
    method public java.lang.reflect.Type[] getGenericExceptionTypes();
    method public java.lang.reflect.Type[] getGenericParameterTypes();
    method public abstract int getModifiers();
    method public abstract java.lang.String getName();
    method public abstract java.lang.annotation.Annotation[][] getParameterAnnotations();
    method public int getParameterCount();
    method public abstract java.lang.Class<?>[] getParameterTypes();
    method public java.lang.reflect.Parameter[] getParameters();
    method public abstract java.lang.reflect.TypeVariable<?>[] getTypeParameters();
    method public boolean isSynthetic();
    method public boolean isVarArgs();
    method public abstract java.lang.String toGenericString();
  }

  public final class Field extends java.lang.reflect.AccessibleObject {
    method public java.lang.Object get(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public java.lang.reflect.AnnotatedType getAnnotatedType();
    method public boolean getBoolean(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public byte getByte(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public char getChar(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public java.lang.Class<?> getDeclaringClass();
    method public double getDouble(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public float getFloat(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public java.lang.reflect.Type getGenericType();
    method public int getInt(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public long getLong(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public int getModifiers();
    method public java.lang.String getName();
    method public short getShort(java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public java.lang.Class<?> getType();
    method public boolean isEnumConstant();
    method public boolean isSynthetic();
    method public void set(java.lang.Object, java.lang.Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setBoolean(java.lang.Object, boolean) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setByte(java.lang.Object, byte) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setChar(java.lang.Object, char) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setDouble(java.lang.Object, double) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setFloat(java.lang.Object, float) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setInt(java.lang.Object, int) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setLong(java.lang.Object, long) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setShort(java.lang.Object, short) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public java.lang.String toGenericString();
  }

  public abstract interface GenericDeclaration {
    method public abstract java.lang.reflect.TypeVariable<?>[] getTypeParameters();
  }

  public class InvocationTargetException extends java.lang.ReflectiveOperationException {
    ctor protected InvocationTargetException();
    ctor public InvocationTargetException(java.lang.Throwable);
    ctor public InvocationTargetException(java.lang.Throwable, java.lang.String);
    method public java.lang.Throwable getCause();
    method public java.lang.Throwable getTargetException();
  }

  public final class Method extends java.lang.reflect.Executable {
    method public java.lang.reflect.AnnotatedType getAnnotatedReturnType();
    method public java.lang.Class<?> getDeclaringClass();
    method public java.lang.Object getDefaultValue();
    method public java.lang.Class<?>[] getExceptionTypes();
    method public java.lang.reflect.Type getGenericReturnType();
    method public int getModifiers();
    method public java.lang.String getName();
    method public java.lang.annotation.Annotation[][] getParameterAnnotations();
    method public java.lang.Class<?>[] getParameterTypes();
    method public java.lang.Class<?> getReturnType();
    method public java.lang.reflect.TypeVariable<java.lang.reflect.Method>[] getTypeParameters();
    method public java.lang.Object invoke(java.lang.Object, java.lang.Object...) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException, java.lang.reflect.InvocationTargetException;
    method public boolean isBridge();
    method public boolean isDefault();
    method public java.lang.String toGenericString();
  }

  public final class Parameter {
    method public java.lang.reflect.AnnotatedType getAnnotatedType();
    method public <T extends java.lang.annotation.Annotation> T getAnnotation(java.lang.Class<T>);
    method public java.lang.annotation.Annotation[] getAnnotations();
    method public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public java.lang.reflect.Executable getDeclaringExecutable();
    method public int getModifiers();
    method public java.lang.String getName();
    method public java.lang.reflect.Type getParameterizedType();
    method public java.lang.Class<?> getType();
    method public boolean isImplicit();
    method public boolean isNamePresent();
    method public boolean isSynthetic();
    method public boolean isVarArgs();
  }

  public abstract interface Type {
    method public default java.lang.String getTypeName();
  }

  public abstract interface TypeVariable<D extends java.lang.reflect.GenericDeclaration> implements java.lang.reflect.Type {
    method public abstract java.lang.reflect.AnnotatedType[] getAnnotatedBounds();
    method public abstract java.lang.reflect.Type[] getBounds();
    method public abstract D getGenericDeclaration();
    method public abstract java.lang.String getName();
  }

}

package java.net {

  public abstract class ContentHandler {
    ctor public ContentHandler();
    method public abstract java.lang.Object getContent(java.net.URLConnection) throws java.io.IOException;
    method public java.lang.Object getContent(java.net.URLConnection, java.lang.Class[]) throws java.io.IOException;
  }

  public abstract interface ContentHandlerFactory {
    method public abstract java.net.ContentHandler createContentHandler(java.lang.String);
  }

  public abstract interface FileNameMap {
    method public abstract java.lang.String getContentTypeFor(java.lang.String);
  }

  public class InetAddress {
    method public byte[] getAddress();
    method public static java.net.InetAddress[] getAllByName(java.lang.String) throws java.net.UnknownHostException;
    method public static java.net.InetAddress getByAddress(java.lang.String, byte[]) throws java.net.UnknownHostException;
    method public static java.net.InetAddress getByAddress(byte[]) throws java.net.UnknownHostException;
    method public static java.net.InetAddress getByName(java.lang.String) throws java.net.UnknownHostException;
    method public java.lang.String getCanonicalHostName();
    method public java.lang.String getHostAddress();
    method public java.lang.String getHostName();
    method public static java.net.InetAddress getLocalHost() throws java.net.UnknownHostException;
    method public static java.net.InetAddress getLoopbackAddress();
    method public boolean isAnyLocalAddress();
    method public boolean isLinkLocalAddress();
    method public boolean isLoopbackAddress();
    method public boolean isMCGlobal();
    method public boolean isMCLinkLocal();
    method public boolean isMCNodeLocal();
    method public boolean isMCOrgLocal();
    method public boolean isMCSiteLocal();
    method public boolean isMulticastAddress();
    method public boolean isReachable(int) throws java.io.IOException;
    method public boolean isReachable(java.net.NetworkInterface, int, int) throws java.io.IOException;
    method public boolean isSiteLocalAddress();
  }

  public class InterfaceAddress {
    method public java.net.InetAddress getAddress();
    method public java.net.InetAddress getBroadcast();
    method public short getNetworkPrefixLength();
  }

  public class MalformedURLException extends java.io.IOException {
    ctor public MalformedURLException();
    ctor public MalformedURLException(java.lang.String);
  }

  public final class NetworkInterface {
    method public static java.net.NetworkInterface getByIndex(int) throws java.net.SocketException;
    method public static java.net.NetworkInterface getByInetAddress(java.net.InetAddress) throws java.net.SocketException;
    method public static java.net.NetworkInterface getByName(java.lang.String) throws java.net.SocketException;
    method public java.lang.String getDisplayName();
    method public byte[] getHardwareAddress() throws java.net.SocketException;
    method public int getIndex();
    method public java.util.Enumeration<java.net.InetAddress> getInetAddresses();
    method public java.util.List<java.net.InterfaceAddress> getInterfaceAddresses();
    method public int getMTU() throws java.net.SocketException;
    method public java.lang.String getName();
    method public static java.util.Enumeration<java.net.NetworkInterface> getNetworkInterfaces() throws java.net.SocketException;
    method public java.net.NetworkInterface getParent();
    method public java.util.Enumeration<java.net.NetworkInterface> getSubInterfaces();
    method public boolean isLoopback() throws java.net.SocketException;
    method public boolean isPointToPoint() throws java.net.SocketException;
    method public boolean isUp() throws java.net.SocketException;
    method public boolean isVirtual();
    method public boolean supportsMulticast() throws java.net.SocketException;
  }

  public class Proxy {
    ctor public Proxy(java.net.Proxy.Type, java.net.SocketAddress);
    method public java.net.SocketAddress address();
    method public final boolean equals(java.lang.Object);
    method public final int hashCode();
    method public java.net.Proxy.Type type();
    field public static final java.net.Proxy NO_PROXY;
  }

  public static final class Proxy.Type extends java.lang.Enum {
    method public static java.net.Proxy.Type valueOf(java.lang.String);
    method public static final java.net.Proxy.Type[] values();
    enum_constant public static final java.net.Proxy.Type DIRECT;
    enum_constant public static final java.net.Proxy.Type HTTP;
    enum_constant public static final java.net.Proxy.Type SOCKS;
  }

  public abstract class SocketAddress {
    ctor public SocketAddress();
  }

  public class SocketException extends java.io.IOException {
    ctor public SocketException(java.lang.String);
    ctor public SocketException();
  }

  public final class URI implements java.lang.Comparable {
    ctor public URI(java.lang.String) throws java.net.URISyntaxException;
    ctor public URI(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String) throws java.net.URISyntaxException;
    ctor public URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String) throws java.net.URISyntaxException;
    ctor public URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String) throws java.net.URISyntaxException;
    ctor public URI(java.lang.String, java.lang.String, java.lang.String) throws java.net.URISyntaxException;
    method public int compareTo(java.net.URI);
    method public int compareTo(java.lang.Object);
    method public static java.net.URI create(java.lang.String);
    method public java.lang.String getAuthority();
    method public java.lang.String getFragment();
    method public java.lang.String getHost();
    method public java.lang.String getPath();
    method public int getPort();
    method public java.lang.String getQuery();
    method public java.lang.String getRawAuthority();
    method public java.lang.String getRawFragment();
    method public java.lang.String getRawPath();
    method public java.lang.String getRawQuery();
    method public java.lang.String getRawSchemeSpecificPart();
    method public java.lang.String getRawUserInfo();
    method public java.lang.String getScheme();
    method public java.lang.String getSchemeSpecificPart();
    method public java.lang.String getUserInfo();
    method public boolean isAbsolute();
    method public boolean isOpaque();
    method public java.net.URI normalize();
    method public java.net.URI parseServerAuthority() throws java.net.URISyntaxException;
    method public java.net.URI relativize(java.net.URI);
    method public java.net.URI resolve(java.net.URI);
    method public java.net.URI resolve(java.lang.String);
    method public java.lang.String toASCIIString();
    method public java.net.URL toURL() throws java.net.MalformedURLException;
  }

  public class URISyntaxException extends java.lang.Exception {
    ctor public URISyntaxException(java.lang.String, java.lang.String, int);
    ctor public URISyntaxException(java.lang.String, java.lang.String);
    method public int getIndex();
    method public java.lang.String getInput();
    method public java.lang.String getReason();
  }

  public final class URL {
    ctor public URL(java.lang.String, java.lang.String, int, java.lang.String) throws java.net.MalformedURLException;
    ctor public URL(java.lang.String, java.lang.String, java.lang.String) throws java.net.MalformedURLException;
    ctor public URL(java.lang.String, java.lang.String, int, java.lang.String, java.net.URLStreamHandler) throws java.net.MalformedURLException;
    ctor public URL(java.lang.String) throws java.net.MalformedURLException;
    ctor public URL(java.net.URL, java.lang.String) throws java.net.MalformedURLException;
    ctor public URL(java.net.URL, java.lang.String, java.net.URLStreamHandler) throws java.net.MalformedURLException;
    method public java.lang.String getAuthority();
    method public final java.lang.Object getContent() throws java.io.IOException;
    method public final java.lang.Object getContent(java.lang.Class[]) throws java.io.IOException;
    method public int getDefaultPort();
    method public java.lang.String getFile();
    method public java.lang.String getHost();
    method public java.lang.String getPath();
    method public int getPort();
    method public java.lang.String getProtocol();
    method public java.lang.String getQuery();
    method public java.lang.String getRef();
    method public java.lang.String getUserInfo();
    method public synchronized int hashCode();
    method public java.net.URLConnection openConnection() throws java.io.IOException;
    method public java.net.URLConnection openConnection(java.net.Proxy) throws java.io.IOException;
    method public final java.io.InputStream openStream() throws java.io.IOException;
    method public boolean sameFile(java.net.URL);
    method public static void setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory);
    method public java.lang.String toExternalForm();
    method public java.net.URI toURI() throws java.net.URISyntaxException;
  }

  public abstract class URLConnection {
    ctor protected URLConnection(java.net.URL);
    method public void addRequestProperty(java.lang.String, java.lang.String);
    method public abstract void connect() throws java.io.IOException;
    method public boolean getAllowUserInteraction();
    method public int getConnectTimeout();
    method public java.lang.Object getContent() throws java.io.IOException;
    method public java.lang.Object getContent(java.lang.Class[]) throws java.io.IOException;
    method public java.lang.String getContentEncoding();
    method public int getContentLength();
    method public long getContentLengthLong();
    method public java.lang.String getContentType();
    method public long getDate();
    method public static boolean getDefaultAllowUserInteraction();
    method public static deprecated java.lang.String getDefaultRequestProperty(java.lang.String);
    method public boolean getDefaultUseCaches();
    method public boolean getDoInput();
    method public boolean getDoOutput();
    method public long getExpiration();
    method public static synchronized java.net.FileNameMap getFileNameMap();
    method public java.lang.String getHeaderField(java.lang.String);
    method public java.lang.String getHeaderField(int);
    method public long getHeaderFieldDate(java.lang.String, long);
    method public int getHeaderFieldInt(java.lang.String, int);
    method public java.lang.String getHeaderFieldKey(int);
    method public long getHeaderFieldLong(java.lang.String, long);
    method public java.util.Map<java.lang.String, java.util.List<java.lang.String>> getHeaderFields();
    method public long getIfModifiedSince();
    method public java.io.InputStream getInputStream() throws java.io.IOException;
    method public long getLastModified();
    method public java.io.OutputStream getOutputStream() throws java.io.IOException;
    method public java.security.Permission getPermission() throws java.io.IOException;
    method public int getReadTimeout();
    method public java.util.Map<java.lang.String, java.util.List<java.lang.String>> getRequestProperties();
    method public java.lang.String getRequestProperty(java.lang.String);
    method public java.net.URL getURL();
    method public boolean getUseCaches();
    method public static java.lang.String guessContentTypeFromName(java.lang.String);
    method public static java.lang.String guessContentTypeFromStream(java.io.InputStream) throws java.io.IOException;
    method public void setAllowUserInteraction(boolean);
    method public void setConnectTimeout(int);
    method public static synchronized void setContentHandlerFactory(java.net.ContentHandlerFactory);
    method public static void setDefaultAllowUserInteraction(boolean);
    method public static deprecated void setDefaultRequestProperty(java.lang.String, java.lang.String);
    method public void setDefaultUseCaches(boolean);
    method public void setDoInput(boolean);
    method public void setDoOutput(boolean);
    method public static void setFileNameMap(java.net.FileNameMap);
    method public void setIfModifiedSince(long);
    method public void setReadTimeout(int);
    method public void setRequestProperty(java.lang.String, java.lang.String);
    method public void setUseCaches(boolean);
    field protected boolean allowUserInteraction;
    field protected boolean connected;
    field protected boolean doInput;
    field protected boolean doOutput;
    field protected long ifModifiedSince;
    field protected java.net.URL url;
    field protected boolean useCaches;
  }

  public abstract class URLStreamHandler {
    ctor public URLStreamHandler();
    method protected boolean equals(java.net.URL, java.net.URL);
    method protected int getDefaultPort();
    method protected synchronized java.net.InetAddress getHostAddress(java.net.URL);
    method protected int hashCode(java.net.URL);
    method protected boolean hostsEqual(java.net.URL, java.net.URL);
    method protected abstract java.net.URLConnection openConnection(java.net.URL) throws java.io.IOException;
    method protected java.net.URLConnection openConnection(java.net.URL, java.net.Proxy) throws java.io.IOException;
    method protected void parseURL(java.net.URL, java.lang.String, int, int);
    method protected boolean sameFile(java.net.URL, java.net.URL);
    method protected void setURL(java.net.URL, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String);
    method protected deprecated void setURL(java.net.URL, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String);
    method protected java.lang.String toExternalForm(java.net.URL);
  }

  public abstract interface URLStreamHandlerFactory {
    method public abstract java.net.URLStreamHandler createURLStreamHandler(java.lang.String);
  }

  public class UnknownHostException extends java.io.IOException {
    ctor public UnknownHostException(java.lang.String);
    ctor public UnknownHostException();
  }

}

package java.nio {

  public abstract class Buffer {
    method public abstract java.lang.Object array();
    method public abstract int arrayOffset();
    method public final int capacity();
    method public final java.nio.Buffer clear();
    method public final java.nio.Buffer flip();
    method public abstract boolean hasArray();
    method public final boolean hasRemaining();
    method public abstract boolean isDirect();
    method public abstract boolean isReadOnly();
    method public final int limit();
    method public final java.nio.Buffer limit(int);
    method public final java.nio.Buffer mark();
    method public final int position();
    method public final java.nio.Buffer position(int);
    method public final int remaining();
    method public final java.nio.Buffer reset();
    method public final java.nio.Buffer rewind();
  }

  public abstract class ByteBuffer extends java.nio.Buffer implements java.lang.Comparable {
    method public static java.nio.ByteBuffer allocate(int);
    method public static java.nio.ByteBuffer allocateDirect(int);
    method public final byte[] array();
    method public java.lang.Object array();
    method public final int arrayOffset();
    method public abstract java.nio.CharBuffer asCharBuffer();
    method public abstract java.nio.DoubleBuffer asDoubleBuffer();
    method public abstract java.nio.FloatBuffer asFloatBuffer();
    method public abstract java.nio.IntBuffer asIntBuffer();
    method public abstract java.nio.LongBuffer asLongBuffer();
    method public abstract java.nio.ByteBuffer asReadOnlyBuffer();
    method public abstract java.nio.ShortBuffer asShortBuffer();
    method public abstract java.nio.ByteBuffer compact();
    method public int compareTo(java.nio.ByteBuffer);
    method public int compareTo(java.lang.Object);
    method public abstract java.nio.ByteBuffer duplicate();
    method public abstract byte get();
    method public abstract byte get(int);
    method public java.nio.ByteBuffer get(byte[], int, int);
    method public java.nio.ByteBuffer get(byte[]);
    method public abstract char getChar();
    method public abstract char getChar(int);
    method public abstract double getDouble();
    method public abstract double getDouble(int);
    method public abstract float getFloat();
    method public abstract float getFloat(int);
    method public abstract int getInt();
    method public abstract int getInt(int);
    method public abstract long getLong();
    method public abstract long getLong(int);
    method public abstract short getShort();
    method public abstract short getShort(int);
    method public final boolean hasArray();
    method public abstract boolean isDirect();
    method public final java.nio.ByteOrder order();
    method public final java.nio.ByteBuffer order(java.nio.ByteOrder);
    method public abstract java.nio.ByteBuffer put(byte);
    method public abstract java.nio.ByteBuffer put(int, byte);
    method public java.nio.ByteBuffer put(java.nio.ByteBuffer);
    method public java.nio.ByteBuffer put(byte[], int, int);
    method public final java.nio.ByteBuffer put(byte[]);
    method public abstract java.nio.ByteBuffer putChar(char);
    method public abstract java.nio.ByteBuffer putChar(int, char);
    method public abstract java.nio.ByteBuffer putDouble(double);
    method public abstract java.nio.ByteBuffer putDouble(int, double);
    method public abstract java.nio.ByteBuffer putFloat(float);
    method public abstract java.nio.ByteBuffer putFloat(int, float);
    method public abstract java.nio.ByteBuffer putInt(int);
    method public abstract java.nio.ByteBuffer putInt(int, int);
    method public abstract java.nio.ByteBuffer putLong(long);
    method public abstract java.nio.ByteBuffer putLong(int, long);
    method public abstract java.nio.ByteBuffer putShort(short);
    method public abstract java.nio.ByteBuffer putShort(int, short);
    method public abstract java.nio.ByteBuffer slice();
    method public static java.nio.ByteBuffer wrap(byte[], int, int);
    method public static java.nio.ByteBuffer wrap(byte[]);
  }

  public final class ByteOrder {
    method public static java.nio.ByteOrder nativeOrder();
    field public static final java.nio.ByteOrder BIG_ENDIAN;
    field public static final java.nio.ByteOrder LITTLE_ENDIAN;
  }

  public abstract class CharBuffer extends java.nio.Buffer implements java.lang.Appendable java.lang.CharSequence java.lang.Comparable {
    method public static java.nio.CharBuffer allocate(int);
    method public java.nio.CharBuffer append(java.lang.CharSequence);
    method public java.nio.CharBuffer append(java.lang.CharSequence, int, int);
    method public java.nio.CharBuffer append(char);
    method public java.lang.Appendable append(char) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence, int, int) throws java.io.IOException;
    method public java.lang.Appendable append(java.lang.CharSequence) throws java.io.IOException;
    method public final char[] array();
    method public java.lang.Object array();
    method public final int arrayOffset();
    method public abstract java.nio.CharBuffer asReadOnlyBuffer();
    method public final char charAt(int);
    method public abstract java.nio.CharBuffer compact();
    method public int compareTo(java.nio.CharBuffer);
    method public int compareTo(java.lang.Object);
    method public abstract java.nio.CharBuffer duplicate();
    method public abstract char get();
    method public abstract char get(int);
    method public java.nio.CharBuffer get(char[], int, int);
    method public java.nio.CharBuffer get(char[]);
    method public final boolean hasArray();
    method public abstract boolean isDirect();
    method public final int length();
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.CharBuffer put(char);
    method public abstract java.nio.CharBuffer put(int, char);
    method public java.nio.CharBuffer put(java.nio.CharBuffer);
    method public java.nio.CharBuffer put(char[], int, int);
    method public final java.nio.CharBuffer put(char[]);
    method public java.nio.CharBuffer put(java.lang.String, int, int);
    method public final java.nio.CharBuffer put(java.lang.String);
    method public int read(java.nio.CharBuffer) throws java.io.IOException;
    method public abstract java.nio.CharBuffer slice();
    method public abstract java.nio.CharBuffer subSequence(int, int);
    method public java.lang.CharSequence subSequence(int, int);
    method public static java.nio.CharBuffer wrap(char[], int, int);
    method public static java.nio.CharBuffer wrap(char[]);
    method public static java.nio.CharBuffer wrap(java.lang.CharSequence, int, int);
    method public static java.nio.CharBuffer wrap(java.lang.CharSequence);
  }

  public abstract class DoubleBuffer extends java.nio.Buffer implements java.lang.Comparable {
    method public static java.nio.DoubleBuffer allocate(int);
    method public final double[] array();
    method public java.lang.Object array();
    method public final int arrayOffset();
    method public abstract java.nio.DoubleBuffer asReadOnlyBuffer();
    method public abstract java.nio.DoubleBuffer compact();
    method public int compareTo(java.nio.DoubleBuffer);
    method public int compareTo(java.lang.Object);
    method public abstract java.nio.DoubleBuffer duplicate();
    method public abstract double get();
    method public abstract double get(int);
    method public java.nio.DoubleBuffer get(double[], int, int);
    method public java.nio.DoubleBuffer get(double[]);
    method public final boolean hasArray();
    method public abstract boolean isDirect();
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.DoubleBuffer put(double);
    method public abstract java.nio.DoubleBuffer put(int, double);
    method public java.nio.DoubleBuffer put(java.nio.DoubleBuffer);
    method public java.nio.DoubleBuffer put(double[], int, int);
    method public final java.nio.DoubleBuffer put(double[]);
    method public abstract java.nio.DoubleBuffer slice();
    method public static java.nio.DoubleBuffer wrap(double[], int, int);
    method public static java.nio.DoubleBuffer wrap(double[]);
  }

  public abstract class FloatBuffer extends java.nio.Buffer implements java.lang.Comparable {
    method public static java.nio.FloatBuffer allocate(int);
    method public final float[] array();
    method public java.lang.Object array();
    method public final int arrayOffset();
    method public abstract java.nio.FloatBuffer asReadOnlyBuffer();
    method public abstract java.nio.FloatBuffer compact();
    method public int compareTo(java.nio.FloatBuffer);
    method public int compareTo(java.lang.Object);
    method public abstract java.nio.FloatBuffer duplicate();
    method public abstract float get();
    method public abstract float get(int);
    method public java.nio.FloatBuffer get(float[], int, int);
    method public java.nio.FloatBuffer get(float[]);
    method public final boolean hasArray();
    method public abstract boolean isDirect();
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.FloatBuffer put(float);
    method public abstract java.nio.FloatBuffer put(int, float);
    method public java.nio.FloatBuffer put(java.nio.FloatBuffer);
    method public java.nio.FloatBuffer put(float[], int, int);
    method public final java.nio.FloatBuffer put(float[]);
    method public abstract java.nio.FloatBuffer slice();
    method public static java.nio.FloatBuffer wrap(float[], int, int);
    method public static java.nio.FloatBuffer wrap(float[]);
  }

  public abstract class IntBuffer extends java.nio.Buffer implements java.lang.Comparable {
    method public static java.nio.IntBuffer allocate(int);
    method public final int[] array();
    method public java.lang.Object array();
    method public final int arrayOffset();
    method public abstract java.nio.IntBuffer asReadOnlyBuffer();
    method public abstract java.nio.IntBuffer compact();
    method public int compareTo(java.nio.IntBuffer);
    method public int compareTo(java.lang.Object);
    method public abstract java.nio.IntBuffer duplicate();
    method public abstract int get();
    method public abstract int get(int);
    method public java.nio.IntBuffer get(int[], int, int);
    method public java.nio.IntBuffer get(int[]);
    method public final boolean hasArray();
    method public abstract boolean isDirect();
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.IntBuffer put(int);
    method public abstract java.nio.IntBuffer put(int, int);
    method public java.nio.IntBuffer put(java.nio.IntBuffer);
    method public java.nio.IntBuffer put(int[], int, int);
    method public final java.nio.IntBuffer put(int[]);
    method public abstract java.nio.IntBuffer slice();
    method public static java.nio.IntBuffer wrap(int[], int, int);
    method public static java.nio.IntBuffer wrap(int[]);
  }

  public abstract class LongBuffer extends java.nio.Buffer implements java.lang.Comparable {
    method public static java.nio.LongBuffer allocate(int);
    method public final long[] array();
    method public java.lang.Object array();
    method public final int arrayOffset();
    method public abstract java.nio.LongBuffer asReadOnlyBuffer();
    method public abstract java.nio.LongBuffer compact();
    method public int compareTo(java.nio.LongBuffer);
    method public int compareTo(java.lang.Object);
    method public abstract java.nio.LongBuffer duplicate();
    method public abstract long get();
    method public abstract long get(int);
    method public java.nio.LongBuffer get(long[], int, int);
    method public java.nio.LongBuffer get(long[]);
    method public final boolean hasArray();
    method public abstract boolean isDirect();
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.LongBuffer put(long);
    method public abstract java.nio.LongBuffer put(int, long);
    method public java.nio.LongBuffer put(java.nio.LongBuffer);
    method public java.nio.LongBuffer put(long[], int, int);
    method public final java.nio.LongBuffer put(long[]);
    method public abstract java.nio.LongBuffer slice();
    method public static java.nio.LongBuffer wrap(long[], int, int);
    method public static java.nio.LongBuffer wrap(long[]);
  }

  public abstract class MappedByteBuffer extends java.nio.ByteBuffer {
    method public final java.nio.MappedByteBuffer force();
    method public final boolean isLoaded();
    method public final java.nio.MappedByteBuffer load();
  }

  public abstract class ShortBuffer extends java.nio.Buffer implements java.lang.Comparable {
    method public static java.nio.ShortBuffer allocate(int);
    method public final short[] array();
    method public java.lang.Object array();
    method public final int arrayOffset();
    method public abstract java.nio.ShortBuffer asReadOnlyBuffer();
    method public abstract java.nio.ShortBuffer compact();
    method public int compareTo(java.nio.ShortBuffer);
    method public int compareTo(java.lang.Object);
    method public abstract java.nio.ShortBuffer duplicate();
    method public abstract short get();
    method public abstract short get(int);
    method public java.nio.ShortBuffer get(short[], int, int);
    method public java.nio.ShortBuffer get(short[]);
    method public final boolean hasArray();
    method public abstract boolean isDirect();
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.ShortBuffer put(short);
    method public abstract java.nio.ShortBuffer put(int, short);
    method public java.nio.ShortBuffer put(java.nio.ShortBuffer);
    method public java.nio.ShortBuffer put(short[], int, int);
    method public final java.nio.ShortBuffer put(short[]);
    method public abstract java.nio.ShortBuffer slice();
    method public static java.nio.ShortBuffer wrap(short[], int, int);
    method public static java.nio.ShortBuffer wrap(short[]);
  }

}

package java.nio.channels {

  public class AsynchronousCloseException extends java.nio.channels.ClosedChannelException {
    ctor public AsynchronousCloseException();
  }

  public abstract class AsynchronousFileChannel {
    ctor protected AsynchronousFileChannel();
    method public abstract void force(boolean) throws java.io.IOException;
    method public abstract <A> void lock(long, long, boolean, A, java.nio.channels.CompletionHandler<java.nio.channels.FileLock, ? super A>);
    method public final <A> void lock(A, java.nio.channels.CompletionHandler<java.nio.channels.FileLock, ? super A>);
    method public abstract java.util.concurrent.Future<java.nio.channels.FileLock> lock(long, long, boolean);
    method public final java.util.concurrent.Future<java.nio.channels.FileLock> lock();
    method public static java.nio.channels.AsynchronousFileChannel open(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.util.concurrent.ExecutorService, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.channels.AsynchronousFileChannel open(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public abstract <A> void read(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler<java.lang.Integer, ? super A>);
    method public abstract java.util.concurrent.Future<java.lang.Integer> read(java.nio.ByteBuffer, long);
    method public abstract long size() throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousFileChannel truncate(long) throws java.io.IOException;
    method public abstract java.nio.channels.FileLock tryLock(long, long, boolean) throws java.io.IOException;
    method public final java.nio.channels.FileLock tryLock() throws java.io.IOException;
    method public abstract <A> void write(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler<java.lang.Integer, ? super A>);
    method public abstract java.util.concurrent.Future<java.lang.Integer> write(java.nio.ByteBuffer, long);
  }

  public abstract interface Channel {
    method public abstract void close() throws java.io.IOException;
    method public abstract boolean isOpen();
  }

  public class ClosedChannelException extends java.io.IOException {
    ctor public ClosedChannelException();
  }

  public abstract interface CompletionHandler<V, A> {
    method public abstract void completed(V, A);
    method public abstract void failed(java.lang.Throwable, A);
  }

  public abstract class FileChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.SeekableByteChannel {
    ctor protected FileChannel();
    method public abstract void force(boolean) throws java.io.IOException;
    method public abstract java.nio.channels.FileLock lock(long, long, boolean) throws java.io.IOException;
    method public final java.nio.channels.FileLock lock() throws java.io.IOException;
    method public abstract java.nio.MappedByteBuffer map(java.nio.channels.FileChannel.MapMode, long, long) throws java.io.IOException;
    method public static java.nio.channels.FileChannel open(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.channels.FileChannel open(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public abstract long position() throws java.io.IOException;
    method public abstract java.nio.channels.FileChannel position(long) throws java.io.IOException;
    method public java.nio.channels.SeekableByteChannel position(long) throws java.io.IOException;
    method public abstract int read(java.nio.ByteBuffer) throws java.io.IOException;
    method public abstract long read(java.nio.ByteBuffer[], int, int) throws java.io.IOException;
    method public final long read(java.nio.ByteBuffer[]) throws java.io.IOException;
    method public abstract int read(java.nio.ByteBuffer, long) throws java.io.IOException;
    method public abstract long size() throws java.io.IOException;
    method public abstract long transferFrom(java.nio.channels.ReadableByteChannel, long, long) throws java.io.IOException;
    method public abstract long transferTo(long, long, java.nio.channels.WritableByteChannel) throws java.io.IOException;
    method public abstract java.nio.channels.FileChannel truncate(long) throws java.io.IOException;
    method public java.nio.channels.SeekableByteChannel truncate(long) throws java.io.IOException;
    method public abstract java.nio.channels.FileLock tryLock(long, long, boolean) throws java.io.IOException;
    method public final java.nio.channels.FileLock tryLock() throws java.io.IOException;
    method public abstract int write(java.nio.ByteBuffer) throws java.io.IOException;
    method public abstract long write(java.nio.ByteBuffer[], int, int) throws java.io.IOException;
    method public final long write(java.nio.ByteBuffer[]) throws java.io.IOException;
    method public abstract int write(java.nio.ByteBuffer, long) throws java.io.IOException;
  }

  public static class FileChannel.MapMode {
    field public static final java.nio.channels.FileChannel.MapMode PRIVATE;
    field public static final java.nio.channels.FileChannel.MapMode READ_ONLY;
    field public static final java.nio.channels.FileChannel.MapMode READ_WRITE;
  }

  public abstract class FileLock {
    ctor protected FileLock(java.nio.channels.FileChannel, long, long, boolean);
    ctor protected FileLock(java.nio.channels.AsynchronousFileChannel, long, long, boolean);
    method public java.nio.channels.Channel acquiredBy();
    method public final java.nio.channels.FileChannel channel();
    method public final void close() throws java.io.IOException;
    method public final boolean isShared();
    method public abstract boolean isValid();
    method public final boolean overlaps(long, long);
    method public final long position();
    method public abstract void release() throws java.io.IOException;
    method public final long size();
    method public final java.lang.String toString();
  }

  public abstract interface ReadableByteChannel implements java.nio.channels.Channel {
    method public abstract int read(java.nio.ByteBuffer) throws java.io.IOException;
  }

  public abstract interface SeekableByteChannel {
    method public abstract long position() throws java.io.IOException;
    method public abstract java.nio.channels.SeekableByteChannel position(long) throws java.io.IOException;
    method public abstract int read(java.nio.ByteBuffer) throws java.io.IOException;
    method public abstract long size() throws java.io.IOException;
    method public abstract java.nio.channels.SeekableByteChannel truncate(long) throws java.io.IOException;
    method public abstract int write(java.nio.ByteBuffer) throws java.io.IOException;
  }

  public abstract interface WritableByteChannel implements java.nio.channels.Channel {
    method public abstract int write(java.nio.ByteBuffer) throws java.io.IOException;
  }

}

package java.nio.channels.spi {

  public abstract class AbstractInterruptibleChannel implements java.nio.channels.Channel {
    ctor protected AbstractInterruptibleChannel();
    method protected final void begin();
    method public final void close() throws java.io.IOException;
    method protected final void end(boolean) throws java.nio.channels.AsynchronousCloseException;
    method protected abstract void implCloseChannel() throws java.io.IOException;
    method public final boolean isOpen();
  }

}

package java.nio.charset {

  public class CharacterCodingException extends java.io.IOException {
    ctor public CharacterCodingException();
  }

  public abstract class Charset implements java.lang.Comparable {
    ctor protected Charset(java.lang.String, java.lang.String[]);
    method public final java.util.Set<java.lang.String> aliases();
    method public static java.util.SortedMap<java.lang.String, java.nio.charset.Charset> availableCharsets();
    method public boolean canEncode();
    method public final int compareTo(java.nio.charset.Charset);
    method public int compareTo(java.lang.Object);
    method public abstract boolean contains(java.nio.charset.Charset);
    method public final java.nio.CharBuffer decode(java.nio.ByteBuffer);
    method public static java.nio.charset.Charset defaultCharset();
    method public java.lang.String displayName();
    method public java.lang.String displayName(java.util.Locale);
    method public final java.nio.ByteBuffer encode(java.nio.CharBuffer);
    method public final java.nio.ByteBuffer encode(java.lang.String);
    method public final boolean equals(java.lang.Object);
    method public static java.nio.charset.Charset forName(java.lang.String);
    method public final int hashCode();
    method public final boolean isRegistered();
    method public static boolean isSupported(java.lang.String);
    method public final java.lang.String name();
    method public abstract java.nio.charset.CharsetDecoder newDecoder();
    method public abstract java.nio.charset.CharsetEncoder newEncoder();
    method public final java.lang.String toString();
  }

  public abstract class CharsetDecoder {
    ctor protected CharsetDecoder(java.nio.charset.Charset, float, float);
    method public final float averageCharsPerByte();
    method public final java.nio.charset.Charset charset();
    method public final java.nio.charset.CoderResult decode(java.nio.ByteBuffer, java.nio.CharBuffer, boolean);
    method public final java.nio.CharBuffer decode(java.nio.ByteBuffer) throws java.nio.charset.CharacterCodingException;
    method protected abstract java.nio.charset.CoderResult decodeLoop(java.nio.ByteBuffer, java.nio.CharBuffer);
    method public java.nio.charset.Charset detectedCharset();
    method public final java.nio.charset.CoderResult flush(java.nio.CharBuffer);
    method protected java.nio.charset.CoderResult implFlush(java.nio.CharBuffer);
    method protected void implOnMalformedInput(java.nio.charset.CodingErrorAction);
    method protected void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method protected void implReplaceWith(java.lang.String);
    method protected void implReset();
    method public boolean isAutoDetecting();
    method public boolean isCharsetDetected();
    method public java.nio.charset.CodingErrorAction malformedInputAction();
    method public final float maxCharsPerByte();
    method public final java.nio.charset.CharsetDecoder onMalformedInput(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetDecoder onUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetDecoder replaceWith(java.lang.String);
    method public final java.lang.String replacement();
    method public final java.nio.charset.CharsetDecoder reset();
    method public java.nio.charset.CodingErrorAction unmappableCharacterAction();
  }

  public abstract class CharsetEncoder {
    ctor protected CharsetEncoder(java.nio.charset.Charset, float, float, byte[]);
    ctor protected CharsetEncoder(java.nio.charset.Charset, float, float);
    method public final float averageBytesPerChar();
    method public boolean canEncode(char);
    method public boolean canEncode(java.lang.CharSequence);
    method public final java.nio.charset.Charset charset();
    method public final java.nio.charset.CoderResult encode(java.nio.CharBuffer, java.nio.ByteBuffer, boolean);
    method public final java.nio.ByteBuffer encode(java.nio.CharBuffer) throws java.nio.charset.CharacterCodingException;
    method protected abstract java.nio.charset.CoderResult encodeLoop(java.nio.CharBuffer, java.nio.ByteBuffer);
    method public final java.nio.charset.CoderResult flush(java.nio.ByteBuffer);
    method protected java.nio.charset.CoderResult implFlush(java.nio.ByteBuffer);
    method protected void implOnMalformedInput(java.nio.charset.CodingErrorAction);
    method protected void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method protected void implReplaceWith(byte[]);
    method protected void implReset();
    method public boolean isLegalReplacement(byte[]);
    method public java.nio.charset.CodingErrorAction malformedInputAction();
    method public final float maxBytesPerChar();
    method public final java.nio.charset.CharsetEncoder onMalformedInput(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetEncoder onUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetEncoder replaceWith(byte[]);
    method public final byte[] replacement();
    method public final java.nio.charset.CharsetEncoder reset();
    method public java.nio.charset.CodingErrorAction unmappableCharacterAction();
  }

  public class CoderResult {
    method public boolean isError();
    method public boolean isMalformed();
    method public boolean isOverflow();
    method public boolean isUnderflow();
    method public boolean isUnmappable();
    method public int length();
    method public static java.nio.charset.CoderResult malformedForLength(int);
    method public void throwException() throws java.nio.charset.CharacterCodingException;
    method public static java.nio.charset.CoderResult unmappableForLength(int);
    field public static final java.nio.charset.CoderResult OVERFLOW;
    field public static final java.nio.charset.CoderResult UNDERFLOW;
  }

  public class CodingErrorAction {
    field public static final java.nio.charset.CodingErrorAction IGNORE;
    field public static final java.nio.charset.CodingErrorAction REPLACE;
    field public static final java.nio.charset.CodingErrorAction REPORT;
  }

}

package java.nio.file {

  public final class AccessMode extends java.lang.Enum {
    method public static java.nio.file.AccessMode valueOf(java.lang.String);
    method public static final java.nio.file.AccessMode[] values();
    enum_constant public static final java.nio.file.AccessMode EXECUTE;
    enum_constant public static final java.nio.file.AccessMode READ;
    enum_constant public static final java.nio.file.AccessMode WRITE;
  }

  public abstract interface CopyOption {
  }

  public abstract interface DirectoryStream<T> implements java.lang.Iterable {
    method public abstract java.util.Iterator<T> iterator();
  }

  public static abstract interface DirectoryStream.Filter<T> {
    method public abstract boolean accept(T) throws java.io.IOException;
  }

  public abstract class FileStore {
    ctor protected FileStore();
    method public abstract java.lang.Object getAttribute(java.lang.String) throws java.io.IOException;
    method public abstract <V extends java.nio.file.attribute.FileStoreAttributeView> V getFileStoreAttributeView(java.lang.Class<V>);
    method public abstract long getTotalSpace() throws java.io.IOException;
    method public abstract long getUnallocatedSpace() throws java.io.IOException;
    method public abstract long getUsableSpace() throws java.io.IOException;
    method public abstract boolean isReadOnly();
    method public abstract java.lang.String name();
    method public abstract boolean supportsFileAttributeView(java.lang.Class<? extends java.nio.file.attribute.FileAttributeView>);
    method public abstract boolean supportsFileAttributeView(java.lang.String);
    method public abstract java.lang.String type();
  }

  public abstract class FileSystem {
    ctor protected FileSystem();
    method public abstract void close() throws java.io.IOException;
    method public abstract java.lang.Iterable<java.nio.file.FileStore> getFileStores();
    method public abstract java.nio.file.Path getPath(java.lang.String, java.lang.String...);
    method public abstract java.nio.file.PathMatcher getPathMatcher(java.lang.String);
    method public abstract java.lang.Iterable<java.nio.file.Path> getRootDirectories();
    method public abstract java.lang.String getSeparator();
    method public abstract java.nio.file.attribute.UserPrincipalLookupService getUserPrincipalLookupService();
    method public abstract boolean isOpen();
    method public abstract boolean isReadOnly();
    method public abstract java.nio.file.WatchService newWatchService() throws java.io.IOException;
    method public abstract java.nio.file.spi.FileSystemProvider provider();
    method public abstract java.util.Set<java.lang.String> supportedFileAttributeViews();
  }

  public final class LinkOption extends java.lang.Enum implements java.nio.file.CopyOption java.nio.file.OpenOption {
    method public static java.nio.file.LinkOption valueOf(java.lang.String);
    method public static final java.nio.file.LinkOption[] values();
    enum_constant public static final java.nio.file.LinkOption NOFOLLOW_LINKS;
  }

  public abstract interface OpenOption {
  }

  public abstract interface Path implements java.lang.Comparable java.lang.Iterable java.nio.file.Watchable {
    method public abstract int compareTo(java.nio.file.Path);
    method public default int compareTo(java.lang.Object);
    method public abstract boolean endsWith(java.nio.file.Path);
    method public abstract boolean endsWith(java.lang.String);
    method public abstract boolean equals(java.lang.Object);
    method public abstract java.nio.file.Path getFileName();
    method public abstract java.nio.file.FileSystem getFileSystem();
    method public abstract java.nio.file.Path getName(int);
    method public abstract int getNameCount();
    method public abstract java.nio.file.Path getParent();
    method public abstract java.nio.file.Path getRoot();
    method public abstract int hashCode();
    method public abstract boolean isAbsolute();
    method public abstract java.util.Iterator<java.nio.file.Path> iterator();
    method public abstract java.nio.file.Path normalize();
    method public abstract java.nio.file.WatchKey register(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind<?>[], java.nio.file.WatchEvent.Modifier...) throws java.io.IOException;
    method public abstract java.nio.file.WatchKey register(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind<?>...) throws java.io.IOException;
    method public abstract java.nio.file.Path relativize(java.nio.file.Path);
    method public abstract java.nio.file.Path resolve(java.nio.file.Path);
    method public abstract java.nio.file.Path resolve(java.lang.String);
    method public abstract java.nio.file.Path resolveSibling(java.nio.file.Path);
    method public abstract java.nio.file.Path resolveSibling(java.lang.String);
    method public abstract boolean startsWith(java.nio.file.Path);
    method public abstract boolean startsWith(java.lang.String);
    method public abstract java.nio.file.Path subpath(int, int);
    method public abstract java.nio.file.Path toAbsolutePath();
    method public abstract java.io.File toFile();
    method public abstract java.nio.file.Path toRealPath(java.nio.file.LinkOption...) throws java.io.IOException;
    method public abstract java.lang.String toString();
    method public abstract java.net.URI toUri();
  }

  public abstract interface PathMatcher {
    method public abstract boolean matches(java.nio.file.Path);
  }

  public abstract interface WatchEvent<T> {
    method public abstract T context();
    method public abstract int count();
    method public abstract java.nio.file.WatchEvent.Kind<T> kind();
  }

  public static abstract interface WatchEvent.Kind<T> {
    method public abstract java.lang.String name();
    method public abstract java.lang.Class<T> type();
  }

  public static abstract interface WatchEvent.Modifier {
    method public abstract java.lang.String name();
  }

  public abstract interface WatchKey {
    method public abstract void cancel();
    method public abstract boolean isValid();
    method public abstract java.util.List<java.nio.file.WatchEvent<?>> pollEvents();
    method public abstract boolean reset();
    method public abstract java.nio.file.Watchable watchable();
  }

  public abstract interface WatchService {
    method public abstract void close() throws java.io.IOException;
    method public abstract java.nio.file.WatchKey poll();
    method public abstract java.nio.file.WatchKey poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public abstract java.nio.file.WatchKey take() throws java.lang.InterruptedException;
  }

  public abstract interface Watchable {
    method public abstract java.nio.file.WatchKey register(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind<?>[], java.nio.file.WatchEvent.Modifier...) throws java.io.IOException;
    method public abstract java.nio.file.WatchKey register(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind<?>...) throws java.io.IOException;
  }

}

package java.nio.file.attribute {

  public abstract interface BasicFileAttributes {
    method public abstract java.nio.file.attribute.FileTime creationTime();
    method public abstract java.lang.Object fileKey();
    method public abstract boolean isDirectory();
    method public abstract boolean isOther();
    method public abstract boolean isRegularFile();
    method public abstract boolean isSymbolicLink();
    method public abstract java.nio.file.attribute.FileTime lastAccessTime();
    method public abstract java.nio.file.attribute.FileTime lastModifiedTime();
    method public abstract long size();
  }

  public abstract interface FileAttribute<T> {
    method public abstract java.lang.String name();
    method public abstract T value();
  }

  public abstract interface FileAttributeView {
  }

  public abstract interface FileStoreAttributeView {
  }

  public final class FileTime implements java.lang.Comparable {
    method public int compareTo(java.nio.file.attribute.FileTime);
    method public int compareTo(java.lang.Object);
    method public static java.nio.file.attribute.FileTime from(long, java.util.concurrent.TimeUnit);
    method public static java.nio.file.attribute.FileTime from(java.time.Instant);
    method public static java.nio.file.attribute.FileTime fromMillis(long);
    method public long to(java.util.concurrent.TimeUnit);
    method public java.time.Instant toInstant();
    method public long toMillis();
  }

  public abstract interface GroupPrincipal implements java.nio.file.attribute.UserPrincipal {
  }

  public abstract interface UserPrincipal implements java.security.Principal {
  }

  public abstract class UserPrincipalLookupService {
    ctor protected UserPrincipalLookupService();
    method public abstract java.nio.file.attribute.GroupPrincipal lookupPrincipalByGroupName(java.lang.String) throws java.io.IOException;
    method public abstract java.nio.file.attribute.UserPrincipal lookupPrincipalByName(java.lang.String) throws java.io.IOException;
  }

}

package java.nio.file.spi {

  public abstract class FileSystemProvider {
    ctor protected FileSystemProvider();
    method public abstract void checkAccess(java.nio.file.Path, java.nio.file.AccessMode...) throws java.io.IOException;
    method public abstract void copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...) throws java.io.IOException;
    method public abstract void createDirectory(java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public void createLink(java.nio.file.Path, java.nio.file.Path) throws java.io.IOException;
    method public void createSymbolicLink(java.nio.file.Path, java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract void delete(java.nio.file.Path) throws java.io.IOException;
    method public boolean deleteIfExists(java.nio.file.Path) throws java.io.IOException;
    method public abstract <V extends java.nio.file.attribute.FileAttributeView> V getFileAttributeView(java.nio.file.Path, java.lang.Class<V>, java.nio.file.LinkOption...);
    method public abstract java.nio.file.FileStore getFileStore(java.nio.file.Path) throws java.io.IOException;
    method public abstract java.nio.file.FileSystem getFileSystem(java.net.URI);
    method public abstract java.nio.file.Path getPath(java.net.URI);
    method public abstract java.lang.String getScheme();
    method public static java.util.List<java.nio.file.spi.FileSystemProvider> installedProviders();
    method public abstract boolean isHidden(java.nio.file.Path) throws java.io.IOException;
    method public abstract boolean isSameFile(java.nio.file.Path, java.nio.file.Path) throws java.io.IOException;
    method public abstract void move(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...) throws java.io.IOException;
    method public java.nio.channels.AsynchronousFileChannel newAsynchronousFileChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.util.concurrent.ExecutorService, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract java.nio.channels.SeekableByteChannel newByteChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path, java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>) throws java.io.IOException;
    method public java.nio.channels.FileChannel newFileChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract java.nio.file.FileSystem newFileSystem(java.net.URI, java.util.Map<java.lang.String, ?>) throws java.io.IOException;
    method public java.nio.file.FileSystem newFileSystem(java.nio.file.Path, java.util.Map<java.lang.String, ?>) throws java.io.IOException;
    method public java.io.InputStream newInputStream(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public java.io.OutputStream newOutputStream(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public abstract <A extends java.nio.file.attribute.BasicFileAttributes> A readAttributes(java.nio.file.Path, java.lang.Class<A>, java.nio.file.LinkOption...) throws java.io.IOException;
    method public abstract java.util.Map<java.lang.String, java.lang.Object> readAttributes(java.nio.file.Path, java.lang.String, java.nio.file.LinkOption...) throws java.io.IOException;
    method public java.nio.file.Path readSymbolicLink(java.nio.file.Path) throws java.io.IOException;
    method public abstract void setAttribute(java.nio.file.Path, java.lang.String, java.lang.Object, java.nio.file.LinkOption...) throws java.io.IOException;
  }

}

package java.security {

  public final class AccessControlContext {
    ctor public AccessControlContext(java.security.ProtectionDomain[]);
    ctor public AccessControlContext(java.security.AccessControlContext, java.security.DomainCombiner);
    method public void checkPermission(java.security.Permission) throws java.security.AccessControlException;
    method public java.security.DomainCombiner getDomainCombiner();
  }

  public class AccessControlException extends java.lang.SecurityException {
    ctor public AccessControlException(java.lang.String);
    ctor public AccessControlException(java.lang.String, java.security.Permission);
    method public java.security.Permission getPermission();
  }

  public final class CodeSigner {
    ctor public CodeSigner(java.security.cert.CertPath, java.security.Timestamp);
    method public java.security.cert.CertPath getSignerCertPath();
    method public java.security.Timestamp getTimestamp();
  }

  public class CodeSource {
    ctor public CodeSource(java.net.URL, java.security.cert.Certificate[]);
    ctor public CodeSource(java.net.URL, java.security.CodeSigner[]);
    method public final java.security.cert.Certificate[] getCertificates();
    method public final java.security.CodeSigner[] getCodeSigners();
    method public final java.net.URL getLocation();
    method public boolean implies(java.security.CodeSource);
  }

  public abstract interface DomainCombiner {
    method public abstract java.security.ProtectionDomain[] combine(java.security.ProtectionDomain[], java.security.ProtectionDomain[]);
  }

  public class GeneralSecurityException extends java.lang.Exception {
    ctor public GeneralSecurityException();
    ctor public GeneralSecurityException(java.lang.String);
    ctor public GeneralSecurityException(java.lang.String, java.lang.Throwable);
    ctor public GeneralSecurityException(java.lang.Throwable);
  }

  public class InvalidKeyException extends java.security.KeyException {
    ctor public InvalidKeyException();
    ctor public InvalidKeyException(java.lang.String);
    ctor public InvalidKeyException(java.lang.String, java.lang.Throwable);
    ctor public InvalidKeyException(java.lang.Throwable);
  }

  public class KeyException extends java.security.GeneralSecurityException {
    ctor public KeyException();
    ctor public KeyException(java.lang.String);
    ctor public KeyException(java.lang.String, java.lang.Throwable);
    ctor public KeyException(java.lang.Throwable);
  }

  public class NoSuchAlgorithmException extends java.security.GeneralSecurityException {
    ctor public NoSuchAlgorithmException();
    ctor public NoSuchAlgorithmException(java.lang.String);
    ctor public NoSuchAlgorithmException(java.lang.String, java.lang.Throwable);
    ctor public NoSuchAlgorithmException(java.lang.Throwable);
  }

  public class NoSuchProviderException extends java.security.GeneralSecurityException {
    ctor public NoSuchProviderException();
    ctor public NoSuchProviderException(java.lang.String);
  }

  public abstract class Permission {
    ctor public Permission(java.lang.String);
    method public void checkGuard(java.lang.Object) throws java.lang.SecurityException;
    method public abstract boolean equals(java.lang.Object);
    method public abstract java.lang.String getActions();
    method public final java.lang.String getName();
    method public abstract int hashCode();
    method public abstract boolean implies(java.security.Permission);
    method public java.security.PermissionCollection newPermissionCollection();
  }

  public abstract class PermissionCollection {
    ctor public PermissionCollection();
    method public abstract void add(java.security.Permission);
    method public abstract java.util.Enumeration<java.security.Permission> elements();
    method public abstract boolean implies(java.security.Permission);
    method public boolean isReadOnly();
    method public void setReadOnly();
  }

  public abstract interface Principal {
    method public abstract boolean equals(java.lang.Object);
    method public abstract java.lang.String getName();
    method public abstract int hashCode();
    method public default boolean implies(javax.security.auth.Subject);
    method public abstract java.lang.String toString();
  }

  public abstract interface PrivilegedAction<T> {
    method public abstract T run();
  }

  public class PrivilegedActionException extends java.lang.Exception {
    ctor public PrivilegedActionException(java.lang.Exception);
    method public java.lang.Throwable getCause();
    method public java.lang.Exception getException();
  }

  public abstract interface PrivilegedExceptionAction<T> {
    method public abstract T run() throws java.lang.Exception;
  }

  public class ProtectionDomain {
    ctor public ProtectionDomain(java.security.CodeSource, java.security.PermissionCollection);
    ctor public ProtectionDomain(java.security.CodeSource, java.security.PermissionCollection, java.lang.ClassLoader, java.security.Principal[]);
    method public final java.lang.ClassLoader getClassLoader();
    method public final java.security.CodeSource getCodeSource();
    method public final java.security.PermissionCollection getPermissions();
    method public final java.security.Principal[] getPrincipals();
    method public boolean implies(java.security.Permission);
  }

  public abstract class Provider extends java.util.Properties {
    ctor protected Provider(java.lang.String, double, java.lang.String);
    method public synchronized java.lang.Object compute(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>);
    method public synchronized java.lang.Object computeIfAbsent(java.lang.Object, java.util.function.Function<? super java.lang.Object, ? extends java.lang.Object>);
    method public synchronized java.lang.Object computeIfPresent(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>);
    method public java.util.Enumeration<java.lang.Object> elements();
    method public synchronized java.util.Set<java.util.Map.Entry<java.lang.Object, java.lang.Object>> entrySet();
    method public synchronized void forEach(java.util.function.BiConsumer<? super java.lang.Object, ? super java.lang.Object>);
    method public java.lang.Object get(java.lang.Object);
    method public java.lang.String getInfo();
    method public java.lang.String getName();
    method public synchronized java.lang.Object getOrDefault(java.lang.Object, java.lang.Object);
    method public synchronized java.security.Provider.Service getService(java.lang.String, java.lang.String);
    method public synchronized java.util.Set<java.security.Provider.Service> getServices();
    method public double getVersion();
    method public java.util.Set<java.lang.Object> keySet();
    method public java.util.Enumeration<java.lang.Object> keys();
    method public synchronized java.lang.Object merge(java.lang.Object, java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>);
    method public synchronized java.lang.Object put(java.lang.Object, java.lang.Object);
    method public synchronized void putAll(java.util.Map<?, ?>);
    method public synchronized java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object);
    method protected synchronized void putService(java.security.Provider.Service);
    method public synchronized java.lang.Object remove(java.lang.Object);
    method protected synchronized void removeService(java.security.Provider.Service);
    method public synchronized boolean replace(java.lang.Object, java.lang.Object, java.lang.Object);
    method public synchronized java.lang.Object replace(java.lang.Object, java.lang.Object);
    method public synchronized void replaceAll(java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>);
    method public java.lang.String toString();
    method public java.util.Collection<java.lang.Object> values();
  }

  public static class Provider.Service {
    ctor public Provider.Service(java.security.Provider, java.lang.String, java.lang.String, java.lang.String, java.util.List<java.lang.String>, java.util.Map<java.lang.String, java.lang.String>);
    method public final java.lang.String getAlgorithm();
    method public final java.lang.String getAttribute(java.lang.String);
    method public final java.lang.String getClassName();
    method public final java.security.Provider getProvider();
    method public final java.lang.String getType();
    method public java.lang.Object newInstance(java.lang.Object) throws java.security.NoSuchAlgorithmException;
    method public boolean supportsParameter(java.lang.Object);
  }

  public abstract interface PublicKey {
    field public static final long serialVersionUID = 7187392471159151072L; // 0x63bebf5f40c219e0L
  }

  public class SignatureException extends java.security.GeneralSecurityException {
    ctor public SignatureException();
    ctor public SignatureException(java.lang.String);
    ctor public SignatureException(java.lang.String, java.lang.Throwable);
    ctor public SignatureException(java.lang.Throwable);
  }

  public final class Timestamp {
    ctor public Timestamp(java.util.Date, java.security.cert.CertPath);
    method public java.security.cert.CertPath getSignerCertPath();
    method public java.util.Date getTimestamp();
  }

}

package java.security.cert {

  public abstract class CertPath {
    ctor protected CertPath(java.lang.String);
    method public abstract java.util.List<? extends java.security.cert.Certificate> getCertificates();
    method public abstract byte[] getEncoded() throws java.security.cert.CertificateEncodingException;
    method public abstract byte[] getEncoded(java.lang.String) throws java.security.cert.CertificateEncodingException;
    method public abstract java.util.Iterator<java.lang.String> getEncodings();
    method public java.lang.String getType();
    method protected java.lang.Object writeReplace() throws java.io.ObjectStreamException;
  }

  public abstract class Certificate {
    ctor protected Certificate(java.lang.String);
    method public abstract byte[] getEncoded() throws java.security.cert.CertificateEncodingException;
    method public abstract java.security.PublicKey getPublicKey();
    method public final java.lang.String getType();
    method public abstract java.lang.String toString();
    method public abstract void verify(java.security.PublicKey) throws java.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
    method public abstract void verify(java.security.PublicKey, java.lang.String) throws java.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
    method public void verify(java.security.PublicKey, java.security.Provider) throws java.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.SignatureException;
    method protected java.lang.Object writeReplace() throws java.io.ObjectStreamException;
  }

  public class CertificateEncodingException extends java.security.cert.CertificateException {
    ctor public CertificateEncodingException();
    ctor public CertificateEncodingException(java.lang.String);
    ctor public CertificateEncodingException(java.lang.String, java.lang.Throwable);
    ctor public CertificateEncodingException(java.lang.Throwable);
  }

  public class CertificateException extends java.security.GeneralSecurityException {
    ctor public CertificateException();
    ctor public CertificateException(java.lang.String);
    ctor public CertificateException(java.lang.String, java.lang.Throwable);
    ctor public CertificateException(java.lang.Throwable);
  }

}

package java.text {

  public abstract interface AttributedCharacterIterator {
    method public abstract java.util.Set<java.text.AttributedCharacterIterator.Attribute> getAllAttributeKeys();
    method public abstract java.lang.Object getAttribute(java.text.AttributedCharacterIterator.Attribute);
    method public abstract java.util.Map<java.text.AttributedCharacterIterator.Attribute, java.lang.Object> getAttributes();
    method public abstract int getRunLimit();
    method public abstract int getRunLimit(java.text.AttributedCharacterIterator.Attribute);
    method public abstract int getRunLimit(java.util.Set<? extends java.text.AttributedCharacterIterator.Attribute>);
    method public abstract int getRunStart();
    method public abstract int getRunStart(java.text.AttributedCharacterIterator.Attribute);
    method public abstract int getRunStart(java.util.Set<? extends java.text.AttributedCharacterIterator.Attribute>);
  }

  public static class AttributedCharacterIterator.Attribute {
    ctor protected AttributedCharacterIterator.Attribute(java.lang.String);
    method public final boolean equals(java.lang.Object);
    method protected java.lang.String getName();
    method public final int hashCode();
    method protected java.lang.Object readResolve() throws java.io.InvalidObjectException;
    field public static final java.text.AttributedCharacterIterator.Attribute INPUT_METHOD_SEGMENT;
    field public static final java.text.AttributedCharacterIterator.Attribute LANGUAGE;
    field public static final java.text.AttributedCharacterIterator.Attribute READING;
  }

  public class FieldPosition {
    ctor public FieldPosition(int);
    ctor public FieldPosition(java.text.Format.Field);
    ctor public FieldPosition(java.text.Format.Field, int);
    method public int getBeginIndex();
    method public int getEndIndex();
    method public int getField();
    method public java.text.Format.Field getFieldAttribute();
    method public void setBeginIndex(int);
    method public void setEndIndex(int);
  }

  public abstract class Format {
    ctor protected Format();
    method public java.lang.Object clone();
    method public final java.lang.String format(java.lang.Object);
    method public abstract java.lang.StringBuffer format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition);
    method public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object);
    method public abstract java.lang.Object parseObject(java.lang.String, java.text.ParsePosition);
    method public java.lang.Object parseObject(java.lang.String) throws java.text.ParseException;
  }

  public static class Format.Field extends java.text.AttributedCharacterIterator.Attribute {
    ctor protected Format.Field(java.lang.String);
  }

  public class ParseException extends java.lang.Exception {
    ctor public ParseException(java.lang.String, int);
    method public int getErrorOffset();
  }

  public class ParsePosition {
    ctor public ParsePosition(int);
    method public int getErrorIndex();
    method public int getIndex();
    method public void setErrorIndex(int);
    method public void setIndex(int);
  }

}

package java.time {

  public abstract class Clock {
    ctor protected Clock();
    method public static java.time.Clock fixed(java.time.Instant, java.time.ZoneId);
    method public abstract java.time.ZoneId getZone();
    method public abstract java.time.Instant instant();
    method public long millis();
    method public static java.time.Clock offset(java.time.Clock, java.time.Duration);
    method public static java.time.Clock system(java.time.ZoneId);
    method public static java.time.Clock systemDefaultZone();
    method public static java.time.Clock systemUTC();
    method public static java.time.Clock tick(java.time.Clock, java.time.Duration);
    method public static java.time.Clock tickMinutes(java.time.ZoneId);
    method public static java.time.Clock tickSeconds(java.time.ZoneId);
    method public abstract java.time.Clock withZone(java.time.ZoneId);
  }

  public final class DayOfWeek extends java.lang.Enum implements java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public static java.time.DayOfWeek from(java.time.temporal.TemporalAccessor);
    method public java.lang.String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public long getLong(java.time.temporal.TemporalField);
    method public int getValue();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public java.time.DayOfWeek minus(long);
    method public static java.time.DayOfWeek of(int);
    method public java.time.DayOfWeek plus(long);
    method public static java.time.DayOfWeek valueOf(java.lang.String);
    method public static final java.time.DayOfWeek[] values();
    enum_constant public static final java.time.DayOfWeek FRIDAY;
    enum_constant public static final java.time.DayOfWeek MONDAY;
    enum_constant public static final java.time.DayOfWeek SATURDAY;
    enum_constant public static final java.time.DayOfWeek SUNDAY;
    enum_constant public static final java.time.DayOfWeek THURSDAY;
    enum_constant public static final java.time.DayOfWeek TUESDAY;
    enum_constant public static final java.time.DayOfWeek WEDNESDAY;
  }

  public final class Duration implements java.lang.Comparable java.time.temporal.TemporalAmount {
    method public java.time.Duration abs();
    method public java.time.temporal.Temporal addTo(java.time.temporal.Temporal);
    method public static java.time.Duration between(java.time.temporal.Temporal, java.time.temporal.Temporal);
    method public int compareTo(java.time.Duration);
    method public int compareTo(java.lang.Object);
    method public java.time.Duration dividedBy(long);
    method public static java.time.Duration from(java.time.temporal.TemporalAmount);
    method public long get(java.time.temporal.TemporalUnit);
    method public int getNano();
    method public long getSeconds();
    method public java.util.List<java.time.temporal.TemporalUnit> getUnits();
    method public boolean isNegative();
    method public boolean isZero();
    method public java.time.Duration minus(java.time.Duration);
    method public java.time.Duration minus(long, java.time.temporal.TemporalUnit);
    method public java.time.Duration minusDays(long);
    method public java.time.Duration minusHours(long);
    method public java.time.Duration minusMillis(long);
    method public java.time.Duration minusMinutes(long);
    method public java.time.Duration minusNanos(long);
    method public java.time.Duration minusSeconds(long);
    method public java.time.Duration multipliedBy(long);
    method public java.time.Duration negated();
    method public static java.time.Duration of(long, java.time.temporal.TemporalUnit);
    method public static java.time.Duration ofDays(long);
    method public static java.time.Duration ofHours(long);
    method public static java.time.Duration ofMillis(long);
    method public static java.time.Duration ofMinutes(long);
    method public static java.time.Duration ofNanos(long);
    method public static java.time.Duration ofSeconds(long);
    method public static java.time.Duration ofSeconds(long, long);
    method public static java.time.Duration parse(java.lang.CharSequence);
    method public java.time.Duration plus(java.time.Duration);
    method public java.time.Duration plus(long, java.time.temporal.TemporalUnit);
    method public java.time.Duration plusDays(long);
    method public java.time.Duration plusHours(long);
    method public java.time.Duration plusMillis(long);
    method public java.time.Duration plusMinutes(long);
    method public java.time.Duration plusNanos(long);
    method public java.time.Duration plusSeconds(long);
    method public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal);
    method public long toDays();
    method public long toHours();
    method public long toMillis();
    method public long toMinutes();
    method public long toNanos();
    method public java.time.Duration withNanos(int);
    method public java.time.Duration withSeconds(long);
    field public static final java.time.Duration ZERO;
  }

  public final class Instant implements java.lang.Comparable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.OffsetDateTime atOffset(java.time.ZoneOffset);
    method public java.time.ZonedDateTime atZone(java.time.ZoneId);
    method public int compareTo(java.time.Instant);
    method public int compareTo(java.lang.Object);
    method public static java.time.Instant from(java.time.temporal.TemporalAccessor);
    method public long getEpochSecond();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getNano();
    method public boolean isAfter(java.time.Instant);
    method public boolean isBefore(java.time.Instant);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.Instant minus(java.time.temporal.TemporalAmount);
    method public java.time.Instant minus(long, java.time.temporal.TemporalUnit);
    method public java.time.Instant minusMillis(long);
    method public java.time.Instant minusNanos(long);
    method public java.time.Instant minusSeconds(long);
    method public static java.time.Instant now();
    method public static java.time.Instant now(java.time.Clock);
    method public static java.time.Instant ofEpochMilli(long);
    method public static java.time.Instant ofEpochSecond(long);
    method public static java.time.Instant ofEpochSecond(long, long);
    method public static java.time.Instant parse(java.lang.CharSequence);
    method public java.time.Instant plus(java.time.temporal.TemporalAmount);
    method public java.time.Instant plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public java.time.Instant plusMillis(long);
    method public java.time.Instant plusNanos(long);
    method public java.time.Instant plusSeconds(long);
    method public long toEpochMilli();
    method public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.Instant with(java.time.temporal.TemporalAdjuster);
    method public java.time.Instant with(java.time.temporal.TemporalField, long);
    method public java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
    field public static final java.time.Instant EPOCH;
    field public static final java.time.Instant MAX;
    field public static final java.time.Instant MIN;
  }

  public final class LocalDate implements java.time.chrono.ChronoLocalDate java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.LocalDateTime atStartOfDay();
    method public java.time.ZonedDateTime atStartOfDay(java.time.ZoneId);
    method public java.time.LocalDateTime atTime(java.time.LocalTime);
    method public java.time.LocalDateTime atTime(int, int);
    method public java.time.LocalDateTime atTime(int, int, int);
    method public java.time.LocalDateTime atTime(int, int, int, int);
    method public java.time.OffsetDateTime atTime(java.time.OffsetTime);
    method public java.time.chrono.ChronoLocalDateTime atTime(java.time.LocalTime);
    method public static java.time.LocalDate from(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.IsoChronology getChronology();
    method public java.time.chrono.Chronology getChronology();
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public long getLong(java.time.temporal.TemporalField);
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getYear();
    method public int lengthOfMonth();
    method public java.time.LocalDate minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDate minus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDate minus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDate minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDate minusDays(long);
    method public java.time.LocalDate minusMonths(long);
    method public java.time.LocalDate minusWeeks(long);
    method public java.time.LocalDate minusYears(long);
    method public static java.time.LocalDate now();
    method public static java.time.LocalDate now(java.time.ZoneId);
    method public static java.time.LocalDate now(java.time.Clock);
    method public static java.time.LocalDate of(int, java.time.Month, int);
    method public static java.time.LocalDate of(int, int, int);
    method public static java.time.LocalDate ofEpochDay(long);
    method public static java.time.LocalDate ofYearDay(int, int);
    method public static java.time.LocalDate parse(java.lang.CharSequence);
    method public static java.time.LocalDate parse(java.lang.CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.LocalDate plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDate plus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDate plus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDate plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDate plusDays(long);
    method public java.time.LocalDate plusMonths(long);
    method public java.time.LocalDate plusWeeks(long);
    method public java.time.LocalDate plusYears(long);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.Period until(java.time.chrono.ChronoLocalDate);
    method public java.time.chrono.ChronoPeriod until(java.time.chrono.ChronoLocalDate);
    method public java.time.LocalDate with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalDate with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ChronoLocalDate with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ChronoLocalDate with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalDate withDayOfMonth(int);
    method public java.time.LocalDate withDayOfYear(int);
    method public java.time.LocalDate withMonth(int);
    method public java.time.LocalDate withYear(int);
    field public static final java.time.LocalDate MAX;
    field public static final java.time.LocalDate MIN;
  }

  public final class LocalDateTime implements java.time.chrono.ChronoLocalDateTime java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.OffsetDateTime atOffset(java.time.ZoneOffset);
    method public java.time.ZonedDateTime atZone(java.time.ZoneId);
    method public java.time.chrono.ChronoZonedDateTime atZone(java.time.ZoneId);
    method public static java.time.LocalDateTime from(java.time.temporal.TemporalAccessor);
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getNano();
    method public int getSecond();
    method public int getYear();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public java.time.LocalDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDateTime minusDays(long);
    method public java.time.LocalDateTime minusHours(long);
    method public java.time.LocalDateTime minusMinutes(long);
    method public java.time.LocalDateTime minusMonths(long);
    method public java.time.LocalDateTime minusNanos(long);
    method public java.time.LocalDateTime minusSeconds(long);
    method public java.time.LocalDateTime minusWeeks(long);
    method public java.time.LocalDateTime minusYears(long);
    method public static java.time.LocalDateTime now();
    method public static java.time.LocalDateTime now(java.time.ZoneId);
    method public static java.time.LocalDateTime now(java.time.Clock);
    method public static java.time.LocalDateTime of(int, java.time.Month, int, int, int);
    method public static java.time.LocalDateTime of(int, java.time.Month, int, int, int, int);
    method public static java.time.LocalDateTime of(int, java.time.Month, int, int, int, int, int);
    method public static java.time.LocalDateTime of(int, int, int, int, int);
    method public static java.time.LocalDateTime of(int, int, int, int, int, int);
    method public static java.time.LocalDateTime of(int, int, int, int, int, int, int);
    method public static java.time.LocalDateTime of(java.time.LocalDate, java.time.LocalTime);
    method public static java.time.LocalDateTime ofEpochSecond(long, int, java.time.ZoneOffset);
    method public static java.time.LocalDateTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.LocalDateTime parse(java.lang.CharSequence);
    method public static java.time.LocalDateTime parse(java.lang.CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.LocalDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoLocalDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDateTime plusDays(long);
    method public java.time.LocalDateTime plusHours(long);
    method public java.time.LocalDateTime plusMinutes(long);
    method public java.time.LocalDateTime plusMonths(long);
    method public java.time.LocalDateTime plusNanos(long);
    method public java.time.LocalDateTime plusSeconds(long);
    method public java.time.LocalDateTime plusWeeks(long);
    method public java.time.LocalDateTime plusYears(long);
    method public java.time.LocalDate toLocalDate();
    method public java.time.chrono.ChronoLocalDate toLocalDate();
    method public java.time.LocalTime toLocalTime();
    method public java.time.LocalDateTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.LocalDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ChronoLocalDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ChronoLocalDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalDateTime withDayOfMonth(int);
    method public java.time.LocalDateTime withDayOfYear(int);
    method public java.time.LocalDateTime withHour(int);
    method public java.time.LocalDateTime withMinute(int);
    method public java.time.LocalDateTime withMonth(int);
    method public java.time.LocalDateTime withNano(int);
    method public java.time.LocalDateTime withSecond(int);
    method public java.time.LocalDateTime withYear(int);
    field public static final java.time.LocalDateTime MAX;
    field public static final java.time.LocalDateTime MIN;
  }

  public final class LocalTime implements java.lang.Comparable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.LocalDateTime atDate(java.time.LocalDate);
    method public java.time.OffsetTime atOffset(java.time.ZoneOffset);
    method public int compareTo(java.time.LocalTime);
    method public int compareTo(java.lang.Object);
    method public java.lang.String format(java.time.format.DateTimeFormatter);
    method public static java.time.LocalTime from(java.time.temporal.TemporalAccessor);
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public int getNano();
    method public int getSecond();
    method public boolean isAfter(java.time.LocalTime);
    method public boolean isBefore(java.time.LocalTime);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.LocalTime minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalTime minusHours(long);
    method public java.time.LocalTime minusMinutes(long);
    method public java.time.LocalTime minusNanos(long);
    method public java.time.LocalTime minusSeconds(long);
    method public static java.time.LocalTime now();
    method public static java.time.LocalTime now(java.time.ZoneId);
    method public static java.time.LocalTime now(java.time.Clock);
    method public static java.time.LocalTime of(int, int);
    method public static java.time.LocalTime of(int, int, int);
    method public static java.time.LocalTime of(int, int, int, int);
    method public static java.time.LocalTime ofNanoOfDay(long);
    method public static java.time.LocalTime ofSecondOfDay(long);
    method public static java.time.LocalTime parse(java.lang.CharSequence);
    method public static java.time.LocalTime parse(java.lang.CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.LocalTime plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalTime plusHours(long);
    method public java.time.LocalTime plusMinutes(long);
    method public java.time.LocalTime plusNanos(long);
    method public java.time.LocalTime plusSeconds(long);
    method public long toNanoOfDay();
    method public int toSecondOfDay();
    method public java.time.LocalTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.LocalTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalTime with(java.time.temporal.TemporalField, long);
    method public java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
    method public java.time.LocalTime withHour(int);
    method public java.time.LocalTime withMinute(int);
    method public java.time.LocalTime withNano(int);
    method public java.time.LocalTime withSecond(int);
    field public static final java.time.LocalTime MAX;
    field public static final java.time.LocalTime MIDNIGHT;
    field public static final java.time.LocalTime MIN;
    field public static final java.time.LocalTime NOON;
  }

  public final class Month extends java.lang.Enum implements java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public int firstDayOfYear(boolean);
    method public java.time.Month firstMonthOfQuarter();
    method public static java.time.Month from(java.time.temporal.TemporalAccessor);
    method public java.lang.String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public long getLong(java.time.temporal.TemporalField);
    method public int getValue();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public int length(boolean);
    method public int maxLength();
    method public int minLength();
    method public java.time.Month minus(long);
    method public static java.time.Month of(int);
    method public java.time.Month plus(long);
    method public static java.time.Month valueOf(java.lang.String);
    method public static final java.time.Month[] values();
    enum_constant public static final java.time.Month APRIL;
    enum_constant public static final java.time.Month AUGUST;
    enum_constant public static final java.time.Month DECEMBER;
    enum_constant public static final java.time.Month FEBRUARY;
    enum_constant public static final java.time.Month JANUARY;
    enum_constant public static final java.time.Month JULY;
    enum_constant public static final java.time.Month JUNE;
    enum_constant public static final java.time.Month MARCH;
    enum_constant public static final java.time.Month MAY;
    enum_constant public static final java.time.Month NOVEMBER;
    enum_constant public static final java.time.Month OCTOBER;
    enum_constant public static final java.time.Month SEPTEMBER;
  }

  public final class OffsetDateTime implements java.lang.Comparable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.ZonedDateTime atZoneSameInstant(java.time.ZoneId);
    method public java.time.ZonedDateTime atZoneSimilarLocal(java.time.ZoneId);
    method public int compareTo(java.time.OffsetDateTime);
    method public int compareTo(java.lang.Object);
    method public java.lang.String format(java.time.format.DateTimeFormatter);
    method public static java.time.OffsetDateTime from(java.time.temporal.TemporalAccessor);
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getNano();
    method public java.time.ZoneOffset getOffset();
    method public int getSecond();
    method public int getYear();
    method public boolean isAfter(java.time.OffsetDateTime);
    method public boolean isBefore(java.time.OffsetDateTime);
    method public boolean isEqual(java.time.OffsetDateTime);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime minusDays(long);
    method public java.time.OffsetDateTime minusHours(long);
    method public java.time.OffsetDateTime minusMinutes(long);
    method public java.time.OffsetDateTime minusMonths(long);
    method public java.time.OffsetDateTime minusNanos(long);
    method public java.time.OffsetDateTime minusSeconds(long);
    method public java.time.OffsetDateTime minusWeeks(long);
    method public java.time.OffsetDateTime minusYears(long);
    method public static java.time.OffsetDateTime now();
    method public static java.time.OffsetDateTime now(java.time.ZoneId);
    method public static java.time.OffsetDateTime now(java.time.Clock);
    method public static java.time.OffsetDateTime of(java.time.LocalDate, java.time.LocalTime, java.time.ZoneOffset);
    method public static java.time.OffsetDateTime of(java.time.LocalDateTime, java.time.ZoneOffset);
    method public static java.time.OffsetDateTime of(int, int, int, int, int, int, int, java.time.ZoneOffset);
    method public static java.time.OffsetDateTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.OffsetDateTime parse(java.lang.CharSequence);
    method public static java.time.OffsetDateTime parse(java.lang.CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.OffsetDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime plusDays(long);
    method public java.time.OffsetDateTime plusHours(long);
    method public java.time.OffsetDateTime plusMinutes(long);
    method public java.time.OffsetDateTime plusMonths(long);
    method public java.time.OffsetDateTime plusNanos(long);
    method public java.time.OffsetDateTime plusSeconds(long);
    method public java.time.OffsetDateTime plusWeeks(long);
    method public java.time.OffsetDateTime plusYears(long);
    method public static java.util.Comparator<java.time.OffsetDateTime> timeLineOrder();
    method public long toEpochSecond();
    method public java.time.Instant toInstant();
    method public java.time.LocalDate toLocalDate();
    method public java.time.LocalDateTime toLocalDateTime();
    method public java.time.LocalTime toLocalTime();
    method public java.time.OffsetTime toOffsetTime();
    method public java.time.ZonedDateTime toZonedDateTime();
    method public java.time.OffsetDateTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.OffsetDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
    method public java.time.OffsetDateTime withDayOfMonth(int);
    method public java.time.OffsetDateTime withDayOfYear(int);
    method public java.time.OffsetDateTime withHour(int);
    method public java.time.OffsetDateTime withMinute(int);
    method public java.time.OffsetDateTime withMonth(int);
    method public java.time.OffsetDateTime withNano(int);
    method public java.time.OffsetDateTime withOffsetSameInstant(java.time.ZoneOffset);
    method public java.time.OffsetDateTime withOffsetSameLocal(java.time.ZoneOffset);
    method public java.time.OffsetDateTime withSecond(int);
    method public java.time.OffsetDateTime withYear(int);
    field public static final java.time.OffsetDateTime MAX;
    field public static final java.time.OffsetDateTime MIN;
  }

  public final class OffsetTime implements java.lang.Comparable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.OffsetDateTime atDate(java.time.LocalDate);
    method public int compareTo(java.time.OffsetTime);
    method public int compareTo(java.lang.Object);
    method public java.lang.String format(java.time.format.DateTimeFormatter);
    method public static java.time.OffsetTime from(java.time.temporal.TemporalAccessor);
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public int getNano();
    method public java.time.ZoneOffset getOffset();
    method public int getSecond();
    method public boolean isAfter(java.time.OffsetTime);
    method public boolean isBefore(java.time.OffsetTime);
    method public boolean isEqual(java.time.OffsetTime);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime minus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime minusHours(long);
    method public java.time.OffsetTime minusMinutes(long);
    method public java.time.OffsetTime minusNanos(long);
    method public java.time.OffsetTime minusSeconds(long);
    method public static java.time.OffsetTime now();
    method public static java.time.OffsetTime now(java.time.ZoneId);
    method public static java.time.OffsetTime now(java.time.Clock);
    method public static java.time.OffsetTime of(java.time.LocalTime, java.time.ZoneOffset);
    method public static java.time.OffsetTime of(int, int, int, int, java.time.ZoneOffset);
    method public static java.time.OffsetTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.OffsetTime parse(java.lang.CharSequence);
    method public static java.time.OffsetTime parse(java.lang.CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.OffsetTime plus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime plusHours(long);
    method public java.time.OffsetTime plusMinutes(long);
    method public java.time.OffsetTime plusNanos(long);
    method public java.time.OffsetTime plusSeconds(long);
    method public java.time.LocalTime toLocalTime();
    method public java.time.OffsetTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.OffsetTime with(java.time.temporal.TemporalField, long);
    method public java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
    method public java.time.OffsetTime withHour(int);
    method public java.time.OffsetTime withMinute(int);
    method public java.time.OffsetTime withNano(int);
    method public java.time.OffsetTime withOffsetSameInstant(java.time.ZoneOffset);
    method public java.time.OffsetTime withOffsetSameLocal(java.time.ZoneOffset);
    method public java.time.OffsetTime withSecond(int);
    field public static final java.time.OffsetTime MAX;
    field public static final java.time.OffsetTime MIN;
  }

  public final class Period implements java.time.chrono.ChronoPeriod {
    method public java.time.temporal.Temporal addTo(java.time.temporal.Temporal);
    method public static java.time.Period between(java.time.LocalDate, java.time.LocalDate);
    method public static java.time.Period from(java.time.temporal.TemporalAmount);
    method public long get(java.time.temporal.TemporalUnit);
    method public java.time.chrono.IsoChronology getChronology();
    method public java.time.chrono.Chronology getChronology();
    method public int getDays();
    method public int getMonths();
    method public java.util.List<java.time.temporal.TemporalUnit> getUnits();
    method public int getYears();
    method public java.time.Period minus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.ChronoPeriod minus(java.time.temporal.TemporalAmount);
    method public java.time.Period minusDays(long);
    method public java.time.Period minusMonths(long);
    method public java.time.Period minusYears(long);
    method public java.time.Period multipliedBy(int);
    method public java.time.chrono.ChronoPeriod multipliedBy(int);
    method public java.time.Period negated();
    method public java.time.Period normalized();
    method public java.time.chrono.ChronoPeriod normalized();
    method public static java.time.Period of(int, int, int);
    method public static java.time.Period ofDays(int);
    method public static java.time.Period ofMonths(int);
    method public static java.time.Period ofWeeks(int);
    method public static java.time.Period ofYears(int);
    method public static java.time.Period parse(java.lang.CharSequence);
    method public java.time.Period plus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.ChronoPeriod plus(java.time.temporal.TemporalAmount);
    method public java.time.Period plusDays(long);
    method public java.time.Period plusMonths(long);
    method public java.time.Period plusYears(long);
    method public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal);
    method public long toTotalMonths();
    method public java.time.Period withDays(int);
    method public java.time.Period withMonths(int);
    method public java.time.Period withYears(int);
    field public static final java.time.Period ZERO;
  }

  public abstract class ZoneId {
    method public static java.time.ZoneId from(java.time.temporal.TemporalAccessor);
    method public static java.util.Set<java.lang.String> getAvailableZoneIds();
    method public java.lang.String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public abstract java.lang.String getId();
    method public abstract java.time.zone.ZoneRules getRules();
    method public java.time.ZoneId normalized();
    method public static java.time.ZoneId of(java.lang.String, java.util.Map<java.lang.String, java.lang.String>);
    method public static java.time.ZoneId of(java.lang.String);
    method public static java.time.ZoneId ofOffset(java.lang.String, java.time.ZoneOffset);
    method public static java.time.ZoneId systemDefault();
    field public static final java.util.Map<java.lang.String, java.lang.String> SHORT_IDS;
  }

  public final class ZoneOffset extends java.time.ZoneId implements java.lang.Comparable java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public int compareTo(java.time.ZoneOffset);
    method public int compareTo(java.lang.Object);
    method public static java.time.ZoneOffset from(java.time.temporal.TemporalAccessor);
    method public java.lang.String getId();
    method public long getLong(java.time.temporal.TemporalField);
    method public java.time.zone.ZoneRules getRules();
    method public int getTotalSeconds();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public static java.time.ZoneOffset of(java.lang.String);
    method public static java.time.ZoneOffset ofHours(int);
    method public static java.time.ZoneOffset ofHoursMinutes(int, int);
    method public static java.time.ZoneOffset ofHoursMinutesSeconds(int, int, int);
    method public static java.time.ZoneOffset ofTotalSeconds(int);
    field public static final java.time.ZoneOffset MAX;
    field public static final java.time.ZoneOffset MIN;
    field public static final java.time.ZoneOffset UTC;
  }

  public final class ZonedDateTime implements java.time.chrono.ChronoZonedDateTime java.time.temporal.Temporal {
    method public static java.time.ZonedDateTime from(java.time.temporal.TemporalAccessor);
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public int getHour();
    method public int getMinute();
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getNano();
    method public java.time.ZoneOffset getOffset();
    method public int getSecond();
    method public int getYear();
    method public java.time.ZoneId getZone();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public java.time.ZonedDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.ZonedDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoZonedDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoZonedDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.ZonedDateTime minusDays(long);
    method public java.time.ZonedDateTime minusHours(long);
    method public java.time.ZonedDateTime minusMinutes(long);
    method public java.time.ZonedDateTime minusMonths(long);
    method public java.time.ZonedDateTime minusNanos(long);
    method public java.time.ZonedDateTime minusSeconds(long);
    method public java.time.ZonedDateTime minusWeeks(long);
    method public java.time.ZonedDateTime minusYears(long);
    method public static java.time.ZonedDateTime now();
    method public static java.time.ZonedDateTime now(java.time.ZoneId);
    method public static java.time.ZonedDateTime now(java.time.Clock);
    method public static java.time.ZonedDateTime of(java.time.LocalDate, java.time.LocalTime, java.time.ZoneId);
    method public static java.time.ZonedDateTime of(java.time.LocalDateTime, java.time.ZoneId);
    method public static java.time.ZonedDateTime of(int, int, int, int, int, int, int, java.time.ZoneId);
    method public static java.time.ZonedDateTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.ZonedDateTime ofInstant(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneId);
    method public static java.time.ZonedDateTime ofLocal(java.time.LocalDateTime, java.time.ZoneId, java.time.ZoneOffset);
    method public static java.time.ZonedDateTime ofStrict(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneId);
    method public static java.time.ZonedDateTime parse(java.lang.CharSequence);
    method public static java.time.ZonedDateTime parse(java.lang.CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.ZonedDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.ZonedDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoZonedDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ChronoZonedDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.ZonedDateTime plusDays(long);
    method public java.time.ZonedDateTime plusHours(long);
    method public java.time.ZonedDateTime plusMinutes(long);
    method public java.time.ZonedDateTime plusMonths(long);
    method public java.time.ZonedDateTime plusNanos(long);
    method public java.time.ZonedDateTime plusSeconds(long);
    method public java.time.ZonedDateTime plusWeeks(long);
    method public java.time.ZonedDateTime plusYears(long);
    method public java.time.LocalDate toLocalDate();
    method public java.time.chrono.ChronoLocalDate toLocalDate();
    method public java.time.LocalDateTime toLocalDateTime();
    method public java.time.chrono.ChronoLocalDateTime toLocalDateTime();
    method public java.time.OffsetDateTime toOffsetDateTime();
    method public java.time.ZonedDateTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.ZonedDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.ZonedDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ChronoZonedDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ChronoZonedDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.ZonedDateTime withDayOfMonth(int);
    method public java.time.ZonedDateTime withDayOfYear(int);
    method public java.time.ZonedDateTime withEarlierOffsetAtOverlap();
    method public java.time.chrono.ChronoZonedDateTime withEarlierOffsetAtOverlap();
    method public java.time.ZonedDateTime withFixedOffsetZone();
    method public java.time.ZonedDateTime withHour(int);
    method public java.time.ZonedDateTime withLaterOffsetAtOverlap();
    method public java.time.chrono.ChronoZonedDateTime withLaterOffsetAtOverlap();
    method public java.time.ZonedDateTime withMinute(int);
    method public java.time.ZonedDateTime withMonth(int);
    method public java.time.ZonedDateTime withNano(int);
    method public java.time.ZonedDateTime withSecond(int);
    method public java.time.ZonedDateTime withYear(int);
    method public java.time.ZonedDateTime withZoneSameInstant(java.time.ZoneId);
    method public java.time.chrono.ChronoZonedDateTime withZoneSameInstant(java.time.ZoneId);
    method public java.time.ZonedDateTime withZoneSameLocal(java.time.ZoneId);
    method public java.time.chrono.ChronoZonedDateTime withZoneSameLocal(java.time.ZoneId);
  }

}

package java.time.chrono {

  public abstract class AbstractChronology implements java.time.chrono.Chronology {
    ctor protected AbstractChronology();
    method public int compareTo(java.time.chrono.Chronology);
    method public java.time.chrono.ChronoLocalDate resolveDate(java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, java.time.format.ResolverStyle);
  }

  public abstract interface ChronoLocalDate implements java.lang.Comparable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public default java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public default java.time.chrono.ChronoLocalDateTime<?> atTime(java.time.LocalTime);
    method public default int compareTo(java.time.chrono.ChronoLocalDate);
    method public default int compareTo(java.lang.Object);
    method public abstract boolean equals(java.lang.Object);
    method public default java.lang.String format(java.time.format.DateTimeFormatter);
    method public static java.time.chrono.ChronoLocalDate from(java.time.temporal.TemporalAccessor);
    method public abstract java.time.chrono.Chronology getChronology();
    method public default java.time.chrono.Era getEra();
    method public abstract int hashCode();
    method public default boolean isAfter(java.time.chrono.ChronoLocalDate);
    method public default boolean isBefore(java.time.chrono.ChronoLocalDate);
    method public default boolean isEqual(java.time.chrono.ChronoLocalDate);
    method public default boolean isLeapYear();
    method public default boolean isSupported(java.time.temporal.TemporalField);
    method public default boolean isSupported(java.time.temporal.TemporalUnit);
    method public abstract int lengthOfMonth();
    method public default int lengthOfYear();
    method public default java.time.chrono.ChronoLocalDate minus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoLocalDate minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoLocalDate plus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoLocalDate plus(long, java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public static java.util.Comparator<java.time.chrono.ChronoLocalDate> timeLineOrder();
    method public default long toEpochDay();
    method public abstract java.lang.String toString();
    method public abstract long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public abstract java.time.chrono.ChronoPeriod until(java.time.chrono.ChronoLocalDate);
    method public default java.time.chrono.ChronoLocalDate with(java.time.temporal.TemporalAdjuster);
    method public default java.time.chrono.ChronoLocalDate with(java.time.temporal.TemporalField, long);
    method public default java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
  }

  public abstract interface ChronoLocalDateTime<D extends java.time.chrono.ChronoLocalDate> implements java.lang.Comparable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public default java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public abstract java.time.chrono.ChronoZonedDateTime<D> atZone(java.time.ZoneId);
    method public default int compareTo(java.time.chrono.ChronoLocalDateTime<?>);
    method public default int compareTo(java.lang.Object);
    method public abstract boolean equals(java.lang.Object);
    method public default java.lang.String format(java.time.format.DateTimeFormatter);
    method public static java.time.chrono.ChronoLocalDateTime<?> from(java.time.temporal.TemporalAccessor);
    method public default java.time.chrono.Chronology getChronology();
    method public abstract int hashCode();
    method public default boolean isAfter(java.time.chrono.ChronoLocalDateTime<?>);
    method public default boolean isBefore(java.time.chrono.ChronoLocalDateTime<?>);
    method public default boolean isEqual(java.time.chrono.ChronoLocalDateTime<?>);
    method public abstract boolean isSupported(java.time.temporal.TemporalField);
    method public default boolean isSupported(java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoLocalDateTime<D> minus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoLocalDateTime<D> minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoLocalDateTime<D> plus(java.time.temporal.TemporalAmount);
    method public abstract java.time.chrono.ChronoLocalDateTime<D> plus(long, java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public static java.util.Comparator<java.time.chrono.ChronoLocalDateTime<?>> timeLineOrder();
    method public default long toEpochSecond(java.time.ZoneOffset);
    method public default java.time.Instant toInstant(java.time.ZoneOffset);
    method public abstract D toLocalDate();
    method public abstract java.time.LocalTime toLocalTime();
    method public abstract java.lang.String toString();
    method public default java.time.chrono.ChronoLocalDateTime<D> with(java.time.temporal.TemporalAdjuster);
    method public abstract java.time.chrono.ChronoLocalDateTime<D> with(java.time.temporal.TemporalField, long);
    method public default java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
  }

  public abstract interface ChronoPeriod implements java.time.temporal.TemporalAmount {
    method public abstract java.time.temporal.Temporal addTo(java.time.temporal.Temporal);
    method public static java.time.chrono.ChronoPeriod between(java.time.chrono.ChronoLocalDate, java.time.chrono.ChronoLocalDate);
    method public abstract boolean equals(java.lang.Object);
    method public abstract long get(java.time.temporal.TemporalUnit);
    method public abstract java.time.chrono.Chronology getChronology();
    method public abstract java.util.List<java.time.temporal.TemporalUnit> getUnits();
    method public abstract int hashCode();
    method public default boolean isNegative();
    method public default boolean isZero();
    method public abstract java.time.chrono.ChronoPeriod minus(java.time.temporal.TemporalAmount);
    method public abstract java.time.chrono.ChronoPeriod multipliedBy(int);
    method public default java.time.chrono.ChronoPeriod negated();
    method public abstract java.time.chrono.ChronoPeriod normalized();
    method public abstract java.time.chrono.ChronoPeriod plus(java.time.temporal.TemporalAmount);
    method public abstract java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal);
    method public abstract java.lang.String toString();
  }

  public abstract interface ChronoZonedDateTime<D extends java.time.chrono.ChronoLocalDate> implements java.lang.Comparable java.time.temporal.Temporal {
    method public default int compareTo(java.time.chrono.ChronoZonedDateTime<?>);
    method public default int compareTo(java.lang.Object);
    method public abstract boolean equals(java.lang.Object);
    method public default java.lang.String format(java.time.format.DateTimeFormatter);
    method public static java.time.chrono.ChronoZonedDateTime<?> from(java.time.temporal.TemporalAccessor);
    method public default java.time.chrono.Chronology getChronology();
    method public default long getLong(java.time.temporal.TemporalField);
    method public abstract java.time.ZoneOffset getOffset();
    method public abstract java.time.ZoneId getZone();
    method public abstract int hashCode();
    method public default boolean isAfter(java.time.chrono.ChronoZonedDateTime<?>);
    method public default boolean isBefore(java.time.chrono.ChronoZonedDateTime<?>);
    method public default boolean isEqual(java.time.chrono.ChronoZonedDateTime<?>);
    method public abstract boolean isSupported(java.time.temporal.TemporalField);
    method public default boolean isSupported(java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoZonedDateTime<D> minus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoZonedDateTime<D> minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoZonedDateTime<D> plus(java.time.temporal.TemporalAmount);
    method public abstract java.time.chrono.ChronoZonedDateTime<D> plus(long, java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public static java.util.Comparator<java.time.chrono.ChronoZonedDateTime<?>> timeLineOrder();
    method public default long toEpochSecond();
    method public default java.time.Instant toInstant();
    method public default D toLocalDate();
    method public abstract java.time.chrono.ChronoLocalDateTime<D> toLocalDateTime();
    method public default java.time.LocalTime toLocalTime();
    method public abstract java.lang.String toString();
    method public default java.time.chrono.ChronoZonedDateTime<D> with(java.time.temporal.TemporalAdjuster);
    method public abstract java.time.chrono.ChronoZonedDateTime<D> with(java.time.temporal.TemporalField, long);
    method public default java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
    method public abstract java.time.chrono.ChronoZonedDateTime<D> withEarlierOffsetAtOverlap();
    method public abstract java.time.chrono.ChronoZonedDateTime<D> withLaterOffsetAtOverlap();
    method public abstract java.time.chrono.ChronoZonedDateTime<D> withZoneSameInstant(java.time.ZoneId);
    method public abstract java.time.chrono.ChronoZonedDateTime<D> withZoneSameLocal(java.time.ZoneId);
  }

  public abstract interface Chronology implements java.lang.Comparable {
    method public abstract int compareTo(java.time.chrono.Chronology);
    method public default int compareTo(java.lang.Object);
    method public default java.time.chrono.ChronoLocalDate date(java.time.chrono.Era, int, int, int);
    method public abstract java.time.chrono.ChronoLocalDate date(int, int, int);
    method public abstract java.time.chrono.ChronoLocalDate date(java.time.temporal.TemporalAccessor);
    method public abstract java.time.chrono.ChronoLocalDate dateEpochDay(long);
    method public default java.time.chrono.ChronoLocalDate dateNow();
    method public default java.time.chrono.ChronoLocalDate dateNow(java.time.ZoneId);
    method public default java.time.chrono.ChronoLocalDate dateNow(java.time.Clock);
    method public default java.time.chrono.ChronoLocalDate dateYearDay(java.time.chrono.Era, int, int);
    method public abstract java.time.chrono.ChronoLocalDate dateYearDay(int, int);
    method public abstract boolean equals(java.lang.Object);
    method public abstract java.time.chrono.Era eraOf(int);
    method public abstract java.util.List<java.time.chrono.Era> eras();
    method public static java.time.chrono.Chronology from(java.time.temporal.TemporalAccessor);
    method public static java.util.Set<java.time.chrono.Chronology> getAvailableChronologies();
    method public abstract java.lang.String getCalendarType();
    method public default java.lang.String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public abstract java.lang.String getId();
    method public abstract int hashCode();
    method public abstract boolean isLeapYear(long);
    method public default java.time.chrono.ChronoLocalDateTime<? extends java.time.chrono.ChronoLocalDate> localDateTime(java.time.temporal.TemporalAccessor);
    method public static java.time.chrono.Chronology of(java.lang.String);
    method public static java.time.chrono.Chronology ofLocale(java.util.Locale);
    method public default java.time.chrono.ChronoPeriod period(int, int, int);
    method public abstract int prolepticYear(java.time.chrono.Era, int);
    method public abstract java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public abstract java.time.chrono.ChronoLocalDate resolveDate(java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, java.time.format.ResolverStyle);
    method public abstract java.lang.String toString();
    method public default java.time.chrono.ChronoZonedDateTime<? extends java.time.chrono.ChronoLocalDate> zonedDateTime(java.time.temporal.TemporalAccessor);
    method public default java.time.chrono.ChronoZonedDateTime<? extends java.time.chrono.ChronoLocalDate> zonedDateTime(java.time.Instant, java.time.ZoneId);
  }

  public abstract interface Era implements java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public default java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public default java.lang.String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public default long getLong(java.time.temporal.TemporalField);
    method public abstract int getValue();
    method public default boolean isSupported(java.time.temporal.TemporalField);
  }

  public final class IsoChronology extends java.time.chrono.AbstractChronology {
    method public java.time.LocalDate date(java.time.chrono.Era, int, int, int);
    method public java.time.LocalDate date(int, int, int);
    method public java.time.LocalDate date(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoLocalDate date(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoLocalDate date(int, int, int);
    method public java.time.LocalDate dateEpochDay(long);
    method public java.time.chrono.ChronoLocalDate dateEpochDay(long);
    method public java.time.LocalDate dateNow();
    method public java.time.LocalDate dateNow(java.time.ZoneId);
    method public java.time.LocalDate dateNow(java.time.Clock);
    method public java.time.LocalDate dateYearDay(java.time.chrono.Era, int, int);
    method public java.time.LocalDate dateYearDay(int, int);
    method public java.time.chrono.ChronoLocalDate dateYearDay(int, int);
    method public java.time.chrono.IsoEra eraOf(int);
    method public java.time.chrono.Era eraOf(int);
    method public java.util.List<java.time.chrono.Era> eras();
    method public java.lang.String getCalendarType();
    method public java.lang.String getId();
    method public boolean isLeapYear(long);
    method public java.time.LocalDateTime localDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoLocalDateTime localDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.Period period(int, int, int);
    method public int prolepticYear(java.time.chrono.Era, int);
    method public java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public java.time.LocalDate resolveDate(java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, java.time.format.ResolverStyle);
    method public java.time.chrono.ChronoLocalDate resolveDate(java.util.Map, java.time.format.ResolverStyle);
    method public java.time.ZonedDateTime zonedDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.ZonedDateTime zonedDateTime(java.time.Instant, java.time.ZoneId);
    method public java.time.chrono.ChronoZonedDateTime zonedDateTime(java.time.Instant, java.time.ZoneId);
    method public java.time.chrono.ChronoZonedDateTime zonedDateTime(java.time.temporal.TemporalAccessor);
    field public static final java.time.chrono.IsoChronology INSTANCE;
  }

  public final class IsoEra extends java.lang.Enum implements java.time.chrono.Era {
    method public int getValue();
    method public static java.time.chrono.IsoEra of(int);
    method public static java.time.chrono.IsoEra valueOf(java.lang.String);
    method public static final java.time.chrono.IsoEra[] values();
    enum_constant public static final java.time.chrono.IsoEra BCE;
    enum_constant public static final java.time.chrono.IsoEra CE;
  }

}

package java.time.format {

  public final class DateTimeFormatter {
    method public java.lang.String format(java.time.temporal.TemporalAccessor);
    method public void formatTo(java.time.temporal.TemporalAccessor, java.lang.Appendable);
    method public java.time.chrono.Chronology getChronology();
    method public java.time.format.DecimalStyle getDecimalStyle();
    method public java.util.Locale getLocale();
    method public java.util.Set<java.time.temporal.TemporalField> getResolverFields();
    method public java.time.format.ResolverStyle getResolverStyle();
    method public java.time.ZoneId getZone();
    method public static java.time.format.DateTimeFormatter ofLocalizedDate(java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofLocalizedDateTime(java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofLocalizedDateTime(java.time.format.FormatStyle, java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofLocalizedTime(java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofPattern(java.lang.String);
    method public static java.time.format.DateTimeFormatter ofPattern(java.lang.String, java.util.Locale);
    method public java.time.temporal.TemporalAccessor parse(java.lang.CharSequence);
    method public java.time.temporal.TemporalAccessor parse(java.lang.CharSequence, java.text.ParsePosition);
    method public <T> T parse(java.lang.CharSequence, java.time.temporal.TemporalQuery<T>);
    method public java.time.temporal.TemporalAccessor parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery<?>...);
    method public java.time.temporal.TemporalAccessor parseUnresolved(java.lang.CharSequence, java.text.ParsePosition);
    method public static final java.time.temporal.TemporalQuery<java.time.Period> parsedExcessDays();
    method public static final java.time.temporal.TemporalQuery<java.lang.Boolean> parsedLeapSecond();
    method public java.text.Format toFormat();
    method public java.text.Format toFormat(java.time.temporal.TemporalQuery<?>);
    method public java.time.format.DateTimeFormatter withChronology(java.time.chrono.Chronology);
    method public java.time.format.DateTimeFormatter withDecimalStyle(java.time.format.DecimalStyle);
    method public java.time.format.DateTimeFormatter withLocale(java.util.Locale);
    method public java.time.format.DateTimeFormatter withResolverFields(java.time.temporal.TemporalField...);
    method public java.time.format.DateTimeFormatter withResolverFields(java.util.Set<java.time.temporal.TemporalField>);
    method public java.time.format.DateTimeFormatter withResolverStyle(java.time.format.ResolverStyle);
    method public java.time.format.DateTimeFormatter withZone(java.time.ZoneId);
    field public static final java.time.format.DateTimeFormatter BASIC_ISO_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_INSTANT;
    field public static final java.time.format.DateTimeFormatter ISO_LOCAL_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_LOCAL_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_LOCAL_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_OFFSET_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_OFFSET_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_OFFSET_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_ORDINAL_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_WEEK_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_ZONED_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter RFC_1123_DATE_TIME;
  }

  public final class DecimalStyle {
    method public static java.util.Set<java.util.Locale> getAvailableLocales();
    method public char getDecimalSeparator();
    method public char getNegativeSign();
    method public char getPositiveSign();
    method public char getZeroDigit();
    method public static java.time.format.DecimalStyle of(java.util.Locale);
    method public static java.time.format.DecimalStyle ofDefaultLocale();
    method public java.time.format.DecimalStyle withDecimalSeparator(char);
    method public java.time.format.DecimalStyle withNegativeSign(char);
    method public java.time.format.DecimalStyle withPositiveSign(char);
    method public java.time.format.DecimalStyle withZeroDigit(char);
    field public static final java.time.format.DecimalStyle STANDARD;
  }

  public final class FormatStyle extends java.lang.Enum {
    method public static java.time.format.FormatStyle valueOf(java.lang.String);
    method public static final java.time.format.FormatStyle[] values();
    enum_constant public static final java.time.format.FormatStyle FULL;
    enum_constant public static final java.time.format.FormatStyle LONG;
    enum_constant public static final java.time.format.FormatStyle MEDIUM;
    enum_constant public static final java.time.format.FormatStyle SHORT;
  }

  public final class ResolverStyle extends java.lang.Enum {
    method public static java.time.format.ResolverStyle valueOf(java.lang.String);
    method public static final java.time.format.ResolverStyle[] values();
    enum_constant public static final java.time.format.ResolverStyle LENIENT;
    enum_constant public static final java.time.format.ResolverStyle SMART;
    enum_constant public static final java.time.format.ResolverStyle STRICT;
  }

  public final class TextStyle extends java.lang.Enum {
    method public java.time.format.TextStyle asNormal();
    method public java.time.format.TextStyle asStandalone();
    method public boolean isStandalone();
    method public static java.time.format.TextStyle valueOf(java.lang.String);
    method public static final java.time.format.TextStyle[] values();
    enum_constant public static final java.time.format.TextStyle FULL;
    enum_constant public static final java.time.format.TextStyle FULL_STANDALONE;
    enum_constant public static final java.time.format.TextStyle NARROW;
    enum_constant public static final java.time.format.TextStyle NARROW_STANDALONE;
    enum_constant public static final java.time.format.TextStyle SHORT;
    enum_constant public static final java.time.format.TextStyle SHORT_STANDALONE;
  }

}

package java.time.temporal {

  public final class ChronoField extends java.lang.Enum implements java.time.temporal.TemporalField {
    method public <R extends java.time.temporal.Temporal> R adjustInto(R, long);
    method public int checkValidIntValue(long);
    method public long checkValidValue(long);
    method public java.time.temporal.TemporalUnit getBaseUnit();
    method public long getFrom(java.time.temporal.TemporalAccessor);
    method public java.time.temporal.TemporalUnit getRangeUnit();
    method public boolean isDateBased();
    method public boolean isSupportedBy(java.time.temporal.TemporalAccessor);
    method public boolean isTimeBased();
    method public java.time.temporal.ValueRange range();
    method public java.time.temporal.ValueRange rangeRefinedBy(java.time.temporal.TemporalAccessor);
    method public static java.time.temporal.ChronoField valueOf(java.lang.String);
    method public static final java.time.temporal.ChronoField[] values();
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_DAY_OF_WEEK_IN_MONTH;
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_DAY_OF_WEEK_IN_YEAR;
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_WEEK_OF_MONTH;
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_WEEK_OF_YEAR;
    enum_constant public static final java.time.temporal.ChronoField AMPM_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField CLOCK_HOUR_OF_AMPM;
    enum_constant public static final java.time.temporal.ChronoField CLOCK_HOUR_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField DAY_OF_MONTH;
    enum_constant public static final java.time.temporal.ChronoField DAY_OF_WEEK;
    enum_constant public static final java.time.temporal.ChronoField DAY_OF_YEAR;
    enum_constant public static final java.time.temporal.ChronoField EPOCH_DAY;
    enum_constant public static final java.time.temporal.ChronoField ERA;
    enum_constant public static final java.time.temporal.ChronoField HOUR_OF_AMPM;
    enum_constant public static final java.time.temporal.ChronoField HOUR_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField INSTANT_SECONDS;
    enum_constant public static final java.time.temporal.ChronoField MICRO_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField MICRO_OF_SECOND;
    enum_constant public static final java.time.temporal.ChronoField MILLI_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField MILLI_OF_SECOND;
    enum_constant public static final java.time.temporal.ChronoField MINUTE_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField MINUTE_OF_HOUR;
    enum_constant public static final java.time.temporal.ChronoField MONTH_OF_YEAR;
    enum_constant public static final java.time.temporal.ChronoField NANO_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField NANO_OF_SECOND;
    enum_constant public static final java.time.temporal.ChronoField OFFSET_SECONDS;
    enum_constant public static final java.time.temporal.ChronoField PROLEPTIC_MONTH;
    enum_constant public static final java.time.temporal.ChronoField SECOND_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField SECOND_OF_MINUTE;
    enum_constant public static final java.time.temporal.ChronoField YEAR;
    enum_constant public static final java.time.temporal.ChronoField YEAR_OF_ERA;
  }

  public abstract interface Temporal implements java.time.temporal.TemporalAccessor {
    method public abstract boolean isSupported(java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal minus(java.time.temporal.TemporalAmount);
    method public default java.time.temporal.Temporal minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal plus(java.time.temporal.TemporalAmount);
    method public abstract java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public abstract long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal with(java.time.temporal.TemporalAdjuster);
    method public abstract java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
  }

  public abstract interface TemporalAccessor {
    method public default int get(java.time.temporal.TemporalField);
    method public abstract long getLong(java.time.temporal.TemporalField);
    method public abstract boolean isSupported(java.time.temporal.TemporalField);
    method public default <R> R query(java.time.temporal.TemporalQuery<R>);
    method public default java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
  }

  public abstract interface TemporalAdjuster {
    method public abstract java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
  }

  public abstract interface TemporalAmount {
    method public abstract java.time.temporal.Temporal addTo(java.time.temporal.Temporal);
    method public abstract long get(java.time.temporal.TemporalUnit);
    method public abstract java.util.List<java.time.temporal.TemporalUnit> getUnits();
    method public abstract java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal);
  }

  public abstract interface TemporalField {
    method public abstract <R extends java.time.temporal.Temporal> R adjustInto(R, long);
    method public abstract java.time.temporal.TemporalUnit getBaseUnit();
    method public default java.lang.String getDisplayName(java.util.Locale);
    method public abstract long getFrom(java.time.temporal.TemporalAccessor);
    method public abstract java.time.temporal.TemporalUnit getRangeUnit();
    method public abstract boolean isDateBased();
    method public abstract boolean isSupportedBy(java.time.temporal.TemporalAccessor);
    method public abstract boolean isTimeBased();
    method public abstract java.time.temporal.ValueRange range();
    method public abstract java.time.temporal.ValueRange rangeRefinedBy(java.time.temporal.TemporalAccessor);
    method public default java.time.temporal.TemporalAccessor resolve(java.util.Map<java.time.temporal.TemporalField, java.lang.Long>, java.time.temporal.TemporalAccessor, java.time.format.ResolverStyle);
    method public abstract java.lang.String toString();
  }

  public abstract interface TemporalQuery<R> {
    method public abstract R queryFrom(java.time.temporal.TemporalAccessor);
  }

  public abstract interface TemporalUnit {
    method public abstract <R extends java.time.temporal.Temporal> R addTo(R, long);
    method public abstract long between(java.time.temporal.Temporal, java.time.temporal.Temporal);
    method public abstract java.time.Duration getDuration();
    method public abstract boolean isDateBased();
    method public abstract boolean isDurationEstimated();
    method public default boolean isSupportedBy(java.time.temporal.Temporal);
    method public abstract boolean isTimeBased();
    method public abstract java.lang.String toString();
  }

  public final class ValueRange {
    method public int checkValidIntValue(long, java.time.temporal.TemporalField);
    method public long checkValidValue(long, java.time.temporal.TemporalField);
    method public long getLargestMinimum();
    method public long getMaximum();
    method public long getMinimum();
    method public long getSmallestMaximum();
    method public boolean isFixed();
    method public boolean isIntValue();
    method public boolean isValidIntValue(long);
    method public boolean isValidValue(long);
    method public static java.time.temporal.ValueRange of(long, long);
    method public static java.time.temporal.ValueRange of(long, long, long);
    method public static java.time.temporal.ValueRange of(long, long, long, long);
  }

}

package java.time.zone {

  public final class ZoneOffsetTransition implements java.lang.Comparable {
    method public int compareTo(java.time.zone.ZoneOffsetTransition);
    method public int compareTo(java.lang.Object);
    method public java.time.LocalDateTime getDateTimeAfter();
    method public java.time.LocalDateTime getDateTimeBefore();
    method public java.time.Duration getDuration();
    method public java.time.Instant getInstant();
    method public java.time.ZoneOffset getOffsetAfter();
    method public java.time.ZoneOffset getOffsetBefore();
    method public boolean isGap();
    method public boolean isOverlap();
    method public boolean isValidOffset(java.time.ZoneOffset);
    method public static java.time.zone.ZoneOffsetTransition of(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneOffset);
    method public long toEpochSecond();
  }

  public final class ZoneOffsetTransitionRule {
    method public java.time.zone.ZoneOffsetTransition createTransition(int);
    method public int getDayOfMonthIndicator();
    method public java.time.DayOfWeek getDayOfWeek();
    method public java.time.LocalTime getLocalTime();
    method public java.time.Month getMonth();
    method public java.time.ZoneOffset getOffsetAfter();
    method public java.time.ZoneOffset getOffsetBefore();
    method public java.time.ZoneOffset getStandardOffset();
    method public java.time.zone.ZoneOffsetTransitionRule.TimeDefinition getTimeDefinition();
    method public boolean isMidnightEndOfDay();
    method public static java.time.zone.ZoneOffsetTransitionRule of(java.time.Month, int, java.time.DayOfWeek, java.time.LocalTime, boolean, java.time.zone.ZoneOffsetTransitionRule.TimeDefinition, java.time.ZoneOffset, java.time.ZoneOffset, java.time.ZoneOffset);
  }

  public static final class ZoneOffsetTransitionRule.TimeDefinition extends java.lang.Enum {
    method public java.time.LocalDateTime createDateTime(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneOffset);
    method public static java.time.zone.ZoneOffsetTransitionRule.TimeDefinition valueOf(java.lang.String);
    method public static final java.time.zone.ZoneOffsetTransitionRule.TimeDefinition[] values();
    enum_constant public static final java.time.zone.ZoneOffsetTransitionRule.TimeDefinition STANDARD;
    enum_constant public static final java.time.zone.ZoneOffsetTransitionRule.TimeDefinition UTC;
    enum_constant public static final java.time.zone.ZoneOffsetTransitionRule.TimeDefinition WALL;
  }

  public final class ZoneRules {
    method public java.time.Duration getDaylightSavings(java.time.Instant);
    method public java.time.ZoneOffset getOffset(java.time.Instant);
    method public java.time.ZoneOffset getOffset(java.time.LocalDateTime);
    method public java.time.ZoneOffset getStandardOffset(java.time.Instant);
    method public java.time.zone.ZoneOffsetTransition getTransition(java.time.LocalDateTime);
    method public java.util.List<java.time.zone.ZoneOffsetTransitionRule> getTransitionRules();
    method public java.util.List<java.time.zone.ZoneOffsetTransition> getTransitions();
    method public java.util.List<java.time.ZoneOffset> getValidOffsets(java.time.LocalDateTime);
    method public boolean isDaylightSavings(java.time.Instant);
    method public boolean isFixedOffset();
    method public boolean isValidOffset(java.time.LocalDateTime, java.time.ZoneOffset);
    method public java.time.zone.ZoneOffsetTransition nextTransition(java.time.Instant);
    method public static java.time.zone.ZoneRules of(java.time.ZoneOffset, java.time.ZoneOffset, java.util.List<java.time.zone.ZoneOffsetTransition>, java.util.List<java.time.zone.ZoneOffsetTransition>, java.util.List<java.time.zone.ZoneOffsetTransitionRule>);
    method public static java.time.zone.ZoneRules of(java.time.ZoneOffset);
    method public java.time.zone.ZoneOffsetTransition previousTransition(java.time.Instant);
  }

}

package java.util {

  public abstract interface Collection<E> implements java.lang.Iterable {
    method public abstract boolean add(E);
    method public abstract boolean addAll(java.util.Collection<? extends E>);
    method public abstract void clear();
    method public abstract boolean contains(java.lang.Object);
    method public abstract boolean containsAll(java.util.Collection<?>);
    method public abstract boolean equals(java.lang.Object);
    method public abstract int hashCode();
    method public abstract boolean isEmpty();
    method public abstract java.util.Iterator<E> iterator();
    method public default java.util.stream.Stream<E> parallelStream();
    method public abstract boolean remove(java.lang.Object);
    method public abstract boolean removeAll(java.util.Collection<?>);
    method public default boolean removeIf(java.util.function.Predicate<? super E>);
    method public abstract boolean retainAll(java.util.Collection<?>);
    method public abstract int size();
    method public default java.util.Spliterator<E> spliterator();
    method public default java.util.stream.Stream<E> stream();
    method public abstract java.lang.Object[] toArray();
    method public abstract <T> T[] toArray(T[]);
  }

  public abstract interface Comparator<T> {
    method public abstract int compare(T, T);
    method public static <T, U> java.util.Comparator<T> comparing(java.util.function.Function<? super T, ? extends U>, java.util.Comparator<? super U>);
    method public static <T, U extends java.lang.Comparable<? super U>> java.util.Comparator<T> comparing(java.util.function.Function<? super T, ? extends U>);
    method public static <T> java.util.Comparator<T> comparingDouble(java.util.function.ToDoubleFunction<? super T>);
    method public static <T> java.util.Comparator<T> comparingInt(java.util.function.ToIntFunction<? super T>);
    method public static <T> java.util.Comparator<T> comparingLong(java.util.function.ToLongFunction<? super T>);
    method public abstract boolean equals(java.lang.Object);
    method public static <T extends java.lang.Comparable<? super T>> java.util.Comparator<T> naturalOrder();
    method public static <T> java.util.Comparator<T> nullsFirst(java.util.Comparator<? super T>);
    method public static <T> java.util.Comparator<T> nullsLast(java.util.Comparator<? super T>);
    method public static <T extends java.lang.Comparable<? super T>> java.util.Comparator<T> reverseOrder();
    method public default java.util.Comparator<T> reversed();
    method public default java.util.Comparator<T> thenComparing(java.util.Comparator<? super T>);
    method public default <U> java.util.Comparator<T> thenComparing(java.util.function.Function<? super T, ? extends U>, java.util.Comparator<? super U>);
    method public default <U extends java.lang.Comparable<? super U>> java.util.Comparator<T> thenComparing(java.util.function.Function<? super T, ? extends U>);
    method public default java.util.Comparator<T> thenComparingDouble(java.util.function.ToDoubleFunction<? super T>);
    method public default java.util.Comparator<T> thenComparingInt(java.util.function.ToIntFunction<? super T>);
    method public default java.util.Comparator<T> thenComparingLong(java.util.function.ToLongFunction<? super T>);
  }

  public class Date implements java.lang.Comparable {
    ctor public Date();
    ctor public Date(long);
    ctor public deprecated Date(int, int, int);
    ctor public deprecated Date(int, int, int, int, int);
    ctor public deprecated Date(int, int, int, int, int, int);
    ctor public deprecated Date(java.lang.String);
    method public static deprecated long UTC(int, int, int, int, int, int);
    method public boolean after(java.util.Date);
    method public boolean before(java.util.Date);
    method public java.lang.Object clone();
    method public int compareTo(java.util.Date);
    method public int compareTo(java.lang.Object);
    method public static java.util.Date from(java.time.Instant);
    method public deprecated int getDate();
    method public deprecated int getDay();
    method public deprecated int getHours();
    method public deprecated int getMinutes();
    method public deprecated int getMonth();
    method public deprecated int getSeconds();
    method public long getTime();
    method public deprecated int getTimezoneOffset();
    method public deprecated int getYear();
    method public static deprecated long parse(java.lang.String);
    method public deprecated void setDate(int);
    method public deprecated void setHours(int);
    method public deprecated void setMinutes(int);
    method public deprecated void setMonth(int);
    method public deprecated void setSeconds(int);
    method public void setTime(long);
    method public deprecated void setYear(int);
    method public deprecated java.lang.String toGMTString();
    method public java.time.Instant toInstant();
    method public deprecated java.lang.String toLocaleString();
  }

  public abstract class Dictionary<K, V> {
    ctor public Dictionary();
    method public abstract java.util.Enumeration<V> elements();
    method public abstract V get(java.lang.Object);
    method public abstract boolean isEmpty();
    method public abstract java.util.Enumeration<K> keys();
    method public abstract V put(K, V);
    method public abstract V remove(java.lang.Object);
    method public abstract int size();
  }

  public class DoubleSummaryStatistics implements java.util.function.DoubleConsumer {
    ctor public DoubleSummaryStatistics();
    method public void accept(double);
    method public void combine(java.util.DoubleSummaryStatistics);
    method public final double getAverage();
    method public final long getCount();
    method public final double getMax();
    method public final double getMin();
    method public final double getSum();
  }

  public abstract interface Enumeration<E> {
    method public abstract boolean hasMoreElements();
    method public abstract E nextElement();
  }

  public class Hashtable<K, V> extends java.util.Dictionary implements java.util.Map {
    ctor public Hashtable(int, float);
    ctor public Hashtable(int);
    ctor public Hashtable();
    ctor public Hashtable(java.util.Map<? extends K, ? extends V>);
    method public synchronized void clear();
    method public synchronized java.lang.Object clone();
    method public synchronized V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
    method public synchronized V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
    method public synchronized V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
    method public synchronized boolean contains(java.lang.Object);
    method public synchronized boolean containsKey(java.lang.Object);
    method public boolean containsValue(java.lang.Object);
    method public synchronized java.util.Enumeration<V> elements();
    method public java.util.Set<java.util.Map.Entry<K, V>> entrySet();
    method public synchronized boolean equals(java.lang.Object);
    method public synchronized void forEach(java.util.function.BiConsumer<? super K, ? super V>);
    method public synchronized V get(java.lang.Object);
    method public synchronized V getOrDefault(java.lang.Object, V);
    method public synchronized int hashCode();
    method public synchronized boolean isEmpty();
    method public java.util.Set<K> keySet();
    method public synchronized java.util.Enumeration<K> keys();
    method public synchronized V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
    method public synchronized V put(K, V);
    method public synchronized void putAll(java.util.Map<? extends K, ? extends V>);
    method public synchronized V putIfAbsent(K, V);
    method protected void rehash();
    method public synchronized V remove(java.lang.Object);
    method public synchronized boolean remove(java.lang.Object, java.lang.Object);
    method public synchronized boolean replace(K, V, V);
    method public synchronized V replace(K, V);
    method public synchronized void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
    method public synchronized int size();
    method public synchronized java.lang.String toString();
    method public java.util.Collection<V> values();
  }

  public class IntSummaryStatistics implements java.util.function.IntConsumer {
    ctor public IntSummaryStatistics();
    method public void accept(int);
    method public void combine(java.util.IntSummaryStatistics);
    method public final double getAverage();
    method public final long getCount();
    method public final int getMax();
    method public final int getMin();
    method public final long getSum();
  }

  public class InvalidPropertiesFormatException extends java.io.IOException {
    ctor public InvalidPropertiesFormatException(java.lang.Throwable);
    ctor public InvalidPropertiesFormatException(java.lang.String);
  }

  public abstract interface Iterator<E> {
    method public default void forEachRemaining(java.util.function.Consumer<? super E>);
    method public abstract boolean hasNext();
    method public abstract E next();
    method public default void remove();
  }

  public abstract interface List<E> implements java.util.Collection {
    method public abstract boolean add(E);
    method public abstract void add(int, E);
    method public abstract boolean addAll(java.util.Collection<? extends E>);
    method public abstract boolean addAll(int, java.util.Collection<? extends E>);
    method public abstract void clear();
    method public abstract boolean contains(java.lang.Object);
    method public abstract boolean containsAll(java.util.Collection<?>);
    method public abstract boolean equals(java.lang.Object);
    method public abstract E get(int);
    method public abstract int hashCode();
    method public abstract int indexOf(java.lang.Object);
    method public abstract boolean isEmpty();
    method public abstract java.util.Iterator<E> iterator();
    method public abstract int lastIndexOf(java.lang.Object);
    method public abstract java.util.ListIterator<E> listIterator();
    method public abstract java.util.ListIterator<E> listIterator(int);
    method public abstract boolean remove(java.lang.Object);
    method public abstract E remove(int);
    method public abstract boolean removeAll(java.util.Collection<?>);
    method public default void replaceAll(java.util.function.UnaryOperator<E>);
    method public abstract boolean retainAll(java.util.Collection<?>);
    method public abstract E set(int, E);
    method public abstract int size();
    method public default void sort(java.util.Comparator<? super E>);
    method public abstract java.util.List<E> subList(int, int);
    method public abstract java.lang.Object[] toArray();
    method public abstract <T> T[] toArray(T[]);
  }

  public abstract interface ListIterator<E> implements java.util.Iterator {
    method public abstract void add(E);
    method public abstract boolean hasNext();
    method public abstract boolean hasPrevious();
    method public abstract E next();
    method public abstract int nextIndex();
    method public abstract E previous();
    method public abstract int previousIndex();
    method public abstract void remove();
    method public abstract void set(E);
  }

  public final class Locale {
    ctor public Locale(java.lang.String, java.lang.String, java.lang.String);
    ctor public Locale(java.lang.String, java.lang.String);
    ctor public Locale(java.lang.String);
    method public java.lang.Object clone();
    method public static java.util.List<java.util.Locale> filter(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.util.Locale>, java.util.Locale.FilteringMode);
    method public static java.util.List<java.util.Locale> filter(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.util.Locale>);
    method public static java.util.List<java.lang.String> filterTags(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.lang.String>, java.util.Locale.FilteringMode);
    method public static java.util.List<java.lang.String> filterTags(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.lang.String>);
    method public static java.util.Locale forLanguageTag(java.lang.String);
    method public static java.util.Locale[] getAvailableLocales();
    method public java.lang.String getCountry();
    method public static java.util.Locale getDefault();
    method public static java.util.Locale getDefault(java.util.Locale.Category);
    method public final java.lang.String getDisplayCountry();
    method public java.lang.String getDisplayCountry(java.util.Locale);
    method public final java.lang.String getDisplayLanguage();
    method public java.lang.String getDisplayLanguage(java.util.Locale);
    method public final java.lang.String getDisplayName();
    method public java.lang.String getDisplayName(java.util.Locale);
    method public java.lang.String getDisplayScript();
    method public java.lang.String getDisplayScript(java.util.Locale);
    method public final java.lang.String getDisplayVariant();
    method public java.lang.String getDisplayVariant(java.util.Locale);
    method public java.lang.String getExtension(char);
    method public java.util.Set<java.lang.Character> getExtensionKeys();
    method public java.lang.String getISO3Country() throws java.util.MissingResourceException;
    method public java.lang.String getISO3Language() throws java.util.MissingResourceException;
    method public static java.lang.String[] getISOCountries();
    method public static java.lang.String[] getISOLanguages();
    method public java.lang.String getLanguage();
    method public java.lang.String getScript();
    method public java.util.Set<java.lang.String> getUnicodeLocaleAttributes();
    method public java.util.Set<java.lang.String> getUnicodeLocaleKeys();
    method public java.lang.String getUnicodeLocaleType(java.lang.String);
    method public java.lang.String getVariant();
    method public boolean hasExtensions();
    method public static java.util.Locale lookup(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.util.Locale>);
    method public static java.lang.String lookupTag(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.lang.String>);
    method public static synchronized void setDefault(java.util.Locale);
    method public static synchronized void setDefault(java.util.Locale.Category, java.util.Locale);
    method public java.util.Locale stripExtensions();
    method public java.lang.String toLanguageTag();
    method public final java.lang.String toString();
    field public static final java.util.Locale CANADA;
    field public static final java.util.Locale CANADA_FRENCH;
    field public static final java.util.Locale CHINA;
    field public static final java.util.Locale CHINESE;
    field public static final java.util.Locale ENGLISH;
    field public static final java.util.Locale FRANCE;
    field public static final java.util.Locale FRENCH;
    field public static final java.util.Locale GERMAN;
    field public static final java.util.Locale GERMANY;
    field public static final java.util.Locale ITALIAN;
    field public static final java.util.Locale ITALY;
    field public static final java.util.Locale JAPAN;
    field public static final java.util.Locale JAPANESE;
    field public static final java.util.Locale KOREA;
    field public static final java.util.Locale KOREAN;
    field public static final java.util.Locale PRC;
    field public static final char PRIVATE_USE_EXTENSION = 120; // 0x0078 'x'
    field public static final java.util.Locale ROOT;
    field public static final java.util.Locale SIMPLIFIED_CHINESE;
    field public static final java.util.Locale TAIWAN;
    field public static final java.util.Locale TRADITIONAL_CHINESE;
    field public static final java.util.Locale UK;
    field public static final char UNICODE_LOCALE_EXTENSION = 117; // 0x0075 'u'
    field public static final java.util.Locale US;
  }

  public static final class Locale.Category extends java.lang.Enum {
    method public static java.util.Locale.Category valueOf(java.lang.String);
    method public static final java.util.Locale.Category[] values();
    enum_constant public static final java.util.Locale.Category DISPLAY;
    enum_constant public static final java.util.Locale.Category FORMAT;
  }

  public static final class Locale.FilteringMode extends java.lang.Enum {
    method public static java.util.Locale.FilteringMode valueOf(java.lang.String);
    method public static final java.util.Locale.FilteringMode[] values();
    enum_constant public static final java.util.Locale.FilteringMode AUTOSELECT_FILTERING;
    enum_constant public static final java.util.Locale.FilteringMode EXTENDED_FILTERING;
    enum_constant public static final java.util.Locale.FilteringMode IGNORE_EXTENDED_RANGES;
    enum_constant public static final java.util.Locale.FilteringMode MAP_EXTENDED_RANGES;
    enum_constant public static final java.util.Locale.FilteringMode REJECT_EXTENDED_RANGES;
  }

  public static final class Locale.LanguageRange {
    ctor public Locale.LanguageRange(java.lang.String);
    ctor public Locale.LanguageRange(java.lang.String, double);
    method public java.lang.String getRange();
    method public double getWeight();
    method public static java.util.List<java.util.Locale.LanguageRange> mapEquivalents(java.util.List<java.util.Locale.LanguageRange>, java.util.Map<java.lang.String, java.util.List<java.lang.String>>);
    method public static java.util.List<java.util.Locale.LanguageRange> parse(java.lang.String);
    method public static java.util.List<java.util.Locale.LanguageRange> parse(java.lang.String, java.util.Map<java.lang.String, java.util.List<java.lang.String>>);
    field public static final double MAX_WEIGHT = 1.0;
    field public static final double MIN_WEIGHT = 0.0;
  }

  public class LongSummaryStatistics implements java.util.function.IntConsumer java.util.function.LongConsumer {
    ctor public LongSummaryStatistics();
    method public void accept(int);
    method public void accept(long);
    method public void combine(java.util.LongSummaryStatistics);
    method public final double getAverage();
    method public final long getCount();
    method public final long getMax();
    method public final long getMin();
    method public final long getSum();
  }

  public abstract interface Map<K, V> {
    method public abstract void clear();
    method public default V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
    method public default V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
    method public default V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
    method public abstract boolean containsKey(java.lang.Object);
    method public abstract boolean containsValue(java.lang.Object);
    method public abstract java.util.Set<java.util.Map.Entry<K, V>> entrySet();
    method public abstract boolean equals(java.lang.Object);
    method public default void forEach(java.util.function.BiConsumer<? super K, ? super V>);
    method public abstract V get(java.lang.Object);
    method public default V getOrDefault(java.lang.Object, V);
    method public abstract int hashCode();
    method public abstract boolean isEmpty();
    method public abstract java.util.Set<K> keySet();
    method public default V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
    method public abstract V put(K, V);
    method public abstract void putAll(java.util.Map<? extends K, ? extends V>);
    method public default V putIfAbsent(K, V);
    method public abstract V remove(java.lang.Object);
    method public default boolean remove(java.lang.Object, java.lang.Object);
    method public default boolean replace(K, V, V);
    method public default V replace(K, V);
    method public default void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
    method public abstract int size();
    method public abstract java.util.Collection<V> values();
  }

  public static abstract interface Map.Entry<K, V> {
    method public static <K extends java.lang.Comparable<? super K>, V> java.util.Comparator<java.util.Map.Entry<K, V>> comparingByKey();
    method public static <K, V> java.util.Comparator<java.util.Map.Entry<K, V>> comparingByKey(java.util.Comparator<? super K>);
    method public static <K, V extends java.lang.Comparable<? super V>> java.util.Comparator<java.util.Map.Entry<K, V>> comparingByValue();
    method public static <K, V> java.util.Comparator<java.util.Map.Entry<K, V>> comparingByValue(java.util.Comparator<? super V>);
    method public abstract boolean equals(java.lang.Object);
    method public abstract K getKey();
    method public abstract V getValue();
    method public abstract int hashCode();
    method public abstract V setValue(V);
  }

  public class MissingResourceException extends java.lang.RuntimeException {
    ctor public MissingResourceException(java.lang.String, java.lang.String, java.lang.String);
    method public java.lang.String getClassName();
    method public java.lang.String getKey();
  }

  public final class Optional<T> {
    method public static <T> java.util.Optional<T> empty();
    method public java.util.Optional<T> filter(java.util.function.Predicate<? super T>);
    method public <U> java.util.Optional<U> flatMap(java.util.function.Function<? super T, java.util.Optional<U>>);
    method public T get();
    method public void ifPresent(java.util.function.Consumer<? super T>);
    method public boolean isPresent();
    method public <U> java.util.Optional<U> map(java.util.function.Function<? super T, ? extends U>);
    method public static <T> java.util.Optional<T> of(T);
    method public static <T> java.util.Optional<T> ofNullable(T);
    method public T orElse(T);
    method public T orElseGet(java.util.function.Supplier<? extends T>);
    method public <X extends java.lang.Throwable> T orElseThrow(java.util.function.Supplier<? extends X>) throws java.lang.Throwable;
  }

  public final class OptionalDouble {
    method public static java.util.OptionalDouble empty();
    method public double getAsDouble();
    method public void ifPresent(java.util.function.DoubleConsumer);
    method public boolean isPresent();
    method public static java.util.OptionalDouble of(double);
    method public double orElse(double);
    method public double orElseGet(java.util.function.DoubleSupplier);
    method public <X extends java.lang.Throwable> double orElseThrow(java.util.function.Supplier<X>) throws java.lang.Throwable;
  }

  public final class OptionalInt {
    method public static java.util.OptionalInt empty();
    method public int getAsInt();
    method public void ifPresent(java.util.function.IntConsumer);
    method public boolean isPresent();
    method public static java.util.OptionalInt of(int);
    method public int orElse(int);
    method public int orElseGet(java.util.function.IntSupplier);
    method public <X extends java.lang.Throwable> int orElseThrow(java.util.function.Supplier<X>) throws java.lang.Throwable;
  }

  public final class OptionalLong {
    method public static java.util.OptionalLong empty();
    method public long getAsLong();
    method public void ifPresent(java.util.function.LongConsumer);
    method public boolean isPresent();
    method public static java.util.OptionalLong of(long);
    method public long orElse(long);
    method public long orElseGet(java.util.function.LongSupplier);
    method public <X extends java.lang.Throwable> long orElseThrow(java.util.function.Supplier<X>) throws java.lang.Throwable;
  }

  public abstract interface PrimitiveIterator<T, T_CONS> implements java.util.Iterator {
    method public abstract void forEachRemaining(T_CONS);
  }

  public static abstract interface PrimitiveIterator.OfDouble implements java.util.PrimitiveIterator {
    method public default void forEachRemaining(java.util.function.DoubleConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Double>);
    method public default void forEachRemaining(java.lang.Object);
    method public default java.lang.Double next();
    method public default java.lang.Object next();
    method public abstract double nextDouble();
  }

  public static abstract interface PrimitiveIterator.OfInt implements java.util.PrimitiveIterator {
    method public default void forEachRemaining(java.util.function.IntConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Integer>);
    method public default void forEachRemaining(java.lang.Object);
    method public default java.lang.Integer next();
    method public default java.lang.Object next();
    method public abstract int nextInt();
  }

  public static abstract interface PrimitiveIterator.OfLong implements java.util.PrimitiveIterator {
    method public default void forEachRemaining(java.util.function.LongConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Long>);
    method public default void forEachRemaining(java.lang.Object);
    method public default java.lang.Long next();
    method public default java.lang.Object next();
    method public abstract long nextLong();
  }

  public class Properties extends java.util.Hashtable {
    ctor public Properties();
    ctor public Properties(java.util.Properties);
    method public java.lang.String getProperty(java.lang.String);
    method public java.lang.String getProperty(java.lang.String, java.lang.String);
    method public void list(java.io.PrintStream);
    method public void list(java.io.PrintWriter);
    method public synchronized void load(java.io.Reader) throws java.io.IOException;
    method public synchronized void load(java.io.InputStream) throws java.io.IOException;
    method public synchronized void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException;
    method public java.util.Enumeration<?> propertyNames();
    method public deprecated void save(java.io.OutputStream, java.lang.String);
    method public synchronized java.lang.Object setProperty(java.lang.String, java.lang.String);
    method public void store(java.io.Writer, java.lang.String) throws java.io.IOException;
    method public void store(java.io.OutputStream, java.lang.String) throws java.io.IOException;
    method public void storeToXML(java.io.OutputStream, java.lang.String) throws java.io.IOException;
    method public void storeToXML(java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException;
    method public java.util.Set<java.lang.String> stringPropertyNames();
    field protected java.util.Properties defaults;
  }

  public abstract interface Set<E> implements java.util.Collection {
    method public abstract boolean add(E);
    method public abstract boolean addAll(java.util.Collection<? extends E>);
    method public abstract void clear();
    method public abstract boolean contains(java.lang.Object);
    method public abstract boolean containsAll(java.util.Collection<?>);
    method public abstract boolean equals(java.lang.Object);
    method public abstract int hashCode();
    method public abstract boolean isEmpty();
    method public abstract java.util.Iterator<E> iterator();
    method public abstract boolean remove(java.lang.Object);
    method public abstract boolean removeAll(java.util.Collection<?>);
    method public abstract boolean retainAll(java.util.Collection<?>);
    method public abstract int size();
    method public abstract java.lang.Object[] toArray();
    method public abstract <T> T[] toArray(T[]);
  }

  public abstract interface SortedMap<K, V> implements java.util.Map {
    method public abstract java.util.Comparator<? super K> comparator();
    method public abstract java.util.Set<java.util.Map.Entry<K, V>> entrySet();
    method public abstract K firstKey();
    method public abstract java.util.SortedMap<K, V> headMap(K);
    method public abstract java.util.Set<K> keySet();
    method public abstract K lastKey();
    method public abstract java.util.SortedMap<K, V> subMap(K, K);
    method public abstract java.util.SortedMap<K, V> tailMap(K);
    method public abstract java.util.Collection<V> values();
  }

  public abstract interface Spliterator<T> {
    method public abstract int characteristics();
    method public abstract long estimateSize();
    method public default void forEachRemaining(java.util.function.Consumer<? super T>);
    method public default java.util.Comparator<? super T> getComparator();
    method public default long getExactSizeIfKnown();
    method public default boolean hasCharacteristics(int);
    method public abstract boolean tryAdvance(java.util.function.Consumer<? super T>);
    method public abstract java.util.Spliterator<T> trySplit();
    field public static final int CONCURRENT = 4096; // 0x1000
    field public static final int DISTINCT = 1; // 0x1
    field public static final int IMMUTABLE = 1024; // 0x400
    field public static final int NONNULL = 256; // 0x100
    field public static final int ORDERED = 16; // 0x10
    field public static final int SIZED = 64; // 0x40
    field public static final int SORTED = 4; // 0x4
    field public static final int SUBSIZED = 16384; // 0x4000
  }

  public static abstract interface Spliterator.OfDouble implements java.util.Spliterator.OfPrimitive {
    method public default void forEachRemaining(java.util.function.DoubleConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Double>);
    method public default void forEachRemaining(java.lang.Object);
    method public abstract boolean tryAdvance(java.util.function.DoubleConsumer);
    method public default boolean tryAdvance(java.util.function.Consumer<? super java.lang.Double>);
    method public default boolean tryAdvance(java.lang.Object);
    method public abstract java.util.Spliterator.OfDouble trySplit();
    method public default java.util.Spliterator.OfPrimitive trySplit();
  }

  public static abstract interface Spliterator.OfInt implements java.util.Spliterator.OfPrimitive {
    method public default void forEachRemaining(java.util.function.IntConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Integer>);
    method public default void forEachRemaining(java.lang.Object);
    method public abstract boolean tryAdvance(java.util.function.IntConsumer);
    method public default boolean tryAdvance(java.util.function.Consumer<? super java.lang.Integer>);
    method public default boolean tryAdvance(java.lang.Object);
    method public abstract java.util.Spliterator.OfInt trySplit();
    method public default java.util.Spliterator.OfPrimitive trySplit();
  }

  public static abstract interface Spliterator.OfLong implements java.util.Spliterator.OfPrimitive {
    method public default void forEachRemaining(java.util.function.LongConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Long>);
    method public default void forEachRemaining(java.lang.Object);
    method public abstract boolean tryAdvance(java.util.function.LongConsumer);
    method public default boolean tryAdvance(java.util.function.Consumer<? super java.lang.Long>);
    method public default boolean tryAdvance(java.lang.Object);
    method public abstract java.util.Spliterator.OfLong trySplit();
    method public default java.util.Spliterator.OfPrimitive trySplit();
  }

  public static abstract interface Spliterator.OfPrimitive<T, T_CONS, T_SPLITR extends java.util.Spliterator.OfPrimitive<T, T_CONS, T_SPLITR>> implements java.util.Spliterator {
    method public default void forEachRemaining(T_CONS);
    method public abstract boolean tryAdvance(T_CONS);
    method public abstract T_SPLITR trySplit();
    method public default java.util.Spliterator trySplit();
  }

}

package java.util.concurrent {

  public abstract interface Callable<V> {
    method public abstract V call() throws java.lang.Exception;
  }

  public class ExecutionException extends java.lang.Exception {
    ctor protected ExecutionException();
    ctor protected ExecutionException(java.lang.String);
    ctor public ExecutionException(java.lang.String, java.lang.Throwable);
    ctor public ExecutionException(java.lang.Throwable);
  }

  public abstract interface ExecutorService {
    method public abstract boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public abstract <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.lang.InterruptedException;
    method public abstract <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public abstract <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public abstract <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public abstract boolean isShutdown();
    method public abstract boolean isTerminated();
    method public abstract void shutdown();
    method public abstract java.util.List<java.lang.Runnable> shutdownNow();
    method public abstract <T> java.util.concurrent.Future<T> submit(java.util.concurrent.Callable<T>);
    method public abstract <T> java.util.concurrent.Future<T> submit(java.lang.Runnable, T);
    method public abstract java.util.concurrent.Future<?> submit(java.lang.Runnable);
  }

  public abstract interface Future<V> {
    method public abstract boolean cancel(boolean);
    method public abstract V get() throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public abstract V get(long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public abstract boolean isCancelled();
    method public abstract boolean isDone();
  }

  public abstract class TimeUnit extends java.lang.Enum {
    method public long convert(long, java.util.concurrent.TimeUnit);
    method public void sleep(long) throws java.lang.InterruptedException;
    method public void timedJoin(java.lang.Thread, long) throws java.lang.InterruptedException;
    method public void timedWait(java.lang.Object, long) throws java.lang.InterruptedException;
    method public long toDays(long);
    method public long toHours(long);
    method public long toMicros(long);
    method public long toMillis(long);
    method public long toMinutes(long);
    method public long toNanos(long);
    method public long toSeconds(long);
    method public static java.util.concurrent.TimeUnit valueOf(java.lang.String);
    method public static final java.util.concurrent.TimeUnit[] values();
    enum_constant public static final java.util.concurrent.TimeUnit DAYS;
    enum_constant public static final java.util.concurrent.TimeUnit HOURS;
    enum_constant public static final java.util.concurrent.TimeUnit MICROSECONDS;
    enum_constant public static final java.util.concurrent.TimeUnit MILLISECONDS;
    enum_constant public static final java.util.concurrent.TimeUnit MINUTES;
    enum_constant public static final java.util.concurrent.TimeUnit NANOSECONDS;
    enum_constant public static final java.util.concurrent.TimeUnit SECONDS;
  }

  public class TimeoutException extends java.lang.Exception {
    ctor public TimeoutException();
    ctor public TimeoutException(java.lang.String);
  }

}

package java.util.function {

  public abstract interface BiConsumer<T, U> {
    method public abstract void accept(T, U);
    method public default java.util.function.BiConsumer<T, U> andThen(java.util.function.BiConsumer<? super T, ? super U>);
  }

  public abstract interface BiFunction<T, U, R> {
    method public default <V> java.util.function.BiFunction<T, U, V> andThen(java.util.function.Function<? super R, ? extends V>);
    method public abstract R apply(T, U);
  }

  public abstract interface BinaryOperator<T> implements java.util.function.BiFunction {
    method public static <T> java.util.function.BinaryOperator<T> maxBy(java.util.Comparator<? super T>);
    method public static <T> java.util.function.BinaryOperator<T> minBy(java.util.Comparator<? super T>);
  }

  public abstract interface Consumer<T> {
    method public abstract void accept(T);
    method public default java.util.function.Consumer<T> andThen(java.util.function.Consumer<? super T>);
  }

  public abstract interface DoubleBinaryOperator {
    method public abstract double applyAsDouble(double, double);
  }

  public abstract interface DoubleConsumer {
    method public abstract void accept(double);
    method public default java.util.function.DoubleConsumer andThen(java.util.function.DoubleConsumer);
  }

  public abstract interface DoubleFunction<R> {
    method public abstract R apply(double);
  }

  public abstract interface DoublePredicate {
    method public default java.util.function.DoublePredicate and(java.util.function.DoublePredicate);
    method public default java.util.function.DoublePredicate negate();
    method public default java.util.function.DoublePredicate or(java.util.function.DoublePredicate);
    method public abstract boolean test(double);
  }

  public abstract interface DoubleSupplier {
    method public abstract double getAsDouble();
  }

  public abstract interface DoubleToIntFunction {
    method public abstract int applyAsInt(double);
  }

  public abstract interface DoubleToLongFunction {
    method public abstract long applyAsLong(double);
  }

  public abstract interface DoubleUnaryOperator {
    method public default java.util.function.DoubleUnaryOperator andThen(java.util.function.DoubleUnaryOperator);
    method public abstract double applyAsDouble(double);
    method public default java.util.function.DoubleUnaryOperator compose(java.util.function.DoubleUnaryOperator);
    method public static java.util.function.DoubleUnaryOperator identity();
  }

  public abstract interface Function<T, R> {
    method public default <V> java.util.function.Function<T, V> andThen(java.util.function.Function<? super R, ? extends V>);
    method public abstract R apply(T);
    method public default <V> java.util.function.Function<V, R> compose(java.util.function.Function<? super V, ? extends T>);
    method public static <T> java.util.function.Function<T, T> identity();
  }

  public abstract interface IntBinaryOperator {
    method public abstract int applyAsInt(int, int);
  }

  public abstract interface IntConsumer {
    method public abstract void accept(int);
    method public default java.util.function.IntConsumer andThen(java.util.function.IntConsumer);
  }

  public abstract interface IntFunction<R> {
    method public abstract R apply(int);
  }

  public abstract interface IntPredicate {
    method public default java.util.function.IntPredicate and(java.util.function.IntPredicate);
    method public default java.util.function.IntPredicate negate();
    method public default java.util.function.IntPredicate or(java.util.function.IntPredicate);
    method public abstract boolean test(int);
  }

  public abstract interface IntSupplier {
    method public abstract int getAsInt();
  }

  public abstract interface IntToDoubleFunction {
    method public abstract double applyAsDouble(int);
  }

  public abstract interface IntToLongFunction {
    method public abstract long applyAsLong(int);
  }

  public abstract interface IntUnaryOperator {
    method public default java.util.function.IntUnaryOperator andThen(java.util.function.IntUnaryOperator);
    method public abstract int applyAsInt(int);
    method public default java.util.function.IntUnaryOperator compose(java.util.function.IntUnaryOperator);
    method public static java.util.function.IntUnaryOperator identity();
  }

  public abstract interface LongBinaryOperator {
    method public abstract long applyAsLong(long, long);
  }

  public abstract interface LongConsumer {
    method public abstract void accept(long);
    method public default java.util.function.LongConsumer andThen(java.util.function.LongConsumer);
  }

  public abstract interface LongFunction<R> {
    method public abstract R apply(long);
  }

  public abstract interface LongPredicate {
    method public default java.util.function.LongPredicate and(java.util.function.LongPredicate);
    method public default java.util.function.LongPredicate negate();
    method public default java.util.function.LongPredicate or(java.util.function.LongPredicate);
    method public abstract boolean test(long);
  }

  public abstract interface LongSupplier {
    method public abstract long getAsLong();
  }

  public abstract interface LongToDoubleFunction {
    method public abstract double applyAsDouble(long);
  }

  public abstract interface LongToIntFunction {
    method public abstract int applyAsInt(long);
  }

  public abstract interface LongUnaryOperator {
    method public default java.util.function.LongUnaryOperator andThen(java.util.function.LongUnaryOperator);
    method public abstract long applyAsLong(long);
    method public default java.util.function.LongUnaryOperator compose(java.util.function.LongUnaryOperator);
    method public static java.util.function.LongUnaryOperator identity();
  }

  public abstract interface ObjDoubleConsumer<T> {
    method public abstract void accept(T, double);
  }

  public abstract interface ObjIntConsumer<T> {
    method public abstract void accept(T, int);
  }

  public abstract interface ObjLongConsumer<T> {
    method public abstract void accept(T, long);
  }

  public abstract interface Predicate<T> {
    method public default java.util.function.Predicate<T> and(java.util.function.Predicate<? super T>);
    method public static <T> java.util.function.Predicate<T> isEqual(java.lang.Object);
    method public default java.util.function.Predicate<T> negate();
    method public default java.util.function.Predicate<T> or(java.util.function.Predicate<? super T>);
    method public abstract boolean test(T);
  }

  public abstract interface Supplier<T> {
    method public abstract T get();
  }

  public abstract interface ToDoubleFunction<T> {
    method public abstract double applyAsDouble(T);
  }

  public abstract interface ToIntFunction<T> {
    method public abstract int applyAsInt(T);
  }

  public abstract interface ToLongFunction<T> {
    method public abstract long applyAsLong(T);
  }

  public abstract interface UnaryOperator<T> implements java.util.function.Function {
    method public static <T> java.util.function.UnaryOperator<T> identity();
  }

}

package java.util.stream {

  public abstract interface BaseStream<T, S extends java.util.stream.BaseStream<T, S>> {
    method public abstract void close();
    method public abstract boolean isParallel();
    method public abstract java.util.Iterator<T> iterator();
    method public abstract S onClose(java.lang.Runnable);
    method public abstract S parallel();
    method public abstract S sequential();
    method public abstract java.util.Spliterator<T> spliterator();
    method public abstract S unordered();
  }

  public abstract interface Collector<T, A, R> {
    method public abstract java.util.function.BiConsumer<A, T> accumulator();
    method public abstract java.util.Set<java.util.stream.Collector.Characteristics> characteristics();
    method public abstract java.util.function.BinaryOperator<A> combiner();
    method public abstract java.util.function.Function<A, R> finisher();
    method public static <T, R> java.util.stream.Collector<T, R, R> of(java.util.function.Supplier<R>, java.util.function.BiConsumer<R, T>, java.util.function.BinaryOperator<R>, java.util.stream.Collector.Characteristics...);
    method public static <T, A, R> java.util.stream.Collector<T, A, R> of(java.util.function.Supplier<A>, java.util.function.BiConsumer<A, T>, java.util.function.BinaryOperator<A>, java.util.function.Function<A, R>, java.util.stream.Collector.Characteristics...);
    method public abstract java.util.function.Supplier<A> supplier();
  }

  public static final class Collector.Characteristics extends java.lang.Enum {
    method public static java.util.stream.Collector.Characteristics valueOf(java.lang.String);
    method public static final java.util.stream.Collector.Characteristics[] values();
    enum_constant public static final java.util.stream.Collector.Characteristics CONCURRENT;
    enum_constant public static final java.util.stream.Collector.Characteristics IDENTITY_FINISH;
    enum_constant public static final java.util.stream.Collector.Characteristics UNORDERED;
  }

  public abstract interface DoubleStream implements java.util.stream.BaseStream {
    method public abstract boolean allMatch(java.util.function.DoublePredicate);
    method public abstract boolean anyMatch(java.util.function.DoublePredicate);
    method public abstract java.util.OptionalDouble average();
    method public abstract java.util.stream.Stream<java.lang.Double> boxed();
    method public static java.util.stream.DoubleStream.Builder builder();
    method public abstract <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjDoubleConsumer<R>, java.util.function.BiConsumer<R, R>);
    method public static java.util.stream.DoubleStream concat(java.util.stream.DoubleStream, java.util.stream.DoubleStream);
    method public abstract long count();
    method public abstract java.util.stream.DoubleStream distinct();
    method public static java.util.stream.DoubleStream empty();
    method public abstract java.util.stream.DoubleStream filter(java.util.function.DoublePredicate);
    method public abstract java.util.OptionalDouble findAny();
    method public abstract java.util.OptionalDouble findFirst();
    method public abstract java.util.stream.DoubleStream flatMap(java.util.function.DoubleFunction<? extends java.util.stream.DoubleStream>);
    method public abstract void forEach(java.util.function.DoubleConsumer);
    method public abstract void forEachOrdered(java.util.function.DoubleConsumer);
    method public static java.util.stream.DoubleStream generate(java.util.function.DoubleSupplier);
    method public static java.util.stream.DoubleStream iterate(double, java.util.function.DoubleUnaryOperator);
    method public abstract java.util.PrimitiveIterator.OfDouble iterator();
    method public default java.util.Iterator iterator();
    method public abstract java.util.stream.DoubleStream limit(long);
    method public abstract java.util.stream.DoubleStream map(java.util.function.DoubleUnaryOperator);
    method public abstract java.util.stream.IntStream mapToInt(java.util.function.DoubleToIntFunction);
    method public abstract java.util.stream.LongStream mapToLong(java.util.function.DoubleToLongFunction);
    method public abstract <U> java.util.stream.Stream<U> mapToObj(java.util.function.DoubleFunction<? extends U>);
    method public abstract java.util.OptionalDouble max();
    method public abstract java.util.OptionalDouble min();
    method public abstract boolean noneMatch(java.util.function.DoublePredicate);
    method public static java.util.stream.DoubleStream of(double);
    method public static java.util.stream.DoubleStream of(double...);
    method public abstract java.util.stream.DoubleStream parallel();
    method public default java.util.stream.BaseStream parallel();
    method public abstract java.util.stream.DoubleStream peek(java.util.function.DoubleConsumer);
    method public abstract double reduce(double, java.util.function.DoubleBinaryOperator);
    method public abstract java.util.OptionalDouble reduce(java.util.function.DoubleBinaryOperator);
    method public abstract java.util.stream.DoubleStream sequential();
    method public default java.util.stream.BaseStream sequential();
    method public abstract java.util.stream.DoubleStream skip(long);
    method public abstract java.util.stream.DoubleStream sorted();
    method public abstract java.util.Spliterator.OfDouble spliterator();
    method public default java.util.Spliterator spliterator();
    method public abstract double sum();
    method public abstract java.util.DoubleSummaryStatistics summaryStatistics();
    method public abstract double[] toArray();
  }

  public static abstract interface DoubleStream.Builder implements java.util.function.DoubleConsumer {
    method public abstract void accept(double);
    method public default java.util.stream.DoubleStream.Builder add(double);
    method public abstract java.util.stream.DoubleStream build();
  }

  public abstract interface IntStream implements java.util.stream.BaseStream {
    method public abstract boolean allMatch(java.util.function.IntPredicate);
    method public abstract boolean anyMatch(java.util.function.IntPredicate);
    method public abstract java.util.stream.DoubleStream asDoubleStream();
    method public abstract java.util.stream.LongStream asLongStream();
    method public abstract java.util.OptionalDouble average();
    method public abstract java.util.stream.Stream<java.lang.Integer> boxed();
    method public static java.util.stream.IntStream.Builder builder();
    method public abstract <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjIntConsumer<R>, java.util.function.BiConsumer<R, R>);
    method public static java.util.stream.IntStream concat(java.util.stream.IntStream, java.util.stream.IntStream);
    method public abstract long count();
    method public abstract java.util.stream.IntStream distinct();
    method public static java.util.stream.IntStream empty();
    method public abstract java.util.stream.IntStream filter(java.util.function.IntPredicate);
    method public abstract java.util.OptionalInt findAny();
    method public abstract java.util.OptionalInt findFirst();
    method public abstract java.util.stream.IntStream flatMap(java.util.function.IntFunction<? extends java.util.stream.IntStream>);
    method public abstract void forEach(java.util.function.IntConsumer);
    method public abstract void forEachOrdered(java.util.function.IntConsumer);
    method public static java.util.stream.IntStream generate(java.util.function.IntSupplier);
    method public static java.util.stream.IntStream iterate(int, java.util.function.IntUnaryOperator);
    method public abstract java.util.PrimitiveIterator.OfInt iterator();
    method public default java.util.Iterator iterator();
    method public abstract java.util.stream.IntStream limit(long);
    method public abstract java.util.stream.IntStream map(java.util.function.IntUnaryOperator);
    method public abstract java.util.stream.DoubleStream mapToDouble(java.util.function.IntToDoubleFunction);
    method public abstract java.util.stream.LongStream mapToLong(java.util.function.IntToLongFunction);
    method public abstract <U> java.util.stream.Stream<U> mapToObj(java.util.function.IntFunction<? extends U>);
    method public abstract java.util.OptionalInt max();
    method public abstract java.util.OptionalInt min();
    method public abstract boolean noneMatch(java.util.function.IntPredicate);
    method public static java.util.stream.IntStream of(int);
    method public static java.util.stream.IntStream of(int...);
    method public abstract java.util.stream.IntStream parallel();
    method public default java.util.stream.BaseStream parallel();
    method public abstract java.util.stream.IntStream peek(java.util.function.IntConsumer);
    method public static java.util.stream.IntStream range(int, int);
    method public static java.util.stream.IntStream rangeClosed(int, int);
    method public abstract int reduce(int, java.util.function.IntBinaryOperator);
    method public abstract java.util.OptionalInt reduce(java.util.function.IntBinaryOperator);
    method public abstract java.util.stream.IntStream sequential();
    method public default java.util.stream.BaseStream sequential();
    method public abstract java.util.stream.IntStream skip(long);
    method public abstract java.util.stream.IntStream sorted();
    method public abstract java.util.Spliterator.OfInt spliterator();
    method public default java.util.Spliterator spliterator();
    method public abstract int sum();
    method public abstract java.util.IntSummaryStatistics summaryStatistics();
    method public abstract int[] toArray();
  }

  public static abstract interface IntStream.Builder implements java.util.function.IntConsumer {
    method public abstract void accept(int);
    method public default java.util.stream.IntStream.Builder add(int);
    method public abstract java.util.stream.IntStream build();
  }

  public abstract interface LongStream implements java.util.stream.BaseStream {
    method public abstract boolean allMatch(java.util.function.LongPredicate);
    method public abstract boolean anyMatch(java.util.function.LongPredicate);
    method public abstract java.util.stream.DoubleStream asDoubleStream();
    method public abstract java.util.OptionalDouble average();
    method public abstract java.util.stream.Stream<java.lang.Long> boxed();
    method public static java.util.stream.LongStream.Builder builder();
    method public abstract <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjLongConsumer<R>, java.util.function.BiConsumer<R, R>);
    method public static java.util.stream.LongStream concat(java.util.stream.LongStream, java.util.stream.LongStream);
    method public abstract long count();
    method public abstract java.util.stream.LongStream distinct();
    method public static java.util.stream.LongStream empty();
    method public abstract java.util.stream.LongStream filter(java.util.function.LongPredicate);
    method public abstract java.util.OptionalLong findAny();
    method public abstract java.util.OptionalLong findFirst();
    method public abstract java.util.stream.LongStream flatMap(java.util.function.LongFunction<? extends java.util.stream.LongStream>);
    method public abstract void forEach(java.util.function.LongConsumer);
    method public abstract void forEachOrdered(java.util.function.LongConsumer);
    method public static java.util.stream.LongStream generate(java.util.function.LongSupplier);
    method public static java.util.stream.LongStream iterate(long, java.util.function.LongUnaryOperator);
    method public abstract java.util.PrimitiveIterator.OfLong iterator();
    method public default java.util.Iterator iterator();
    method public abstract java.util.stream.LongStream limit(long);
    method public abstract java.util.stream.LongStream map(java.util.function.LongUnaryOperator);
    method public abstract java.util.stream.DoubleStream mapToDouble(java.util.function.LongToDoubleFunction);
    method public abstract java.util.stream.IntStream mapToInt(java.util.function.LongToIntFunction);
    method public abstract <U> java.util.stream.Stream<U> mapToObj(java.util.function.LongFunction<? extends U>);
    method public abstract java.util.OptionalLong max();
    method public abstract java.util.OptionalLong min();
    method public abstract boolean noneMatch(java.util.function.LongPredicate);
    method public static java.util.stream.LongStream of(long);
    method public static java.util.stream.LongStream of(long...);
    method public abstract java.util.stream.LongStream parallel();
    method public default java.util.stream.BaseStream parallel();
    method public abstract java.util.stream.LongStream peek(java.util.function.LongConsumer);
    method public static java.util.stream.LongStream range(long, long);
    method public static java.util.stream.LongStream rangeClosed(long, long);
    method public abstract long reduce(long, java.util.function.LongBinaryOperator);
    method public abstract java.util.OptionalLong reduce(java.util.function.LongBinaryOperator);
    method public abstract java.util.stream.LongStream sequential();
    method public default java.util.stream.BaseStream sequential();
    method public abstract java.util.stream.LongStream skip(long);
    method public abstract java.util.stream.LongStream sorted();
    method public abstract java.util.Spliterator.OfLong spliterator();
    method public default java.util.Spliterator spliterator();
    method public abstract long sum();
    method public abstract java.util.LongSummaryStatistics summaryStatistics();
    method public abstract long[] toArray();
  }

  public static abstract interface LongStream.Builder implements java.util.function.LongConsumer {
    method public abstract void accept(long);
    method public default java.util.stream.LongStream.Builder add(long);
    method public abstract java.util.stream.LongStream build();
  }

  public abstract interface Stream<T> implements java.util.stream.BaseStream {
    method public abstract boolean allMatch(java.util.function.Predicate<? super T>);
    method public abstract boolean anyMatch(java.util.function.Predicate<? super T>);
    method public static <T> java.util.stream.Stream.Builder<T> builder();
    method public abstract <R> R collect(java.util.function.Supplier<R>, java.util.function.BiConsumer<R, ? super T>, java.util.function.BiConsumer<R, R>);
    method public abstract <R, A> R collect(java.util.stream.Collector<? super T, A, R>);
    method public static <T> java.util.stream.Stream<T> concat(java.util.stream.Stream<? extends T>, java.util.stream.Stream<? extends T>);
    method public abstract long count();
    method public abstract java.util.stream.Stream<T> distinct();
    method public static <T> java.util.stream.Stream<T> empty();
    method public abstract java.util.stream.Stream<T> filter(java.util.function.Predicate<? super T>);
    method public abstract java.util.Optional<T> findAny();
    method public abstract java.util.Optional<T> findFirst();
    method public abstract <R> java.util.stream.Stream<R> flatMap(java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends R>>);
    method public abstract java.util.stream.DoubleStream flatMapToDouble(java.util.function.Function<? super T, ? extends java.util.stream.DoubleStream>);
    method public abstract java.util.stream.IntStream flatMapToInt(java.util.function.Function<? super T, ? extends java.util.stream.IntStream>);
    method public abstract java.util.stream.LongStream flatMapToLong(java.util.function.Function<? super T, ? extends java.util.stream.LongStream>);
    method public abstract void forEach(java.util.function.Consumer<? super T>);
    method public abstract void forEachOrdered(java.util.function.Consumer<? super T>);
    method public static <T> java.util.stream.Stream<T> generate(java.util.function.Supplier<T>);
    method public static <T> java.util.stream.Stream<T> iterate(T, java.util.function.UnaryOperator<T>);
    method public abstract java.util.stream.Stream<T> limit(long);
    method public abstract <R> java.util.stream.Stream<R> map(java.util.function.Function<? super T, ? extends R>);
    method public abstract java.util.stream.DoubleStream mapToDouble(java.util.function.ToDoubleFunction<? super T>);
    method public abstract java.util.stream.IntStream mapToInt(java.util.function.ToIntFunction<? super T>);
    method public abstract java.util.stream.LongStream mapToLong(java.util.function.ToLongFunction<? super T>);
    method public abstract java.util.Optional<T> max(java.util.Comparator<? super T>);
    method public abstract java.util.Optional<T> min(java.util.Comparator<? super T>);
    method public abstract boolean noneMatch(java.util.function.Predicate<? super T>);
    method public static <T> java.util.stream.Stream<T> of(T);
    method public static <T> java.util.stream.Stream<T> of(T...);
    method public abstract java.util.stream.Stream<T> peek(java.util.function.Consumer<? super T>);
    method public abstract T reduce(T, java.util.function.BinaryOperator<T>);
    method public abstract java.util.Optional<T> reduce(java.util.function.BinaryOperator<T>);
    method public abstract <U> U reduce(U, java.util.function.BiFunction<U, ? super T, U>, java.util.function.BinaryOperator<U>);
    method public abstract java.util.stream.Stream<T> skip(long);
    method public abstract java.util.stream.Stream<T> sorted();
    method public abstract java.util.stream.Stream<T> sorted(java.util.Comparator<? super T>);
    method public abstract java.lang.Object[] toArray();
    method public abstract <A> A[] toArray(java.util.function.IntFunction<A[]>);
  }

  public static abstract interface Stream.Builder<T> implements java.util.function.Consumer {
    method public abstract void accept(T);
    method public default java.util.stream.Stream.Builder<T> add(T);
    method public abstract java.util.stream.Stream<T> build();
  }

}

package javax.security.auth {

  public final class Subject {
    ctor public Subject();
    ctor public Subject(boolean, java.util.Set<? extends java.security.Principal>, java.util.Set<?>, java.util.Set<?>);
    method public static <T> T doAs(javax.security.auth.Subject, java.security.PrivilegedAction<T>);
    method public static <T> T doAs(javax.security.auth.Subject, java.security.PrivilegedExceptionAction<T>) throws java.security.PrivilegedActionException;
    method public static <T> T doAsPrivileged(javax.security.auth.Subject, java.security.PrivilegedAction<T>, java.security.AccessControlContext);
    method public static <T> T doAsPrivileged(javax.security.auth.Subject, java.security.PrivilegedExceptionAction<T>, java.security.AccessControlContext) throws java.security.PrivilegedActionException;
    method public java.util.Set<java.security.Principal> getPrincipals();
    method public <T extends java.security.Principal> java.util.Set<T> getPrincipals(java.lang.Class<T>);
    method public java.util.Set<java.lang.Object> getPrivateCredentials();
    method public <T> java.util.Set<T> getPrivateCredentials(java.lang.Class<T>);
    method public java.util.Set<java.lang.Object> getPublicCredentials();
    method public <T> java.util.Set<T> getPublicCredentials(java.lang.Class<T>);
    method public static javax.security.auth.Subject getSubject(java.security.AccessControlContext);
    method public boolean isReadOnly();
    method public void setReadOnly();
  }

}

package org.chromium.android_component_loader {

  public class ComponentInterface {
    ctor public ComponentInterface();
    method public static java.lang.String packageLabel();
    method public static java.lang.String wow();
  }

}

