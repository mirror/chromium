// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file defined the mojo interface between Android and Chromium for video
// decoding.

module arc.mojom;

import "video_common.mojom";

// Information of the shared memory bitstream buffer.
struct BitstreamBufferInfo {
  uint32 bitstream_id;
  handle ashmem_fd;
  uint32 offset;
  uint32 length;
  uint32 bytes_used;
};

// Format specification of the picture buffer request.
struct PictureBufferFormat {
  uint32 pixel_format;
  uint32 buffer_size;

  // minimal number of buffers required to process the video.
  uint32 min_num_buffers;
  uint32 coded_width;
  uint32 coded_height;
};

// Crop information of picture rendering.
struct CropWindow {
  uint32 crop_left;
  uint32 crop_width;
  uint32 crop_top;
  uint32 crop_height;
};

// Next MinVersion: 1
// Next method ID: 7
interface VideoDecodeAccelerator {
  enum Result {
    SUCCESS = 0,
    ILLEGAL_STATE = 1,
    INVALID_ARGUMENT = 2,
    UNREADABLE_INPUT = 3,
    PLATFORM_FAILURE = 4,
    INSUFFICIENT_RESOURCES = 5,
  };

  // Initializes video decoder accelerator with specific video codec profile.
  // This must be called before any other methods. This call is synchronous and
  // returns SUCCESS iff initialization is successful.
  Initialize@0(VideoCodecProfile profile,
               VideoDecodeClient client) => (Result result);

  // Imports a shared memory with bitstream data with bitstream ID to the
  // accelerator for decoding.
  Decode@1(BitstreamBufferInfo info);

  // Sets the number of output picture buffers.
  AssignPictureBuffers@2(uint32 number);

  // Assigns a buffer to be used for the accelerator with specified index. It
  // must be successfully bound and then sent to be used by the decoder. Already
  // bound buffers may be reused multiple times without additional bindings via
  // ReusePictureBuffer().
  ImportBufferForPicture@3(uint32 index, handle dmabuf_fd,
                           array<VideoFramePlane> planes);

  // Sends picture buffer with specified index to be reused by the accelerator.
  ReusePictureBuffer@4(uint32 index);

  // Resets the accelerator. When it is done, Client::NotifyResetDone() will
  // be called. Afterwards, all buffers won't be accessed by the accelerator
  // and there won't be more callbacks.
  Reset@5();

  // Flushes the accelerator. After all the output buffers pending decode have
  // been returned to client, Client::NotifyFlushDone() will be called.
  Flush@6();
};

// Next MinVersion: 1
// Next method ID: 6
interface VideoDecodeClient {
  // Callback to tell client how many and what size of buffers to provide.
  ProvidePictureBuffers@0(PictureBufferFormat format);

  // Called to deliver the specified index of picture buffer is decoded and
  // ready to be displayed. This callback provides the information of crop
  // window size, and ID of source bitstream as well.
  PictureReady@1(uint32 index, uint32 bitstream_id, CropWindow crop_window);

  // Called to notify that decoder has decoded the end of the current
  // bitstream buffer.
  NotifyEndOfBitstreamBuffer@2(uint32 bitstream_id);

  // Called as a completion notification for Reset().
  NotifyResetDone@3();

  // Called as a completion notification for Flush().
  NotifyFlushDone@4();

  // Called when an asynchronous error happens. The errors in Initialize()
  // will not be reported here, but will be indicated by a return value
  // there.
  NotifyError@5(VideoDecodeAccelerator.Result error);
};
