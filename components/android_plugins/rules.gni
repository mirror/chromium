import("//build/config/android/rules.gni")

template("java_stable_api") {
  _deps_configs = []
  if (defined(invoker.deps)) {
    foreach(_possible_dep, invoker.deps) {
      _dep_gen_dir = get_label_info(_possible_dep, "target_gen_dir")
      _dep_name = get_label_info(_possible_dep, "name")
      _deps_configs += [ "$_dep_gen_dir/$_dep_name.build_config" ]
    }
  }
  _rebased_deps_configs = rebase_path(_deps_configs, root_build_dir)

  _gen_target_name = target_name
  action(_gen_target_name) {
    script = "//components/android_plugins/generate_api.py"
    sources = invoker.sources
    outputs = [
      invoker.output,
    ]
    args = [
      "--output",
      rebase_path(invoker.output, root_build_dir),
    ]
    foreach(_dep_config, _rebased_deps_configs) {
      args += [
        "--dep-jar",
        "@FileArg($_dep_config:deps_info:interface_jar_path)",
      ]
    }
    args += rebase_path(sources, root_build_dir)
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
  }

  _check_target_name = "check_${target_name}"
  action(_check_target_name) {
    deps = [
      ":${_gen_target_name}",
    ]
    sources = [
      invoker.output,
    ]
    outputs = [
      "$target_gen_dir/$_check_target_name.stamp",
    ]
    script = "//components/android_plugins/api_check.py"
    args = [
      "--old-api",
      rebase_path(invoker.compare, root_build_dir),
      "--new-api",
      rebase_path(invoker.output, root_build_dir),
      "--stamp",
      rebase_path(outputs[0], root_build_dir),
    ]
  }
}

# Declare an Android component APK
#
# Variables
#   apk_name:
#   java_files:
#   deps:
template("android_plugin") {
  _api_target_name = "${target_name}_api"

  if (defined(invoker.api_file)) {
    java_stable_api(_api_target_name) {
      sources = invoker.java_interface_files
      output = "$target_gen_dir/$target_name.txt"
      compare = invoker.api_file
    }
  }

  # Generates a proguard rule to prevent removal of the given interface class.
  _proguard_flags_target = "${target_name}__interface_proguard_flags"
  _proguard_flags_output =
      "${target_gen_dir}/${target_name}__keep_interface.flags"
  jinja_template(_proguard_flags_target) {
    input = "//components/android_plugins/keep_class.flags.jinja2"
    output = _proguard_flags_output
    variables = [ "CLASS_NAME=${invoker.interface_class}" ]
  }

  # This library contains the plugin's public interface definition. It should
  # be linked into the main Chrome APK. It should be made available to the
  # plugin at compile time, but not included in the final plugin APK.
  _interface_lib_target_name = "${target_name}_interface_java"
  android_library(_interface_lib_target_name) {
    deps = [
      ":${_proguard_flags_target}",
      "//components/android_plugins:plugin_api_java",
    ]
    if (defined(invoker.api_file)) {
      deps += [ ":check_${_api_target_name}" ]
    }
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    proguard_configs = [ _proguard_flags_output ]
    java_files = invoker.java_interface_files
  }

  # This library contains the plugin. The final plugin APK should depend
  # on this. The interface library above is included in classpath_deps so
  # this library can compile against it, but not include it in the jar (at
  # runtime, the interface type will be resolved by the host class loader)
  _lib_target_name = "${target_name}__lib_java"
  android_library(_lib_target_name) {
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    classpath_deps = [
      "//components/android_plugins:plugin_api_java",
      ":${_interface_lib_target_name}",
    ]
    java_files = invoker.java_files
  }

  android_apk("${target_name}_apk") {
    apk_name = invoker.apk_name
    android_manifest = "//build/android/AndroidManifest.xml"
    deps = [
      ":${_lib_target_name}",
    ]
  }
}
