// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "components/tracing/core/trace_buffer_writer.h"

#include "base/logging.h"
#include "components/tracing/core/proto_utils.h"
#include "components/tracing/core/trace_ring_buffer.h"

namespace tracing {
namespace v2 {

namespace {

// TODO(primiano) remove this soon. This should just be taken from the C++ class
// autogenerated from events_chunk.proto, once kraynov@'s generator is landed.
struct ChunkProto {
  static const uint32_t kEventsFieldNumber = 1;
};

}  // namespace

TraceBufferWriter::TraceBufferWriter(TraceRingBuffer* trace_buffer,
                                     uint32_t writer_id)
    : trace_buffer_(trace_buffer),
      writer_id_(writer_id),
      chunk_seq_id_(0),
      chunk_(nullptr),
      writer_id_(writer_id),
      continue_on_next_chunk_ptr_(nullptr),
      event_start_addr_(nullptr),
      stream_writer_(this) {
}

TraceBufferWriter::~TraceBufferWriter() {}

ContiguousMemoryRange WriteEventPreamble() {
  static_assert(
      ChunkProto::kEventsFieldNumber < 16,
      "Chunk.event must have a field id < 16 to have a small (1 byte) preamble");
  auto range = stream_writer_.ReserveBytes(1 + ProtoZeroMessage::kMaxMessageLengthFieldSize);
  *(range.begin++) = static_cast<uint8_t>(
      proto::MakeTagLengthLimited(ChunkProto::kEventsFieldNumber));
  return range;
}

TraceEvent* TraceBufferWriter::AddEvent() {
  event_.Reset(&stream_writer_);

  // In order to start a new event at least kMaxMessageLengthFieldSize + 1 bytes
  // are required in the chunk to write the preamble and size of the event
  // itself. We stay a bit more conservative here purely as a perf optimization.
  // It doesn't make a lot of sense starting a partial event that will fragment
  // for sure.
  // TODO bump up 16 to a reasonable value.///////////////////////////////////////////
  if (stream_writer_.bytes_available() < 16) {
    stream_writer_.Reset(
        AcquireNewChunk(false /* event_continues_from_prev_chunk */));
  }

  auto range = WriteEventPreamble();
  event_start_addr_ = range.end;
  DCHECK_EQ(stream_writer_.write_ptr(), event_start_addr_);

  // TODO keep alive chunks for reservation until event is finalized. Hmmmmm.
  return &event_;
}

// This is invoked by the ProtoZeroMessage write methods when reaching the
// end of the current chunk during a write.
ContiguousMemoryRange TraceBufferWriter::GetNewBuffer() {
  return AcquireNewChunk(true /* event_continues_from_prev_chunk */);
}

// There are two ways we can get here:
// 1. The first event for this writer is created and chunk_ is still nullptr.
// 2. The client is writing an event, the ProtoZeroMessage Append* methods hit
//    the boundary of the chunk and request a new one via GetNewBuffer().
ContiguousMemoryRange TraceBufferWriter::AcquireNewChunk(
    bool event_continues_from_prev_chunk) {
  if (event_continues_from_prev_chunk) {
    // The |event_| spawn across multiple chunks.
    *continue_on_next_chunk_ptr_ = 1;
    const size_t event_partial_size =
        static_cast<size_t>(stream_writer_.write_ptr() - event_start_addr_);
    proto::WriteRedundantVarIntUnsigned(event_partial_size, ProtoZeroMessage::kMaxMessageLengthFieldSize, event_->size_field().begin);
    event_->inc_size_already_written(event_partial_size);
  }

  // Return the current chunk and acquire a new one.
  if (chunk_) {
    DCHECK_GE(stream_writer_.write_ptr(), chunk_->proto_begin());
    DCHECK_LE(stream_writer_.write_ptr(), chunk_->end());
    const uint32_t used_size = static_cast<uint32_t>(stream_writer_.write_ptr() - chunk_->proto_begin());
    ring_buffer_->ReturnChunk(chunk_, used_size);
  }
  chunk_ = ring_buffer_->TakeChunk();

  // Write the protobuf for the chunk header. The proto for events_chunk is
  // filled manually instead of using the generated C++ stub. Rationale: the
  // stub require this class to perform the buffer write operations. Using this
  // to write our own proto would make this code extremely hard to reason about.
  uint8_t* header = reinterpret_cast<uint8_t*>(chunk_->proto_begin());

  header =
      WriteProtoVarInt(header, ChunkProto::kStreamIdFieldNumber, stream_id_);
  header = WriteProtoVarInt(header, ChunkProto::kSeqIdInStreamFieldNumber,
                            chunk_seq_id_);

  header = WriteProtoVarInt(
      header, ChunkProto::kFirstEventContinuesFromPrevChunkFieldNumber,
      event_continues_from_prev_chunk ? 1 : 0);

  // At this point we don't know yet whether the last event in the chunk is
  // going to continue on the next chunk. For the moment we put a zero as a
  // placeholder and remember its position in the chunk. The actual value will
  // be written the next time we take a new chunk (above in this function).
  header = WriteProtoVarInt(
      header, ChunkProto::kLastEventContinuesOnNextChunkFieldNumber, 0);
  continue_on_next_chunk_ptr_ = header - 1;
  ++chunk_seq_id_;

  // If the new chunk happened while writing an event (the event is spread over
  // multiple chunks) write a new proto preamble for the new partial byte array.
  if (event_continues_from_prev_chunk) {
    header = WriteEventPreamble(event_, header);
  }

  return {header, chunk_->end()};
}

// TODO: Things to test:
// events beginning and ending precisely on a chunk boundary.
// events longer than 2 chunks.
// presence of last event in a non-full chunk.
// test a long message which nested submessages where the size of the nested
// subm is in a previous chunk. (chunk retaining logic).
// reserved size field num bytes != for main event in chunk vs nested messages.

// TODO possible optimization: in the codegen for add_args_simple instead of
// ::tracing::EventArgsSimple* inst = new ::tracing::EventArgsSimple();
// use a placement new.


}  // namespace v2
}  // namespace tracing
