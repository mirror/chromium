// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "proto_zero_generator.h"

#include <memory>
#include <string>

#include "third_party/protobuf/src/google/protobuf/descriptor.h"
#include "third_party/protobuf/src/google/protobuf/io/printer.h"
#include "third_party/protobuf/src/google/protobuf/io/zero_copy_stream.h"
#include "third_party/protobuf/src/google/protobuf/stubs/strutil.h"

namespace tracing {
namespace proto {

using google::protobuf::FileDescriptor;
using google::protobuf::StripSuffixString;
using google::protobuf::compiler::GeneratorContext;
using google::protobuf::io::Printer;
using google::protobuf::io::ZeroCopyOutputStream;

namespace {

class GeneratorJob {
 public:
  GeneratorJob(const FileDescriptor *file,
               Printer* stub_h_printer,
               Printer* stub_cc_printer)
    : file_(file),
      stub_h_(stub_h_printer),
      stub_cc_(stub_cc_printer) {}

  bool GenerateStubs() {
    stub_h_->Print(
        "// Autogenerated. DO NOT EDIT.\n"
        "// Generated by: //components/tracing/proto_zero_plugin.\n\n"
        "// Package: $package$\n",
        "package", file_->package());
    stub_cc_->Print(
        "// Autogenerated. DO NOT EDIT.\n"
        "// Generated by: //components/tracing/proto_zero_plugin.\n\n"
        "// This file intentionally left blank.\n");
    // TODO(kraynov) Implement in the next CL (crbug.com/608721).
    return true;
  }

  // If generator fails to produce stubs for a particular proto definitions
  // it finishes with undefined output and writes the first error occured.
  const std::string& GetFirstError() const {
    return error_;
  }

 private:
  // Only the first error will be recorded.
  void Abort(const std::string& reason) {
    if (error_.empty()) {
      error_ = reason;
    }
  }

  const FileDescriptor* const file_;
  Printer* const stub_h_;
  Printer* const stub_cc_;
  std::string error_;
};

}  // namespace

ProtoZeroGenerator::ProtoZeroGenerator() {
}

ProtoZeroGenerator::~ProtoZeroGenerator() {
}

bool ProtoZeroGenerator::Generate(const FileDescriptor* file,
                                  const std::string& options,
                                  GeneratorContext* context,
                                  std::string* error) const {

  const std::string proto_stubs_name =
      StripSuffixString(file->name(), ".proto") + ".pbzero";

  const std::unique_ptr<ZeroCopyOutputStream> stub_h_file_stream(
      context->Open(proto_stubs_name + ".h"));
  const std::unique_ptr<ZeroCopyOutputStream> stub_cc_file_stream(
      context->Open(proto_stubs_name + ".cc"));

  // Variables are delimited by $.
  Printer stub_h_printer(stub_h_file_stream.get(), '$');
  Printer stub_cc_printer(stub_cc_file_stream.get(), '$');

  GeneratorJob job(file, &stub_h_printer, &stub_cc_printer);
  if (!job.GenerateStubs()) {
    *error = job.GetFirstError();
    return false;
  }
  return true;
}

}  // namespace proto
}  // namespace tracing
