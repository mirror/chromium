// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* DO NOT EDIT. Generated from {{module.path}} */


{%- if variant -%}
{%-   set variant_path = "%s-%s"|format(module.path, variant) -%}
{%- else -%}
{%-   set variant_path = module.path -%}
{%- endif %}

#include "{{variant_path}}_impl_struct.h"

#include "base/logging.h"

{%- for struct in structs %}

// Struct {{struct.name}}.
{{struct.name}}Ptr {{struct.name}}_Create() {
  return new {{struct.name}}();
}
void {{struct.name}}_Destroy({{struct.name}}Ptr self) {
  delete self;
}
// {{struct.name}} setters.
{%- for packed_field in struct.packed.packed_fields_in_ordinal_order %}
{%-  set kind = packed_field.field.kind %}
{%-  if kind|is_array_kind %}
void {{struct.name}}_add_{{packed_field.field.name}}({{struct.name}}Ptr self, {{kind.kind|c_wrapper_type}} {{packed_field.field.name}}) {
  DCHECK(self);
{%-   if kind.kind|is_struct_kind %}
  {{kind.kind|cpp_wrapper_type}} tmp_ptr({{packed_field.field.name}});
  self->{{packed_field.field.name}}.push_back(std::move(tmp_ptr));
{%-   else %}
  self->{{packed_field.field.name}}.push_back({{packed_field.field.name}});
{%-   endif %}
}
{%-  else %}
void {{struct.name}}_set_{{packed_field.field.name}}({{struct.name}}Ptr self, {{packed_field.field.kind|c_wrapper_type}} {{packed_field.field.name}}) {
  DCHECK(self);
{%-   if kind|is_struct_kind %}
  self->{{packed_field.field.name}}.reset({{packed_field.field.name}});
{%-   else %}
  self->{{packed_field.field.name}} = {{packed_field.field.name}};
{%-   endif %}
}
{%- endif %}

{%- endfor %}
// {{struct.name}} getters.
{%- for packed_field in struct.packed.packed_fields_in_ordinal_order %}
{%-  set kind = packed_field.field.kind %}
{%-  if kind|is_array_kind %}
uint32_t {{struct.name}}_get_{{packed_field.field.name}}Size({{struct.name}}Ptr self) {
  DCHECK(self);
  return self->{{packed_field.field.name}}.size();
}
{{kind.kind|c_wrapper_type}} {{struct.name}}_get_{{packed_field.field.name}}AtIndex({{struct.name}}Ptr self, uint32_t index) {
  DCHECK(self);
  DCHECK(index < self->{{packed_field.field.name}}.size());
{%-   if kind.kind|is_struct_kind %}
  return self->{{packed_field.field.name}}[index].get();
{%-   elif kind.kind|is_string_kind %}
  return self->{{packed_field.field.name}}[index].c_str();
{%-   else %}
  return self->{{packed_field.field.name}}[index];
{%-   endif %}
}
{%-  else %}
{{packed_field.field.kind|c_wrapper_type}} {{struct.name}}_get_{{packed_field.field.name}}({{struct.name}}Ptr self) {
  DCHECK(self);
{%-   if kind|is_struct_kind %}
  return self->{{packed_field.field.name}}.get();
{%-   elif kind|is_string_kind %}
  return self->{{packed_field.field.name}}.c_str();
{%-   else %}
  return self->{{packed_field.field.name}};
{%-   endif %}
}
{%- endif %}
{%- endfor %}
{%- endfor %}

