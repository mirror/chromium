{
  "comments": [
    {
      "key": {
        "uuid": "7533dce3_582a6071",
        "filename": "android_webview/java/src/org/chromium/android_webview/PopupTouchHandleDrawable.java",
        "patchSetId": 11
      },
      "lineNbr": 536,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-12-07T05:20:53Z",
      "side": 1,
      "message": "do we need to null out mWebContents (like mContentViewCore was being done...or was that to prevent duplicate calls to hide())?",
      "range": {
        "startLine": 536,
        "startChar": 8,
        "endLine": 536,
        "endChar": 30
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "961ec13d_b656e2c9",
        "filename": "android_webview/java/src/org/chromium/android_webview/PopupTouchHandleDrawable.java",
        "patchSetId": 11
      },
      "lineNbr": 536,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-12-07T22:42:14Z",
      "side": 1,
      "message": "From the way the CL adding this line was written, this null checking is done in all native-originated calls to be defensive against being invoked again. Yes the intention is to prevent duplicated calls.",
      "parentUuid": "7533dce3_582a6071",
      "range": {
        "startLine": 536,
        "startChar": 8,
        "endLine": 536,
        "endChar": 30
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "737d3fe8_735312b9",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 11
      },
      "lineNbr": 1875,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-12-07T05:20:53Z",
      "side": 1,
      "message": "I\u0027d be tempted to pass this in as a param for now (WebContents not cvc)",
      "range": {
        "startLine": 1875,
        "startChar": 34,
        "endLine": 1875,
        "endChar": 50
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8908355_fc1b6318",
        "filename": "chrome/android/java/src/org/chromium/chrome/browser/tab/Tab.java",
        "patchSetId": 11
      },
      "lineNbr": 1875,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-12-08T00:37:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "737d3fe8_735312b9",
      "range": {
        "startLine": 1875,
        "startChar": 34,
        "endLine": 1875,
        "endChar": 50
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a8e3af0a_19b1e5ce",
        "filename": "content/browser/android/gesture_listener_manager_android.h",
        "patchSetId": 11
      },
      "lineNbr": 23,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-12-07T05:20:53Z",
      "side": 1,
      "message": "the need for this to be a WebContentsObserver just to get destroy seems sad to me.\n\nI feel that WebContentsUserData should have a destroy method in java that you\u0027d get notified of there (similar to the destructor in C++).  Having to do this referencing seems rather unfortunate IMO.\n\nAnd if we do need the observer, I feel it should live on the same side as the user data.\n\nThat being said, this does exactly fall into the case I was worried about.  We have the niceties of the user data on the java side, but the ugly-ness of an explicit setter on the C++ side.  I feel it would be better if the C++ was also able to pull this out of the user data (granted this would likely need to be a user data on the C++ side that has one on the java side...I\u0027m not 100% sure that is the worst thing in the world, but I do worry about this somewhat mixed behavior being the gold standard for how this is handled)",
      "range": {
        "startLine": 23,
        "startChar": 44,
        "endLine": 23,
        "endChar": 63
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50044943_60d93c8e",
        "filename": "content/browser/android/gesture_listener_manager_android.h",
        "patchSetId": 11
      },
      "lineNbr": 23,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-12-07T16:00:11Z",
      "side": 1,
      "message": "\u003e the need for this to be a WebContentsObserver just to get destroy seems sad to me.\n\u003e \n\u003e I feel that WebContentsUserData should have a destroy method in java that you\u0027d get notified of there (similar to the destructor in C++).  Having to do this referencing seems rather unfortunate IMO.\n\nnative WebContentsImpl owns WebContentsUserData, which is more appropriate here\n\n\u003e \n\u003e And if we do need the observer, I feel it should live on the same side as the user data.\n\u003e \n\u003e That being said, this does exactly fall into the case I was worried about.  We have the niceties of the user data on the java side, but the ugly-ness of an explicit setter on the C++ side.  I feel it would be better if the C++ was also able to pull this out of the user data (granted this would likely need to be a user data on the C++ side that has one on the java side...I\u0027m not 100% sure that is the worst thing in the world, but I do worry about this somewhat mixed behavior being the gold standard for how this is handled)",
      "parentUuid": "a8e3af0a_19b1e5ce",
      "range": {
        "startLine": 23,
        "startChar": 44,
        "endLine": 23,
        "endChar": 63
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3397ec5_f3a93424",
        "filename": "content/browser/android/gesture_listener_manager_android.h",
        "patchSetId": 11
      },
      "lineNbr": 23,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-12-07T17:22:48Z",
      "side": 1,
      "message": "I was a bit unclear with Bo\u0027s comment (I might be alone there), but the take away is that the native side should also be a UserData and not a WebContentsObserver.\n\nFor now, I don\u0027t think we have a path to java UserData having a destroy call because WebView can have it be GC\u0027d before web contents destroy is called so it would be unreachable.\n\nIf we need a predictable destroy, then you can\u0027t use the java side, you have to add yourself to the native userdata and do all that plumbing.\n\nI do wonder if there are things we can do to make user data across both boundaries cleaner, but I\u0027m not sure there is yet.\n\nI guess the question I have here is that if the native side of GestureListenerManager is a native user data, should we just have this own the java side too (with all the fun weak ref\u0027s that come along with it) to not make two sided user data?  Should we try to have user data be only on one side of the boundary (either java or native, but not both)?",
      "parentUuid": "50044943_60d93c8e",
      "range": {
        "startLine": 23,
        "startChar": 44,
        "endLine": 23,
        "endChar": 63
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e07c89f3_797de892",
        "filename": "content/browser/android/gesture_listener_manager_android.h",
        "patchSetId": 11
      },
      "lineNbr": 23,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-12-07T22:42:14Z",
      "side": 1,
      "message": "\u003e I was a bit unclear with Bo\u0027s comment (I might be alone there), but the take away is that the native side should also be a UserData and not a WebContentsObserver.\n\nYou have a point. Let me replace WebContentsObserver with UserData (I guess you mean WebContentsUserData?). \n\n\u003e I guess the question I have here is that if the native side of GestureListenerManager is a native user data, should we just have this own the java side too (with all the fun weak ref\u0027s that come along with it) to not make two sided user data?  Should we try to have user data be only on one side of the boundary (either java or native, but not both)?\n\nI\u0027m now a bit more inclined to having java and native manage each side separately for consistency\u0027s sake - I think that\u0027s better than having the guide saying \"if your class Foo has java side only, let it be managed by WebContents\u0027s user data map. If it has native side too, then its native should manage the java class\".\n\nAlso, it always feels more awkward for me to let the native side own the java via a strong ref, which creates a new gc root and inevitably brings up the WebView gc issue.",
      "parentUuid": "d3397ec5_f3a93424",
      "range": {
        "startLine": 23,
        "startChar": 44,
        "endLine": 23,
        "endChar": 63
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb7cc534_2c8634ef",
        "filename": "content/public/android/java/src/org/chromium/content/browser/webcontents/WebContentsImpl.java",
        "patchSetId": 11
      },
      "lineNbr": 772,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2017-12-07T05:20:53Z",
      "side": 1,
      "message": "do we ever set the mInternalsHolder to null in the destructor?\n\nI feel we should throw an illegalstateexception here if this is called and the webcontents has been destroyed.\n\nI worry someone will add something to a destroyed webcontents w/o this and unintentionally leak something because they\u0027ll never get a destroy call.",
      "range": {
        "startLine": 772,
        "startChar": 38,
        "endLine": 772,
        "endChar": 39
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7f4c7450_59870c73",
        "filename": "content/public/android/java/src/org/chromium/content/browser/webcontents/WebContentsImpl.java",
        "patchSetId": 11
      },
      "lineNbr": 772,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2017-12-07T16:00:11Z",
      "side": 1,
      "message": "\u003e do we ever set the mInternalsHolder to null in the destructor?\n\nNo\n\n\u003e \n\u003e I feel we should throw an illegalstateexception here if this is called and the webcontents has been destroyed.\n\nwe can make this an assert. should not happen\n\n\u003e \n\u003e I worry someone will add something to a destroyed webcontents w/o this and unintentionally leak something because they\u0027ll never get a destroy call.\n\nThat\u0027s always possible.\n\nBtw, I\u0027ve only been looking at the java WebContentsUserData APIs and haven\u0027t looked at the rest of this CL. It\u0027s very possible using WebContentsInternals is wrong. Like I said on the bug, it might be required for the UserData to actually specify if it wants a strong ref from WebContentsImpl.",
      "parentUuid": "eb7cc534_2c8634ef",
      "range": {
        "startLine": 772,
        "startChar": 38,
        "endLine": 772,
        "endChar": 39
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "021d6da6_4e22dd92",
        "filename": "content/public/android/java/src/org/chromium/content/browser/webcontents/WebContentsImpl.java",
        "patchSetId": 11
      },
      "lineNbr": 772,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-12-07T22:42:14Z",
      "side": 1,
      "message": "\u003e Btw, I\u0027ve only been looking at the java WebContentsUserData APIs and haven\u0027t looked at the rest of this CL. It\u0027s very possible using WebContentsInternals is wrong. Like I said on the bug, it might be required for the UserData to actually specify if it wants a strong ref from WebContentsImpl.\n\nYes, I know that GestureStateListener in WebView has a reference back to AwContents. This requires at least some classes  be allowed to have weak reference somewhere. I think it convenient to use WebContentsInternals so that userdata classes don\u0027t have to worry about the issue.",
      "parentUuid": "7f4c7450_59870c73",
      "range": {
        "startLine": 772,
        "startChar": 38,
        "endLine": 772,
        "endChar": 39
      },
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "994eb951_4847a393",
        "filename": "content/public/android/java/src/org/chromium/content/browser/webcontents/WebContentsUserData.java",
        "patchSetId": 11
      },
      "lineNbr": 30,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-12-07T19:52:38Z",
      "side": 1,
      "message": "Nit: Remove? Refer to class comment above?",
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18f63531_ce26939d",
        "filename": "content/public/android/java/src/org/chromium/content/browser/webcontents/WebContentsUserData.java",
        "patchSetId": 11
      },
      "lineNbr": 30,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-12-08T00:37:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "994eb951_4847a393",
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca25962c_59bdd78c",
        "filename": "content/public/android/java/src/org/chromium/content/browser/webcontents/WebContentsUserData.java",
        "patchSetId": 11
      },
      "lineNbr": 56,
      "author": {
        "id": 1002237
      },
      "writtenOn": "2017-12-07T19:52:38Z",
      "side": 1,
      "message": "In case the setUserData(...) call fails, should we still return mObject? It kind of feels we should go through a getUserData(...) call here?",
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c88e1fae_71cb9b05",
        "filename": "content/public/android/java/src/org/chromium/content/browser/webcontents/WebContentsUserData.java",
        "patchSetId": 11
      },
      "lineNbr": 56,
      "author": {
        "id": 1149077
      },
      "writtenOn": "2017-12-08T00:37:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ca25962c_59bdd78c",
      "revId": "6c9435c4bd9d1420e9eaf156c218e9da638e16cd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}