{
  "comments": [
    {
      "key": {
        "uuid": "b57f129b_78e558a0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-08-28T22:02:23Z",
      "side": 1,
      "message": "I am not sure about needing both PlatformKeyEventFilter and KeyEventFilter.\n\nI think we can do with only KeyEventFilter, which would handle a ui::KeyEvent. ui::PlatformWindow implementation (or DesktopWindowTreeHostWin|X11) will create a ui::KeyEvent out of the native event it receives, then it will call the KeyEventFilter to see if the event is the \u0027special\u0027 kind of event or not.",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6464930d_362acc26",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1196069
      },
      "writtenOn": "2017-08-28T22:11:37Z",
      "side": 1,
      "message": "The workflow is reverse: PlatformKeyEventFilter receives ui::PlatformEvent from native APIs, which can be XNextEvent() on X11 or LowLevelKeyboardProc on Windows, and sends them to DesktopWindowTreeHostWin|X11 (or RenderWidgetHost) through KeyEventFilter. So both PlatformKeyEventFilter and KeyEventFilter do not know ui::Event. ui::Event will only be created when the event reaches DesktopWindowTreeHostWin|X11 or RenderWidgetHost layer.",
      "parentUuid": "b57f129b_78e558a0",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7833a4d_5e734eba",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-08-29T15:00:23Z",
      "side": 1,
      "message": "On aura platforms, we create the ui::KeyEvent in aura/views. So the event is not created in RenderWidgetHostView. In both windows, linux, and chromeos, the ui::KeyEvent starts being processed here [1]. I am suggesting this is where the KeyEventFilter should be used. This way, we don\u0027t need any platform-specific code in handling the events once received from the platform [2]. I don\u0027t see why we need a PlatformKeyEventFilter.\n\n[1] https://cs.chromium.org/chromium/src/ui/aura/window_event_dispatcher.cc?sq\u003dpackage:chromium\u0026dr\u003dSs\u0026l\u003d953\n[2] We would, of course, still need platform-specific code to request the keys in the first place.",
      "parentUuid": "6464930d_362acc26",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c22e8848_34954ca5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1196069
      },
      "writtenOn": "2017-08-29T17:38:32Z",
      "side": 1,
      "message": "The events are receiving from LowLevelKeyboardProc (https://msdn.microsoft.com/en-us/library/windows/desktop/ms644985(v\u003dvs.85).aspx), which is a parameter of SetWindowHookEx (https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v\u003dvs.85).aspx) function in our case. But regular route won\u0027t be able to receive these key events. So adding KeyEventFilter in DesktopWindowTreeHostWin|X11 won\u0027t help us to receive OS reserved keys.\n\nIt looks like I have not explained the LowLevelKeyboardProc clearly. It\u0027s a *different*[1] route for an application to receive keyboard events from the OS. OS will send the keyboard events first to this route, if the callback function discards it (returns false), the regular route will be used. Otherwise the event is considered to be consumed by the callback function. By using this more powerful route, applications can receive events usually reserved by OS.\n\n[1]: On X11, there is no additional route, XNextEvent() is still used to receive events. Windows and Mac OSX provide an additional route. But the same design can apply to both architectures, since both architectures process native keyboard events.\n\nYou may find more information from \"Receive Low Level Key Events\" section in \"System Keyboard Lock in Chrome\" @ https://docs.google.com/document/d/1cRtxr17qdwZqKD5_OgEFmoQJl1fh01ZScPT6NX4dMX4/edit#heading\u003dh.ch70sq2sqae1.",
      "parentUuid": "a7833a4d_5e734eba",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a6bb69c_81f9d85a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000528
      },
      "writtenOn": "2017-08-29T22:01:08Z",
      "side": 1,
      "message": "To expand a little on Zijie\u0027s statement, I believe one of the problems in creating a ui::KeyEvent is that doing so affects global state (specifically the repeat timer). So, for example, the following sequence is problematic:\n\n* LowLevelKeyboardProc receives a key (say, A)\n  - Creates a ui::Event, passes it to the KeyEventFilter.\n  - Determines that it isn\u0027t reserved.\n  - Returns false to tell the OS to handle the key normally (ie, don\u0027t bypass the input pipeline).\n* WndProc receives the same key.\n  - Creates another ui::Event, which now has the wrong repeat count.\n\nThis is specific to Windows, but any platform where we need a dedicated low-level proc to handle some subset of keyboard events has the same problem.",
      "parentUuid": "c22e8848_34954ca5",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}