{
  "comments": [
    {
      "key": {
        "uuid": "b57f129b_78e558a0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-08-28T22:02:23Z",
      "side": 1,
      "message": "I am not sure about needing both PlatformKeyEventFilter and KeyEventFilter.\n\nI think we can do with only KeyEventFilter, which would handle a ui::KeyEvent. ui::PlatformWindow implementation (or DesktopWindowTreeHostWin|X11) will create a ui::KeyEvent out of the native event it receives, then it will call the KeyEventFilter to see if the event is the \u0027special\u0027 kind of event or not.",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6464930d_362acc26",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1196069
      },
      "writtenOn": "2017-08-28T22:11:37Z",
      "side": 1,
      "message": "The workflow is reverse: PlatformKeyEventFilter receives ui::PlatformEvent from native APIs, which can be XNextEvent() on X11 or LowLevelKeyboardProc on Windows, and sends them to DesktopWindowTreeHostWin|X11 (or RenderWidgetHost) through KeyEventFilter. So both PlatformKeyEventFilter and KeyEventFilter do not know ui::Event. ui::Event will only be created when the event reaches DesktopWindowTreeHostWin|X11 or RenderWidgetHost layer.",
      "parentUuid": "b57f129b_78e558a0",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7833a4d_5e734eba",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2017-08-29T15:00:23Z",
      "side": 1,
      "message": "On aura platforms, we create the ui::KeyEvent in aura/views. So the event is not created in RenderWidgetHostView. In both windows, linux, and chromeos, the ui::KeyEvent starts being processed here [1]. I am suggesting this is where the KeyEventFilter should be used. This way, we don\u0027t need any platform-specific code in handling the events once received from the platform [2]. I don\u0027t see why we need a PlatformKeyEventFilter.\n\n[1] https://cs.chromium.org/chromium/src/ui/aura/window_event_dispatcher.cc?sq\u003dpackage:chromium\u0026dr\u003dSs\u0026l\u003d953\n[2] We would, of course, still need platform-specific code to request the keys in the first place.",
      "parentUuid": "6464930d_362acc26",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c22e8848_34954ca5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1196069
      },
      "writtenOn": "2017-08-29T17:38:32Z",
      "side": 1,
      "message": "The events are receiving from LowLevelKeyboardProc (https://msdn.microsoft.com/en-us/library/windows/desktop/ms644985(v\u003dvs.85).aspx), which is a parameter of SetWindowHookEx (https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v\u003dvs.85).aspx) function in our case. But regular route won\u0027t be able to receive these key events. So adding KeyEventFilter in DesktopWindowTreeHostWin|X11 won\u0027t help us to receive OS reserved keys.\n\nIt looks like I have not explained the LowLevelKeyboardProc clearly. It\u0027s a *different*[1] route for an application to receive keyboard events from the OS. OS will send the keyboard events first to this route, if the callback function discards it (returns false), the regular route will be used. Otherwise the event is considered to be consumed by the callback function. By using this more powerful route, applications can receive events usually reserved by OS.\n\n[1]: On X11, there is no additional route, XNextEvent() is still used to receive events. Windows and Mac OSX provide an additional route. But the same design can apply to both architectures, since both architectures process native keyboard events.\n\nYou may find more information from \"Receive Low Level Key Events\" section in \"System Keyboard Lock in Chrome\" @ https://docs.google.com/document/d/1cRtxr17qdwZqKD5_OgEFmoQJl1fh01ZScPT6NX4dMX4/edit#heading\u003dh.ch70sq2sqae1.",
      "parentUuid": "a7833a4d_5e734eba",
      "revId": "cb8b7a70b3fcca7cfc3659768b92e0663fb99b6a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}