{
  "comments": [
    {
      "key": {
        "uuid": "34325e6c_ceb3bb2b",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-06T00:59:39Z",
      "side": 1,
      "message": "I still don\u0027t understand. The cross face animation in WindowState::SetBoundsDIrectCrossFace won\u0027t work correctly it doesn\u0027t have\nboth (before and after) layers.\n\nYou need to call wm::CrossFadeAnimation with old (current layer), with updated window), don\u0027t you?",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c0f3eaa_5dbafd54",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-06T01:44:39Z",
      "side": 1,
      "message": "\u003e I still don\u0027t understand. The cross...\n\nAbove Resore() and Maximize() are called when we have an old buffer in the window layer, and new buffer will be pushed to that layer in line #788 below. So, SetBoundsDirectCrossFace will recreate the window layer, which means the current layer with old buffer will be detached, and cross faded with the newly created layer which will be very soon filled out with the new buffer in #788.\n\n\n\u003e You need to call wm::CrossFadeAnimation with old (current layer), with updated window), don\u0027t you?\n\nNot sure if I understand. Yes, we need to call it with old layer (for the old window state). What do you mean by \"updated window\"?",
      "parentUuid": "34325e6c_ceb3bb2b",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edc1cd00_e5032b02",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-06T06:16:42Z",
      "side": 1,
      "message": "Won\u0027t it apply wrong animation for pillar-boxed/letter-boxed app because it doesn\u0027t know the real target size there?",
      "parentUuid": "1c0f3eaa_5dbafd54",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48f08e65_321f499b",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-06T07:29:46Z",
      "side": 1,
      "message": "Yes. Animating from restored to pillar-box/letter-box is off. The other way works fine. The culprit is ash::ScreenUtil::GetMaximizedWindowBoundsInParent which returns an incorrect value for pillar boxed windows.\n\n\nIIUC currently we let ash set incorrect dimensions, and then we overwrite them in ShellSurface::OnWindowBoundsChanged. I believe we could avoid this and just add support for custom maximized dimensions to aura, eg. by adding something like GetMaximizedBounds() to aura::WindowDelegate.\n\n\nIn either case, this CL is not intended to fix all animations. It\u0027s just the first step. How about disabling animations when pillar/letterbox are used in this CL and addressing those cases separately?",
      "parentUuid": "edc1cd00_e5032b02",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afdd3181_bb6b9a28",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-06T08:35:16Z",
      "side": 1,
      "message": "I took a closer look, and we don\u0027t overwrite the bounds in OnWindowBoundsChanged for NYC as I wrote earlier, but we do overwrite then in a surface commit. This means that if a window state change is invoked from Chrome (eg. Alt+) the window will have incorrect geometry until the surface is committed. It can be easily confirmed by pressing F4 quickly after alt+.\n\nI believe we should address this in aura by adding native supports for such geometry constraints. We already have aura::WindowDelegate::get(Minimum|Maximum)Size. Either by adding aura::WindowDelegate::GetMaximizedBounds or maybe even aura::WindowDelegate::GetAspectRatio. The second one could be used together with the existing GetMaximumBounds to define the maximized bounds.\n\nI don\u0027t see much alternative. Maybe use custom code for animating ARC windows. Or overwrite widget bounds in OnWindowBoundsChanged, but this may turn into spaghetti.",
      "parentUuid": "48f08e65_321f499b",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}