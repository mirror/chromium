{
  "comments": [
    {
      "key": {
        "uuid": "34325e6c_ceb3bb2b",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-06T00:59:39Z",
      "side": 1,
      "message": "I still don\u0027t understand. The cross face animation in WindowState::SetBoundsDIrectCrossFace won\u0027t work correctly it doesn\u0027t have\nboth (before and after) layers.\n\nYou need to call wm::CrossFadeAnimation with old (current layer), with updated window), don\u0027t you?",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c0f3eaa_5dbafd54",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-06T01:44:39Z",
      "side": 1,
      "message": "\u003e I still don\u0027t understand. The cross...\n\nAbove Resore() and Maximize() are called when we have an old buffer in the window layer, and new buffer will be pushed to that layer in line #788 below. So, SetBoundsDirectCrossFace will recreate the window layer, which means the current layer with old buffer will be detached, and cross faded with the newly created layer which will be very soon filled out with the new buffer in #788.\n\n\n\u003e You need to call wm::CrossFadeAnimation with old (current layer), with updated window), don\u0027t you?\n\nNot sure if I understand. Yes, we need to call it with old layer (for the old window state). What do you mean by \"updated window\"?",
      "parentUuid": "34325e6c_ceb3bb2b",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edc1cd00_e5032b02",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-06T06:16:42Z",
      "side": 1,
      "message": "Won\u0027t it apply wrong animation for pillar-boxed/letter-boxed app because it doesn\u0027t know the real target size there?",
      "parentUuid": "1c0f3eaa_5dbafd54",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48f08e65_321f499b",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-06T07:29:46Z",
      "side": 1,
      "message": "Yes. Animating from restored to pillar-box/letter-box is off. The other way works fine. The culprit is ash::ScreenUtil::GetMaximizedWindowBoundsInParent which returns an incorrect value for pillar boxed windows.\n\n\nIIUC currently we let ash set incorrect dimensions, and then we overwrite them in ShellSurface::OnWindowBoundsChanged. I believe we could avoid this and just add support for custom maximized dimensions to aura, eg. by adding something like GetMaximizedBounds() to aura::WindowDelegate.\n\n\nIn either case, this CL is not intended to fix all animations. It\u0027s just the first step. How about disabling animations when pillar/letterbox are used in this CL and addressing those cases separately?",
      "parentUuid": "edc1cd00_e5032b02",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afdd3181_bb6b9a28",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-06T08:35:16Z",
      "side": 1,
      "message": "I took a closer look, and we don\u0027t overwrite the bounds in OnWindowBoundsChanged for NYC as I wrote earlier, but we do overwrite then in a surface commit. This means that if a window state change is invoked from Chrome (eg. Alt+) the window will have incorrect geometry until the surface is committed. It can be easily confirmed by pressing F4 quickly after alt+.\n\nI believe we should address this in aura by adding native supports for such geometry constraints. We already have aura::WindowDelegate::get(Minimum|Maximum)Size. Either by adding aura::WindowDelegate::GetMaximizedBounds or maybe even aura::WindowDelegate::GetAspectRatio. The second one could be used together with the existing GetMaximumBounds to define the maximized bounds.\n\nI don\u0027t see much alternative. Maybe use custom code for animating ARC windows. Or overwrite widget bounds in OnWindowBoundsChanged, but this may turn into spaghetti.",
      "parentUuid": "48f08e65_321f499b",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c287eb3_87ce2fdc",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-06T09:02:53Z",
      "side": 1,
      "message": "Unfortunately, Chrome shouldn\u0027t (and can\u0027t) control the bounds of the ARC++ windows because we can\u0027t predict the bounds that application will use. I was going to add ARC++ specific state impl that will delegate the request to client without changing state nor bounds.\n\nMin/Max size won\u0027t solve 100% cases for above reason. It\u0027s dynamic and up to application. We only know after the fact.",
      "parentUuid": "afdd3181_bb6b9a28",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05ac5ce4_f35f8b7c",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1002249
      },
      "writtenOn": "2017-09-06T09:31:01Z",
      "side": 1,
      "message": "Hm, I think I see the issue now. Putting pillar boxed windows aside, even the restored bounds on Chrome side may be different than those restored by Android. Currently they seem to be the same and make the cross fade work fine (except pillar box), but it\u0027s not guaranteed.\n\n\u003e Min/Max size won\u0027t solve 100% cases for above reason\n\nCarefully chosen delegate method should work in 100% cases if the window state change is invoked from Android. WindowDelegate::GetBoundsForState would remove the responsibility on deciding bounds from Chrome to Android.\n\nIf the window state is invoked from Chrome, then we\u0027d need your suggested logic for sure. Could you write something more about it?",
      "parentUuid": "1c287eb3_87ce2fdc",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eaf29bbb_4b285822",
        "filename": "components/exo/shell_surface.cc",
        "patchSetId": 7
      },
      "lineNbr": 778,
      "author": {
        "id": 1001380
      },
      "writtenOn": "2017-09-06T23:09:02Z",
      "side": 1,
      "message": "yeah, something like that would work, although it may be more work than simply cross fading between two here. Let\u0027s chat offline today.",
      "parentUuid": "05ac5ce4_f35f8b7c",
      "revId": "e16ce506b34e26dcd2b8757eb954176f49abad7a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}