{
  "comments": [
    {
      "key": {
        "uuid": "ee377906_a9adcda5",
        "filename": "content/browser/renderer_host/render_widget_host_input_event_router.cc",
        "patchSetId": 4
      },
      "lineNbr": 374,
      "author": {
        "id": 1000111
      },
      "writtenOn": "2018-01-08T20:09:30Z",
      "side": 1,
      "message": "This is something you should do during dispatch, right? Not before targeting is done?",
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4551089_e014032e",
        "filename": "content/browser/renderer_host/render_widget_host_input_event_router.cc",
        "patchSetId": 4
      },
      "lineNbr": 374,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-08T22:34:36Z",
      "side": 1,
      "message": "+1 to Sadrul comments. Any side-effect events (e.g. SendGestureScrollEnd()) should be in the dispatch event, otherwise they could in theory use incorrect targetting information.",
      "parentUuid": "ee377906_a9adcda5",
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97971b81_52b53b4e",
        "filename": "content/browser/renderer_host/render_widget_host_input_event_router.cc",
        "patchSetId": 4
      },
      "lineNbr": 374,
      "author": {
        "id": 1211635
      },
      "writtenOn": "2018-01-08T23:13:31Z",
      "side": 1,
      "message": "Yea, I had this updating in dispatching, but thought that this caused a site-per-process browser test failure so tried moving this up (because on TOT, we are sending a GSE even when we cannot find a target to dispatch events to, which is not the case when we put it in dispatch). However, that didn\u0027t solve the browser test failure so I reverted this and have another patch up for review now.",
      "parentUuid": "f4551089_e014032e",
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc06e856_4a68b736",
        "filename": "content/browser/renderer_host/render_widget_host_input_event_router.cc",
        "patchSetId": 4
      },
      "lineNbr": 374,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-09T13:00:13Z",
      "side": 1,
      "message": "Then let\u0027s mark this comment as resolved.",
      "parentUuid": "97971b81_52b53b4e",
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6f7bee04_b7150667",
        "filename": "content/browser/renderer_host/render_widget_host_input_event_router.h",
        "patchSetId": 4
      },
      "lineNbr": 193,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-08T22:34:36Z",
      "side": 1,
      "message": "See comment below.",
      "range": {
        "startLine": 193,
        "startChar": 17,
        "endLine": 193,
        "endChar": 26
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10cd5ac0_8c775810",
        "filename": "content/browser/renderer_host/render_widget_host_input_event_router.h",
        "patchSetId": 4
      },
      "lineNbr": 204,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-08T22:34:36Z",
      "side": 1,
      "message": "Do we really need to propagate this? Why not just delay the coordinate conversion until inside the DispatchMouseWheelEvent function, using root_view-\u003eTransformPointToCoordSpaceForView(..., target, ...)?",
      "range": {
        "startLine": 204,
        "startChar": 37,
        "endLine": 204,
        "endChar": 42
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "87ec0b8c_69693d99",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-08T22:34:36Z",
      "side": 1,
      "message": "Would it be simpler to send the WheelEventAck from inside the dispatch function inside RWHIER?",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 6
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b19f5f76_ce02f19f",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1211635
      },
      "writtenOn": "2018-01-08T23:13:31Z",
      "side": 1,
      "message": "We do an early return here tho, so it won\u0027t reach dispatching. And there seems to be no easy way to do that in RouteMouseWheelEvent because we also early return if events are put in the queue. WDYT?",
      "parentUuid": "87ec0b8c_69693d99",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 6
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7049ad7d_22825ad4",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-09T13:00:13Z",
      "side": 1,
      "message": "I suppose, though you don\u0027t have to do an early return ... you could dispatch the event, and have the dispatcher do the Ack when it sees the null target.",
      "parentUuid": "b19f5f76_ce02f19f",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 6
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "319990fd_4312e2d6",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-09T14:10:28Z",
      "side": 1,
      "message": "Perhaps a better way of explaining what I\u0027m thinking is this: when there\u0027s no target, it should be up to the delegate (and not this class) to decide what should happen to the event. So if you just dispatch the event back to the delegate with a null target, it can decide what to do.\n\nFor example, for touch events, the target is set by the *first* touch start in a sequence. All subsequent touch events until the final TouchEnd/Cancel will not even be hit-tested by the delegate ... rather it will send back a null target, *and* indicate false for |should_query_view|. When the events are dispatched to it with null targets, it will know to handle them using the target found for the initial TouchStart.\n\nIn the touch case it\u0027s essential that the delegate has this control; it seems that we should do this consistently for all event types.",
      "parentUuid": "7049ad7d_22825ad4",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 6
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "036a0248_f01cb51b",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1001433
      },
      "writtenOn": "2018-01-09T16:48:24Z",
      "side": 1,
      "message": "I agree with James, it seems like simpler model if we guarantee a callback to the RWHIER after it requests dispatch, so it can handle the errors. Calling FoundTarget with a null view feels a bit weird but it better encapsulates the event handling logic.",
      "parentUuid": "319990fd_4312e2d6",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 6
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bfed2cb6_9c4d9514",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 190,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-08T22:34:36Z",
      "side": 1,
      "message": "Instead of propagating this delta all the way back, why not send the point back in root_view coords, and do a single call to root_view-\u003eTransformPointToCoordSpaceForView() inside RWHIER? This has the advantage of being a more general transform than a simple offset.",
      "range": {
        "startLine": 190,
        "startChar": 24,
        "endLine": 190,
        "endChar": 29
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d00c7ab4_c07bf382",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 190,
      "author": {
        "id": 1211635
      },
      "writtenOn": "2018-01-08T23:13:31Z",
      "side": 1,
      "message": "The point can be transformed by other function as well (e.g. FindViewAtLocation in RWHIER) other than TransformPointToCoordSpaceForView(), so I think we still need to pass back the result |target_location| in DispatchEventToTarget if we want to do the conversion in RWHIER. Did I misunderstand your proposal?",
      "parentUuid": "bfed2cb6_9c4d9514",
      "range": {
        "startLine": 190,
        "startChar": 24,
        "endLine": 190,
        "endChar": 29
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12a300f3_dc5c299c",
        "filename": "content/browser/renderer_host/render_widget_targeter.cc",
        "patchSetId": 4
      },
      "lineNbr": 190,
      "author": {
        "id": 1212389
      },
      "writtenOn": "2018-01-09T13:00:13Z",
      "side": 1,
      "message": "I\u0027m only interested in the value passed to DispatchEventToTarget(). If it has the root view, the target view, and the *original* event location, then it can do the transformation itself without needing the delta parameter at all. Up until this point the original event has had its PositionInWidget() left unchanged, and if you continue to leave it unchanged then you don\u0027t need the delta parameter, you can just do the final transformation in DispatchMouseWheelEvent().",
      "parentUuid": "d00c7ab4_c07bf382",
      "range": {
        "startLine": 190,
        "startChar": 24,
        "endLine": 190,
        "endChar": 29
      },
      "revId": "50b3770b6298f353a15d977607d45f45b081ae76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}