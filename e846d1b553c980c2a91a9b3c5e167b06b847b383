{
  "comments": [
    {
      "key": {
        "uuid": "c5d39411_e9199417",
        "filename": "build/util/lib/common/chrome_test_server_spawner.py",
        "patchSetId": 4
      },
      "lineNbr": 260,
      "author": {
        "id": 1116023
      },
      "writtenOn": "2018-01-26T00:46:04Z",
      "side": 1,
      "message": "For OCSP we need to ensure that the certificate contains correct port number for OCSP server.  There are two ways to make it work:\n1. Pass self.host_ocsp_port instead of 0 for the first parameter. It\u0027s the port number on the target device. 0 means that it\u0027s allocated dynamically.\n\n2. Detect when OCSP is enabled from the command line, and forward the port first before starting testserver.py. Then pass self.forwarder_ocsp_device_port using --ocsp-proxy-port-number argument in the command_line.\n\nThe first solution may be flaky because it\u0027s not possible to guarantee that the port is available on device . (2) is slightly more complex but it would be more reliable.",
      "range": {
        "startLine": 260,
        "startChar": 26,
        "endLine": 260,
        "endChar": 27
      },
      "revId": "e846d1b553c980c2a91a9b3c5e167b06b847b383",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a21822a_2fd0052a",
        "filename": "build/util/lib/common/chrome_test_server_spawner.py",
        "patchSetId": 4
      },
      "lineNbr": 260,
      "author": {
        "id": 1002844
      },
      "writtenOn": "2018-01-27T00:00:43Z",
      "side": 1,
      "message": "hm, doesn\u0027t (2) still have the same basic problem? You can\u0027t set up the adb forwarding before starting testserver, since you don\u0027t know what port testserver will bind for the ocsp server. The port_forwarder doesn\u0027t seem to have a way to bind the device port and then later choose where to forward it to.",
      "parentUuid": "c5d39411_e9199417",
      "range": {
        "startLine": 260,
        "startChar": 26,
        "endLine": 260,
        "endChar": 27
      },
      "revId": "e846d1b553c980c2a91a9b3c5e167b06b847b383",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c9bbccd_97d99b74",
        "filename": "build/util/lib/common/chrome_test_server_spawner.py",
        "patchSetId": 4
      },
      "lineNbr": 260,
      "author": {
        "id": 1116023
      },
      "writtenOn": "2018-01-27T00:45:35Z",
      "side": 1,
      "message": "That\u0027s a good point. It\u0027s not so straightforward as I thought. But as far as I can tell ADB should allow to remap ports that are already mapped. You can call port_map.Map([already_mapped_device_port, new_host_port]) and this will update host port for the a client port that\u0027s already mapped. Something like this could work:\n\nlisten_socket \u003d socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nlisten_socket.bind((\u0027127.0.0.1\u0027, 0))\nlisten_socket.listen(1)\ndummy_host_port \u003d listen_socket.getsockname()[1]\nself.port_forwarder.Map([(0, dummy_host_port)])\ndevice_ocsp_port \u003d self.port_forwarder.GetDevicePortForHostPort(socket_port)\n\n... Start testserver.py --ocsp-proxy-port-number\u003d\u003cdevice_ocsp_port\u003e\n\nself.port_forwarder.Map([(device_ocsp_port, self.host_ocsp_port)])\nlisten_socket.close()\n\nIt doesn\u0027t look very clean, but it should work properly.\nWDYT?",
      "parentUuid": "3a21822a_2fd0052a",
      "range": {
        "startLine": 260,
        "startChar": 26,
        "endLine": 260,
        "endChar": 27
      },
      "revId": "e846d1b553c980c2a91a9b3c5e167b06b847b383",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}