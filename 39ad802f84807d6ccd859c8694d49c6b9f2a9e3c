{
  "comments": [
    {
      "key": {
        "uuid": "fd24c1e5_2e34881f",
        "filename": "components/ui_devtools/views/ui_devtools_dom_agent.cc",
        "patchSetId": 10
      },
      "lineNbr": 258,
      "author": {
        "id": 1116046
      },
      "writtenOn": "2017-07-31T22:24:23Z",
      "side": 1,
      "message": "nit: newline",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf882410_240748e1",
        "filename": "components/ui_devtools/views/ui_devtools_dom_agent.cc",
        "patchSetId": 10
      },
      "lineNbr": 258,
      "author": {
        "id": 1229390
      },
      "writtenOn": "2017-08-01T00:57:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fd24c1e5_2e34881f",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b70de041_ed242b16",
        "filename": "components/ui_devtools/views/ui_devtools_dom_agent.cc",
        "patchSetId": 10
      },
      "lineNbr": 263,
      "author": {
        "id": 1116046
      },
      "writtenOn": "2017-07-31T22:24:23Z",
      "side": 1,
      "message": "nit: newline",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f8b1990_fa9493d6",
        "filename": "components/ui_devtools/views/ui_devtools_dom_agent.cc",
        "patchSetId": 10
      },
      "lineNbr": 263,
      "author": {
        "id": 1229390
      },
      "writtenOn": "2017-08-01T00:57:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b70de041_ed242b16",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e797d00d_fc9c2bf8",
        "filename": "components/ui_devtools/views/ui_devtools_dom_agent.h",
        "patchSetId": 10
      },
      "lineNbr": 65,
      "author": {
        "id": 1116046
      },
      "writtenOn": "2017-07-31T22:24:23Z",
      "side": 1,
      "message": "nit: Suggested rewording: \"Return the id of the UI element targeted by an event located at |p|, where |p| is in the local coodinate space of |window_element_root_|. The function first searches for the targeted window, then the targeted widget (if one exists), then the targeted view (if one exists).\"\n\nAlso, optional, perhaps consider a function name such as \"FindElementIdTargetedByPoint\" or similar.",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d62a9390_750bfe5c",
        "filename": "components/ui_devtools/views/ui_devtools_dom_agent.h",
        "patchSetId": 10
      },
      "lineNbr": 65,
      "author": {
        "id": 1229390
      },
      "writtenOn": "2017-08-01T00:57:48Z",
      "side": 1,
      "message": "Nice rewording Terry, thanks!",
      "parentUuid": "e797d00d_fc9c2bf8",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0bd20027_1052b96f",
        "filename": "components/ui_devtools/views/ui_devtools_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 354,
      "author": {
        "id": 1116046
      },
      "writtenOn": "2017-07-31T22:24:23Z",
      "side": 1,
      "message": "Since there is only one EXPECT_*(...) assertion in this test, the only thing you are testing is whether or not FindElementByEventHandler() returns a non-zero ID when given a point |p|. This is itself a good thing to be checking, but I don\u0027t think it requires entering inspection mode, dispatching a mouse event, and then exiting inspect mode. I think this test could just be:\n\nCreateTestWidget(...);\n...DOM::Node... root;\ndom_agent()-\u003egetDocument(\u0026root);\ngfx::Point p(1,1);\nEXPECT_NE(0, dom_agent()-\u003eFindElementByEventHandler(p));\n\nThat test could be named FindElementByEventHandler (or similar) with the description \"Tests that FindElementByEventHandler returns a non-zero id when a UI element target exists.\"\n\n\nThen, as a second test case, you could do something similar to lines 356-372 in order to verify that dispatching a mouse event has the intended effect. So, consider something like:\n\nCreateTestWidget(...);\n...DOM::Node... root;\ndom_agent()-\u003egetDocument(\u0026root);\n\noverlay_agent()-\u003esetInspectMode(\"searchForNode\", ...);\n\n// Dispatch a mouse move using EventGenerator.\n// Verify that nodeHighlightRequested was sent to the FE (*).\n\n// Dispatch a mouse press using EventGenerator.\n// Verify that inspectNodeRequested was sent to the FE (*).\n\n// Dispatch a mouse move.\n// Verify that neither event was sent to the FE (*), since the previous mouse-press removed the overlay agent as a pre-target handler.\n\nNote that for each of the lines marked as (*) above, I am assuming that you are able to see what is being dispatched to the FE by using |fake_frontend_channel_|.\n\n\nThese are just some thoughts, which may or may not be correct; feel free to leave the test as-is and keep this comment thread Unresolved so that Sadrul can weigh in during his code review.",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0a890f34_4a8a21b1",
        "filename": "components/ui_devtools/views/ui_devtools_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 354,
      "author": {
        "id": 1229390
      },
      "writtenOn": "2017-08-01T00:57:48Z",
      "side": 1,
      "message": "Thanks Terry. I added a test UIDevToolsTest.FindElementIdTargetedByPoint as you suggested. For second test case, I just removed EXPECT_NE, keep it as it is and add your dispatch comments.",
      "parentUuid": "0bd20027_1052b96f",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4c554bf_d20de375",
        "filename": "components/ui_devtools/views/ui_devtools_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 354,
      "author": {
        "id": 1116046
      },
      "writtenOn": "2017-08-01T15:48:37Z",
      "side": 1,
      "message": "Ah sorry, I don\u0027t think my suggestion here was very clear; I meant for the comments to represent pseudocode. Here\u0027s what I had in mind:\n\n  overlay_agent()-\u003esetInspectMode(\n        \"searchForNode\", protocol::Maybe\u003cprotocol::Overlay::HighlightConfig\u003e());\n\n  ui::test::EventGenerator generator(widget-\u003eGetNativeWindow());\n  gfx::Point p(1, 1);\n\n  // Moving the mouse cursor over the widget bounds should request a node highlight.\n  generator.MoveMouseBy(p.x(), p.y());\n  EXPECT_EQ(1, GetNodeHighlightRequestedCount());\n\n  // Clicking on the widget should request that element be inspected.\n  generator.PressLeftButton();\n  EXPECT_EQ(1, GetInspectNodeRequestedCount());\n\n  // Since the last event dispatched to the widget was a click, a subsequent\n  // mouse event should generate neither a nodeHighlightRequested nor a\n  // inspectNodeRequested event.\n  generator.MoveMouseBy(p.x(), p.y());\n  EXPECT_EQ(1, GetNodeHighlightRequestedCount());\n  EXPECT_EQ(1, GetInspectNodeRequestedCount());\n\nYou can implement the two Get*Count() methods similar to GetStyleSheetChangedCount().\n\nAs-is, because you are not EXPECT-ing anything in the second test in PS11, it doesn\u0027t verify the correct behavior in response to mouse events. Instead, all it is doing is verifying that the code you call does not cause a crash.",
      "parentUuid": "0a890f34_4a8a21b1",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c49a560_191d66f9",
        "filename": "components/ui_devtools/views/ui_devtools_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 354,
      "author": {
        "id": 1229390
      },
      "writtenOn": "2017-08-01T22:20:11Z",
      "side": 1,
      "message": "Thanks Terry. I\u0027m able to do almost what you described here. The minor differences is we don\u0027t really know how much overlay notification frontend() produces so we use EXPECT_NE instead of EXPECT_EQ(1, ...). You can view the change in patchset 12.",
      "parentUuid": "f4c554bf_d20de375",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e3eb373e_16bc33a0",
        "filename": "components/ui_devtools/views/ui_devtools_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 354,
      "author": {
        "id": 1116046
      },
      "writtenOn": "2017-08-02T17:50:31Z",
      "side": 1,
      "message": "I\u0027m not sure I understand why this is the case. We dispatch the inspectNodeRequested message only in the case of a mouse-press, and dispatch the nodeHighlightRequested message for all other mouse event types. In your test you are synthesizing a mouse move followed by a mouse press, which means that we should be able to assert EXPECT_EQ() in the test with a pre-determined value.\n\nWhen you run your test, how many of each event type is being seen by the FakeFrontendChannel? Do these numbers change based on the order in which you run the test suite / on independent runs of the same test?\n\n(Side note: depending on implementation in EventGenerator, it\u0027s possible that the call to MoveMouseBy() will actually generate more than one ui:: mouse event, e.g., a ET_MOUSE_ENTERED followed by an ET_MOUSE_MOVED. If this is the case then it would be correct to make the expected value for EXPECT_EQ(..., GetNodeHighlightRequestedCount()) be greater than 1. To double-check, it would be a good idea to add logging in UIDevToolsOverlayAgent::OnMouseEvent() during your test run in order to understand which mouse event types are being seen, and if they trigger the appropriate calls to frontend() as you\u0027d expect.)",
      "parentUuid": "5c49a560_191d66f9",
      "revId": "39ad802f84807d6ccd859c8694d49c6b9f2a9e3c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}