{
  "comments": [
    {
      "key": {
        "uuid": "b8bfcad5_69b699de",
        "filename": "chrome/browser/offline_pages/background_loader_offliner.cc",
        "patchSetId": 7
      },
      "lineNbr": 372,
      "author": {
        "id": 1002911
      },
      "writtenOn": "2017-06-06T00:08:45Z",
      "side": 1,
      "message": "This postpones the clean up and risks that you get a race condition between ResetState execution and perhaps the next request to use the offliner.\n\nDid you consider adding something like inside of ResetState instead?\nbase::ThreadTaskRunnerHandle::Get()-\u003eDeleteSoon(FROM_HERE, snapshot_controller_.release());",
      "range": {
        "startLine": 372,
        "startChar": 10,
        "endLine": 372,
        "endChar": 32
      },
      "revId": "8be9875258e273b446dd1dfcfafaefbe7f2dff83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56296b5b_e79c5d5b",
        "filename": "chrome/browser/offline_pages/background_loader_offliner.cc",
        "patchSetId": 7
      },
      "lineNbr": 372,
      "author": {
        "id": 1212384
      },
      "writtenOn": "2017-06-08T01:04:46Z",
      "side": 1,
      "message": "Yes, at first I thought it was OK because the restart would reset most of the fields anyway. However, the real problem is the ResetState running afterwards....\n\nI also don\u0027t really see how using DeleteSoon would resolve this issue? Wouldn\u0027t that risk another race condition between starting next request and the snapshot controller deletion?\n\nI\u0027m playing with the idea of invalidating the weak ptrs right before we call loadurl on the webcontents, and also moving the number/field resetting to a method like ResetCounters and call that inside start request.\n\nStartRequest will reset the webcontents and the snapshot controller anyway, so those things don\u0027t really need to be reset to nullptr. The only important part is we reset download counters and error page states?",
      "parentUuid": "b8bfcad5_69b699de",
      "range": {
        "startLine": 372,
        "startChar": 10,
        "endLine": 372,
        "endChar": 32
      },
      "revId": "8be9875258e273b446dd1dfcfafaefbe7f2dff83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb1a850d_738302e3",
        "filename": "chrome/browser/offline_pages/background_loader_offliner.cc",
        "patchSetId": 7
      },
      "lineNbr": 372,
      "author": {
        "id": 1002911
      },
      "writtenOn": "2017-06-08T18:45:14Z",
      "side": 1,
      "message": "If I understand correctly, the race condition you are referring to can happen if there are more calls from snapshot controller to the BLO. Not sure if that can happen in this scenario. We could probably add means to reset any activity pending on snapshot controller or tell it to no longer send updates, before we reset it.\n(* It does look like we guard from it by checks on pending_requests_ thou *)\n\nWhy \u0027delete soon\u0027 would (mostly) work? Because by calling release() you are resetting snapshot_controller_ to nullptr, without releasing the object that is still on the call stack, but ensuring that once the stack unwinds you will call delete on that object. (* I still like this approach. *)\n\nThe alternative you mention (to do nothing with the snapshot_controller_ in the ResetState() as it will be overwritten in LoadAndSave()), means it will be hanging in memory for a little longer if there are no new requests coming. This is not that big of a deal, unless it will still be capable to send signals to BLO, while it is there, which could lead to state updates. (* We do guard for that as mention in comment to paragraph 1, hence keeping stuff in memory is the only real problem. *)",
      "parentUuid": "56296b5b_e79c5d5b",
      "range": {
        "startLine": 372,
        "startChar": 10,
        "endLine": 372,
        "endChar": 32
      },
      "revId": "8be9875258e273b446dd1dfcfafaefbe7f2dff83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}