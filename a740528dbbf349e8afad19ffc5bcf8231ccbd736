{
  "comments": [
    {
      "key": {
        "uuid": "7e5eee22_2face9b9",
        "filename": "chrome/browser/chromeos/file_system_provider/notification_manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1115907
      },
      "writtenOn": "2017-10-04T16:54:52Z",
      "side": 1,
      "message": "this is another example of a NotificationHandler which doesn\u0027t really do anything except forward to a different object based on the notification\u0027s ID. The type (FILE_SYSTEM_PROVIDER) is pretty much irrelevant here, UMA aside. This is a whole lot of boiler plate to add to many files, so I would like to reconsider the decision to create a generic ID-to-delegate type and NotificationHandler object.",
      "range": {
        "startLine": 29,
        "startChar": 6,
        "endLine": 29,
        "endChar": 43
      },
      "revId": "a740528dbbf349e8afad19ffc5bcf8231ccbd736",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3faf7853_cd89187d",
        "filename": "chrome/browser/chromeos/file_system_provider/notification_manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1002032
      },
      "writtenOn": "2017-10-05T16:02:52Z",
      "side": 1,
      "message": "Maybe we could do something like type\u003dEPHEMERAL and have a delegate in the Metadata? That would change the lifetime semantics of the Metadata.\n\nA standing concern is that we don\u0027t always know whether a notification is still showing on native platforms. (I.e. the Action Center gives us the `close` event when the notification dismisses to the notification center.) These are small objects, but there is a possibility we have to consider where they may leak.",
      "parentUuid": "7e5eee22_2face9b9",
      "range": {
        "startLine": 29,
        "startChar": 6,
        "endLine": 29,
        "endChar": 43
      },
      "revId": "a740528dbbf349e8afad19ffc5bcf8231ccbd736",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "022b6c61_42fb29ef",
        "filename": "chrome/browser/chromeos/file_system_provider/notification_manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1115907
      },
      "writtenOn": "2017-10-05T16:16:49Z",
      "side": 1,
      "message": "\u003e Maybe we could do something like type\u003dEPHEMERAL and have a delegate in the Metadata? That would change the lifetime semantics of the Metadata.\n\nI like the idea of the EPHEMERAL (or GENERIC or w/e) handler holding onto a map from ID to delegate. What I don\u0027t like about the existing NotificationDelegate is that it\u0027s ref counted (which is bad for understanding object lifetimes and it\u0027s why we have these pass-through delegates in the first place).\n\n\u003e \n\u003e A standing concern is that we don\u0027t always know whether a notification is still showing on native platforms. (I.e. the Action Center gives us the `close` event when the notification dismisses to the notification center.) These are small objects, but there is a possibility we have to consider where they may leak.\n\nWhat is the action center? Are you suggesting the Close calls won\u0027t be reliable? When you say \"these are small objects\", are you referring to the delegates? I think the delegates should be in control of their own lifetime and not be ref counted. So then I would be more concerned about the handler calling back into a stale delegate, and while we could use WeakPtr I think it\u0027s better to demand notification clients unregister themselves if they exit early (i.e. before the notification has been interacted with) for some reason.",
      "parentUuid": "3faf7853_cd89187d",
      "range": {
        "startLine": 29,
        "startChar": 6,
        "endLine": 29,
        "endChar": 43
      },
      "revId": "a740528dbbf349e8afad19ffc5bcf8231ccbd736",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}