{
  "comments": [
    {
      "key": {
        "uuid": "32fccc5d_39443a4d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "can we just change the target level for chrome? why is dynamic loading not needed just because target level changed? do we build chrome for each target level we support?",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdfca6ed_c97b3af4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "The functions used here were added to the NDK libraries as required Android features at platform level 26, so they would be usable as plain functions without manual dynamic loading if that were used as the NDK platform build level. However, in practice this would require raising the sdkMin version for the entire application to API level 26, and this would make Chrome only show in the Play Store for devices running Android O and newer. That\u0027s obviously a nonstarter.\n\nThere\u0027s a fairly long (though somewhat opinionated) description here: https://stackoverflow.com/a/41079462\n\nThere may be ways to do tricky things such as offering multiple APKs on Play Store or shipping multiple .so files in an APK for runtime switching, but that seems unreasonable.\n\nThe Java SDK supports separately setting minimum, target, and compile SDK levels, but the NDK does not support this. Using compatible declarations together with manual dynamic loading appears to be the usual approach here. Any changes to the NDK platform level need to be done very carefully due to risk of incompatibility.",
      "parentUuid": "32fccc5d_39443a4d",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e226fba2_ab0a1576",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-22T22:57:08Z",
      "side": 1,
      "message": "Ok, then it seems like the right thing to do is always use dynamic loading for now and protect the code that will use this with a:\n\nif (base::android::BuildInfo::GetInstance()-\u003esdk_int() \u003e\u003d\n    base::android::SDK_VERSION_OREO)\n\ncheck. There\u0027s some precedence for this here:\nhttps://cs.chromium.org/chromium/src/net/socket/udp_socket_posix.cc?l\u003d505\n\nAnd I think this check should be done by the GMB code that advertises native support but fine of course to have a helper function such as IsAndroidHardwareBufferSupported in base/ if useful.",
      "parentUuid": "bdfca6ed_c97b3af4",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c277f496_55f5fc3f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-23T20:55:05Z",
      "side": 1,
      "message": "I\u0027m adding this check as a requirement, but I don\u0027t think it\u0027s safe to treat this as a sufficient test for support being available. I think it\u0027s safer to continue handling the case where symbol loading may fail even on a \u003e\u003d Oreo system, to avoid potential crashes if this runs on a weird device that may not entirely follow CDD requirements.\n\nThe code already uses this for advertising support, gpu/ipc/common/gpu_memory_buffer_support.cc\u0027s IsNativeGpuMemoryBufferConfigurationSupported will return false if base::AndroidHardwareBufferCompat::IsSupportAvailable() is false.",
      "parentUuid": "e226fba2_ab0a1576",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "92a8720d_60826ace",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-24T15:52:31Z",
      "side": 1,
      "message": "Devices that doesn\u0027t follow CDD requirements doesn\u0027t seem like something we should worry about. At least not until we know it exists and we need to support AHardwareBuffer on these devices.",
      "parentUuid": "c277f496_55f5fc3f",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a62f612c_021e420e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-31T21:07:04Z",
      "side": 1,
      "message": "I agree, the one concern I still have is that the AHardwareBuffer GMB code gets activated even in cases when it\u0027s not really needed due to being part of the generic GMB handle struct, and I\u0027d want to avoid potential crashes as part of unrelated code doing checks as a side effect. This should be doable as part of the lazy initialization.\n\nFor example, I had a mistake in earlier versions of the code that didn\u0027t correctly handle null AHardwareBuffer GMB handles, and this unexpectedly broke the Google Search and Docs web pages.",
      "parentUuid": "92a8720d_60826ace",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42c6787a_96f773e9",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 25,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "Please cleanup all this type of debug logging before asking for review.",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47b23cba_df4c6963",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 25,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Sorry about that, done. I\u0027ve left a small amount of error logging, let me know if this seems appropriate now.",
      "parentUuid": "42c6787a_96f773e9",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cdf3d1e_1e10bb0e",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 44,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "move this into a separate helper function like other GMB impls",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be2cd239_0dc31198",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 44,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "This is a bit different from the other GMB implementations since it needs to convert the Chrome types to AHArdwareBufferDesc equivalents for the supported types. I\u0027ve moved it to a no-fail \"GetBufferConfig\" method that\u0027s called after checking the already-existing IsConfigurationSupported() logic, with some DCHECK/NOTREACHED as sanity check in case the code gets updated inconsistently.",
      "parentUuid": "3cdf3d1e_1e10bb0e",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0aa3338e_1315c107",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 57,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "move this into a separate helper function like other GMB impls",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ea5a4fc_067576ad",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 57,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "See previous.",
      "parentUuid": "0aa3338e_1315c107",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6a8b271_a77d324b",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 104,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "what is this used for?",
      "range": {
        "startLine": 104,
        "startChar": 9,
        "endLine": 104,
        "endChar": 20
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36d9491a_1ce33511",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 104,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Removed. I was following the SharedMemory implementation here, it seems to be a sanity check on the size calculation to avoid integer overflow or similar based on safe_math and ValueOrDie, but I\u0027m not sure if it adds much benefit since I\u0027m not using the resulting buffer_size for the allocation. \n\nThis does trust the AHardwareBuffer allocation now though to do the right thing, please let me know if you want me to add additional size sanity checks.",
      "parentUuid": "d6a8b271_a77d324b",
      "range": {
        "startLine": 104,
        "startChar": 9,
        "endLine": 104,
        "endChar": 20
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "902eb4a3_31e77be7",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 108,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "I think it would be a bit more consistent to have an AHardwareBufferDesc(size, format, usage) function that cannot fail and then call AHardwareBuffer_allocate here.",
      "range": {
        "startLine": 108,
        "startChar": 32,
        "endLine": 108,
        "endChar": 46
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e4cb669_8808e8eb",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 108,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "902eb4a3_31e77be7",
      "range": {
        "startLine": 108,
        "startChar": 32,
        "endLine": 108,
        "endChar": 46
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "531a33c4_9c920029",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 168,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "fyi, no need to handle failures in this case. just DCHECK if format or anything else is not supported as we shouldn\u0027t be trying to test unsupported configurations.",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e03f47a7_ede81b7d",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 168,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "531a33c4_9c920029",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a069bb6_92b443b4",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 22,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "can you remove this and have the caller use eglGetNativeClientBufferANDROID?",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "340b0c19_db58e788",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 22,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Done. I was assuming that direct GL commands would largely be expected to stay in ui/gl/, but it looks as if direct_composition_surface_win and related code in gpu/ipc/service/ use them fairly extensively already.",
      "parentUuid": "5a069bb6_92b443b4",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "447ddccd_73da97d7",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "why add this as part of this patch?",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b914eb3_7e4a85a4",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 40,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "I\u0027m actually confused about this myself. OnMemoryDump is a pure abstract method in GlImage that didn\u0027t get defined or overridden for GlImageEGL (as far as I can tell), so the compiler complained to me that the \"new gl: GLImageEGL(size)\" call in the factory code was an invalid attempt to construct an abstract class instance. I agree with the compiler, but it\u0027s unclear to me how come this never caused issues previously. My guess is that these were only being instantiated via GLImageNativePixmap which does override OnMemoryDump.",
      "parentUuid": "447ddccd_73da97d7",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9399e018_489be0c9",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-22T22:57:08Z",
      "side": 1,
      "message": "GLImageEGL is not meant to be a full implementation. I think we should add a GLImageAHardwareBuffer to be consistent with GLImageNativePixmap.",
      "parentUuid": "1b914eb3_7e4a85a4",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e8c2991_e56cefb3",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 40,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-23T20:55:05Z",
      "side": 1,
      "message": "Done, and I added a comment that this class is intentionally abstract.",
      "parentUuid": "9399e018_489be0c9",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}