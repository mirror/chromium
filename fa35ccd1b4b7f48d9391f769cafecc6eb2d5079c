{
  "comments": [
    {
      "key": {
        "uuid": "32fccc5d_39443a4d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "can we just change the target level for chrome? why is dynamic loading not needed just because target level changed? do we build chrome for each target level we support?",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdfca6ed_c97b3af4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 13
      },
      "lineNbr": 12,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "The functions used here were added to the NDK libraries as required Android features at platform level 26, so they would be usable as plain functions without manual dynamic loading if that were used as the NDK platform build level. However, in practice this would require raising the sdkMin version for the entire application to API level 26, and this would make Chrome only show in the Play Store for devices running Android O and newer. That\u0027s obviously a nonstarter.\n\nThere\u0027s a fairly long (though somewhat opinionated) description here: https://stackoverflow.com/a/41079462\n\nThere may be ways to do tricky things such as offering multiple APKs on Play Store or shipping multiple .so files in an APK for runtime switching, but that seems unreasonable.\n\nThe Java SDK supports separately setting minimum, target, and compile SDK levels, but the NDK does not support this. Using compatible declarations together with manual dynamic loading appears to be the usual approach here. Any changes to the NDK platform level need to be done very carefully due to risk of incompatibility.",
      "parentUuid": "32fccc5d_39443a4d",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 38
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "42c6787a_96f773e9",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 25,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "Please cleanup all this type of debug logging before asking for review.",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47b23cba_df4c6963",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 25,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Sorry about that, done. I\u0027ve left a small amount of error logging, let me know if this seems appropriate now.",
      "parentUuid": "42c6787a_96f773e9",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cdf3d1e_1e10bb0e",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 44,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "move this into a separate helper function like other GMB impls",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be2cd239_0dc31198",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 44,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "This is a bit different from the other GMB implementations since it needs to convert the Chrome types to AHArdwareBufferDesc equivalents for the supported types. I\u0027ve moved it to a no-fail \"GetBufferConfig\" method that\u0027s called after checking the already-existing IsConfigurationSupported() logic, with some DCHECK/NOTREACHED as sanity check in case the code gets updated inconsistently.",
      "parentUuid": "3cdf3d1e_1e10bb0e",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0aa3338e_1315c107",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 57,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "move this into a separate helper function like other GMB impls",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ea5a4fc_067576ad",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 57,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "See previous.",
      "parentUuid": "0aa3338e_1315c107",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6a8b271_a77d324b",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 104,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "what is this used for?",
      "range": {
        "startLine": 104,
        "startChar": 9,
        "endLine": 104,
        "endChar": 20
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36d9491a_1ce33511",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 104,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Removed. I was following the SharedMemory implementation here, it seems to be a sanity check on the size calculation to avoid integer overflow or similar based on safe_math and ValueOrDie, but I\u0027m not sure if it adds much benefit since I\u0027m not using the resulting buffer_size for the allocation. \n\nThis does trust the AHardwareBuffer allocation now though to do the right thing, please let me know if you want me to add additional size sanity checks.",
      "parentUuid": "d6a8b271_a77d324b",
      "range": {
        "startLine": 104,
        "startChar": 9,
        "endLine": 104,
        "endChar": 20
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "902eb4a3_31e77be7",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 108,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "I think it would be a bit more consistent to have an AHardwareBufferDesc(size, format, usage) function that cannot fail and then call AHardwareBuffer_allocate here.",
      "range": {
        "startLine": 108,
        "startChar": 32,
        "endLine": 108,
        "endChar": 46
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e4cb669_8808e8eb",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 108,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "902eb4a3_31e77be7",
      "range": {
        "startLine": 108,
        "startChar": 32,
        "endLine": 108,
        "endChar": 46
      },
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "531a33c4_9c920029",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 168,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "fyi, no need to handle failures in this case. just DCHECK if format or anything else is not supported as we shouldn\u0027t be trying to test unsupported configurations.",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e03f47a7_ede81b7d",
        "filename": "gpu/ipc/client/gpu_memory_buffer_impl_android_hardware_buffer.cc",
        "patchSetId": 13
      },
      "lineNbr": 168,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "531a33c4_9c920029",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a069bb6_92b443b4",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 22,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "can you remove this and have the caller use eglGetNativeClientBufferANDROID?",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "340b0c19_db58e788",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 22,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "Done. I was assuming that direct GL commands would largely be expected to stay in ui/gl/, but it looks as if direct_composition_surface_win and related code in gpu/ipc/service/ use them fairly extensively already.",
      "parentUuid": "5a069bb6_92b443b4",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "447ddccd_73da97d7",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 40,
      "author": {
        "id": 1000539
      },
      "writtenOn": "2017-10-21T03:53:49Z",
      "side": 1,
      "message": "why add this as part of this patch?",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b914eb3_7e4a85a4",
        "filename": "ui/gl/gl_image_egl.h",
        "patchSetId": 13
      },
      "lineNbr": 40,
      "author": {
        "id": 1187745
      },
      "writtenOn": "2017-10-21T06:47:13Z",
      "side": 1,
      "message": "I\u0027m actually confused about this myself. OnMemoryDump is a pure abstract method in GlImage that didn\u0027t get defined or overridden for GlImageEGL (as far as I can tell), so the compiler complained to me that the \"new gl: GLImageEGL(size)\" call in the factory code was an invalid attempt to construct an abstract class instance. I agree with the compiler, but it\u0027s unclear to me how come this never caused issues previously. My guess is that these were only being instantiated via GLImageNativePixmap which does override OnMemoryDump.",
      "parentUuid": "447ddccd_73da97d7",
      "revId": "fa35ccd1b4b7f48d9391f769cafecc6eb2d5079c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}