{
  "comments": [
    {
      "key": {
        "uuid": "ad6b2c31_4466769e",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 30,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-06T17:06:12Z",
      "side": 1,
      "message": "this looks like a copy, did you want auto\u0026 all_tabs?",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70499159_ba7eff14",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 30,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2018-02-06T21:35:56Z",
      "side": 1,
      "message": "I suppose that\u0027s better. I\u0027m trying to find a syntax that works as an implied global property of Chrome (\"all the tab contentses\") that doesn\u0027t have too much C++ overhead.",
      "parentUuid": "ad6b2c31_4466769e",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "639c83cf_f9b91251",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 37,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-06T17:06:12Z",
      "side": 1,
      "message": "Forward iterators need to be default constructible. I don\u0027t see that constructor?\n\nhttp://en.cppreference.com/w/cpp/concept/ForwardIterator\n\nRagarding the default constructor:\n\nA value-initialized ForwardIterator behaves like the past-the-end iterator of some unspecified empty container: it compares equal to all value-initialized ForwardIterators of the same type.",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6d896b2_f1a9021f",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 37,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2018-02-06T21:35:56Z",
      "side": 1,
      "message": "Done, though how is this useful in any meaningful way other than compatibility with C++ requirements?",
      "parentUuid": "639c83cf_f9b91251",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "952756a8_a415dedf",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 37,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-07T19:18:50Z",
      "side": 1,
      "message": "An STL algo could try to default instantiate the iterator and fail to compile.",
      "parentUuid": "a6d896b2_f1a9021f",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "072b59e5_e8c662f3",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-06T17:06:12Z",
      "side": 1,
      "message": "operator* is supposed to return |reference| for forward iterators, but this is |pointer|:\n\nExpression\tReturn type\tEquivalent expression\ni++\t\tIt\t\tIt ip\u003di; ++i; return ip;\t\n*i++\t\treference",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "820bed92_6e8a85ad",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2018-02-06T21:35:56Z",
      "side": 1,
      "message": "I\u0027m having a real problem here. The spec talks about owning containers, where that makes sense. Creating a pseudo-container, like I am here, is tough.\n\nSwitching to |reference| here yields:\n\n../../chrome/browser/ui/tab_contents/tab_contents_iterator.h:48:42: error: binding value of type \u0027content::WebContents *const\u0027 to reference to type \u0027AllTabContentsesList::Iterator::value_type\u0027 (aka \u0027content::WebContents *\u0027) drops \u0027const\u0027 qualifier\n    reference operator*() const { return cur_; }\n\nNow I get how this is supposed to work for owning containers; *it means \"get me a reference to the thing (that lives in the container) pointed to by the iterator\". But the AllTabContentsesList vends out WebContents*s that aren\u0027t contained in it. *it on a AllTabContentsesList::Iterator means \"get me the WebContents* that the iterator points at\". There is no \"getting a reference to a thing in the container\" and I can\u0027t figure out how to say this in a way that is spec compliant.\n\nSo questions to you:\n\n1. Can you think of a way to make this spec compliant?\n2. Is the best way forward to drop the \"forward iterator\" tag?\n3. If so, am I allowed to use all the fancy std:: algorithms?",
      "parentUuid": "072b59e5_e8c662f3",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ee9d52e_180081f0",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000805
      },
      "writtenOn": "2018-02-06T21:52:37Z",
      "side": 1,
      "message": "It doesn\u0027t make sense to vend a non-const ref out of this iterator; vending a ref-to-const could work (aka content::WebContents* const \u0026, aka const value_type\u0026), but I\u0027m not sure what would break if you made your reference type be that.  Probably there is code that\u0027s not expecting the reference type to actually be reference-to-const?",
      "parentUuid": "820bed92_6e8a85ad",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd06b25b_52aa54cf",
        "filename": "chrome/browser/ui/tab_contents/tab_contents_iterator.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000887
      },
      "writtenOn": "2018-02-07T19:18:50Z",
      "side": 1,
      "message": "I think your |reference| should be a const reference to WebContents*, because this iterator is not an OutputIterator.\n\n```\nThe type std::iterator_traits\u003cIt\u003e::reference must be exactly\n  - T\u0026 if It satisfies OutputIterator (It is mutable)\n  - const T\u0026 otherwise (It is constant),\n```\n\nThen your const operator* method can return a const reference to the pointer it holds.",
      "parentUuid": "7ee9d52e_180081f0",
      "revId": "ebd8aab69a11dd938aa4ae0292c13fc0c315d6f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}