{
  "comments": [
    {
      "key": {
        "uuid": "ff89245d_fbeed180",
        "filename": "third_party/zlib/BUILD.gn",
        "patchSetId": 16
      },
      "lineNbr": 48,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "I didn\u0027t actually see anywhere that defining this matters.  Is it here out of habit or something?  I think you can get away with just\n\n  if (!is_win || is_clang) {\n    cflags \u003d [ \"-mssse3\" ]\n  }\n\nI think clang-cl.exe does still need -mssse3 right, even though cl.exe doesn\u0027t need (or have) any equivalent flag?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "227fecb3_e4520c4d",
        "filename": "third_party/zlib/BUILD.gn",
        "patchSetId": 16
      },
      "lineNbr": 107,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "Putting my GN-encapsulation hat on, this define seems like the sort of thing that :zlib_adler32_simd wants to provide to :zlib via public_configs.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5fd6f19_998d1e45",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Missing (CC).",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "164808cf_b78a900d",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "I\u0027m not quite sure what this means, sorry.  You want be to cc someone?",
      "parentUuid": "b5fd6f19_998d1e45",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97702a1c_7079702a",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 43,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Is there a reason to include \u0027deflate.h\u0027 here?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45c80ba9_604c13a0",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 43,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Compilation is the primary reason: it provides the definition of ZLIB_INTERNAL, I believe.  Are you familiar with what ZLIB_INTERNAL does?",
      "parentUuid": "97702a1c_7079702a",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "087691cf_9a284e07",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 69,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "You might want to time how things go if you don\u0027t do this, and just _mm_loadu_si128 right from the start.  I\u0027ve found it often just doesn\u0027t matter anymore, and people tend to just do this out of superstition.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c6e3aa3_6e2461b4",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 69,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Agree it doesn\u0027t matter on current-generation Intel, they don\u0027t penalize unaligned access anymore.  Older Intel\u0027s did though, so given the wide range and age of chrome user machines, might be prudent to keep it?",
      "parentUuid": "087691cf_9a284e07",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3109de9_2698d3d3",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 73,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "Might be nice to write this as s2 +\u003d (s1 +\u003d *buf++); like elsewhere.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc27b784_a2d3243c",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 98,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Probably won\u0027t change the ASM at all, but similarly to what you requested in the NEON patch, please move it outside of the loop.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18071e76_b93b08e9",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 98,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "I really think we need to have more faith in our compiler.  These constants should go where they make the code read most clearly, which is usually scoped as tightly and lexically as close as possible to the point of use.\n\nHoisting these values outside of a loop is trivially easy for any compiler we\u0027d ever use.",
      "parentUuid": "dc27b784_a2d3243c",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2022afd0_41d92664",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 98,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Adenilson@ I also later asked that you undo my suggestion when you mentioned that good compilers spot this and do generate good code to handle this case well.\n\n\"These constants should go where they make the code read most clearly, which is usually scoped as tightly and lexically as close as possible to the point of use.\"\n\nHaving had to implement this algorithm, agree.",
      "parentUuid": "dc27b784_a2d3243c",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59959851_8a307f15",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 100,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "2 questions:\na) Can\u0027t you just hold all the constants as a single array like we did in the NEON patch?\n\nb) \u0027tap1\u0027 and \u0027tap2\u0027 are not quite descriptive. What about \u0027tap_upper\u0027 and \u0027tap_lower\u0027 or something like that?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7be8156c_54440faa",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 100,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "To a), It usually doesn\u0027t matter, except that we\u0027re more likely to get good code generation for x86 (and in my experience, for ARM) if you keep yourself in the habit of staying away from arrays of vector types.  But given that these are constant, the compiler\u0027s really just going to ignore any opinion we have about where or how to store them and do it itself.",
      "parentUuid": "59959851_8a307f15",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2d79688_64b00a08",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 100,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "a) Also, SSE registers are 128-bits wide (16 x 8 bytes), _mm_setr_epi8 is a convenience initializer of those 16 bytes as noted much earlier in this review.\n\nb) Naming is interesting sometimes, but the code here matches the description I provided in the associated bug, and I\u0027d like to maintain that if possible.\n\nmtklein@\n\u003e But given that these are constant, the compiler\u0027s really just going to ignore any opinion we have about where or how to store them and do it itself.\n\nWhen you made the suggestion of using _mm_set_epi8 and co, rather than the union array thing I had, I examined code generation for both cases.  The clang compiler just ignores us, as you just noted, and generates the exactly same code.",
      "parentUuid": "59959851_8a307f15",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1df88ab3_0c508140",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 168,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "While on ARM it doesn\u0027t matter (i.e. the compiler will map to the same instruction), I recall that in Intel may be a tad faster an alternative way of calculating the modulo using bitwise operators.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be5c698c_c0152b6e",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 168,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "This will be fine on as written on x86 too, really any platform.  This is kid stuff for compilers...",
      "parentUuid": "1df88ab3_0c508140",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "263295c9_dfc28072",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 168,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "\"kid-stuff\", like it :)  Clang generates nice code for this:\n \n        movl    $2147975281, %esi       # imm \u003d 0x80078071\n        imulq   %rcx, %rsi\n        shrq    $47, %rsi\n        imull   $65521, %esi, %ecx      # imm \u003d 0xFFF1\n        subl    %ecx, %eax",
      "parentUuid": "1df88ab3_0c508140",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "392e94de_10856c41",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Maybe use the macro technique as in vanilla adler32 or verify if the compiler could unroll the loop for it.\n\nWhile at it, it may make sense to turn it into an inline function to reuse it at the bottom of the file.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "252fc186_657113ac",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "Yeah, I\u0027m a little curious to see what sort of code Clang generates from just\n\n   while (len--) {\n     s2 +\u003d (s1 +\u003d *buf++);\n   }\n\nIf nothing else, a blank line every group of 4 might help make it visually clear that there really are 16 iterations here.",
      "parentUuid": "392e94de_10856c41",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45872747_6dfc6a86",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Macro\u0027s can have side-effects: *buff++ would be evaluated multiple times with adler-like macros, for example, which would not be good.  The code in it\u0027s current form is correct, assuming readers can count up to 16, and it is also faster (see below).",
      "parentUuid": "392e94de_10856c41",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a1eae378_20622253",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 222,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "I\u0027m not following it.\n\nYou plan to have both Archs implementation in the same file?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f20fc260_cd292afc",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 222,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "That\u0027s an excellent idea.  I have found that keeping related algorithms in the same file generally does make things easier to maintain, more consistent, and helps remind you to implement fast paths for all the platforms you care about.",
      "parentUuid": "a1eae378_20622253",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa54ceaa_47eb7d0e",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 222,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Yeah, use adler32_simd_ as the common drive and call into neon code right here.  Not exactly mind-blowing, but easily possible by the looks, right?\n\n+1 to mike\u0027s comments: easier to maintain, more consistent, all related.",
      "parentUuid": "a1eae378_20622253",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0f2f488_d814351b",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Please see previous comment about the inline function.\n\nAlso, is there any performance advantage in this format than what is used in vanilla adler32?\nI\u0027m referring to DO1 macro: https://cs.chromium.org/chromium/src/third_party/zlib/adler32.c?l\u003d16",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "774b0137_08c6811d",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "I kinda gotta disagree here on hiding this with a macro or inline function.  Seeing the checksum kernel written this clearly and pithily was enlightening.  Anything we do to paper over that is only going to make it harder for the next person reading this code to learn what the adler32 checksum is.\n\n(I don\u0027t think zlib\u0027s existing code is a particularly good reference point for code clarity.)",
      "parentUuid": "f0f2f488_d814351b",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4dd586e9_c432dcbd",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "The form I have used saves instructions compared to doing this with the zlib DOX macros.\n\nAlso an inline function might be a pre-mature.  I suspect this block of code could be done in the vector routine differently, viz., using SSE, and that might be a win compared to the scalar code (but would require more time and corpus measurements to prove it).  The current block should still use scalar code, however.\n\n\u003e Seeing the checksum kernel written this clearly and pithily was enlightening.  Anything we do to paper over that is only going to make it harder for the next person reading this code to learn what the adler32 checksum is.\n\nAppreciate these comments: one goal I had in writing this code and its comments was to make adler32 easily accessible and easily understood ... for myself and that \"next person\", which might be one of you.  \n\nOne of the rules I applied was macros-be-gone due to their tendency to obfuscate in this instance. I assume that both of you can count to 16 :) and, moreover, I assume that in fact you did :D",
      "parentUuid": "f0f2f488_d814351b",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}