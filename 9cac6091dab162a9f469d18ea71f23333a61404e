{
  "comments": [
    {
      "key": {
        "uuid": "ff89245d_fbeed180",
        "filename": "third_party/zlib/BUILD.gn",
        "patchSetId": 16
      },
      "lineNbr": 48,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "I didn\u0027t actually see anywhere that defining this matters.  Is it here out of habit or something?  I think you can get away with just\n\n  if (!is_win || is_clang) {\n    cflags \u003d [ \"-mssse3\" ]\n  }\n\nI think clang-cl.exe does still need -mssse3 right, even though cl.exe doesn\u0027t need (or have) any equivalent flag?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08aa2946_627c7265",
        "filename": "third_party/zlib/BUILD.gn",
        "patchSetId": 16
      },
      "lineNbr": 48,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T14:49:29Z",
      "side": 1,
      "message": "\u003e I didn\u0027t actually see anywhere that defining this matters.  Is it here out of habit or something?  \n\nI was using __SSSE3__ in earlier patches, not using now, it can just go.\n\n\u003e I think you can get away with just\n\u003e \n\u003e   if (!is_win || is_clang) {\n\u003e     cflags \u003d [ \"-mssse3\" ]\n\u003e   }\n\nYeap, looks fine to me.  (Thanks for the code, btw).\n\n\u003e I think clang-cl.exe does still need -mssse3 right, even though cl.exe doesn\u0027t need (or have) any equivalent flag?\n\nYes, clang-cl.exe needs it.  cl.exe maybe doesn\u0027t need it, the bots will tell us I think, like do the win bots compile the adler_simd.c or some such. \n\n(normally robert.bradford@ would tell me, he is a master of these things, but is unavailable at this time).",
      "parentUuid": "ff89245d_fbeed180",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "227fecb3_e4520c4d",
        "filename": "third_party/zlib/BUILD.gn",
        "patchSetId": 16
      },
      "lineNbr": 107,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "Putting my GN-encapsulation hat on, this define seems like the sort of thing that :zlib_adler32_simd wants to provide to :zlib via public_configs.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dcd9b7db_934722d7",
        "filename": "third_party/zlib/BUILD.gn",
        "patchSetId": 16
      },
      "lineNbr": 107,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T14:49:29Z",
      "side": 1,
      "message": "Yeah, I think I kinda get what you\u0027re saying.  Let me see if I can make it work (don\u0027t recall if I\u0027ve ever done this before).",
      "parentUuid": "227fecb3_e4520c4d",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5fd6f19_998d1e45",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Missing (CC).",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "164808cf_b78a900d",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "I\u0027m not quite sure what this means, sorry.  You want be to cc someone?",
      "parentUuid": "b5fd6f19_998d1e45",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6cd479a3_d9c9268a",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T14:20:12Z",
      "side": 1,
      "message": "I suspect, (C), as in Â©?",
      "parentUuid": "164808cf_b78a900d",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "899c474a_9debd7ac",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T15:29:03Z",
      "side": 1,
      "message": "That is correct, sorry my mistake.",
      "parentUuid": "6cd479a3_d9c9268a",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b5d05dec_b8f323f2",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T17:16:27Z",
      "side": 1,
      "message": "Ok, what should be added here then?  Suggestions welcome (/me who has never modified zlib before, so not sure what you OWNERS expect).",
      "parentUuid": "899c474a_9debd7ac",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "035e3dc5_40d8dbd5",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T17:20:06Z",
      "side": 1,
      "message": "Honestly I have no clue.  What do you normally put at the top of a file you write in Chromium?",
      "parentUuid": "b5d05dec_b8f323f2",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "77f0b6b6_bb3f29c0",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T17:39:14Z",
      "side": 1,
      "message": "Me either.  A yard of text about chromium, but that is in the chrome code base, this is in third party.\n\nStepping back, why is it needed?  What needs saying in zlib code that is not clear form this statement?\n\n\"For conditions of distribution and use, see copyright notice in zlib.h\"",
      "parentUuid": "035e3dc5_40d8dbd5",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "710bff8d_a8d4fe51",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T17:50:12Z",
      "side": 1,
      "message": "You are implementing the same public API as zlib, so it certainly makes sense to add \nCopyright (C) 1995-2011, 2017 Mark Adler\n\nI noticed that all code contributed to zlib has part of the copyright attributed to Mark (not sure if that is a hard requirement, but kind of makes sense if you have to maintain the code for 22 years).\n\nMaybe follow it up with Copyright (C) The Chromium project 2017 or whatever is the format used.\n\nIf you consider that this implementation is similar enough to the NEON code, I *guess* that would be the case of adding Copyright (C) 2017 ARM Holdings Inc.\n\nIn any case, my understanding is that ARM has signed the CLA which grants the use of the code/modification/redistribution by the Chromium project, respecting copyrights.\n\nAgain, I\u0027m no lawyer.\n:-)",
      "parentUuid": "77f0b6b6_bb3f29c0",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "09e5ec20_fb4d2e94",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T19:33:21Z",
      "side": 1,
      "message": "I guess cblume@ could provide the extact details we need later.  As far as ARM copyright, that can be added when you add your code in here as discussed earlier in this review.  Will that work you you?",
      "parentUuid": "710bff8d_a8d4fe51",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6647007b_0a1f1317",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 2,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T19:34:51Z",
      "side": 1,
      "message": "Ahem, Will that work for you?",
      "parentUuid": "09e5ec20_fb4d2e94",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97702a1c_7079702a",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 43,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Is there a reason to include \u0027deflate.h\u0027 here?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45c80ba9_604c13a0",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 43,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Compilation is the primary reason: it provides the definition of ZLIB_INTERNAL, I believe.  Are you familiar with what ZLIB_INTERNAL does?",
      "parentUuid": "97702a1c_7079702a",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "087691cf_9a284e07",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 69,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "You might want to time how things go if you don\u0027t do this, and just _mm_loadu_si128 right from the start.  I\u0027ve found it often just doesn\u0027t matter anymore, and people tend to just do this out of superstition.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c6e3aa3_6e2461b4",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 69,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Agree it doesn\u0027t matter on current-generation Intel, they don\u0027t penalize unaligned access anymore.  Older Intel\u0027s did though, so given the wide range and age of chrome user machines, might be prudent to keep it?",
      "parentUuid": "087691cf_9a284e07",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2249f6e_f5cd686b",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 69,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T14:20:12Z",
      "side": 1,
      "message": "I don\u0027t think it hurts to keep, but I\u0027d be surprised if it helps to keep.\n\nI think the party line is, _mm_loadu_si128() and _mm_load_si128() are the exact same speed if the argument actually is 128-bit aligned.  (Or might even be, the exact same speed as long as all 128 bits are in one 512-bit cache line?  Not sure.)  If the argument is not aligned, _mm_loadu_si128() will work and _mm_load_si128() will trap.\n\nNow, what I\u0027ve anecdotally found is beyond that, that we rarely notice a real-world difference between loading unaligned data with _mm_loadu_si128() directly and ramping into loading aligned data with either instruction.  Maybe it\u0027s prefetching helping us, or being compute limited anyway, or being big enough that we\u0027re waiting on memory... who knows.\n\nNo matter what you do here I\u0027m sure you\u0027re going to be speeding decoding up for machines with SSSE3.  I\u0027d kind of think of it like, if we originally wrote the simpler two-phase algorithm here (body, then tail), would we want to go back and add the third head phase?",
      "parentUuid": "6c6e3aa3_6e2461b4",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3109de9_2698d3d3",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 73,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "Might be nice to write this as s2 +\u003d (s1 +\u003d *buf++); like elsewhere.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e617e4aa_0ae683b9",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 73,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T14:27:22Z",
      "side": 1,
      "message": "Indeed, and done.",
      "parentUuid": "a3109de9_2698d3d3",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc27b784_a2d3243c",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 98,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Probably won\u0027t change the ASM at all, but similarly to what you requested in the NEON patch, please move it outside of the loop.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18071e76_b93b08e9",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 98,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "I really think we need to have more faith in our compiler.  These constants should go where they make the code read most clearly, which is usually scoped as tightly and lexically as close as possible to the point of use.\n\nHoisting these values outside of a loop is trivially easy for any compiler we\u0027d ever use.",
      "parentUuid": "dc27b784_a2d3243c",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2022afd0_41d92664",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 98,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Adenilson@ I also later asked that you undo my suggestion when you mentioned that good compilers spot this and do generate good code to handle this case well.\n\n\"These constants should go where they make the code read most clearly, which is usually scoped as tightly and lexically as close as possible to the point of use.\"\n\nHaving had to implement this algorithm, agree.",
      "parentUuid": "dc27b784_a2d3243c",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59959851_8a307f15",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 100,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "2 questions:\na) Can\u0027t you just hold all the constants as a single array like we did in the NEON patch?\n\nb) \u0027tap1\u0027 and \u0027tap2\u0027 are not quite descriptive. What about \u0027tap_upper\u0027 and \u0027tap_lower\u0027 or something like that?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7be8156c_54440faa",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 100,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "To a), It usually doesn\u0027t matter, except that we\u0027re more likely to get good code generation for x86 (and in my experience, for ARM) if you keep yourself in the habit of staying away from arrays of vector types.  But given that these are constant, the compiler\u0027s really just going to ignore any opinion we have about where or how to store them and do it itself.",
      "parentUuid": "59959851_8a307f15",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2d79688_64b00a08",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 100,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "a) Also, SSE registers are 128-bits wide (16 x 8 bytes), _mm_setr_epi8 is a convenience initializer of those 16 bytes as noted much earlier in this review.\n\nb) Naming is interesting sometimes, but the code here matches the description I provided in the associated bug, and I\u0027d like to maintain that if possible.\n\nmtklein@\n\u003e But given that these are constant, the compiler\u0027s really just going to ignore any opinion we have about where or how to store them and do it itself.\n\nWhen you made the suggestion of using _mm_set_epi8 and co, rather than the union array thing I had, I examined code generation for both cases.  The clang compiler just ignores us, as you just noted, and generates the exactly same code.",
      "parentUuid": "59959851_8a307f15",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f810bcb1_34442541",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 100,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T14:20:12Z",
      "side": 1,
      "message": "Right, I mostly just wanted to avoid the union for readability purposes.  They\u0027re kind of a sign that something sneaky\u0027s going on, but in this case it was just kind of more power than needed...",
      "parentUuid": "a2d79688_64b00a08",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1df88ab3_0c508140",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 168,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "While on ARM it doesn\u0027t matter (i.e. the compiler will map to the same instruction), I recall that in Intel may be a tad faster an alternative way of calculating the modulo using bitwise operators.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be5c698c_c0152b6e",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 168,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "This will be fine on as written on x86 too, really any platform.  This is kid stuff for compilers...",
      "parentUuid": "1df88ab3_0c508140",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "263295c9_dfc28072",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 168,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "\"kid-stuff\", like it :)  Clang generates nice code for this:\n \n        movl    $2147975281, %esi       # imm \u003d 0x80078071\n        imulq   %rcx, %rsi\n        shrq    $47, %rsi\n        imull   $65521, %esi, %ecx      # imm \u003d 0xFFF1\n        subl    %ecx, %eax",
      "parentUuid": "1df88ab3_0c508140",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "392e94de_10856c41",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Maybe use the macro technique as in vanilla adler32 or verify if the compiler could unroll the loop for it.\n\nWhile at it, it may make sense to turn it into an inline function to reuse it at the bottom of the file.",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "252fc186_657113ac",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "Yeah, I\u0027m a little curious to see what sort of code Clang generates from just\n\n   while (len--) {\n     s2 +\u003d (s1 +\u003d *buf++);\n   }\n\nIf nothing else, a blank line every group of 4 might help make it visually clear that there really are 16 iterations here.",
      "parentUuid": "392e94de_10856c41",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45872747_6dfc6a86",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Macro\u0027s can have side-effects: *buff++ would be evaluated multiple times with adler-like macros, for example, which would not be good.  The code in it\u0027s current form is correct, assuming readers can count up to 16, and it is also faster (see below).",
      "parentUuid": "392e94de_10856c41",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "29fc8c3e_0f042ae4",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T14:27:22Z",
      "side": 1,
      "message": "ktklein@ Yeah, I\u0027m a little curious to see what sort of code Clang generates from just\n\n   while (len--) {\n     s2 +\u003d (s1 +\u003d *buf++);\n   }\n\nYes, agree, an interesting experiment.  Hope you noticed that adler32.c use that DO16 macro in places to avoid doing the above.  One has to wonder why?\n\n\u003e If nothing else, a blank line every group of 4 might help make it visually clear that there really are 16 iterations here.\n\nLike the \"visually clear\" aspect here, done.  Let me know if you like it.",
      "parentUuid": "45872747_6dfc6a86",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a30338b_a3dcd917",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T14:34:08Z",
      "side": 1,
      "message": "lgtm!\n\nMight just be that zlib has been evolving since the 90s and can\u0027t make very strong assumptions about its compiler?  Now I\u0027m curious and want to see if there\u0027s any record about why the do macros were added or if they\u0027ve been there from the beginning... they\u0027re at least present since v0.71 (14 April 95).",
      "parentUuid": "29fc8c3e_0f042ae4",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ca998e71_90bacbee",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T15:49:59Z",
      "side": 1,
      "message": "Yeah, possible.\n\nNot sure if this\u0027ll work, but see https://godbolt.org/g/HYhQGr which I used to test clang. This code:\n\n   while (len--) {\n     s2 +\u003d (s1 +\u003d *buf++);\n   }\n\ngenerates a loop (Hover over the code of interest on the left, right-click and select \"Scroll to Assembly\")\n\n.LBB0_11:                               # \u003d\u003eThis Inner Loop Header: Depth\u003d1\n        decq    %rdx\n        movzbl  (%rsi), %r9d\n        incq    %rsi\n        addl    %r9d, %eax\n        addl    %eax, %edi\n        incq    %rcx\n        jne     .LBB0_11\n\nRoughly 4 inst. for the loop control, and 4 inst. to do \"s2 +\u003d (s1 +\u003d *buf++);\", so 50% loop overhead.  The body cost equals the loop control cost.\n\n(Noted that clang adds some code straight after for the |len| is exactly divisible by 4 case.  That seems silly, the while (len \u003e\u003d4) { } loop before it already handled that!).\n\nFor the \"while (len \u003e\u003d 4) { .. }\" code we get:\n\n.LBB0_16:                               # \u003d\u003eThis Inner Loop Header: Depth\u003d1\n        movzbl  (%r10), %ecx\n        addl    %eax, %ecx\n        addl    %ecx, %edi\n        movzbl  1(%r10), %eax\n        addl    %ecx, %eax\n        addl    %eax, %edi\n        movzbl  2(%r10), %ecx\n        addl    %eax, %ecx\n        addl    %ecx, %edi\n        movzbl  3(%r10), %eax\n        addl    %ecx, %eax\n        addl    %eax, %edi\n        addq    $-4, %rdx\n        addq    $4, %r10\n        cmpq    $3, %rdx\n        ja      .LBB0_16\n\nAgain 4 inst. for the loop control, and 12 inst. to do \"s2 +\u003d (s1 +\u003d *buf++) 4 times, so loop overhead now 25%, much better.\n\nFor the \"while (len \u003e\u003d 16) { .. }\" code we get:\n  ...\n\n4 inst. for the loop control, and 3 x 16 inst. to do \"s2 +\u003d (s1 +\u003d *buf++) 16 times, loop overhead is smaller again, 8%.\n\nSeems to me that irrespective of compiler, alder32.c is using DO16 to amortize the significant cost of the loop overhead compared to the loop body.  Makes sense to me when I consider small workloads an PNG.",
      "parentUuid": "8a30338b_a3dcd917",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "945f1421_21e83ad1",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T17:10:05Z",
      "side": 1,
      "message": "Just made a couple small tweaks, bumping to Clang 5 and removing everything but the simplest loop: https://godbolt.org/g/vewsR7.\n\nLooks like it\u0027s decided to unroll it 4x.  I guess what I\u0027m wondering is, is Clang right to unroll 4x or are we right to unroll it 16x?  Are you set up to time the difference?  It\u0027s kind of naive to count instructions to measure overhead, especially with out of order execution and instruction fusion.  I\u0027m generally inclined to leave these things up to the compiler and its baked-in cost models when it\u0027s a wash.  They\u0027ve even been forced to write loop-reroll optimization passes just to undo this sort of thing...",
      "parentUuid": "ca998e71_90bacbee",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f309b70_f7325b02",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T19:22:24Z",
      "side": 1,
      "message": "\u003e Looks like it\u0027s decided to unroll it 4x. \n\nNot quite, it\u0027s just a tricky pre-amble\n\n        andq    $3, %rcx\n        je      .LBB0_4\n\nviz, jump to unroll stuff _only if the len is exactly divisible by 4_ :).  The lengths we deal with are 0 ...31.\n\n\u003e I guess what I\u0027m wondering is, is Clang right to unroll 4x or are we right to unroll it 16x?\n\nTLDR: the later.\n\nIn the code we are looking at, the 16x unroll stuff, Clang is not exactly great. Clang adds the 4x unroll code you noted to it, but that code is never used.\n\nConsider in https://godbolt.org/g/HYhQGr \n\n    while (len \u003e\u003d 4) {\n        s2 +\u003d (s1 +\u003d *buf++);\n        s2 +\u003d (s1 +\u003d *buf++);\n        s2 +\u003d (s1 +\u003d *buf++);\n        s2 +\u003d (s1 +\u003d *buf++);\n        len -\u003d 4;\n    }\n\ntherefore, len \u003c\u003d 3 after this loop.  Clang needs to decide if it wants to do the next C code loop ...\n\n    while (len--) {\n        s2 +\u003d (s1 +\u003d *buf++);\n    }\n\nFor that they use:\n\n.LBB0_9:\n        leaq    -1(%rdx), %r8\n        movq    %rdx, %rcx\n        andq    $3, %rcx .      // and the len with 3\n        je      .LBB0_12        // if 0 results, go to \"fancy unroll pre-amble\"\n        negq    %rcx\n\nBut len \u003c\u003d 3 always here, right?  So the go to \"fancy unroll pre-amble\" is never taken for len\u003d1,2,3.  It can be taken for len \u003d 0 mind.\n\nThus, for len\u003d1,2,3, the while (len--) {} is done, and len \u003d -1 when complete. The code then enters the \"fancy unroll pre-amble\", with len \u003d -1 || 0 only.\n\n.LBB0_12:                   // \"fancy unroll preamble\"\n        cmpq    $3, %r8     // compare to len to 3\n        jb      .LBB0_14    // if below, go to the exit .LBB0_14\n                            // but len is either -1 or 0 here\n                            // below 3 is therefore always true\n                            // thus .LBB0_14 is always taken\n.LBB0_13: \n        \"fancy unroll\"\n        ...\n        ...\n.LBB0_14: \"clean-up\"\n        retq\n\nClang has added unrolled code at LBB0_13 that cannot be entered / used.  Not wrong, but not needed either, seems like a Clang bug.",
      "parentUuid": "945f1421_21e83ad1",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6a32d04_8fab0a84",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T20:07:34Z",
      "side": 1,
      "message": "I\u0027m sorry, you\u0027re misreading the assembly at https://godbolt.org/g/vewsR7.\nOnce again, we need to have more faith in our compiler.  :)\n\nThis definitely is a simple 4x unroll, and executes the 4x loop if either len\nis an exact multiple of 4 on its way in, or after executing the first len%4\niterations and there are still more to go.  You can see this yourself by\nrunning the code under a profiler.\n\nFirst we extract s1 and s2, and jump to the end if len \u003d\u003d 0:\n\n        movzwl  %di, %eax\n        shrl    $16, %edi\n        testq   %rdx, %rdx\n        je      .LBB0_6\n\nNow look to see if len (%rdx) is a multiple of 4, and if so jump to .LBB0_4,\nalso storing len-1 into %r8.  %r8 will hold this len-1 the whole way through,\nand %rcx here is set to len % 4.\n\n        leaq    -1(%rdx), %r8\n        movq    %rdx, %rcx\n        andq    $3, %rcx\n        je      .LBB0_4\n\nFor now let\u0027s say len%4 \u003d\u003d 0 and we take the branch to .LBB0_4.\n\n  .LBB0_4:\n        cmpq    $3, %r8\n        jb      .LBB0_6\n\nThis block does double duty and will come back later, but here when we\u0027re\ncoming through already aligned, it\u0027s behavior is trivial.  It jumps to the end\nif len-1 \u003c 3 with an unsigned comparison.  We know len % 4 \u003d\u003d 0, so it\u0027s not\npossible for len-1 to be less than 3.  (Even if len were 0, len-1 is ~0,\ngreater than 3.)\n\nSo we fall through to .LBB0_5 and go four at a time, then exit.  Cool.\n\n  .LBB0_5:\n        movzbl  (%rsi), %ecx\n        addl    %eax, %ecx\n        addl    %ecx, %edi\n        movzbl  1(%rsi), %eax\n        addl    %ecx, %eax\n        addl    %eax, %edi\n        movzbl  2(%rsi), %ecx\n        addl    %eax, %ecx\n        addl    %ecx, %edi\n        movzbl  3(%rsi), %eax\n        addl    %ecx, %eax\n        addl    %eax, %edi\n        addq    $4, %rsi\n        addq    $-4, %rdx\n        jne     .LBB0_5\n  .LBB0_6:\n        shll    $16, %edi\n        orl     %eax, %edi\n        movl    %edi, %eax\n        retq\n\nNow let\u0027s go back and say we didn\u0027t take that first branch to .LBB0_4.  Next\nthing we do is negate len % 4 (%rcx), which we\u0027re going to use as our counter\nup to zero.  We know it\u0027s non-zero, so we\u0027ll get right into the loop one at a\ntime, terminating when %rcx hits zero.\n\n        negq    %rcx\n  .LBB0_3:\n        decq    %rdx\n        movzbl  (%rsi), %r9d\n        incq    %rsi\n        addl    %r9d, %eax\n        addl    %eax, %edi\n        incq    %rcx\n        jne     .LBB0_3\n\nNow we fall through to .LBB0_4  and hit that same check, was our original len-1 \u003c 3?  If so,\nwe\u0027re done, jump to .LBB0_6.  _If not_, we fall trhough to .LBB0_5 and continue 4 at a time\nuntil done.\n\n  .LBB0_4:\n        cmpq    $3, %r8\n        jb      .LBB0_6\n  .LBB0_5\n        ...",
      "parentUuid": "1f309b70_f7325b02",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f400e60_ada1f96c",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 177,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-15T02:44:40Z",
      "side": 1,
      "message": "\u003e I\u0027m sorry, you\u0027re misreading the assembly at https://godbolt.org/g/vewsR7.\n\nYes, I was indeed sleepy at the wheel (and thank you for this wonderful analysis, btw).  I missed the \"double duty\" aspect of that loop, it\u0027s a pretty cool optimization.\n\nSuggests to me that we don\u0027t need the while (len \u003c\u003d 4) {} since Clang handles that for us ...\n\n\u003e Once again, we need to have more faith in our compiler.  :)\n\nAmen to that, we hear ya :)  Uploading a patch to drop the extra while loop, PTAL.",
      "parentUuid": "a6a32d04_8fab0a84",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a1eae378_20622253",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 222,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "I\u0027m not following it.\n\nYou plan to have both Archs implementation in the same file?",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f20fc260_cd292afc",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 222,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "That\u0027s an excellent idea.  I have found that keeping related algorithms in the same file generally does make things easier to maintain, more consistent, and helps remind you to implement fast paths for all the platforms you care about.",
      "parentUuid": "a1eae378_20622253",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa54ceaa_47eb7d0e",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 222,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "Yeah, use adler32_simd_ as the common drive and call into neon code right here.  Not exactly mind-blowing, but easily possible by the looks, right?\n\n+1 to mike\u0027s comments: easier to maintain, more consistent, all related.",
      "parentUuid": "a1eae378_20622253",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0f2f488_d814351b",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T00:07:27Z",
      "side": 1,
      "message": "Please see previous comment about the inline function.\n\nAlso, is there any performance advantage in this format than what is used in vanilla adler32?\nI\u0027m referring to DO1 macro: https://cs.chromium.org/chromium/src/third_party/zlib/adler32.c?l\u003d16",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "774b0137_08c6811d",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T00:59:32Z",
      "side": 1,
      "message": "I kinda gotta disagree here on hiding this with a macro or inline function.  Seeing the checksum kernel written this clearly and pithily was enlightening.  Anything we do to paper over that is only going to make it harder for the next person reading this code to learn what the adler32 checksum is.\n\n(I don\u0027t think zlib\u0027s existing code is a particularly good reference point for code clarity.)",
      "parentUuid": "f0f2f488_d814351b",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4dd586e9_c432dcbd",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T13:59:16Z",
      "side": 1,
      "message": "The form I have used saves instructions compared to doing this with the zlib DOX macros.\n\nAlso an inline function might be a pre-mature.  I suspect this block of code could be done in the vector routine differently, viz., using SSE, and that might be a win compared to the scalar code (but would require more time and corpus measurements to prove it).  The current block should still use scalar code, however.\n\n\u003e Seeing the checksum kernel written this clearly and pithily was enlightening.  Anything we do to paper over that is only going to make it harder for the next person reading this code to learn what the adler32 checksum is.\n\nAppreciate these comments: one goal I had in writing this code and its comments was to make adler32 easily accessible and easily understood ... for myself and that \"next person\", which might be one of you.  \n\nOne of the rules I applied was macros-be-gone due to their tendency to obfuscate in this instance. I assume that both of you can count to 16 :) and, moreover, I assume that in fact you did :D",
      "parentUuid": "f0f2f488_d814351b",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a2232247_0b129281",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1193769
      },
      "writtenOn": "2017-09-14T14:20:12Z",
      "side": 1,
      "message": "I can and did count to 16, but 16 is well past just glancing and knowing the number without counting.  If you group this is into 4 chunks of 4 lines, both of those 4\u0027s will become immediately glanceable and no one will ever have to count.  :)",
      "parentUuid": "4dd586e9_c432dcbd",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "51266470_ff7ad665",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1145695
      },
      "writtenOn": "2017-09-14T15:12:59Z",
      "side": 1,
      "message": "+1 on either grouping it *or* preferably asking the compiler to do the job.",
      "parentUuid": "a2232247_0b129281",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bfaefbf6_bb435c02",
        "filename": "third_party/zlib/adler32_simd.c",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1109754
      },
      "writtenOn": "2017-09-14T19:42:30Z",
      "side": 1,
      "message": "Grouping was done.",
      "parentUuid": "51266470_ff7ad665",
      "revId": "9cac6091dab162a9f469d18ea71f23333a61404e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}