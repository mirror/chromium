{
  "comments": [
    {
      "key": {
        "uuid": "7675d2cb_f610de75",
        "filename": "services/video_capture/service_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 108,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-10-27T16:51:25Z",
      "side": 1,
      "message": "Please add a comment explaining why use of Unretained(this) is safe.",
      "revId": "4e2b65c02ebcfd523e8187aac66c474a57ab8e36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd1d2afb_1af9bdb6",
        "filename": "services/video_capture/service_impl.cc",
        "patchSetId": 4
      },
      "lineNbr": 108,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-10-27T17:17:15Z",
      "side": 1,
      "message": "Will do.",
      "parentUuid": "7675d2cb_f610de75",
      "revId": "4e2b65c02ebcfd523e8187aac66c474a57ab8e36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4062fac9_af02ae1a",
        "filename": "services/video_capture/test/device_factory_provider_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-10-27T16:51:25Z",
      "side": 1,
      "message": "In order to make the difference to the newly added tests below more clear, let us explicitly call out ( in the test case description comment and maybe even test name) that this test here is for the case that 1 client connects and disconnects, while the test at the end of this file is for the case that 2 clients connect and disconnect.",
      "revId": "4e2b65c02ebcfd523e8187aac66c474a57ab8e36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36daf5d8_1eed0921",
        "filename": "services/video_capture/test/device_factory_provider_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-10-27T17:17:15Z",
      "side": 1,
      "message": "Will do.",
      "parentUuid": "4062fac9_af02ae1a",
      "revId": "4e2b65c02ebcfd523e8187aac66c474a57ab8e36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c449d867_4b59d94c",
        "filename": "services/video_capture/test/device_factory_provider_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 109,
      "author": {
        "id": 1175795
      },
      "writtenOn": "2017-10-27T16:51:25Z",
      "side": 1,
      "message": "Waiting for an arbitrarily chosen duration is unfortunately not a deterministic way of testing this. It makes the test run longer than needed in most cases and has the potential for flakiness.\n\nAlso unfortunately, I don\u0027t believe there is any signal or event telling us when the service has received the disconnect. In theory, we could add something to https://cs.chromium.org/chromium/src/services/video_capture/public/interfaces/testing_controls.mojom?dr, but that would mean adding quite a bit of test-only logic, which is not great either.\n\nI wonder if, in order to verify that the service is not shutting down, we could simply try to use |leftover_provider| and see if it still responds. However, this may not be sufficient, since there may not be any guarantee made by Mojo that the disconnect arrives at the service before our subsequent use of |leftover_provider|. Let me ask rockot@ to clarify.",
      "revId": "4e2b65c02ebcfd523e8187aac66c474a57ab8e36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3836790_f3d6fdbe",
        "filename": "services/video_capture/test/device_factory_provider_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 109,
      "author": {
        "id": 1108829
      },
      "writtenOn": "2017-10-27T17:17:15Z",
      "side": 1,
      "message": "Agreed that the use of arbitrary wait time is not a good solution, but couldn\u0027t figure out a way around it. Will wait for rockot@ to clarify. Thanks :)",
      "parentUuid": "c449d867_4b59d94c",
      "revId": "4e2b65c02ebcfd523e8187aac66c474a57ab8e36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf7ec09e_b5872412",
        "filename": "services/video_capture/test/device_factory_provider_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 109,
      "author": {
        "id": 1002808
      },
      "writtenOn": "2017-10-27T17:26:36Z",
      "side": 1,
      "message": "Yeah, this is definitely not a good thing to do.\n\nAnd yes, different interfaces operate independently. Detecting disconnection of an interface is similar to receiving a message on that interface, and as such is ordered only with respect to messages on that interface.\n\nThere\u0027s no magic secret here though; what you conceptually need to do if you want to follow the current testing strategy is this:\n\n1. Establish connection 1\n2. Establish connection 2\n3. Verify that connection 2 is operational (some kind of ping-pong)\n4. Disconnect connection 1\n5. Verify that service has acknowledged connection 1\u0027s disconnection\n6. Verify that connection 2 is still operation (another ping-pong)\n\nThis does not require any arbitrary delays or wishful thinking, but it does require that you solve #5 somehow. That is beyond the scope of Mojo bindings and more a concern of either service design or testing strategy (you could e.g. add some kind of crazy ClientMonitorForTesting API in your service, which tests could use to monitor clients of this particular interface. I *don\u0027t* recommend it though.)\n\nTaking a step back for a moment: do you really need to simulate everything at such a high level to test these internal details of your service implementation? The Service Manager makes certain guarantees about the Service API contract and those guarantees are already tested in Service Manager tests. i.e., you can be sure we\u0027ll call OnStart at a certain time, we\u0027ll call OnBindInterface at certain times, etc.\n\nRather than removing your test code so far from the implementation by going through a real Service Manager in these tests, have you considered just unit-testing the implementation directly? Note that we have even introduced service_manager::TestConnectorFactory to make this easier (https://chromium-review.googlesource.com/c/chromium/src/+/738642 makes a slight modification to it and may give you an idea of usage.)\n\nThe gist is that you have the test code instantiate the Service directly (which means you can observe its internals without needing to expose new mojom interfaces to do so), but you can also still bind its exposed production interfaces via a service_manager::Connector and use that to test e.g. client library code or to write tests which look mostly like normal client code.",
      "parentUuid": "c449d867_4b59d94c",
      "revId": "4e2b65c02ebcfd523e8187aac66c474a57ab8e36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}